

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/icon/warning.png">
  <link rel="icon" href="/img/icon/warning.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="一、Python 一切皆对象Python 的一切皆对象是非常彻底的，不管是函数还是类，都是对象，对象就有一些独特的特性 1.赋值给一个变量2.可以添加到集合对象中3.都能作为函数的参数进行传递4.都能当做函数的返回值">
<meta property="og:type" content="article">
<meta property="og:title" content="Python 编程进阶（重点在于面向对象和魔法方法）">
<meta property="og:url" content="http://example.com/2018/10/04/Python%20%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6%EF%BC%88%E9%87%8D%E7%82%B9%E5%9C%A8%E4%BA%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95%EF%BC%89/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="一、Python 一切皆对象Python 的一切皆对象是非常彻底的，不管是函数还是类，都是对象，对象就有一些独特的特性 1.赋值给一个变量2.可以添加到集合对象中3.都能作为函数的参数进行传递4.都能当做函数的返回值">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2018-10-04T00:16:18.000Z">
<meta property="article:modified_time" content="2025-01-24T15:19:08.252Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="编程 Python 进阶 备忘">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>Python 编程进阶（重点在于面向对象和魔法方法） - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="/css/macpanel.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>K0rz3n&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>Archives</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>Categories</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>Tags</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>About</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/banner/icemountain.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Python 编程进阶（重点在于面向对象和魔法方法）"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2018-10-04 01:16" pubdate>
          October 4, 2018 am
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          8.4k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          70 mins
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Python 编程进阶（重点在于面向对象和魔法方法）</h1>
            
            
              <div class="markdown-body">
                
                <h2 id="一、Python-一切皆对象"><a href="#一、Python-一切皆对象" class="headerlink" title="一、Python 一切皆对象"></a><strong>一、Python 一切皆对象</strong></h2><p>Python 的一切皆对象是非常彻底的，不管是函数还是类，都是对象，对象就有一些独特的特性</p>
<p>1.赋值给一个变量<br>2.可以添加到集合对象中<br>3.都能作为函数的参数进行传递<br>4.都能当做函数的返回值</p>
<span id="more"></span>

<h3 id="1-赋值给一个变量"><a href="#1-赋值给一个变量" class="headerlink" title="1.赋值给一个变量"></a><strong>1.赋值给一个变量</strong></h3><p><strong>(1)函数赋值给一个变量</strong></p>
<p><strong>示例代码:</strong></p>
<pre><code class="hljs">def add(name = &quot;K0rz3n&quot;):
    print name

object_test = add
object_test()
</code></pre>
<p><strong>(2)类赋值给一个变量</strong></p>
<pre><code class="hljs">class Person():
    def __init__(self):
        print &quot;K0rz3n&quot;

class_test = Person
class_test()
</code></pre>
<h3 id="2-添加到集合对象中"><a href="#2-添加到集合对象中" class="headerlink" title="2.添加到集合对象中"></a><strong>2.添加到集合对象中</strong></h3><pre><code class="hljs">def add(name = &quot;K0rz3n&quot;):
    print name

class Person():
    def __init__(self):
        print &quot;K0rz3n&quot;

obj_list = []
obj_list.append(add)
obj_list.append(Person)

for item in obj_list:
    print item()
</code></pre>
<p><strong>结果：</strong></p>
<pre><code class="hljs">K0rz3n
None
K0rz3n
&lt;__main__.Person instance at 0x0000000003277E08&gt;
</code></pre>
<h3 id="3-可以作为函数的返回值"><a href="#3-可以作为函数的返回值" class="headerlink" title="3.可以作为函数的返回值"></a><strong>3.可以作为函数的返回值</strong></h3><p>函数作为返回值其实是 python 装饰器的精髓</p>
<p><strong>示例代码：</strong></p>
<pre><code class="hljs">def add(name = &quot;K0rz3n&quot;):
    print name

class Person():
    def __init__(self):
        print &quot;K0rz3n&quot;

def decorator():
    print &quot;dec success&quot;
    return add

test = decorator()
test()
</code></pre>
<p><strong>结果：</strong></p>
<pre><code class="hljs">dec success
K0rz3n
</code></pre>
<h2 id="二、type-和-object-的关系"><a href="#二、type-和-object-的关系" class="headerlink" title="二、type 和 object 的关系"></a><strong>二、type 和 object 的关系</strong></h2><h3 id="1-type"><a href="#1-type" class="headerlink" title="1.type"></a><strong>1.type</strong></h3><p><strong>type 这个类实例化了一切，包括 object 和 他自己</strong></p>
<p><strong>示例代码：</strong></p>
<pre><code class="hljs">&gt;&gt;&gt; type(1)
&lt;class &#39;int&#39;&gt;

&gt;&gt;&gt; type(int)
&lt;class &#39;type&#39;&gt;

&gt;&gt;&gt; type(type)
&lt;class &#39;type&#39;&gt;

&gt;&gt;&gt; type(object)
&lt;class &#39;type&#39;&gt;
</code></pre>
<p>可以看到，1 是由 int 这个类生成的对象，int 这个类是由type 这个类生成的对象</p>
<p><strong>结论：</strong></p>
<pre><code class="hljs">type-&gt;class-&gt;obj
</code></pre>
<h3 id="2-object"><a href="#2-object" class="headerlink" title="2.object"></a><strong>2.object</strong></h3><p>object 是最顶层的基类，<strong>所有的类都继承了Object，包括type</strong> </p>
<p><strong>示例代码:</strong></p>
<pre><code class="hljs">&gt;&gt;&gt; class Student():
...     pass
...
&gt;&gt;&gt; Student.__bases__
(&lt;class &#39;object&#39;&gt;,)

&gt;&gt;&gt; type.__bases__
(&lt;class &#39;object&#39;&gt;,)

&gt;&gt;&gt; object.__bases__
()
</code></pre>
<p>但是 object 是由 type 实例化的</p>
<p><strong>示例代码：</strong></p>
<pre><code class="hljs">&gt;&gt;&gt; type(object)
&lt;class &#39;type&#39;&gt;
</code></pre>
<p><strong>总结：</strong></p>
<p>type 实例化了一切，包括 object 和他自己,object 是所有类的基类（最顶层，包括type）。于是乎 Type 和 object 就形成了一个回路，<strong>这其实也就是python 中类也是对象的原因（不仅继承了object 还是type 这个类的实例）</strong></p>
<h2 id="三、Python-中的内置类型"><a href="#三、Python-中的内置类型" class="headerlink" title="三、Python 中的内置类型"></a><strong>三、Python 中的内置类型</strong></h2><h3 id="1-对象的三个特征"><a href="#1-对象的三个特征" class="headerlink" title="1.对象的三个特征"></a><strong>1.对象的三个特征</strong></h3><h4 id="（1）身份"><a href="#（1）身份" class="headerlink" title="（1）身份"></a><strong>（1）身份</strong></h4><p>我们把身份理解成对象在内存中的地址</p>
<p>我们可以通过id()这个函数查看一个对象在内存中的地址</p>
<p><strong>示例代码:</strong></p>
<pre><code class="hljs">&gt;&gt;&gt; a= 1
&gt;&gt;&gt; id(a)
1465347104
&gt;&gt;&gt; a = []
&gt;&gt;&gt; id(a)
2406326173512
</code></pre>
<h4 id="（2）类型"><a href="#（2）类型" class="headerlink" title="（2）类型"></a><strong>（2）类型</strong></h4><p>比如有：</p>
<p><strong>None （全局唯一）</strong></p>
<p><strong>示例代码：</strong></p>
<pre><code class="hljs">&gt;&gt;&gt; a =None
&gt;&gt;&gt; b = None
&gt;&gt;&gt; id(a)
1464902800
&gt;&gt;&gt; id(b)
1464902800
</code></pre>
<p>可以看到两个变量都是指向了一个地址，说明其是全局唯一的</p>
<p><strong>数值</strong></p>
<p>Int、float、bool、complex…</p>
<p><strong>迭代类型</strong></p>
<p>可以遍历的</p>
<p><strong>序列类型</strong></p>
<p>list 、tuple 、str 、array 、range 、bytes… </p>
<p><strong>映射（dict）</strong></p>
<p>相当于字典，有 Key 和 value </p>
<p><strong>集合</strong></p>
<p>set 和 forzenset</p>
<p><strong>上下文管理器</strong></p>
<p>with 语句</p>
<p><strong>其他</strong></p>
<p>模块类型、class和实例、函数类型、方法类型、代码类型 、object 对象 、type 类型、ellipsis 类型</p>
<p>Python 有些类型是隐式的，<strong>主要是通过对象内置的魔法方法来判断对象是什么类型</strong>，这其实就是Python魔法方法的精髓，这在我们后面会详细的讲到</p>
<h4 id="（3）值"><a href="#（3）值" class="headerlink" title="（3）值"></a><strong>（3）值</strong></h4><p>这个我就不再细说了，相信大家都懂</p>
<h2 id="四、Python-中的魔法函数"><a href="#四、Python-中的魔法函数" class="headerlink" title="四、Python 中的魔法函数"></a><strong>四、Python 中的魔法函数</strong></h2><h3 id="1-什么是魔法函数"><a href="#1-什么是魔法函数" class="headerlink" title="1.什么是魔法函数"></a><strong>1.什么是魔法函数</strong></h3><p>1.Python中为我们提供的以双下划线开头和结尾的函数<br>2.魔法函数属于全局，在我们自定义的任意一个类中我们能添加任意一个魔法函数，来让这个类有着不同的性质（来增强这个类的特性，<strong>简单的说就相当于给这个类安装了一个插件</strong>）</p>
<p>在我们没有定义魔法函数之前，我们想遍历这个类中的员工，我们需要像这样写</p>
<p><strong>示例代码：</strong></p>
<pre><code class="hljs">class Company(object):
    def __init__(self,employ_list):
        self.employ = employ_list

company = Company([&quot;Tom&quot;,&quot;Alice&quot;,&quot;Bob&quot;])
employ = company.employ
for item in employ:
    print item
</code></pre>
<p><strong>结果：</strong></p>
<pre><code class="hljs">Tom
Alice
Bob
</code></pre>
<p>但是我们在定义了一个魔法方法以后事情就变得非常的简单</p>
<p><strong>示例代码：</strong></p>
<pre><code class="hljs">class Company(object):
    def __init__(self,employ_list):
        self.employ = employ_list

    def __getitem__(self, item):
        return self.employ[item]

company = Company([&quot;Tom&quot;,&quot;Alice&quot;,&quot;Bob&quot;])
for item in company:
    print item
</code></pre>
<p><strong>结果：</strong></p>
<pre><code class="hljs">Tom
Alice
Bob
</code></pre>
<p><strong>解释：</strong></p>
<p>实际上我们定义了 <code>__getitem__</code> 这个魔法方法以后，这个类实例化出来的对象就是一个可迭代的对象</p>
<h3 id="2-str-和-repr"><a href="#2-str-和-repr" class="headerlink" title="2.__str__ 和 __repr__"></a><strong>2.<code>__str__</code> 和 <code>__repr__</code></strong></h3><h4 id="（1）-str"><a href="#（1）-str" class="headerlink" title="（1） __str__"></a><strong>（1） <code>__str__</code></strong></h4><p>Python 在使用 print 的时候会隐式的调用 str() 这个函数，而这个函数会隐式的调用  <code>__str__</code> 这个魔法方法,比如我们想改变一个对象的默认输出格式，我们就需要在实例化这个对象的类中重写 <code>__str__</code>方法</p>
<p><strong>示例代码：</strong></p>
<pre><code class="hljs">class Company(object):
    def __init__(self,employ_list):
        self.employ = employ_list
    
    def __str__(self):
        return &#39;,&#39;.join(self.employ)
    
company = Company([&quot;Tom&quot;,&quot;Alice&quot;,&quot;Bob&quot;])
print company
</code></pre>
<p><strong>结果：</strong></p>
<pre><code class="hljs">Tom,Alice,Bob
</code></pre>
<p>&#96;</p>
<h4 id="2-repr"><a href="#2-repr" class="headerlink" title="(2)__repr__"></a><strong>(2)<code>__repr__</code></strong></h4><p><code>__repr__</code> 是开发者模式下（交互式Python解释器中在直接写某个对象的时候会调用的函数），我们平时直接把对象写在交互式解析器中的时候会输出一些尖括号包裹的类或者对象就是隐式调用这个函数的结果，如果我们重写了这个魔法方法就能改变输出，这个和 上面的例子是一样的，我就不再重新写代码</p>
<h2 id="五、Python-深入类和对象"><a href="#五、Python-深入类和对象" class="headerlink" title="五、Python 深入类和对象"></a><strong>五、Python 深入类和对象</strong></h2><h3 id="1-鸭子类型和多态"><a href="#1-鸭子类型和多态" class="headerlink" title="1.鸭子类型和多态"></a><strong>1.鸭子类型和多态</strong></h3><p>一个对象如果他 走起来 叫起来 看起来 都像一个鸭子那我们就把他看成是一个鸭子，其实意思就是说我们关注的是这个对象内部实现了什么方法，实现的方法决定了我们将其看成是什么</p>
<p>1.比如extend(),它里面并没有要求传入某一个具体的类型，而是要求传入一个可迭代对象，所以很多的类型都是可以的</p>
<p>2.再比如，我们实现多态的时候并不像JAVA一样要求全部继承同一个类，python 只要内部实现同一个方法就可以了，到时候直接赋值调用就ok</p>
<p><strong>示例代码:</strong></p>
<pre><code class="hljs">class Cat(object):
    def say(self):
        print &quot;i am a cat\n&quot;

class Dog(object):
    def say(self):
        print &quot;i am a dog\n&quot;

animal = [Cat,Dog]
for i in animal:
    i().say()
</code></pre>
<p><strong>结果：</strong></p>
<pre><code class="hljs">i am a cat

i am a dog
</code></pre>
<h3 id="2-Python-中的抽象基类"><a href="#2-Python-中的抽象基类" class="headerlink" title="2.Python 中的抽象基类"></a><strong>2.Python 中的抽象基类</strong></h3><h4 id="概念："><a href="#概念：" class="headerlink" title="概念："></a><strong>概念：</strong></h4><p>可以把 Python 的抽象基类看成是 java 中的接口，java 不能实现多继承单数能实现多个接口，接口在 java 中是不能实例化的，同样抽象基类在 Python 中也是不能实例化的（我们可以继承抽象基类，然后去实例化抽象基类的所有方法）</p>
<p>但是我们不是说过，python 是一种动态语言，<strong>动态语言是没有变量的类型的</strong>，Python中变量只是一个符号而已，他可以指向任何类型的对象。</p>
<p><strong>那么我们为什么还需要有抽象基类这个概念呢？</strong></p>
<p>1.因为我们在有些时候想判断某一个对象的类型，而不是通过一个一个的魔法函数的检验去查看对象的属性如何，这样的体验非常不好，我们提供抽象基类实际上就是提供一种类型（属性）的打包</p>
<p>2.我们在某些时候需要强制某些子类必须实现某些方法</p>
<p><strong>示例代码：</strong></p>
<pre><code class="hljs">class CacheBase():
    def get(self,key):
        raise NotImplemented
    def set(self,key,value):
        raise NotImplemented

class cache(CacheBase):
   pass

my_cache = cache()
my_cache.get(&quot;key&quot;)
</code></pre>
<p><strong>结果：</strong></p>
<pre><code class="hljs">TypeError: exceptions must be old-style classes or derived from BaseException, not NotImplementedType
</code></pre>
<p>当然我们如果想在实例化的时候就抛出异常的话就需要用到abc 模块以及装饰器的操作，这里不再多介绍</p>
<h3 id="3-isinstance-和-type-的区别"><a href="#3-isinstance-和-type-的区别" class="headerlink" title="3.isinstance 和 type 的区别"></a><strong>3.isinstance 和 type 的区别</strong></h3><p>这两个函数都是查看对象的归属的，但是 isinstacne() 会根据继承关系不断的向上递推，直到最顶层为止，但是 Type() 只能向上递推一个</p>
<p><strong>另外 &#x3D;&#x3D; 和 is 不要乱用</strong></p>
<p>&#x3D;&#x3D; 代表的是返回值是不是相等<br>is 查看的是 id() 的结果是不是相等</p>
<h3 id="4-类变量和对象变量"><a href="#4-类变量和对象变量" class="headerlink" title="4.类变量和对象变量"></a><strong>4.类变量和对象变量</strong></h3><p><strong>示例代码：</strong></p>
<pre><code class="hljs">class A:
    aa = 1
    def __init__(self,x,y):
        self.x = x
        self.y = y

a = A(2,3)
print a.x,a.y,a.aa
print A.aa
</code></pre>
<p> <strong>结果：</strong></p>
<pre><code class="hljs">2 3 1
1
</code></pre>
<p>这里 aa 就是类变量，那么为什么我们能打印出来呢？因为我们在寻找实例的属性的时候如果找不到就会自动的向上搜索</p>
<p><strong>还有一个比较神奇的地方</strong></p>
<p><strong>示例代码：</strong></p>
<pre><code class="hljs">class A:
    aa = 1
    def __init__(self,x,y):
        self.x = x
        self.y = y

a = A(2,3)
A.aa = 10
a.aa = 100
print A.aa
print a.aa
</code></pre>
<p><strong>结果：</strong></p>
<pre><code class="hljs">10
100
</code></pre>
<p>可以看到我们在实例中修改了 aa 的值，但是我们在类中访问却依然没改变，这是为什么呢？</p>
<blockquote>
<p><strong>解释：</strong></p>
<p>我们使用 a.aa<br>访问或者赋值的时候实际上会在我们的实例中新建一个属性，我们访问或者修改的都是这个新的属性，这个属性初始值和类的一样，但是他们有着不用的地址空间，因此修改后互不影响</p>
</blockquote>
<h3 id="4-类和实例的属性查找顺序-mro"><a href="#4-类和实例的属性查找顺序-mro" class="headerlink" title="4.类和实例的属性查找顺序__mro__"></a><strong>4.类和实例的属性查找顺序<code>__mro__</code></strong></h3><p>在历史上 python 设置了很多的查找算法，比如 DFS BFS 等，但是依然不能用单纯的一个方法解决所有的问题，于是后来出现了 C3 算法，这个算法比较复杂，能针对不同的模式调整查找顺序</p>
<h4 id="（1）菱形继承方式"><a href="#（1）菱形继承方式" class="headerlink" title="（1）菱形继承方式"></a><strong>（1）菱形继承方式</strong></h4><p><strong>实例代码：</strong></p>
<pre><code class="hljs">class D(object):
    pass


class C(D):
    pass


class B(D):
    pass


class A(B, C):
    pass


print A.__mro__
</code></pre>
<p><strong>结果：</strong></p>
<pre><code class="hljs">(&lt;class &#39;__main__.A&#39;&gt;, &lt;class &#39;__main__.B&#39;&gt;, &lt;class &#39;__main__.C&#39;&gt;, &lt;class &#39;__main__.D&#39;&gt;, &lt;type &#39;object&#39;&gt;)
</code></pre>
<p><strong>解释：</strong></p>
<p>可见这种继承方式使用的是 BFS </p>
<h4 id="（2）锥形继承方式"><a href="#（2）锥形继承方式" class="headerlink" title="（2）锥形继承方式"></a><strong>（2）锥形继承方式</strong></h4><p><strong>示例代码：</strong></p>
<pre><code class="hljs">class E(object):
    pass

class D(object):
    pass


class C(E):
    pass


class B(D):
    pass


class A(B, C):
    pass


print A.__mro__
</code></pre>
<p><strong>结果：</strong></p>
<pre><code class="hljs">(&lt;class &#39;__main__.A&#39;&gt;, &lt;class &#39;__main__.B&#39;&gt;, &lt;class &#39;__main__.D&#39;&gt;, &lt;class &#39;__main__.C&#39;&gt;, &lt;class &#39;__main__.E&#39;&gt;, &lt;type &#39;object&#39;&gt;)
</code></pre>
<p><strong>解释：</strong></p>
<p>可见这种结构的继承方式使用的是 DFS </p>
<h3 id="5-类方法、静态方法和实例方法"><a href="#5-类方法、静态方法和实例方法" class="headerlink" title="5.类方法、静态方法和实例方法"></a><strong>5.类方法、静态方法和实例方法</strong></h3><h4 id="（1）实例方法："><a href="#（1）实例方法：" class="headerlink" title="（1）实例方法："></a><strong>（1）实例方法：</strong></h4><p><strong>示例代码：</strong></p>
<pre><code class="hljs">class Date():
    def __init__(self,year,month,day):
        self.year = year
        self.month = month
        self.day = day

    def __str__(self):
        return &quot;&#123;year&#125;/&#123;month&#125;/&#123;day&#125;&quot;.format(year = self.year,month = self.month,day = self.day)

new_day = Date(2018,10,2)
print new_day
</code></pre>
<p><strong>结果：</strong></p>
<pre><code class="hljs">2018/10/2
</code></pre>
<p>但是如果我们有这样的需求，我们输入 2018-10-2 也能直接解析怎么办，这个时候我们就需要使用静态方法</p>
<h4 id="（2）静态方法："><a href="#（2）静态方法：" class="headerlink" title="（2）静态方法："></a><strong>（2）静态方法：</strong></h4><p><strong>示例代码：</strong></p>
<pre><code class="hljs">class Date():
    def __init__(self,year,month,day):
        self.year = year
        self.month = month
        self.day = day

    @staticmethod
    def parse_fro_string(data_str):
        year,month,day = tuple(data_str.split(&#39;-&#39;))
        return Date(int(year),int(month),int(day))


    def __str__(self):
        return &quot;&#123;year&#125;/&#123;month&#125;/&#123;day&#125;&quot;.format(year = self.year,month = self.month,day = self.day)


new_day = Date.parse_fro_string(&quot;2018-10-2&quot;)
print new_day
</code></pre>
<p><strong>结果：</strong></p>
<pre><code class="hljs">2018/10/2
</code></pre>
<p>但是，这个还有一个问题，就是静态方法是硬编码的，如果我们的类的名字改了，静态方法也要改，这很不好，于是我们就引出了类方法</p>
<h4 id="（3）类方法："><a href="#（3）类方法：" class="headerlink" title="（3）类方法："></a><strong>（3）类方法：</strong></h4><pre><code class="hljs">class Date():
    def __init__(self,year,month,day):
        self.year = year
        self.month = month
        self.day = day

    @staticmethod
    def parse_fro_string(data_str):
        year,month,day = tuple(data_str.split(&#39;-&#39;))
        return Date(int(year),int(month),int(day))

    @classmethod
    def fro_string(cls,data_str):
        year, month, day = tuple(data_str.split(&#39;-&#39;))
        return cls(int(year), int(month), int(day))


    def __str__(self):
        return &quot;&#123;year&#125;/&#123;month&#125;/&#123;day&#125;&quot;.format(year = self.year,month = self.month,day = self.day)

new_day = Date.fro_string(&quot;2018-10-2&quot;)
print new_day
</code></pre>
<p><strong>结果：</strong></p>
<pre><code class="hljs">2018/10/2
</code></pre>
<h3 id="6-数据封装和私有属性"><a href="#6-数据封装和私有属性" class="headerlink" title="6.数据封装和私有属性"></a><strong>6.数据封装和私有属性</strong></h3><p>python 不像 java 有 Private 或者 protetced 这种，那么 Python 是怎么实现私有属性的</p>
<p><strong>示例代码：</strong></p>
<pre><code class="hljs"> class Date():
    def __init__(self,year,month,day):
        self.year = year
        self.month = month
        self.day = day

    @staticmethod
    def parse_fro_string(data_str):
        year,month,day = tuple(data_str.split(&#39;-&#39;))
        return Date(int(year),int(month),int(day))

    @classmethod
    def fro_string(cls,data_str):
        year, month, day = tuple(data_str.split(&#39;-&#39;))
        return cls(int(year), int(month), int(day))


    def __str__(self):
        return &quot;&#123;year&#125;/&#123;month&#125;/&#123;day&#125;&quot;.format(year = self.year,month = self.month,day = self.day)

class User:
    def __init__(self,birthday):
        self.birthday = birthday

    def get_age(self):
        return 2018-self.birthday.year

if __name__ == &#39;__main__&#39;:
    user = User(Date(1990,2,1))
    print user.get_age()
    print user.birthday
</code></pre>
<p><strong>结果:</strong></p>
<pre><code class="hljs"> 28
 1990/2/1
</code></pre>
<p>在这种情况下，我们可以直接访问到用户的生日，如果我们不想直接访问到怎么办？我们可以在属性前面加上双下划线来解决</p>
<p><strong>示例代码：</strong></p>
<pre><code class="hljs">class User:
    def __init__(self,birthday):
        self.__birthday = birthday

    def get_age(self):
        return 2018-self.__birthday.year

if __name__ == &#39;__main__&#39;:
    user = User(Date(1990,2,1))
    print user.get_age()
    print user.__birthday
</code></pre>
<p>可以测试一下 get_age 这个函数还是可以使用的但是 直接访问会出错</p>
<p>但是实际上这个是可以绕过的,python 只是将其做了一个变形而已,变成了  _User__birthday</p>
<p><strong>示例代码：</strong></p>
<pre><code class="hljs">class User:
    def __init__(self,birthday):
        self.__birthday = birthday

    def get_age(self):
        return 2018-self.__birthday.year

if __name__ == &#39;__main__&#39;:
    user = User(Date(1990,2,1))
    print user.get_age()
    print user._User__birthday
</code></pre>
<p>这样就又能正常访问了</p>
<h3 id="7-Python-对象的自省机制"><a href="#7-Python-对象的自省机制" class="headerlink" title="7.Python 对象的自省机制"></a><strong>7.Python 对象的自省机制</strong></h3><h4 id="1-什么叫做自省？"><a href="#1-什么叫做自省？" class="headerlink" title="1. 什么叫做自省？"></a><strong>1. 什么叫做自省？</strong></h4><p>自省就是通过一定的机制来查看对象的内部结构（看看自己是什么东西…自我认识一下）</p>
<p><strong>示例代码：</strong></p>
<pre><code class="hljs">class Person():
    name = &quot;user&quot;

class Student(Person):
    def __init__(self,school_name):
        self.school_name = school_name

if __name__ == &#39;__main__&#39;:
    user = Student(&quot;K0rz3n&quot;)
    print user.__dict__
    print Person.__dict__
</code></pre>
<p><strong>结果：</strong></p>
<pre><code class="hljs">&#123;&#39;school_name&#39;: &#39;K0rz3n&#39;&#125;
&#123;&#39;__module__&#39;: &#39;__main__&#39;, &#39;name&#39;: &#39;user&#39;, &#39;__doc__&#39;: None&#125;
</code></pre>
<p>除了使用 <code>__dict__</code> 以外我们还能使用 dir() 这个函数，这个函数功能更加强大，能列出对象的所有属性</p>
<p><strong>示例代码：</strong></p>
<pre><code class="hljs">class Person():
    name = &quot;user&quot;

class Student(Person):
    def __init__(self,school_name):
        self.school_name = school_name

if __name__ == &#39;__main__&#39;:
    user = Student(&quot;K0rz3n&quot;)
    print user.__dict__
    print Person.__dict__
    print dir(user)
    print dir(Person)
</code></pre>
<p><strong>结果:</strong></p>
<pre><code class="hljs">&#123;&#39;school_name&#39;: &#39;K0rz3n&#39;&#125;
&#123;&#39;__module__&#39;: &#39;__main__&#39;, &#39;name&#39;: &#39;user&#39;, &#39;__doc__&#39;: None&#125;
[&#39;__doc__&#39;, &#39;__init__&#39;, &#39;__module__&#39;, &#39;name&#39;, &#39;school_name&#39;]
[&#39;__doc__&#39;, &#39;__module__&#39;, &#39;name&#39;]
</code></pre>
<h3 id="8-super-真的是调用父类吗"><a href="#8-super-真的是调用父类吗" class="headerlink" title="8.super 真的是调用父类吗"></a><strong>8.super 真的是调用父类吗</strong></h3><p>我们可以在 B中用super()函数调用了父类 A 中的构造方法</p>
<p><strong>示例代码：</strong></p>
<pre><code class="hljs">class A(object):
    def __init__(self):
        print &quot;a&quot;

class B(A):
    def __init__(self):
        super(B,self).__init__()
        print &quot;b&quot;

if __name__ ==  &#39;__main__&#39;:

    b = B()
</code></pre>
<p><strong>结果：</strong></p>
<pre><code class="hljs">a
b
</code></pre>
<h4 id="1-为什么要这样用"><a href="#1-为什么要这样用" class="headerlink" title="1.为什么要这样用"></a><strong>1.为什么要这样用</strong></h4><p>有时候我们可以通过这种方式来重用父类的方法，而不是重写</p>
<h4 id="2-真的是调用父类吗？"><a href="#2-真的是调用父类吗？" class="headerlink" title="2.真的是调用父类吗？"></a><strong>2.真的是调用父类吗？</strong></h4><p>我们来做一个实验</p>
<p><strong>示例代码：</strong></p>
<pre><code class="hljs">class A(object):
    def __init__(self):
        print &quot;a&quot;

class B(A):
    def __init__(self):
        print &quot;b&quot;

        super(B,self).__init__()

class C(A):
    def __init__(self):
        print &quot;c&quot;
        super(C,self).__init__()


class D(B,C):
    def __init__(self):
        print &quot;d&quot;
        super(D,self).__init__()


if __name__ ==  &#39;__main__&#39;:

    b = D()
</code></pre>
<p><strong>结果：</strong></p>
<pre><code class="hljs">d
b
c
a
</code></pre>
<p><strong>解释:</strong></p>
<p>我们看到当我们调用到 B 的时候，super 并没有去找B 的父类A 而是转向了C ，这说明我们单纯的将 super 理解为寻找父类是不正确的，其实这个顺序是我们之前讲的 mro</p>
<h3 id="9-Python-中的-with-语句"><a href="#9-Python-中的-with-语句" class="headerlink" title="9.Python 中的 with 语句"></a><strong>9.Python 中的 with 语句</strong></h3><p>with 语句是用来使用上下文管理器的，那么什么叫做上下文管理器呢？</p>
<h4 id="1-上下文管理器"><a href="#1-上下文管理器" class="headerlink" title="1.上下文管理器"></a><strong>1.上下文管理器</strong></h4><p>介绍这个概念就涉及到我们之前说的魔法函数，只要拥有<code>__enter__</code> 和  <code>__exit__</code> 这两个属性的类实例化的对象就可以作为上下文管理器</p>
<p>我们可以举例看一下</p>
<p><strong>示例代码：</strong></p>
<pre><code class="hljs">class Sample(object):
    def __enter__(self):
        print &quot;enter&quot;
        return self # 注意这句话绝对不能少，要不然sample 根本得不到这个对象的实例
    def __exit__(self, exc_type, exc_val, exc_tb):
        print &quot;exit&quot;
    def do_something(self):
        print &quot;do_something&quot;

with Sample() as sample:
    sample.do_something()
</code></pre>
<p><strong>结果:</strong></p>
<pre><code class="hljs">enter
do_something
exit
</code></pre>
<p><strong>解释：</strong></p>
<p>可以看到，<code>__enter__</code> 和 <code>__exit__</code> 魔法函数会在调用和结束的时候自动运行，同时，拥有这两个魔法函数的类可以用 with 语句进行实例化，成为一个上下文管理器，我们可以在 <code>__enter__</code> 中创建资源，在 <code>__exit__</code> 中释放</p>
<h3 id="10-使用-contextlib-简化上下文管理器"><a href="#10-使用-contextlib-简化上下文管理器" class="headerlink" title="10.使用 contextlib 简化上下文管理器"></a><strong>10.使用 contextlib 简化上下文管理器</strong></h3><p><strong>实例代码：</strong></p>
<pre><code class="hljs">import contextlib

@contextlib.contextmanager
def file_open(file_name):
    print &quot;file_open&quot;  # 这里写的是 __enter__ 中的代码
    yield&#123;&#125;
    print &quot;file_close&quot; # 这里写的是 __exit__ 中的代码


with file_open(&quot;test.txt&quot;) as f:
    print &quot;test&quot;
</code></pre>
<p><strong>结果：</strong></p>
<pre><code class="hljs">file_open
test
file_close
</code></pre>
<h2 id="五、自定义序列类"><a href="#五、自定义序列类" class="headerlink" title="五、自定义序列类"></a><strong>五、自定义序列类</strong></h2><h3 id="1-序列的分类："><a href="#1-序列的分类：" class="headerlink" title="1.序列的分类："></a><strong>1.序列的分类：</strong></h3><h4 id="1-容器序列-list-、tuple-、deque"><a href="#1-容器序列-list-、tuple-、deque" class="headerlink" title="(1)容器序列: list 、tuple 、deque"></a><strong>(1)容器序列: list 、tuple 、deque</strong></h4><p>容器序列中可以放置任何的数据类型</p>
<h4 id="2-扁平序列：str-、bytes-、bytearray-、array-array"><a href="#2-扁平序列：str-、bytes-、bytearray-、array-array" class="headerlink" title="(2)扁平序列：str 、bytes 、bytearray 、array.array"></a><strong>(2)扁平序列：str 、bytes 、bytearray 、array.array</strong></h4><p>该序列中只有一钟类型</p>
<h4 id="3-可变序列-list-、deque-、bytearray-、array"><a href="#3-可变序列-list-、deque-、bytearray-、array" class="headerlink" title="(3) 可变序列: list 、deque 、bytearray 、array"></a><strong>(3) 可变序列: list 、deque 、bytearray 、array</strong></h4><h4 id="4-不可变序列：-str-、tuple-、bytes"><a href="#4-不可变序列：-str-、tuple-、bytes" class="headerlink" title="(4) 不可变序列： str 、tuple 、bytes"></a><strong>(4) 不可变序列： str 、tuple 、bytes</strong></h4><h3 id="2-序列中的魔法函数"><a href="#2-序列中的魔法函数" class="headerlink" title="2.序列中的魔法函数"></a><strong>2.序列中的魔法函数</strong></h3><p><code>__len__</code> 有这个方法就能实现计算长度 </p>
<p><code>__iter__</code> 有这个方法就能实现迭代</p>
<p><code>__container__</code> 有这个方法就能实现使用in判断元素是否存在</p>
<p>等等</p>
<p>我们如果要自定义序列类型就要去实现这些函数</p>
<h3 id="3-序列中的-和-extend-的区别"><a href="#3-序列中的-和-extend-的区别" class="headerlink" title="3.序列中的 + +&#x3D; 和 extend 的区别"></a><strong>3.序列中的 + +&#x3D; 和 extend 的区别</strong></h3><h4 id="1-的使用"><a href="#1-的使用" class="headerlink" title="1. + 的使用"></a><strong>1. + 的使用</strong></h4><p><strong>示例代码：</strong></p>
<pre><code class="hljs">a = [1,2]
c = a +[3,4]
print c
</code></pre>
<p><strong>结果：</strong></p>
<h4 id="2-的使用"><a href="#2-的使用" class="headerlink" title="2.+&#x3D; 的使用"></a><strong>2.+&#x3D; 的使用</strong></h4><p><strong>示例代码：</strong></p>
<pre><code class="hljs">a = [1,2]
a += [3,4]
print a 
</code></pre>
<p><strong>结果：</strong></p>
<pre><code class="hljs">[1, 2, 3, 4]
</code></pre>
<h4 id="3-但是这两个实际上是有一些区别的"><a href="#3-但是这两个实际上是有一些区别的" class="headerlink" title="3.但是这两个实际上是有一些区别的"></a><strong>3.但是这两个实际上是有一些区别的</strong></h4><p><strong>（1）区别一： +&#x3D; 是直接在 a 上进行操作</strong><br>这个就不用多解释了</p>
<p><strong>(2)区别二：+&#x3D; 可以扩展不同类型的可迭代对象</strong></p>
<p><strong>示例代码：</strong></p>
<pre><code class="hljs">a = [1,2]
a += (3,4)
print a
</code></pre>
<p><strong>结果：</strong></p>
<pre><code class="hljs">[1, 2, 3, 4]
</code></pre>
<p>我们发现+&#x3D;的神奇特性，实际上，+&#x3D;底层调用的是 extend()方法，这个方法实际上在调用for 循环，因此支持for 循环的都能添加去</p>
<p><strong>还有一点就是人们经常把 append() 和 extend() 混淆</strong></p>
<p>append(） 会将参数直接放进列表中</p>
<p><strong>示例代码：</strong></p>
<pre><code class="hljs">a = [1,2]
a.append([3,4])
print a
</code></pre>
<p><strong>结果：</strong></p>
<pre><code class="hljs">[1, 2, [3, 4]]
</code></pre>
<h3 id="4-实现可切片对象"><a href="#4-实现可切片对象" class="headerlink" title="4.实现可切片对象"></a><strong>4.实现可切片对象</strong></h3><h4 id="1-先来回顾一下切片操作"><a href="#1-先来回顾一下切片操作" class="headerlink" title="1.先来回顾一下切片操作"></a><strong>1.先来回顾一下切片操作</strong></h4><p>模式： [start:end:step]</p>
<p>start 意思是起始位置，默认是0<br>end 意思是结束的位置，默认是列表的长度<br>step 默认是1</p>
<blockquote>
<p><strong>注意：</strong><br>1.当step 是负数的时候代表反向切片，这个时候 start 要比 end 来的大<br>2.切片返回的是一个新的元素而不会改变原来列表的值<br>3.步长为2表示包括自己在内数两个，也就是隔一个取一个</p>
</blockquote>
<p><strong>实例:</strong></p>
<p>在末尾插入一个元素</p>
<pre><code class="hljs">a[len(a):] = [1] 
</code></pre>
<p>在开头插入一个元素</p>
<pre><code class="hljs">a[:0] = [1]
</code></pre>
<p>在特定位置插入一个元素</p>
<pre><code class="hljs">a[3:3] = [1]
</code></pre>
<p>隔一个修改一个</p>
<pre><code class="hljs">a[::2] = [0]*3
</code></pre>
<p>隔一个删除一个</p>
<pre><code class="hljs">del a[::2]
</code></pre>
<h4 id="2-自己构造一个可切片对象"><a href="#2-自己构造一个可切片对象" class="headerlink" title="2.自己构造一个可切片对象"></a><strong>2.自己构造一个可切片对象</strong></h4><p><strong>示例代码：</strong></p>
<pre><code class="hljs">import numbers
class Group():
    def __init__(self,group_name,company_name,staffs):
        self.group_name = group_name
        self.company_name = company_name
        self.staffs = staffs


    def __getitem__(self, item):
        cls = type(self)
        if isinstance(item,slice):
            return cls(group_name=self.group_name,company_name=self.company_name,staffs=self.staffs[item])
        elif isinstance(item,numbers.Integral):
            return cls(group_name=self.group_name,company_name=self.company_name,staffs=[self.staffs[item]])


staffs = [&quot;Alice&quot;,&quot;Bob&quot;,&quot;Tom&quot;,&quot;Kali&quot;]
group = Group(company_name=&quot;K0rz3n&quot;,group_name=&quot;user&quot;,staffs=staffs)
sub_group = group[1:2]
sub_group = group[0]
</code></pre>
<p>这个代码我本地也没有实现，会报错，还有待解决</p>
<h3 id="5-bisect-维持已排序的序列"><a href="#5-bisect-维持已排序的序列" class="headerlink" title="5.bisect 维持已排序的序列"></a><strong>5.bisect 维持已排序的序列</strong></h3><p>bisect 能维持一个已经排序好的序列（以升序排序）</p>
<p><strong>示例代码：</strong></p>
<pre><code class="hljs">import bisect

inter_list = []
bisect.insort(inter_list,2)
bisect.insort(inter_list,5)
bisect.insort(inter_list,1)
bisect.insort(inter_list,6)
bisect.insort(inter_list,3)
bisect.insort(inter_list,4)

print inter_list
</code></pre>
<p><strong>结果：</strong></p>
<pre><code class="hljs">[1, 2, 3, 4, 5, 6]
</code></pre>
<p>我们还能查看某个元素应该插入什么位置</p>
<p><strong>示例代码：</strong></p>
<pre><code class="hljs">print bisect.bisect(inter_list,3)
</code></pre>
<p><strong>结果：</strong></p>
<pre><code class="hljs">3
</code></pre>
<h3 id="6-什么时候我们不应该使用列表"><a href="#6-什么时候我们不应该使用列表" class="headerlink" title="6.什么时候我们不应该使用列表"></a><strong>6.什么时候我们不应该使用列表</strong></h3><p>array 相当于 C语言的数组，在数据处理中的效率是非常高的，但是我们要注意 array 中存放的只能是一种数据类型，我们在声明的时候就要指定</p>
<p><strong>示例代码：</strong></p>
<pre><code class="hljs">import array

my_array = array.array(&quot;i&quot;)
my_array.append(1)
my_array.append(2)
print my_array
</code></pre>
<p><strong>结果：</strong></p>
<pre><code class="hljs">array(&#39;i&#39;, [1, 2])
</code></pre>
<h2 id="六、Python-中的-set-和-dict"><a href="#六、Python-中的-set-和-dict" class="headerlink" title="六、Python 中的 set 和 dict"></a><strong>六、Python 中的 set 和 dict</strong></h2><h3 id="1-dict-中的常用方法"><a href="#1-dict-中的常用方法" class="headerlink" title="1.dict 中的常用方法"></a><strong>1.dict 中的常用方法</strong></h3><h4 id="1-clear-方法："><a href="#1-clear-方法：" class="headerlink" title="(1)clear 方法："></a><strong>(1)clear 方法：</strong></h4><p><strong>示例代码：</strong></p>
<pre><code class="hljs">a = &#123;&quot;K0rz3n&quot;:&#123;&quot;hello&quot;:&quot;world&quot;&#125;,
     &quot;KKKK&quot;:&#123;&quot;hello&quot;:&quot;K0rz3n&quot;&#125;,
     &quot;xxxxx&quot;:&#123;&quot;xxx&quot;:&quot;sssss&quot;&#125;&#125;

a.clear()
print a 
</code></pre>
<p><strong>结果：</strong></p>
<pre><code class="hljs">&#123;&#125;
</code></pre>
<h4 id="2-copy-方法"><a href="#2-copy-方法" class="headerlink" title="(2)copy() 方法"></a><strong>(2)copy() 方法</strong></h4><blockquote>
<p><strong>注意：</strong></p>
<p>这个拷贝是浅拷贝，也就是说不能循环嵌套拷贝</p>
</blockquote>
<p><strong>示例代码：</strong></p>
<pre><code class="hljs">a = &#123;&quot;K0rz3n&quot;:&#123;&quot;hello&quot;:&quot;world&quot;&#125;,
     &quot;KKKK&quot;:&#123;&quot;hello&quot;:&quot;K0rz3n&quot;&#125;,
     &quot;xxxxx&quot;:&#123;&quot;xxx&quot;:&quot;sssss&quot;&#125;&#125;

new_dict = a.copy()
new_dict[&quot;K0rz3n&quot;][&quot;hello&quot;] = &quot;K0rz3n&quot;
print a
</code></pre>
<p><strong>结果：</strong></p>
<pre><code class="hljs">&#123;&#39;K0rz3n&#39;: &#123;&#39;hello&#39;: &#39;K0rz3n&#39;&#125;, &#39;KKKK&#39;: &#123;&#39;hello&#39;: &#39;K0rz3n&#39;&#125;, &#39;xxxxx&#39;: &#123;&#39;xxx&#39;: &#39;sssss&#39;&#125;&#125;
</code></pre>
<p>我们发现我们修改了拷贝值以后原始值也发生了变化，这其实就是浅拷贝导致的问题，浅拷贝遇到循环嵌套的数据时只能拷贝一层，另外的层都是一个指向，也就是指向原始的位置，因此修改了拷贝以后原始值也发生了变化</p>
<p><strong>解决：</strong></p>
<p>使用python 的一个 copy 的库</p>
<p><strong>示例代码</strong>：</p>
<pre><code class="hljs">import copy
a = &#123;&quot;K0rz3n&quot;:&#123;&quot;hello&quot;:&quot;world&quot;&#125;,
     &quot;KKKK&quot;:&#123;&quot;hello&quot;:&quot;K0rz3n&quot;&#125;,
     &quot;xxxxx&quot;:&#123;&quot;xxx&quot;:&quot;sssss&quot;&#125;&#125;

new_dict = copy.deepcopy(a)
new_dict[&quot;K0rz3n&quot;][&quot;hello&quot;] = &quot;K0rz3n&quot;
print a
</code></pre>
<p><strong>结果：</strong></p>
<pre><code class="hljs">&#123;&#39;K0rz3n&#39;: &#123;&#39;hello&#39;: &#39;world&#39;&#125;, &#39;KKKK&#39;: &#123;&#39;hello&#39;: &#39;K0rz3n&#39;&#125;, &#39;xxxxx&#39;: &#123;&#39;xxx&#39;: &#39;sssss&#39;&#125;&#125;
</code></pre>
<h4 id="3-fromkeys-方法"><a href="#3-fromkeys-方法" class="headerlink" title="(3)fromkeys 方法"></a><strong>(3)fromkeys 方法</strong></h4><p>将可迭代的对象转化成为一个dict</p>
<p><strong>示例代码：</strong></p>
<pre><code class="hljs">new_list = [&quot;K0rz3n&quot;,&quot;hello&quot;,&quot;world&quot;]
new_dict = dict.fromkeys(new_list,&#123;&quot;hhh&quot;&#125;)
print new_dict
</code></pre>
<p><strong>结果：</strong></p>
<pre><code class="hljs">&#123;&#39;K0rz3n&#39;: set([&#39;hhh&#39;]), &#39;world&#39;: set([&#39;hhh&#39;]), &#39;hello&#39;: set([&#39;hhh&#39;])&#125;
</code></pre>
<h4 id="4-get-方法"><a href="#4-get-方法" class="headerlink" title="(4)get 方法"></a><strong>(4)get 方法</strong></h4><p>为了防止出现 keyerror 的错误</p>
<p><strong>示例代码：</strong></p>
<pre><code class="hljs">new_list = [&quot;K0rz3n&quot;,&quot;hello&quot;,&quot;world&quot;]
new_dict = dict.fromkeys(new_list,&#123;&quot;hhh&quot;&#125;)

value = new_dict.get(&quot;hh&quot;,&#123;&#125;)
print value
</code></pre>
<p><strong>结果：</strong></p>
<pre><code class="hljs">&#123;&#125;
</code></pre>
<h4 id="5-items-方法"><a href="#5-items-方法" class="headerlink" title="(5)items 方法"></a><strong>(5)items 方法</strong></h4><p>Items 方法可以实现元祖的拆包</p>
<p><strong>示例代码：</strong></p>
<pre><code class="hljs">new_list = [&quot;K0rz3n&quot;,&quot;hello&quot;,&quot;world&quot;]
new_dict = dict.fromkeys(new_list,&#123;&quot;hhh&quot;&#125;)

for key,value in new_dict.items():
    print key,value
</code></pre>
<p><strong>结果：</strong></p>
<pre><code class="hljs">K0rz3n set([&#39;hhh&#39;])
world set([&#39;hhh&#39;])
hello set([&#39;hhh&#39;])
</code></pre>
<h4 id="6-setdefault-方法"><a href="#6-setdefault-方法" class="headerlink" title="(6)setdefault 方法"></a><strong>(6)setdefault 方法</strong></h4><p>除了试下 get 一样的操作以外，还会将这个值设置进映射</p>
<p><strong>示例代码：</strong></p>
<pre><code class="hljs">new_list = [&quot;K0rz3n&quot;,&quot;hello&quot;,&quot;world&quot;]
new_dict = dict.fromkeys(new_list,&#123;&quot;hhh&quot;&#125;)

new_dict.setdefault(&quot;hh&quot;,&quot;xxx&quot;)
print new_dict
</code></pre>
<p><strong>结果：</strong></p>
<pre><code class="hljs">&#123;&#39;K0rz3n&#39;: set([&#39;hhh&#39;]), &#39;world&#39;: set([&#39;hhh&#39;]), &#39;hh&#39;: &#39;xxx&#39;, &#39;hello&#39;: set([&#39;hhh&#39;])&#125;
</code></pre>
<h4 id="7-update-方法"><a href="#7-update-方法" class="headerlink" title="(7)update 方法"></a><strong>(7)update 方法</strong></h4><p>更新dict </p>
<p><strong>示例代码：</strong></p>
<pre><code class="hljs">new_list = [&quot;K0rz3n&quot;,&quot;hello&quot;,&quot;world&quot;]
new_dict = dict.fromkeys(new_list,&#123;&quot;hhh&quot;&#125;)

new_dict.update(update=&quot;hahah&quot;)
new_dict.update(&#123;&quot;upupup&quot;:&quot;xixixi&quot;&#125;)
print new_dict
</code></pre>
<p><strong>结果：</strong></p>
<pre><code class="hljs">&#123;&#39;K0rz3n&#39;: set([&#39;hhh&#39;]), &#39;world&#39;: set([&#39;hhh&#39;]), &#39;upupup&#39;: &#39;xixixi&#39;, &#39;hello&#39;: set([&#39;hhh&#39;]), &#39;update&#39;: &#39;hahah&#39;&#125;
</code></pre>
<h3 id="2-set-和-frozeset"><a href="#2-set-和-frozeset" class="headerlink" title="2.set 和 frozeset"></a><strong>2.set 和 frozeset</strong></h3><p>set 是集合，是无序的，不重复的，frozenset 是不可变集合</p>
<p>set 中放置的是一个可迭代对象</p>
<h4 id="1-无序"><a href="#1-无序" class="headerlink" title="(1)无序"></a><strong>(1)无序</strong></h4><p><strong>示例代码：</strong></p>
<pre><code class="hljs">a = set(&#39;abcdefs&#39;)
print a
</code></pre>
<p><strong>结果：</strong></p>
<pre><code class="hljs">set([&#39;a&#39;, &#39;c&#39;, &#39;b&#39;, &#39;e&#39;, &#39;d&#39;, &#39;f&#39;, &#39;s&#39;])
</code></pre>
<p>可见显示的顺序和我们传入的顺序是不一样的，也就是说是无序的</p>
<h4 id="（2）不重复"><a href="#（2）不重复" class="headerlink" title="（2）不重复"></a><strong>（2）不重复</strong></h4><p><strong>示例代码：</strong></p>
<pre><code class="hljs">a = set(&#39;abcdefssss&#39;)
print a
</code></pre>
<p><strong>结果：</strong></p>
<pre><code class="hljs">set([&#39;a&#39;, &#39;c&#39;, &#39;b&#39;, &#39;e&#39;, &#39;d&#39;, &#39;f&#39;, &#39;s&#39;])
</code></pre>
<h4 id="（3）frozenset-是不可变的"><a href="#（3）frozenset-是不可变的" class="headerlink" title="（3）frozenset 是不可变的"></a><strong>（3）frozenset 是不可变的</strong></h4><p><strong>示例代码：</strong></p>
<pre><code class="hljs">a = set(&#39;abcdefssss&#39;)
a.add(&quot;x&quot;)
print a

b = frozenset(&#39;abcdefssss&#39;)
b.add(&quot;x&quot;)

print b
</code></pre>
<p><strong>结果：</strong></p>
<pre><code class="hljs">set([&#39;a&#39;, &#39;c&#39;, &#39;b&#39;, &#39;e&#39;, &#39;d&#39;, &#39;f&#39;, &#39;s&#39;, &#39;x&#39;])
AttributeError: &#39;frozenset&#39; object has no attribute &#39;add&#39;
</code></pre>
<p><strong>（4）set 能使用update 更新</strong></p>
<p><strong>示例代码：</strong></p>
<pre><code class="hljs">a = set(&#39;abcdefssss&#39;)
a.add(&quot;x&quot;)
b = set(&quot;xxx&quot;)
a.update(b)
print a
</code></pre>
<p><strong>结果：</strong></p>
<pre><code class="hljs">set([&#39;a&#39;, &#39;c&#39;, &#39;b&#39;, &#39;e&#39;, &#39;d&#39;, &#39;f&#39;, &#39;s&#39;, &#39;x&#39;])
</code></pre>
<p><strong>（5）set 使用difference 求差集</strong></p>
<p><strong>示例代码：</strong></p>
<pre><code class="hljs">a = set(&#39;abcdefssss&#39;)
a.add(&quot;x&quot;)
b = set(&quot;abcde&quot;)
new_set = a.difference(b)
print new_set
</code></pre>
<p><strong>结果：</strong></p>
<p>set([‘x’, ‘s’, ‘f’])</p>
<p>还有一种方式就是直接使用 - 号，其实底层都是使用魔法函数实现的，当然还有 | &amp; </p>
<p><strong>示例代码：</strong></p>
<pre><code class="hljs">a = set(&#39;abcdefssss&#39;)
a.add(&quot;x&quot;)
b = set(&quot;abcde&quot;)
new_set = a.difference(b)
another_set = a-b
print new_set
print another_set
</code></pre>
<p><strong>结果：</strong></p>
<pre><code class="hljs">set([&#39;x&#39;, &#39;s&#39;, &#39;f&#39;])
set([&#39;x&#39;, &#39;s&#39;, &#39;f&#39;])
</code></pre>
<h3 id="2-dict-背后的实现原理"><a href="#2-dict-背后的实现原理" class="headerlink" title="2.dict 背后的实现原理"></a><strong>2.dict 背后的实现原理</strong></h3><p>dict 背后都是通过hash 实现的，背后是一个数组，连续的内存空间，通过键值的hash到数组中寻找，因此速度非常的块。</p>
<p><strong>因此：</strong></p>
<ol>
<li>dict 的 key 和 set 的值都必须是可hash 的</li>
<li>dict 的内存花销大，但是查询速度快，很多自定义的对象或者是python 内部的对象都是用dict 包装的</li>
<li>dict 的存储顺序和存入的顺序有关</li>
<li>添加新的元素可能会改变已有数据的顺序（因为，在数组空间不足以后可能会新开辟一个新的数组，在元素进行转移的时候可能会改变存储顺序）</li>
</ol>
<h2 id="六、对象引用、可变性和垃圾回收"><a href="#六、对象引用、可变性和垃圾回收" class="headerlink" title="六、对象引用、可变性和垃圾回收"></a><strong>六、对象引用、可变性和垃圾回收</strong></h2><h3 id="1-Python-中的变量是什么？"><a href="#1-Python-中的变量是什么？" class="headerlink" title="1.Python 中的变量是什么？"></a><strong>1.Python 中的变量是什么？</strong></h3><p>Python 的变量和 Java 中的变量是不一样的，Java 中的变量是有大小的（因为有类型），声明一个变量就会在内存中开辟一定大小的空间，存放不同类型的数据，但是Python 不一样，Python 中的变量是一个指针，大小都是一样的</p>
<p><strong>示例代码：</strong></p>
<pre><code class="hljs">a = [1,2,3,4]
b = a
b.append(5)
print a 
</code></pre>
<p><strong>结果：</strong></p>
<pre><code class="hljs">[1, 2, 3, 4, 5]
</code></pre>
<p>我们看到，我们修改b 实际上把a 也修改了，本质上是指向了同一个内存空间</p>
<h3 id="2-Python-中的-和-is"><a href="#2-Python-中的-和-is" class="headerlink" title="2.Python 中的 &#x3D;&#x3D; 和 is"></a><strong>2.Python 中的 &#x3D;&#x3D; 和 is</strong></h3><h4 id="（1）is-比较的是两个的-id"><a href="#（1）is-比较的是两个的-id" class="headerlink" title="（1）is 比较的是两个的 id"></a><strong>（1）is 比较的是两个的 id</strong></h4><p><strong>示例代码：</strong></p>
<pre><code class="hljs">a = [1,2,3,4]
b = a
print id(a),id(b)
print a is b
</code></pre>
<p><strong>结果：</strong></p>
<pre><code class="hljs">50435592 50435592
True
</code></pre>
<p>但是有一个奇怪的情况</p>
<p><strong>示例代码：</strong></p>
<pre><code class="hljs">a = [1,2,3]
b = [1,2,3]

print a is b

a = 1
b = 1

print a is b
</code></pre>
<p><strong>结果：</strong></p>
<pre><code class="hljs">False
True
</code></pre>
<p><strong>解释：</strong></p>
<p>其实python 在对于小整数、小字符串的情况下不会另外新建内存空间</p>
<h4 id="（2）-比较的是值"><a href="#（2）-比较的是值" class="headerlink" title="（2）&#x3D;&#x3D; 比较的是值"></a><strong>（2）&#x3D;&#x3D; 比较的是值</strong></h4><p><strong>示例代码：</strong></p>
<pre><code class="hljs">a = [1,2,3]
b = [1,2,3]

print a == b

a = 1
b = 1

print a == b
</code></pre>
<p><strong>结果：</strong></p>
<pre><code class="hljs">True
True
</code></pre>
<h3 id="3-del-和垃圾回收"><a href="#3-del-和垃圾回收" class="headerlink" title="3.del 和垃圾回收"></a><strong>3.del 和垃圾回收</strong></h3><p>Python 中的垃圾回收机制使用的是引用计数的方式</p>
<p>del 并不能直接释放内存，只有在引用计数为0的时候才会释放</p>
<p><strong>示例代码：</strong></p>
<pre><code class="hljs">    a = object()
    b = a
    
    del  a
    print b
    print a
</code></pre>
<p><strong>结果：</strong></p>
<pre><code class="hljs">&lt;object object at 0x00000000030F90C0&gt;
NameError: name &#39;a&#39; is not defined
</code></pre>
<h2 id="七、元类编程"><a href="#七、元类编程" class="headerlink" title="七、元类编程"></a><strong>七、元类编程</strong></h2><h3 id="1-property-动态属性"><a href="#1-property-动态属性" class="headerlink" title="1.property 动态属性"></a><strong>1.property 动态属性</strong></h3><p>使用 @property 装饰器将取函数的模式改变成取属性的模式</p>
<p>先看一下原始的使用调用函数的方法：</p>
<p><strong>示例代码：</strong></p>
<pre><code class="hljs">from  datetime import date,datetime
class User():
    def __init__(self,name,birthday):
        self.name = name
        self.birthday = birthday

    def get_age(self):
        return datetime.now().year - self.birthday.year

if __name__ == &#39;__main__&#39;:
    user = User(&quot;K0rz3n&quot;,date(year = 1999,month = 11,day = 12))
    print user.get_age()
</code></pre>
<p><strong>结果：</strong></p>
<pre><code class="hljs">19
</code></pre>
<p><strong>我们如果想用调用类的属性的方式访问呢？</strong></p>
<p><strong>示例代码：</strong></p>
<pre><code class="hljs">from  datetime import date,datetime
class User():
    def __init__(self,name,birthday):
        self.name = name
        self.birthday = birthday

    @property
    def get_age(self):
        return datetime.now().year - self.birthday.year

if __name__ == &#39;__main__&#39;:
    user = User(&quot;K0rz3n&quot;,date(year = 1999,month = 11,day = 12))
    print user.get_age
</code></pre>
<p><strong>结果：</strong></p>
<pre><code class="hljs">19
</code></pre>
<h3 id="2-getattr-和-getattribute"><a href="#2-getattr-和-getattribute" class="headerlink" title="2.getattr 和 getattribute"></a><strong>2.<strong>getattr</strong> 和 <strong>getattribute</strong></strong></h3><h4 id="1-getattr"><a href="#1-getattr" class="headerlink" title="(1)__getattr__"></a><strong>(1)<code>__getattr__</code></strong></h4><p>这个魔法方法会在找不到属性的时候调用</p>
<p><strong>示例代码：</strong></p>
<pre><code class="hljs">from  datetime import date,datetime
class User():
    def __init__(self,name,birthday):
        self.name = name
        self.birthday = birthday

    def __getattr__(self, item):
        return &quot;can not find the attr&quot;

if __name__ == &#39;__main__&#39;:
    user = User(&quot;K0rz3n&quot;,date(year = 1999,month = 11,day = 12))
    print user.get_age
</code></pre>
<p><strong>结果：</strong></p>
<pre><code class="hljs">can not find the attr
</code></pre>
<h4 id="2-getattribute"><a href="#2-getattribute" class="headerlink" title="(2)__getattribute__"></a><strong>(2)<code>__getattribute__</code></strong></h4><p>这个魔法函数在属性调用的时候会第一个调用，不管属性存不存在，可以把他看成是属性调用的入口，因为地位比较重要因此不建议重写</p>
<p><strong>示例代码:</strong></p>
<pre><code class="hljs">from  datetime import date,datetime
class User(object):
    def __init__(self,name,birthday):
        self.name = name
        self.birthday = birthday

    def __getattr__(self, item):
        return &quot;can not find the attr&quot;

    def __getattribute__(self, item):
        return &quot;hello&quot;

if __name__ == &#39;__main__&#39;:
    user = User(&quot;K0rz3n&quot;,date(year = 1999,month = 11,day = 12))
    print user.get_age
</code></pre>
<p><strong>结果：</strong></p>
<pre><code class="hljs">hello
</code></pre>
<h3 id="3-属性描述符和属性的查找过程"><a href="#3-属性描述符和属性的查找过程" class="headerlink" title="3.属性描述符和属性的查找过程"></a><strong>3.属性描述符和属性的查找过程</strong></h3><h4 id="（1）属性描述符："><a href="#（1）属性描述符：" class="headerlink" title="（1）属性描述符："></a><strong>（1）属性描述符</strong>：</h4><p>开发过程中可能会遇到一个问题：们想对用户传进来的数据类型进行控制，但是由于我们需要控制的数据过多，我们不能每一个都写同样的代码，于是这就涉及到了属性描述符，实际上属性描述符也只是实现了几个魔法方法而已（<code>__get__</code> 、<code>__set__</code> 、<code>__delete__</code>）</p>
<p>下面我们就自己实现一个属性描述符</p>
<p><strong>示例代码:</strong></p>
<pre><code class="hljs">import numbers
class IntField(object):
    def __get__(self, instance, owner):
        return self.value
    def __set__(self, instance, value):
        if not isinstance(value,numbers.Integral):
            raise ValueError(&quot;not int&quot;)
        self.value = value
    def __delete__(self, instance):
        pass

class User(object):
    age = IntField()

if __name__ == &#39;__main__&#39;:
    user = User()
    user.age = &quot;xxx&quot;
    print user.age
</code></pre>
<p><strong>结果：</strong></p>
<pre><code class="hljs">ValueError: not int
</code></pre>
<p>当然我们能多加几个条件：</p>
<p><strong>示例代码：</strong></p>
<pre><code class="hljs">import numbers
class IntField(object):
    def __get__(self, instance, owner):
        return self.value
    def __set__(self, instance, value):
        if not isinstance(value,numbers.Integral):
            raise ValueError(&quot;not int&quot;)
        if value &lt; 0:
            raise ValueError(&quot;not &gt; 0&quot;)
        self.value = value
    def __delete__(self, instance):
        pass

class User(object):
    age = IntField()

if __name__ == &#39;__main__&#39;:
    user = User()
    user.age = -9
    print user.age
</code></pre>
<p><strong>结果：</strong></p>
<pre><code class="hljs">ValueError: not &gt; 0
</code></pre>
<h3 id="4-new-和-init-的区别"><a href="#4-new-和-init-的区别" class="headerlink" title="4.__new__ 和 __init__ 的区别"></a><strong>4.<code>__new__</code> 和 <code>__init__</code> 的区别</strong></h3><p><code>__new__</code> 可以自定义类的生成过程,而<code>__init__</code>控制的是类生成的对象，因此 new 的调用是在 init 的之前</p>
<p><strong>示例代码:</strong></p>
<pre><code class="hljs">class User(object):
    def __new__(cls, *args, **kwargs):
        print &quot;new&quot;
    def __init__(self,name):
        self.name = name
        print &quot;init&quot;
if __name__ == &#39;__main__&#39;:
    user = User(&quot;K0rz3n&quot;)
</code></pre>
<p><strong>结果：</strong></p>
<pre><code class="hljs">new
</code></pre>
<p>这里其实还发现一个问题，就是如果 new 方法不返回对象，Init 就永远得不到调用</p>
<p><strong>示例代码：</strong></p>
<pre><code class="hljs">class User(object):
    def __new__(cls, *args, **kwargs):
        print &quot;new&quot;
        return super(User,cls).__new__(cls)
    def __init__(self,name):
        self.name = name
        print &quot;init&quot;

if __name__ == &#39;__main__&#39;:
    user = User(&quot;K0rz3n&quot;)
</code></pre>
<p><strong>结果：</strong></p>
<pre><code class="hljs">new
init
</code></pre>
<h3 id="5-自定义元类"><a href="#5-自定义元类" class="headerlink" title="5.自定义元类"></a><strong>5.自定义元类</strong></h3><p><strong>概念：</strong></p>
<p>元类是什么呢？元类就是创建类的类，比如我们之前讲的 type() 就是一个元类，再比如我们在Py3 中创建类的时候在括号中写 metaclass &#x3D;  这个就是在指明这个类的元类，MetaClass 也是一个类，他是继承于type的，我们自定义 MetaClass 来控制类对象生成的过程</p>
<p>通过 type() 动态的创建一个类,<strong>语法是 type(类名，继承关系，属性或者方法)</strong></p>
<p><strong>示例代码：</strong></p>
<pre><code class="hljs">User = type(&quot;User&quot;,(),&#123;&#125;)

user = User()

print type(user)
</code></pre>
<p><strong>结果：</strong></p>
<pre><code class="hljs">&lt;class &#39;__main__.User&#39;&gt;
</code></pre>
<p><strong>我们现在来创建一个带有属性的类</strong></p>
<p><strong>示例代码：</strong></p>
<pre><code class="hljs">User = type(&quot;User&quot;,(),&#123;&quot;name&quot;:&quot;K0rz3n&quot;&#125;)
user = User()
print user.name
</code></pre>
<p><strong>结果:</strong></p>
<pre><code class="hljs">K0rz3n
</code></pre>
<p><strong>我们现在来创建一个带有方法的类</strong></p>
<p><strong>示例代码：</strong></p>
<pre><code class="hljs">def get_age(self):
    print &quot;get_age&quot;

if __name__ == &#39;__main__&#39;:
    User = type(&quot;User&quot;,(),&#123;&quot;name&quot;:&quot;K0rz3n&quot;,&quot;get_age&quot;:get_age&#125;)
    user = User()
    print user.name
    print user.get_age()
</code></pre>
<p><strong>结果：</strong></p>
<pre><code class="hljs">K0rz3n
get_age
None
</code></pre>
<p><strong>我们可以创建一个继承基类的类</strong></p>
<p><strong>示例代码：</strong></p>
<pre><code class="hljs">class BaseClass(object):
    def answer(self):
        return &quot;i am baseclass&quot;


if __name__ == &#39;__main__&#39;:
    User = type(&quot;User&quot;,(BaseClass,),&#123;&quot;name&quot;:&quot;K0rz3n&quot;,&quot;get_age&quot;:get_age&#125;)
    user = User()
    print user.answer()
</code></pre>
<p><strong>结果:</strong></p>
<pre><code class="hljs">i am baseclass
</code></pre>
<h2 id="八、Python-的迭代器和生成器"><a href="#八、Python-的迭代器和生成器" class="headerlink" title="八、Python 的迭代器和生成器"></a><strong>八、Python 的迭代器和生成器</strong></h2><h3 id="1-Python-中的迭代协议："><a href="#1-Python-中的迭代协议：" class="headerlink" title="1.Python 中的迭代协议："></a><strong>1.Python 中的迭代协议：</strong></h3><p><strong>什么是迭代器？</strong></p>
<p>迭代器是访问集合类元素的一种方式，我们能实现for循环其实背后就是迭代器,迭代器在Python 中叫做 Iterator ,背后实现的是 <code>__next__</code> 和 <code>__iter__</code> 方法</p>
<p><strong>示例代码：</strong></p>
<pre><code class="hljs">from collections import Iterable,Iterator
a = [1,2,3,4,5]

print isinstance(a,Iterable)
print isinstance(a,Iterator)
</code></pre>
<p><strong>结果：</strong></p>
<pre><code class="hljs">True
False
</code></pre>
<p><strong>解释：</strong></p>
<p>可以看到 a 是一个列表，他是可迭代的，但是他并不是一个迭代器</p>
<h3 id="2-Python-中迭代器和可迭代对象的区别："><a href="#2-Python-中迭代器和可迭代对象的区别：" class="headerlink" title="2.Python 中迭代器和可迭代对象的区别："></a><strong>2.Python 中迭代器和可迭代对象的区别：</strong></h3><h4 id="1-回顾一下之前的代码："><a href="#1-回顾一下之前的代码：" class="headerlink" title="1.回顾一下之前的代码："></a><strong>1.回顾一下之前的代码：</strong></h4><pre><code class="hljs">class Company(object):
    def __init__(self,employ_list):
        self.employ = employ_list
    def __getitem__(self, item):
        return self.employ[item]

if __name__ == &#39;__main__&#39;:
    company = Company([&quot;tom&quot;,&quot;bob&quot;,&quot;angel&quot;])
    for item in company:
        print item
</code></pre>
<p><strong>为什么这个能执行循环呢？</strong></p>
<p>实际上，我们在调用循环的时候会自动调用，iter() 这个方法，这个方法回去寻找实例化这个对象的类中有没有<code>__iter__</code> 这个方法,如果没有他会再退一步寻找<code>__getitem__</code> 这个魔法方法，然后完成调用.</p>
<h4 id="2-我们来自己实现一个迭代器："><a href="#2-我们来自己实现一个迭代器：" class="headerlink" title="2.我们来自己实现一个迭代器："></a><strong>2.我们来自己实现一个迭代器：</strong></h4><p><strong>示例代码：</strong></p>
<pre><code class="hljs"># coding=utf-8
from collections import Iterator

class MyIterator(Iterator):
    def __init__(self, employ_list):
        self.iter = employ_list
        self.index = 0

    def next(self):  # 真正返回迭代之的逻辑
        try:
            word = self.iter[self.index]
        except IndexError:
            raise StopIteration
        self.index += 1
        return word


class Company(object):
    def __init__(self, employ_list):
        self.employ = employ_list

    def __getitem__(self, item):
        return self.employ[item]

    def __iter__(self):
        return MyIterator(self.employ)


if __name__ == &#39;__main__&#39;:
    company = Company([&quot;tom&quot;, &quot;bob&quot;, &quot;angel&quot;])
    for i in company:
        print i
    
</code></pre>
<p><strong>结果：</strong></p>
<pre><code class="hljs">tom
bob
angel
</code></pre>
<h3 id="3-Python-中的生成器函数："><a href="#3-Python-中的生成器函数：" class="headerlink" title="3.Python 中的生成器函数："></a><strong>3.Python 中的生成器函数：</strong></h3><h4 id="1-概念："><a href="#1-概念：" class="headerlink" title="1.概念："></a><strong>1.概念：</strong></h4><blockquote>
<p><strong>什么是生成器函数？</strong></p>
<p>只要函数中有 yield 关键字，这个函数就是生成器函数</p>
</blockquote>
<p><strong>示例代码：</strong></p>
<pre><code class="hljs">def gen_test():
    yield 1

def test():
    return 2

if __name__ == &#39;__main__&#39;:
    gen = gen_test()
    res = test()

    print gen
    print res
</code></pre>
<p><strong>结果：</strong></p>
<pre><code class="hljs">&lt;generator object gen_test at 0x00000000032457E0&gt;
2
</code></pre>
<p><strong>解释：</strong></p>
<p>我们看到，看似同样是定义一个函数，但是第一个实际上是一个生成器，生成器返回的是一个生成器对象，第二个返回的只是一个干巴巴的数据。</p>
<p><strong>那么我们怎么利用这个生成器的返回值呢？</strong></p>
<p>实际上他底层实现也是一个生成器，既然是生成器我们就能通过循环的方式调用</p>
<p><strong>示例代码：</strong></p>
<pre><code class="hljs">def gen_test():
    yield 1

def test():
    return 2

if __name__ == &#39;__main__&#39;:
    gen = gen_test()
    res = test()

    for i in gen:
        print i
    
</code></pre>
<p><strong>结果：</strong></p>
<pre><code class="hljs">1
</code></pre>
<h4 id="2-看一下生成器的优势："><a href="#2-看一下生成器的优势：" class="headerlink" title="2.看一下生成器的优势："></a><strong>2.看一下生成器的优势：</strong></h4><p>原始的生成 斐波那契数列的方法：</p>
<p><strong>示例代码：</strong></p>
<pre><code class="hljs">def fib(index):
    fib_list = []
    n,a,b = 0,0,1
    while n &lt; index:
        fib_list.append(b)
        a,b = b,a+b
        n += 1
    return fib_list

fib_list = fib(10)
print fib_list
</code></pre>
<p><strong>结果：</strong></p>
<pre><code class="hljs">[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]
</code></pre>
<p>但是这种方法在数字非常大的时候就非常的占用内存空间，他会先把结果放在数组中再返回给我们，于是我们尝试使用生成器</p>
<p><strong>示例代码：</strong></p>
<pre><code class="hljs">def fib(index):
    n,a,b = 0,0,1
    while n &lt; index:
        yield b
        a,b = b,a+b
        n += 1

if __name__ == &#39;__main__&#39;:
    fib_list = []
    for i in fib(10):
        fib_list.append(i)
    print fib_list
</code></pre>
<p><strong>结果：</strong></p>
<pre><code class="hljs">[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]
</code></pre>
<p>生成器方式就能实现在循环中不断生成，避免了一下子生成，（当然我这个代码为了方便大家看最后还是放在了列表中）</p>
<h3 id="4-Python-是怎么实现生成器的："><a href="#4-Python-是怎么实现生成器的：" class="headerlink" title="4.Python 是怎么实现生成器的："></a><strong>4.Python 是怎么实现生成器的：</strong></h3><h4 id="1-先来讲讲Python-是怎么实现函数调用的"><a href="#1-先来讲讲Python-是怎么实现函数调用的" class="headerlink" title="1.先来讲讲Python 是怎么实现函数调用的"></a><strong>1.先来讲讲Python 是怎么实现函数调用的</strong></h4><p><strong>实例函数：</strong></p>
<pre><code class="hljs">def foo():
    pass
def bar():
    pass
</code></pre>
<p>首先 python 有一个C语言写的Python的解释器，Python 的所有的代码都是运行在这个解释器之上的，然后我们开始调用foo 函数，一调用函数解释器就会在堆上分配一个栈帧，然后我们在这个栈帧上执行这个函数，然后发现他调用了一个子函数，又会在堆上分配一个新的栈帧，所有的栈帧都分配在堆上，这也就是说，栈帧能脱离于调用者存在</p>
<p>而生成器实际上就是对我们的栈帧进行的一次封装。保存了当前运行的状态，也就是说，我们能够使用其实现迭代</p>
<h4 id="接下来介绍函数装饰器的使用"><a href="#接下来介绍函数装饰器的使用" class="headerlink" title="接下来介绍函数装饰器的使用"></a>接下来介绍函数装饰器的使用</h4><p>这一部分我打算单独拿出来做一篇文章，请关注我的文章列表的 <strong>Python实用编程技巧(装饰器篇)</strong></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E7%BC%96%E7%A8%8B/" class="category-chain-item">编程</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E7%BC%96%E7%A8%8B-Python-%E8%BF%9B%E9%98%B6-%E5%A4%87%E5%BF%98/" class="print-no-link">#编程 Python 进阶 备忘</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Python 编程进阶（重点在于面向对象和魔法方法）</div>
      <div>http://example.com/2018/10/04/Python 编程进阶（重点在于面向对象和魔法方法）/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>October 4, 2018</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2018/10/05/PHP%20%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%EF%BC%88%E6%BC%AB%E8%B0%88%EF%BC%89/" title="PHP 基础教程（漫谈）">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">PHP 基础教程（漫谈）</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2018/10/04/Python%20%E5%AE%9E%E7%94%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7%EF%BC%88%E8%A3%85%E9%A5%B0%E5%99%A8%E7%AF%87%EF%BC%89/" title="Python 实用编程技巧（装饰器篇）">
                        <span class="hidden-mobile">Python 实用编程技巧（装饰器篇）</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
