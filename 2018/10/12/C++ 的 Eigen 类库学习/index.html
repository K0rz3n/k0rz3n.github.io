

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/icon/warning.png">
  <link rel="icon" href="/img/icon/warning.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="K0rz3n">
  <meta name="keywords" content="">
  
    <meta name="description" content="一、Eigen 是什么Eigen 是一个 C++ 中的用于科学计算（矩阵）的类库，提供了非常方便的接口，最近我们小组需要做一个项目，里面涉及到很多的矩阵的计算，于是我打算使用这个类库结合我的 CLion 写代码 二、如何配置下载最新的 release 安装包 解压到项目的目录下（当然任何目录都可以，我习惯上解压到项目的目录下，这样比较方便管理），然后我们配置我们的 CMakeLists.txt">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ 的 Eigen 类库学习">
<meta property="og:url" content="http://k0rz3n.com/2018/10/12/C++%20%E7%9A%84%20Eigen%20%E7%B1%BB%E5%BA%93%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="K0rz3n&#39;s Blog">
<meta property="og:description" content="一、Eigen 是什么Eigen 是一个 C++ 中的用于科学计算（矩阵）的类库，提供了非常方便的接口，最近我们小组需要做一个项目，里面涉及到很多的矩阵的计算，于是我打算使用这个类库结合我的 CLion 写代码 二、如何配置下载最新的 release 安装包 解压到项目的目录下（当然任何目录都可以，我习惯上解压到项目的目录下，这样比较方便管理），然后我们配置我们的 CMakeLists.txt">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2018-10-11T23:03:18.000Z">
<meta property="article:modified_time" content="2025-01-24T15:18:52.465Z">
<meta property="article:author" content="K0rz3n">
<meta property="article:tag" content="编程 C++ 类库">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>C++ 的 Eigen 类库学习 - K0rz3n&#39;s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="/css/macpanel.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"k0rz3n.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 60vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>K0rz3n&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>Archives</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>Categories</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>Tags</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>About</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/banner/icemountain.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="C++ 的 Eigen 类库学习"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2018-10-12 00:03" pubdate>
          October 12, 2018 am
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          5.2k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          44 mins
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">C++ 的 Eigen 类库学习</h1>
            
            
              <div class="markdown-body">
                
                <h2 id="一、Eigen-是什么"><a href="#一、Eigen-是什么" class="headerlink" title="一、Eigen 是什么"></a><strong>一、Eigen 是什么</strong></h2><p>Eigen 是一个 C++ 中的用于科学计算（矩阵）的类库，提供了非常方便的接口，最近我们小组需要做一个项目，里面涉及到很多的矩阵的计算，于是我打算使用这个类库结合我的 CLion 写代码</p>
<h2 id="二、如何配置"><a href="#二、如何配置" class="headerlink" title="二、如何配置"></a><strong>二、如何配置</strong></h2><p>下载最新的 release 安装包 解压到项目的目录下（当然任何目录都可以，我习惯上解压到项目的目录下，这样比较方便管理），然后我们配置我们的 CMakeLists.txt</p>
<span id="more"></span>

<p><strong>CMakeLists.txt</strong></p>
<pre><code class="hljs">cmake_minimum_required(VERSION 3.10)
project(juzhen)

set(CMAKE_CXX_STANDARD 11)


include_directories(../eigen)//这里写你的解压目录


add_executable(juzhen main.cpp)
</code></pre>
<p><strong>main.cpp</strong></p>
<pre><code class="hljs">#include &lt;iostream&gt;
#include &lt;Eigen/Dense&gt;

using namespace Eigen;
using namespace std;

int main() &#123;
    typedef Matrix&lt;int,3,3&gt; hh;
    MatrixXd m = MatrixXd::Random(3,3);
    //m = (m + MatrixXd::Constant(3,3,1.2)) * 50;
    MatrixXd c = MatrixXd::Constant(3,3,1)*10;
    hh x;
    cout &lt;&lt; &quot;m =&quot; &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;
    cout &lt;&lt; &quot;c =&quot; &lt;&lt; endl &lt;&lt; c &lt;&lt; endl;
    cout &lt;&lt; &quot;x =&quot; &lt;&lt; endl &lt;&lt; x &lt;&lt; endl;
&#125;
</code></pre>
<p>这样就能运行啦</p>
<h2 id="三、Eigen-基础"><a href="#三、Eigen-基础" class="headerlink" title="三、Eigen 基础"></a><strong>三、Eigen 基础</strong></h2><h3 id="1-Matrix-类"><a href="#1-Matrix-类" class="headerlink" title="1.Matrix 类"></a><strong>1.Matrix 类</strong></h3><h4 id="1-基本："><a href="#1-基本：" class="headerlink" title="1.基本："></a><strong>1.基本：</strong></h4><p>在Eigen中，所有矩阵和向量都是Matrix模板类的对象。向量只是矩阵的一种特殊情况，有1行或1列。</p>
<p><strong>Matrix的三个必需模板参数是：</strong></p>
<pre><code class="hljs">Matrix &lt;typename Scalar，int RowsAtCompileTime，int ColsAtCompileTime&gt;
</code></pre>
<p><strong>例如：</strong> Matrix4f是浮动的4x4矩阵</p>
<pre><code class="hljs">typedef Matrix &lt;float，4,4&gt; Matrix4f ;
</code></pre>
<p>假如：我想生成一个 int 型的 3x3 的矩阵</p>
<p><strong>示例代码：</strong></p>
<pre><code class="hljs">#include &lt;iostream&gt;
#include &lt;Eigen/Dense&gt;

using namespace Eigen;
using namespace std;

int main() &#123;
    typedef Matrix&lt;int,3,3&gt; hh;
    hh x;
    cout &lt;&lt; &quot;x =&quot; &lt;&lt; endl &lt;&lt; x &lt;&lt; endl;
&#125;
</code></pre>
<p><strong>结果：</strong></p>
<pre><code class="hljs">x =
2001839094         36          0
2001791111    6880932 1275664310
        -1          4    6880948
    
</code></pre>
<h4 id="2-向量"><a href="#2-向量" class="headerlink" title="2.向量"></a><strong>2.向量</strong></h4><p>向量只是一种特殊的矩阵而已</p>
<p><strong>列向量：</strong></p>
<pre><code class="hljs">typedef Matrix &lt;float，3,1&gt; Vector3f ;
</code></pre>
<p><strong>行向量：</strong></p>
<pre><code class="hljs">typedef Matrix &lt;int，1,2&gt; RowVector2i ;
</code></pre>
<h4 id="3-动态值"><a href="#3-动态值" class="headerlink" title="3.动态值"></a><strong>3.动态值</strong></h4><p>我们当然不满足在编译时就确定矩阵的大小，于是他给我们也提供了对应的方法</p>
<p>例如，便捷typedef MatrixXd，即具有动态大小的双精度矩阵，定义如下：</p>
<pre><code class="hljs">typedef Matrix &lt;double，Dynamic，Dynamic&gt; MatrixXd ;
</code></pre>
<p>同样，我们定义了一个不言自明的typedef VectorXi如下：</p>
<pre><code class="hljs">typedef Matrix &lt;int，Dynamic，1&gt; VectorXi ;
</code></pre>
<p>您可以完美地拥有例如具有动态列数的固定行数，如下所示：</p>
<pre><code class="hljs">Matrix &lt;float，3，Dynamic&gt;
</code></pre>
<h4 id="4-构造函数"><a href="#4-构造函数" class="headerlink" title="4.构造函数"></a><strong>4.构造函数</strong></h4><p>默认构造函数始终可用，从不执行任何动态内存分配，也从不初始化矩阵系数。你可以做：</p>
<pre><code class="hljs">Matrix3f a;
MatrixXf b;
</code></pre>
<p>a 是一个3乘3的矩阵，具有未初始化系数的普通浮点数<br>b 是一个动态大小的矩阵，其大小目前是0乘0，并且其系数数组尚未分配。</p>
<p><strong>注意：</strong></p>
<pre><code class="hljs">Matrix3i d;
</code></pre>
<p>这里代表声明了一个 Int 型的 3x3 的矩阵，也就是说 最后的f 代表的是 float </p>
<p>对于矩阵，始终首先传递行数。对于矢量，只需传递矢量大小。它们使用给定的大小分配系数数组，但不自行初始化系数：</p>
<pre><code class="hljs">MatrixXf a（10,15）;
VectorXf b（30）;
</code></pre>
<p>a 是一个10x15动态大小的矩阵，具有已分配但当前未初始化的系数。<br>b 是一个大小为30的动态大小向量，具有已分配但当前未初始化的系数</p>
<p><strong>注意：</strong></p>
<pre><code class="hljs">RowVector2d e(1.0,2.0);
</code></pre>
<p>这个代表生成的是一个行向量（不加 row 是列向量）</p>
<h4 id="5-系数访问器"><a href="#5-系数访问器" class="headerlink" title="5.系数访问器"></a><strong>5.系数访问器</strong></h4><p><strong>示例代码：</strong></p>
<pre><code class="hljs">#include &lt;iostream&gt;
#include &lt;Eigen/Dense&gt;

using namespace Eigen;
using namespace std;

int main()
&#123;
    MatrixXd m(2,2);
    m(0,0)= 3;
    m(1,0)= 2.5;
    m(0,1)= -1;
    m(1,1)= m(1,0)+ m(0,1);
    std :: cout &lt;&lt; &quot;这是矩阵m：\n&quot; &lt;&lt; m &lt;&lt; std :: endl;

    VectorXd v(2);
    v(0)= 4;
    v(1)= v(0) - 1;
    std :: cout &lt;&lt; &quot;这是向量v:\n&quot; &lt;&lt; v &lt;&lt; std :: endl;
&#125;
</code></pre>
<p><strong>结果：</strong></p>
<pre><code class="hljs">这是矩阵m：
  3  -1
2.5 1.5
这是向量v:
4
3
</code></pre>
<h4 id="6-逗号初始化"><a href="#6-逗号初始化" class="headerlink" title="6.逗号初始化"></a><strong>6.逗号初始化</strong></h4><p><strong>示例代码：</strong></p>
<pre><code class="hljs">int main()
&#123;
    Matrix3f m;
    m &lt;&lt; 1,2,3,
        4,5,6,
        7,8,9;
    std :: cout &lt;&lt; m &lt;&lt;endl;
&#125;
</code></pre>
<p><strong>结果：</strong></p>
<pre><code class="hljs">1 2 3
4 5 6
7 8 9
</code></pre>
<h4 id="7-调整"><a href="#7-调整" class="headerlink" title="7.调整"></a><strong>7.调整</strong></h4><p>可以通过rows（），cols（）和size（）检索矩阵的当前大小。这些方法分别返回行数，列数和系数数。调整动态大小矩阵的大小由resize（）方法完成。</p>
<p><strong>示例代码：</strong></p>
<pre><code class="hljs">int main()
&#123;

    MatrixXd m(2,5);
    m.resize(4,3);
    std :: cout &lt;&lt; &quot;矩阵m的大小&quot; &lt;&lt; m.rows() &lt;&lt; &quot;x&quot; &lt;&lt; m.cols()&lt;&lt; std :: endl;
    std :: cout &lt;&lt; &quot;它有&quot; &lt;&lt; m.size()&lt;&lt; &quot;系数&quot; &lt;&lt; std :: endl;


    VectorXd v(2);
    v.resize(5);
    std :: cout &lt;&lt; &quot;向量v的大小为&quot; &lt;&lt; v.size()&lt;&lt; std :: endl;
    std :: cout &lt;&lt; &quot;作为矩阵,v的大小&quot; &lt;&lt; v.rows()&lt;&lt; &quot;x&quot; &lt;&lt; v.cols()&lt;&lt; std :: endl;

&#125;
</code></pre>
<p><strong>结果：</strong></p>
<pre><code class="hljs">矩阵m的大小4x3
它有12系数
向量v的大小为5
作为矩阵,v的大小5x1
</code></pre>
<h4 id="8-分配和调整大小"><a href="#8-分配和调整大小" class="headerlink" title="8.分配和调整大小"></a><strong>8.分配和调整大小</strong></h4><p>这里实际上是个C++ 中等号的重载</p>
<p>Eigen自动调整左侧的矩阵大小，使其与右侧大小的矩阵大小相匹配。例如：</p>
<p><strong>示例代码：</strong></p>
<pre><code class="hljs">int main()
&#123;

    MatrixXf a(2,2);
    std :: cout &lt;&lt; &quot;a is size &quot; &lt;&lt; a.rows() &lt;&lt; &quot;x&quot; &lt;&lt; a.cols()&lt;&lt; std :: endl;
    MatrixXf b(3,3);
    a = b;
    std :: cout &lt;&lt; &quot;a现在大小&quot; &lt;&lt; a.rows()&lt;&lt; &quot;x&quot; &lt;&lt; a.cols()&lt;&lt; std :: endl;
&#125;
</code></pre>
<p><strong>结果:</strong></p>
<pre><code class="hljs">a is size 2x2
a现在大小3x3
</code></pre>
<h2 id="四、矩阵和向量算数"><a href="#四、矩阵和向量算数" class="headerlink" title="四、矩阵和向量算数"></a><strong>四、矩阵和向量算数</strong></h2><h3 id="1-加减"><a href="#1-加减" class="headerlink" title="1.加减"></a><strong>1.加减</strong></h3><p>二元运算符+如 a+b<br>二元运算符 - 如 a-b<br>一元算子 - 如同 -a<br>复合运算符+ &#x3D;如 a+&#x3D;b<br>复合运算符 - &#x3D;如 a-&#x3D;b</p>
<p><strong>注意：</strong></p>
<p>运算符的左值和右值，必须要有相同的类型和相同数量的行列</p>
<p><strong>示例代码：</strong></p>
<pre><code class="hljs">int main()
&#123;

    Matrix2d a;
    a &lt;&lt; 1,2,
    3,4;
    MatrixXd b(2,2);
    b &lt;&lt; 2,3,
    1,4;
    std :: cout &lt;&lt; &quot;a + b = \n&quot; &lt;&lt; a + b &lt;&lt; std :: endl;
    std :: cout &lt;&lt; &quot;a  -  b = \n&quot; &lt;&lt; a  -  b &lt;&lt; std :: endl;
    std :: cout &lt;&lt; &quot;做一个+ = b;&quot; &lt;&lt; std :: endl;
    a += b;
    std :: cout &lt;&lt; &quot;现在 a = \n&quot; &lt;&lt; a &lt;&lt; std :: endl;
    Vector3d v(1,2,3);
    Vector3d w(1,0,0);
    std :: cout &lt;&lt; &quot;-v + w - v = \n&quot; &lt;&lt;  -v + w - v &lt;&lt; std :: endl;
&#125;
</code></pre>
<h3 id="2-标量的乘除"><a href="#2-标量的乘除" class="headerlink" title="2.标量的乘除"></a><strong>2.标量的乘除</strong></h3><p>二元运算符<em>如 matrix</em>scalar<br>二元运算符<em>如 scalar</em>matrix<br>二元运算符&#x2F;如 matrix&#x2F;scalar<br>复合运算符* &#x3D;如 matrix*&#x3D;scalar<br>复合运算符&#x2F; &#x3D;如 matrix&#x2F;&#x3D;scalar</p>
<p><strong>示例代码：</strong></p>
<pre><code class="hljs">int main()
&#123;

    Matrix2d a;
    a &lt;&lt; 1,2,
    3,4;
    Vector3d v(1,2,3);
    std :: cout &lt;&lt; &quot;a * 2.5 = \n&quot; &lt;&lt; a * 2.5 &lt;&lt; std :: endl;
    std :: cout &lt;&lt; &quot;0.1 * v = \n&quot; &lt;&lt; 0.1 * v &lt;&lt; std :: endl;
    std :: cout &lt;&lt; &quot;做v *= 2;&quot; &lt;&lt; std :: endl;
    v *= 2;
    std :: cout &lt;&lt; &quot;现在v = \n&quot; &lt;&lt; v &lt;&lt; std :: endl;
&#125;
</code></pre>
<p><strong>结果：</strong></p>
<pre><code class="hljs">a * 2.5 =
2.5   5
7.5  10
0.1 * v =
0.1
0.2
0.3
做v *= 2;
现在v =
2
4
6
</code></pre>
<h3 id="3-转置、共轭、伴随"><a href="#3-转置、共轭、伴随" class="headerlink" title="3.转置、共轭、伴随"></a><strong>3.转置、共轭、伴随</strong></h3><p>通过成员函数transpose（），conjugate（）和adjoint（）分别获得矩阵或向量的转置$ a ^ T $，共轭$ \ bar {a} $和伴随（即，共轭转置）。$ a ^ * $$ a $</p>
<p><strong>示例代码：</strong></p>
<pre><code class="hljs">int main()
&#123;

    MatrixXf a = MatrixXf :: Random(2,2);
    cout &lt;&lt; &quot;这是矩阵a \n&quot; &lt;&lt; a &lt;&lt; endl;
    cout &lt;&lt; &quot;这是矩阵a 的转置\n&quot; &lt;&lt; a.transpose()&lt;&lt; endl;
    cout &lt;&lt; &quot;这是矩阵a 的共轭\n&quot; &lt;&lt; a.conjugate()&lt;&lt;endl;
    cout &lt;&lt; &quot;这是矩阵a 的伴随\n&quot; &lt;&lt; a.adjoint()&lt;&lt; endl;

&#125;
</code></pre>
<p><strong>结果：</strong></p>
<pre><code class="hljs">这是矩阵a
-0.997497 -0.613392
 0.127171  0.617481
这是矩阵a 的转置
-0.997497  0.127171
-0.613392  0.617481
这是矩阵a 的共轭
-0.997497 -0.613392
 0.127171  0.617481
这是矩阵a 的伴随
-0.997497  0.127171
-0.613392  0.617481
</code></pre>
<h3 id="4-矩阵-矩阵和矩阵-向量乘法"><a href="#4-矩阵-矩阵和矩阵-向量乘法" class="headerlink" title="4.矩阵 - 矩阵和矩阵 - 向量乘法"></a><strong>4.矩阵 - 矩阵和矩阵 - 向量乘法</strong></h3><p><strong>示例代码：</strong></p>
<pre><code class="hljs">int main()
&#123;

    Matrix2d mat;
    mat &lt;&lt; 1, 2,
            3, 4;
    Vector2d u(-1,1), v(2,0);
    std::cout &lt;&lt; &quot;Here is mat*mat:\n&quot; &lt;&lt; mat * mat &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Here is mat*u:\n&quot; &lt;&lt; mat*u &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Here is u^T*mat:\n&quot; &lt;&lt; u.transpose()*mat &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Here is u^T*v:\n&quot; &lt;&lt; u.transpose()*v &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Here is u*v^T:\n&quot; &lt;&lt; u*v.transpose() &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Let&#39;s multiply mat by itself&quot; &lt;&lt; std::endl;
    mat = mat*mat;
    std::cout &lt;&lt; &quot;Now mat is mat:\n&quot; &lt;&lt; mat &lt;&lt; std::endl;

&#125;
</code></pre>
<p><strong>结果：</strong></p>
<pre><code class="hljs">Here is mat*mat:
 7 10
15 22
Here is mat*u:
1
1
Here is u^T*mat:
2 2
Here is u^T*v:
-2
Here is u*v^T:
-2 -0
 2  0
Let&#39;s multiply mat by itself
Now mat is mat:
 7 10
15 22
</code></pre>
<h2 id="五、高级初始化"><a href="#五、高级初始化" class="headerlink" title="五、高级初始化"></a><strong>五、高级初始化</strong></h2><h3 id="1-将矩阵进行拼接"><a href="#1-将矩阵进行拼接" class="headerlink" title="1.将矩阵进行拼接"></a><strong>1.将矩阵进行拼接</strong></h3><p>请记住，必须先设置大小，然后才能使用逗号初始值设定项</p>
<p><strong>示例代码：</strong></p>
<pre><code class="hljs">int main()
&#123;

    RowVectorXd vec1(3);
    vec1 &lt;&lt; 1, 2, 3;
    std::cout &lt;&lt; &quot;vec1 = &quot; &lt;&lt; vec1 &lt;&lt; std::endl;
    RowVectorXd vec2(4);
    vec2 &lt;&lt; 1, 4, 9, 16;
    std::cout &lt;&lt; &quot;vec2 = &quot; &lt;&lt; vec2 &lt;&lt; std::endl;
    RowVectorXd joined(7);
    joined &lt;&lt; vec1, vec2;
    std::cout &lt;&lt; &quot;joined = &quot; &lt;&lt; joined &lt;&lt; std::endl;

&#125;
</code></pre>
<p><strong>结果：</strong></p>
<pre><code class="hljs">vec1 = 1 2 3
vec2 =  1  4  9 16
joined =  1  2  3  1  4  9 16
</code></pre>
<p><strong>我们可以使用相同的技术来初始化具有块结构的矩阵。</strong></p>
<p><strong>实例代码：</strong></p>
<pre><code class="hljs">int main()
&#123;

    MatrixXf matA(2, 2);
    matA &lt;&lt; 1, 2, 3, 4;
    MatrixXf matB(4, 4);
    matB &lt;&lt; matA, matA/10, matA/10, matA;
    std::cout &lt;&lt; matB &lt;&lt; std::endl;

&#125;
</code></pre>
<p><strong>结果：</strong></p>
<pre><code class="hljs">  1   2 0.1 0.2
  3   4 0.3 0.4
0.1 0.2   1   2
0.3 0.4   3   4
</code></pre>
<p>更高级的填充：</p>
<p><strong>示例代码：</strong></p>
<pre><code class="hljs">int main()
&#123;

    Matrix3f m;
    m.row(0) &lt;&lt; 1, 2, 3;
    m.block(1,0,2,2) &lt;&lt; 4, 5, 7, 8;
    m.col(2).tail(2) &lt;&lt; 6, 9;
    std::cout &lt;&lt; m;

&#125;
</code></pre>
<p><strong>结果：</strong></p>
<pre><code class="hljs">1 2 3
4 5 6
7 8 9
</code></pre>
<h3 id="2-特殊矩阵"><a href="#2-特殊矩阵" class="headerlink" title="2.特殊矩阵"></a><strong>2.特殊矩阵</strong></h3><p>矩阵和数组都有特殊方法 Zero()</p>
<p><strong>示例代码：</strong></p>
<pre><code class="hljs">int main()
&#123;
    std::cout &lt;&lt; &quot;A fixed-size array:\n&quot;;
    Array33f a1 = Array33f::Zero();
    std::cout &lt;&lt; a1 &lt;&lt; &quot;\n\n&quot;;
    std::cout &lt;&lt; &quot;A one-dimensional dynamic-size array:\n&quot;;
    ArrayXf a2 = ArrayXf::Zero(3);
    std::cout &lt;&lt; a2 &lt;&lt; &quot;\n\n&quot;;
    std::cout &lt;&lt; &quot;A two-dimensional dynamic-size array:\n&quot;;
    ArrayXXf a3 = ArrayXXf::Zero(3, 4);
    std::cout &lt;&lt; a3 &lt;&lt; &quot;\n&quot;;

&#125;
</code></pre>
<p><strong>结果：</strong></p>
<pre><code class="hljs">A fixed-size array:
0 0 0
0 0 0
0 0 0

A one-dimensional dynamic-size array:
0
0
0

A two-dimensional dynamic-size array:
0 0 0 0
0 0 0 0
0 0 0 0
</code></pre>
<p><strong>类似地:</strong></p>
<p>1.静态方法Constant（value）将所有系数设置为value。如果需要指定对象的大小，则附加参数将在value参数之前，如MatrixXd::Constant(rows, cols, value)。</p>
<p>2.方法Random（）用随机系数填充矩阵或数组。</p>
<p>3.可以通过调用Identity（）获得单位矩阵; 此方法仅适用于Matrix，而不适用于Array，因为“单位矩阵”是线性代数概念。</p>
<p>4.LinSpaced方法（大小，低，高）仅适用于向量和一维数组;</p>
<p>它产生一个指定大小的向量，其系数在low和之间等间隔high。</p>
<p><strong>Eigen定义了实用函数</strong></p>
<p>如setZero（），MatrixBase :: setIdentity（）和DenseBase :: setLinSpaced（），可以方便地执行此操作。以下示例对比了构造矩阵的三种方法</p>
<p>使用静态方法和赋值，使用静态方法和逗号初始化程序，或使用setXxx（）方法。</p>
<p><strong>示例代码：</strong></p>
<pre><code class="hljs">int main()
&#123;

    const int size = 6;
    MatrixXd mat1(size, size);
    mat1.topLeftCorner(size/2, size/2)     = MatrixXd::Zero(size/2, size/2);
    mat1.topRightCorner(size/2, size/2)    = MatrixXd::Identity(size/2, size/2);
    mat1.bottomLeftCorner(size/2, size/2)  = MatrixXd::Identity(size/2, size/2);
    mat1.bottomRightCorner(size/2, size/2) = MatrixXd::Zero(size/2, size/2);
    std::cout &lt;&lt; mat1 &lt;&lt; std::endl &lt;&lt; std::endl;


    MatrixXd mat2(size, size);
    mat2.topLeftCorner(size/2, size/2).setZero();
    mat2.topRightCorner(size/2, size/2).setIdentity();
    mat2.bottomLeftCorner(size/2, size/2).setIdentity();
    mat2.bottomRightCorner(size/2, size/2).setZero();
    std::cout &lt;&lt; mat2 &lt;&lt; std::endl &lt;&lt; std::endl;


    MatrixXd mat3(size, size);
    mat3 &lt;&lt; MatrixXd::Zero(size/2, size/2), MatrixXd::Identity(size/2, size/2),
            MatrixXd::Identity(size/2, size/2), MatrixXd::Zero(size/2, size/2);
    std::cout &lt;&lt; mat3 &lt;&lt; std::endl;

&#125;
</code></pre>
<p><strong>结果：</strong></p>
<pre><code class="hljs">0 0 0 1 0 0
0 0 0 0 1 0
0 0 0 0 0 1
1 0 0 0 0 0
0 1 0 0 0 0
0 0 1 0 0 0

0 0 0 1 0 0
0 0 0 0 1 0
0 0 0 0 0 1
1 0 0 0 0 0
0 1 0 0 0 0
0 0 1 0 0 0

0 0 0 1 0 0
0 0 0 0 1 0
0 0 0 0 0 1
1 0 0 0 0 0
0 1 0 0 0 0
0 0 1 0 0 0
</code></pre>
<h3 id="3-用作临时对象"><a href="#3-用作临时对象" class="headerlink" title="3.用作临时对象"></a><strong>3.用作临时对象</strong></h3><p>静态方法如Zero（）和Constant（）可用于在声明时或在赋值运算符的右侧初始化变量。您可以将这些方法视为返回矩阵或数组; 实际上，它们<strong>返回所谓的表达式对象</strong>，在需要时可以计算矩阵或数组。</p>
<p><strong>示例代码：</strong></p>
<pre><code class="hljs">int main()
&#123;

    MatrixXd m = MatrixXd::Random(3,3);
    m = (m + MatrixXd::Constant(3,3,1.2)) * 50;
    cout &lt;&lt; &quot;m =&quot; &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;
    VectorXd v(3);
    v &lt;&lt; 1, 2, 3;
    cout &lt;&lt; &quot;m * v =&quot; &lt;&lt; endl &lt;&lt; m * v &lt;&lt; endl;
&#125;
</code></pre>
<p><strong>结果：</strong></p>
<pre><code class="hljs">m =
10.1251 90.8741 45.0291
66.3585 68.5009 99.5962
29.3304 57.9873  92.284
m * v =
326.961
502.149
422.157
</code></pre>
<h2 id="六、数组"><a href="#六、数组" class="headerlink" title="六、数组"></a><strong>六、数组</strong></h2><h3 id="1-概念："><a href="#1-概念：" class="headerlink" title="1.概念："></a><strong>1.概念：</strong></h3><p>Array是一个类模板，采用与Matrix相同的模板参数</p>
<pre><code class="hljs">Array &lt;typename Scalar，int RowsAtCompileTime，int ColsAtCompileTime&gt;
</code></pre>
<p>我们采用的形式是ArrayNt形式的typedef代表一维数组，其中N和t是大小和标量类型。对于二维数组，我们使用ArrayNNt形式的typedef。</p>
<p><strong>下表显示了一些示例：</strong></p>
<pre><code class="hljs">Array&lt;float,Dynamic,1&gt;                            ArrayXf 
Array&lt;float,3,1&gt;                                  Array3f 
Array&lt;double,Dynamic,Dynamic&gt;                     ArrayXXd 
Array&lt;double,3,3&gt;                                 Array33d 
</code></pre>
<h3 id="2-访问Array中的值"><a href="#2-访问Array中的值" class="headerlink" title="2.访问Array中的值"></a><strong>2.访问Array中的值</strong></h3><p>括号运算符被重载以提供对数组系数的写和读访问，就像使用矩阵一样。此外，&lt;&lt;操作符可用于初始化数组（通过逗号初始化程序）或打印它们。</p>
<p><strong>示例代码：</strong></p>
<pre><code class="hljs">#include &lt;iostream&gt;
#include &lt;Eigen/Dense&gt;

using namespace Eigen;
using namespace std;

int main() &#123;

    ArrayXXf  m(2,2);

    // assign some values coefficient by coefficient
    m(0,0) = 1.0; m(0,1) = 2.0;
    m(1,0) = 3.0; m(1,1) = m(0,1) + m(1,0);

    // print values to standard output
    cout &lt;&lt; m &lt;&lt; endl &lt;&lt; endl;

    // using the comma-initializer is also allowed
    m &lt;&lt; 1.0,2.0,
            3.0,4.0;

    // print values to standard output
    cout &lt;&lt; m &lt;&lt; endl;
&#125;
</code></pre>
<p><strong>结果：</strong></p>
<pre><code class="hljs">1 2
3 5

1 2
3 4
</code></pre>
<h3 id="3-加减"><a href="#3-加减" class="headerlink" title="3.加减"></a><strong>3.加减</strong></h3><p>添加和减去两个数组与矩阵相同。如果两个阵列具有相同的大小，则该操作有效，并且以系数方式进行加法或减法。</p>
<p>数组还支持表单的表达式，该表达式为数组中的array + scalar每个系数添加标量。这提供了一种不能直接用于Matrix对象的功能。</p>
<p><strong>示例代码：</strong></p>
<pre><code class="hljs">#include &lt;Eigen/Dense&gt;
#include &lt;iostream&gt;
using namespace Eigen;
using namespace std;
int main()
&#123;
  ArrayXXf a(3,3);
  ArrayXXf b(3,3);
  a &lt;&lt; 1,2,3,
       4,5,6,
       7,8,9;
  b &lt;&lt; 1,2,3,
       1,2,3,
       1,2,3;
       
  // Adding two arrays
  cout &lt;&lt; &quot;a + b = &quot; &lt;&lt; endl &lt;&lt; a + b &lt;&lt; endl &lt;&lt; endl;
  // Subtracting a scalar from an array
  cout &lt;&lt; &quot;a - 2 = &quot; &lt;&lt; endl &lt;&lt; a - 2 &lt;&lt; endl;
&#125;
</code></pre>
<p><strong>结果：</strong></p>
<pre><code class="hljs">a + b =
 2  4  6
 5  7  9
 8 10 12

a - 2 =
-1  0  1
 2  3  4
 5  6  7
</code></pre>
<h3 id="4-数组乘法"><a href="#4-数组乘法" class="headerlink" title="4.数组乘法"></a><strong>4.数组乘法</strong></h3><p>首先，当然你可以用一个标量乘以一个数组，这与矩阵的工作方式相同。数组与矩阵根本不同的是，当你将两个数组相乘时。矩阵将乘法解释为矩阵乘积，并且数组将乘法解释为系数乘积。因此，当且仅当它们具有相同的尺寸时，两个阵列可以相乘。</p>
<p><strong>示例代码：</strong></p>
<pre><code class="hljs">#include &lt;iostream&gt;
#include &lt;Eigen/Dense&gt;

using namespace Eigen;
using namespace std;

int main() &#123;

    ArrayXXf a(2,2);
    ArrayXXf b(2,2);
    a &lt;&lt; 1,2,
            3,4;
    b &lt;&lt; 5,6,
            7,8;
    cout &lt;&lt; &quot;a * b = &quot; &lt;&lt; endl &lt;&lt; a * b &lt;&lt; endl;
&#125;
</code></pre>
<p><strong>结果：</strong></p>
<pre><code class="hljs">a * b =
 5 12
21 32
</code></pre>
<h3 id="5-其他系数运算"><a href="#5-其他系数运算" class="headerlink" title="5.其他系数运算"></a><strong>5.其他系数运算</strong></h3><p>例如，.abs（）方法取每个系数的绝对值，而.sqrt（）计算系数的平方根。如果你有两个相同大小的数组，你可以调用.min（.）来构造数组，其系数是两个给定数组的相应系数的最小值。以下示例说明了这些操作。</p>
<p><strong>示例代码：</strong></p>
<pre><code class="hljs">#include &lt;iostream&gt;
#include &lt;Eigen/Dense&gt;

using namespace Eigen;
using namespace std;

int main() &#123;

    ArrayXf a = ArrayXf::Random(5);
    a *= 2;
    cout &lt;&lt; &quot;a =&quot; &lt;&lt; endl
         &lt;&lt; a &lt;&lt; endl;
    cout &lt;&lt; &quot;a.abs() =&quot; &lt;&lt; endl
         &lt;&lt; a.abs() &lt;&lt; endl;
    cout &lt;&lt; &quot;a.abs().sqrt() =&quot; &lt;&lt; endl
         &lt;&lt; a.abs().sqrt() &lt;&lt; endl;
    cout &lt;&lt; &quot;a.min(a.abs().sqrt()) =&quot; &lt;&lt; endl
         &lt;&lt; a.min(a.abs().sqrt()) &lt;&lt; endl;

&#125;
</code></pre>
<p><strong>结果：</strong></p>
<pre><code class="hljs">a =
-1.99499
0.254341
-1.22678
 1.23496
0.340037
a.abs() =
 1.99499
0.254341
 1.22678
 1.23496
0.340037
a.abs().sqrt() =
 1.41244
0.504323
  1.1076
 1.11129
0.583127
a.min(a.abs().sqrt()) =
-1.99499
0.254341
-1.22678
 1.11129
0.340037
</code></pre>
<h2 id="七、在数组和矩阵表达式之间转换"><a href="#七、在数组和矩阵表达式之间转换" class="headerlink" title="七、在数组和矩阵表达式之间转换"></a><strong>七、在数组和矩阵表达式之间转换</strong></h2><p>什么时候应该使用Matrix类的对象？何时应该使用Array类的对象？您不能对数组应用Matrix运算，也不能对矩阵应用Array运算。因此，如果你需要进行矩阵乘法等线性代数运算，那么你应该使用矩阵; 如果你需要进行系数运算，那么你应该使用数组。但是，有时它并不那么简单，但您需要同时使用Matrix和Array操作。在这种情况下，您需要将矩阵转换为数组或反向转换。无论选择将对象声明为数组还是矩阵，都可以访问所有操作。</p>
<p>矩阵表达式有一个**.array（）方法**，可以将它们“转换”为数组表达式，因此可以轻松应用系数方法。相反，数组表达式具有**.matrix（）方法**。与所有Eigen表达式抽象一样，这没有任何运行时成本（假设您让编译器进行优化）。即.array（）和.matrix（）可被用作右值和作为左值。</p>
<p>Eigen禁止在表达式中混合矩阵和数组。例如，您无法直接添加矩阵和数组; 该规则的例外是赋值运算符：允许将矩阵表达式赋给数组变量，或者将数组表达式赋给矩阵变量。</p>
<p><strong>以下示例说明如何通过使用.array（）方法对Matrix对象使用数组操作</strong></p>
<p><strong>示例代码1：</strong></p>
<pre><code class="hljs">#include &lt;iostream&gt;
#include &lt;Eigen/Dense&gt;

using namespace Eigen;
using namespace std;

int main() &#123;

    MatrixXf m(2,2);
    MatrixXf n(2,2);
    MatrixXf result(2,2);
    m &lt;&lt; 1,2,
            3,4;
    n &lt;&lt; 5,6,
            7,8;
    result = m * n;
    cout &lt;&lt; &quot;-- Matrix m*n: --&quot; &lt;&lt; endl &lt;&lt; result &lt;&lt; endl &lt;&lt; endl;
    result = m.array() * n.array();
    cout &lt;&lt; &quot;-- Array m*n: --&quot; &lt;&lt; endl &lt;&lt; result &lt;&lt; endl &lt;&lt; endl;
    result = m.cwiseProduct(n);
    cout &lt;&lt; &quot;-- With cwiseProduct: --&quot; &lt;&lt; endl &lt;&lt; result &lt;&lt; endl &lt;&lt; endl;
    result = m.array() + 4;
    cout &lt;&lt; &quot;-- Array m + 4: --&quot; &lt;&lt; endl &lt;&lt; result &lt;&lt; endl &lt;&lt; endl;
&#125;
</code></pre>
<p><strong>结果：</strong></p>
<pre><code class="hljs">-- Matrix m*n: --
19 22
43 50

-- Array m*n: --
 5 12
21 32

-- With cwiseProduct: --
 5 12
21 32

-- Array m + 4: --
5 6
7 8
</code></pre>
<p>类似地，如果array1和array2是数组，那么表达式array1.matrix() * array2.matrix()计算它们的矩阵乘积。</p>
<p><strong>示例代码2：</strong></p>
<pre><code class="hljs">#include &lt;iostream&gt;
#include &lt;Eigen/Dense&gt;

using namespace Eigen;
using namespace std;

int main() &#123;

    MatrixXf m(2,2);
    MatrixXf n(2,2);
    MatrixXf result(2,2);
    m &lt;&lt; 1,2,
            3,4;
    n &lt;&lt; 5,6,
            7,8;

    result = (m.array() + 4).matrix() * m;
    cout &lt;&lt; &quot;-- Combination 1: --&quot; &lt;&lt; endl &lt;&lt; result &lt;&lt; endl &lt;&lt; endl;
    result = (m.array() * n.array()).matrix() * m;
    cout &lt;&lt; &quot;-- Combination 2: --&quot; &lt;&lt; endl &lt;&lt; result &lt;&lt; endl &lt;&lt; endl;

&#125;
</code></pre>
<p><strong>结果：</strong></p>
<pre><code class="hljs">-- Combination 1: --
23 34
31 46

-- Combination 2: --
 41  58
117 170
</code></pre>
<p>求矩阵的行列式</p>
<h2 id="八、实例应用"><a href="#八、实例应用" class="headerlink" title="八、实例应用"></a><strong>八、实例应用</strong></h2><h3 id="1-求矩阵的行列式"><a href="#1-求矩阵的行列式" class="headerlink" title="1. 求矩阵的行列式"></a><strong>1. 求矩阵的行列式</strong></h3><pre><code class="hljs">m.determinant()
</code></pre>
<p>**注意:**矩阵m要是double 类型，要不然报错</p>
<p>下面是我写的一个生成 32x32 位 01 可逆矩阵的类，这里面我在生成32位矩阵的时候使用的是矩阵的拼接技术，但是这样就会出现大量的数组，并且不能用循环实现，很尴尬。</p>
<p><strong>示例代码：</strong></p>
<pre><code class="hljs">#include &lt;iostream&gt;
#include &lt;Eigen/Dense&gt;
#include &lt;cstdlib&gt;
#include &lt;ctime&gt;
#include &lt;cmath&gt;

using namespace Eigen;
using namespace std;
typedef Matrix &lt;double,32,32&gt; Matrix32d;


class cM32&#123;

public:

    Matrix32d create()&#123;//返回一个可逆的32x32 随机 01 矩阵

        Matrix32d m = createPT32();
        if(check(m)) &#123;
            cout &lt;&lt; &quot;可逆 &quot; &lt;&lt; &quot;行列式为： &quot; &lt;&lt; m.determinant() &lt;&lt; endl;
            return m;
        &#125;else&#123;
            cout &lt;&lt; &quot;不可逆&quot; &lt;&lt; endl;
            create();
        &#125;
    &#125;


private:

    Matrix32d createPT32()&#123;//创建一个随机的32x32 的01矩阵
        Matrix32d m5;
        Matrix2d* arrayM =  new Matrix2d[256];
        for(int i=0;i&lt;256;i++)&#123;
            arrayM[i] = create2();
        &#125;

        m5 &lt;&lt; arrayM[0], arrayM[1], arrayM[2], arrayM[3], arrayM[4], arrayM[5], arrayM[6], arrayM[7], arrayM[8], arrayM[9], arrayM[10], arrayM[11], arrayM[12], arrayM[13], arrayM[14], arrayM[15], arrayM[16],
                arrayM[17], arrayM[18], arrayM[19], arrayM[20], arrayM[21], arrayM[22], arrayM[23], arrayM[24], arrayM[25], arrayM[26], arrayM[27], arrayM[28], arrayM[29], arrayM[30], arrayM[31], arrayM[32],
                arrayM[33], arrayM[34], arrayM[35], arrayM[36], arrayM[37], arrayM[38], arrayM[39], arrayM[40], arrayM[41], arrayM[42], arrayM[43], arrayM[44], arrayM[45], arrayM[46], arrayM[47], arrayM[48],
                arrayM[49], arrayM[50], arrayM[51], arrayM[52], arrayM[53], arrayM[54], arrayM[55], arrayM[56], arrayM[57], arrayM[58], arrayM[59], arrayM[60], arrayM[61], arrayM[62], arrayM[63], arrayM[64],
                arrayM[65], arrayM[66], arrayM[67], arrayM[68], arrayM[69], arrayM[70], arrayM[71], arrayM[72], arrayM[73], arrayM[74], arrayM[75], arrayM[76], arrayM[77], arrayM[78], arrayM[79], arrayM[80],
                arrayM[81], arrayM[82], arrayM[83], arrayM[84], arrayM[85], arrayM[86], arrayM[87], arrayM[88], arrayM[89], arrayM[90], arrayM[91], arrayM[92], arrayM[93], arrayM[94], arrayM[95], arrayM[96],
                arrayM[97], arrayM[98], arrayM[99], arrayM[100], arrayM[101], arrayM[102], arrayM[103], arrayM[104], arrayM[105], arrayM[106], arrayM[107], arrayM[108], arrayM[109], arrayM[110], arrayM[111],
                arrayM[112], arrayM[113], arrayM[114], arrayM[115], arrayM[116], arrayM[117], arrayM[118], arrayM[119], arrayM[120], arrayM[121], arrayM[122], arrayM[123], arrayM[124], arrayM[125], arrayM[126],
                arrayM[127], arrayM[128], arrayM[129], arrayM[130], arrayM[131], arrayM[132], arrayM[133], arrayM[134], arrayM[135], arrayM[136], arrayM[137], arrayM[138], arrayM[139], arrayM[140], arrayM[141],
                arrayM[142], arrayM[143], arrayM[144], arrayM[145], arrayM[146], arrayM[147], arrayM[148], arrayM[149], arrayM[150], arrayM[151], arrayM[152], arrayM[153], arrayM[154], arrayM[155], arrayM[156],
                arrayM[157], arrayM[158], arrayM[159], arrayM[160], arrayM[161], arrayM[162], arrayM[163], arrayM[164], arrayM[165], arrayM[166], arrayM[167], arrayM[168], arrayM[169], arrayM[170], arrayM[171],
                arrayM[172], arrayM[173], arrayM[174], arrayM[175], arrayM[176], arrayM[177], arrayM[178], arrayM[179], arrayM[180], arrayM[181], arrayM[182], arrayM[183], arrayM[184], arrayM[185], arrayM[186],
                arrayM[187], arrayM[188], arrayM[189], arrayM[190], arrayM[191], arrayM[192], arrayM[193], arrayM[194], arrayM[195], arrayM[196], arrayM[197], arrayM[198], arrayM[199], arrayM[200], arrayM[201],
                arrayM[202], arrayM[203], arrayM[204], arrayM[205], arrayM[206], arrayM[207], arrayM[208], arrayM[209], arrayM[210], arrayM[211], arrayM[212], arrayM[213], arrayM[214], arrayM[215], arrayM[216],
                arrayM[217], arrayM[218], arrayM[219], arrayM[220], arrayM[221], arrayM[222], arrayM[223], arrayM[224], arrayM[225], arrayM[226], arrayM[227], arrayM[228], arrayM[229], arrayM[230], arrayM[231],
                arrayM[232], arrayM[233], arrayM[234], arrayM[235], arrayM[236], arrayM[237], arrayM[238], arrayM[239], arrayM[240], arrayM[241], arrayM[242], arrayM[243], arrayM[244], arrayM[245], arrayM[246],
                arrayM[247], arrayM[248], arrayM[249], arrayM[250], arrayM[251], arrayM[252], arrayM[253], arrayM[254], arrayM[255];
        return m5;
    &#125;

    Matrix2d create2()&#123;//创建 2x2 的01随机矩阵
        Matrix2d m1;
        m1(0,0) = rand()%2;
        m1(1,0) = rand()%2;
        m1(0,1) = rand()%2;
        m1(1,1) = rand()%2;
        return m1;
    &#125;

    int check(Matrix32d m)&#123;//检查是不是可逆的

        if(fabs(m.determinant()))&#123;
            return 1;
        &#125;else&#123;
            return 0;
        &#125;
    &#125;

&#125;;

int main()&#123;
    srand((unsigned int)time(NULL));
    cM32 *m = new cM32;
    for(int i=0;i&lt;1000;i++)&#123;
        m-&gt;create();

    &#125;
&#125;
</code></pre>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E7%BC%96%E7%A8%8B/" class="category-chain-item">编程</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E7%BC%96%E7%A8%8B-C-%E7%B1%BB%E5%BA%93/" class="print-no-link">#编程 C++ 类库</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>C++ 的 Eigen 类库学习</div>
      <div>http://k0rz3n.com/2018/10/12/C++ 的 Eigen 类库学习/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>K0rz3n</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>October 12, 2018</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="NC - Non-commercial">
                    <i class="iconfont icon-cc-nc"></i>
                  </span>
                </a>
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="SA - Share-alike">
                    <i class="iconfont icon-cc-sa"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2018/10/12/J2EE%E5%9F%BA%E7%A1%80%EF%BC%88Servlet%E7%AF%87%EF%BC%89/" title="J2EE 基础（Servlet篇）">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">J2EE 基础（Servlet篇）</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2018/10/11/C++%20%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/" title="C++ 基础教程">
                        <span class="hidden-mobile">C++ 基础教程</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
