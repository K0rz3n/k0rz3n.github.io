

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/icon/warning.png">
  <link rel="icon" href="/img/icon/warning.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="0X00 前言最近想写一点关于 Java 的东西，然后又遇见了 Java 中比较核心的几个技术，这几个技术贯穿整个 Java 的学习，也是后面各种框架的技术基础，因此深入理解这几种技术对我们后期分析各种框架是非常有帮助的，如果学的不精、不透，那么后面你分析各种漏洞的时候都会被绕进去，这也就是我对这些技术进行简单整理的原因。 0X01 泛型1.什么是泛型泛型，即“参数化类型”，将类型定义成参数形式(">
<meta property="og:type" content="article">
<meta property="og:title" content="JAVA 泛型、动态代理技术要点梳理">
<meta property="og:url" content="http://example.com/2019/04/20/JAVA%20%E6%B3%9B%E5%9E%8B%E3%80%81%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%8A%80%E6%9C%AF%E8%A6%81%E7%82%B9%E6%A2%B3%E7%90%86/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="0X00 前言最近想写一点关于 Java 的东西，然后又遇见了 Java 中比较核心的几个技术，这几个技术贯穿整个 Java 的学习，也是后面各种框架的技术基础，因此深入理解这几种技术对我们后期分析各种框架是非常有帮助的，如果学的不精、不透，那么后面你分析各种漏洞的时候都会被绕进去，这也就是我对这些技术进行简单整理的原因。 0X01 泛型1.什么是泛型泛型，即“参数化类型”，将类型定义成参数形式(">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://picture-1253331270.cos.ap-beijing.myqcloud.com/JAVA%20%E6%B3%9B%E5%9E%8B%E3%80%81%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%8A%80%E6%9C%AF%E8%A6%81%E7%82%B9%E6%A2%B3%E7%90%861.png">
<meta property="article:published_time" content="2019-04-20T18:28:18.000Z">
<meta property="article:modified_time" content="2025-01-24T15:18:57.034Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="java 备忘">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://picture-1253331270.cos.ap-beijing.myqcloud.com/JAVA%20%E6%B3%9B%E5%9E%8B%E3%80%81%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%8A%80%E6%9C%AF%E8%A6%81%E7%82%B9%E6%A2%B3%E7%90%861.png">
  
  
  
  <title>JAVA 泛型、动态代理技术要点梳理 - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="/css/macpanel.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 60vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>K0rz3n&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>Archives</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>Categories</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>Tags</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>About</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/banner/icemountain.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="JAVA 泛型、动态代理技术要点梳理"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2019-04-20 19:28" pubdate>
          April 20, 2019 pm
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          5.8k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          48 mins
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">JAVA 泛型、动态代理技术要点梳理</h1>
            
            
              <div class="markdown-body">
                
                <h2 id="0X00-前言"><a href="#0X00-前言" class="headerlink" title="0X00 前言"></a><strong>0X00 前言</strong></h2><p>最近想写一点关于 Java 的东西，然后又遇见了 Java 中比较核心的几个技术，这几个技术贯穿整个 Java 的学习，也是后面各种框架的技术基础，因此深入理解这几种技术对我们后期分析各种框架是非常有帮助的，如果学的不精、不透，那么后面你分析各种漏洞的时候都会被绕进去，这也就是我对这些技术进行简单整理的原因。</p>
<h2 id="0X01-泛型"><a href="#0X01-泛型" class="headerlink" title="0X01 泛型"></a><strong>0X01 泛型</strong></h2><h3 id="1-什么是泛型"><a href="#1-什么是泛型" class="headerlink" title="1.什么是泛型"></a><strong>1.什么是泛型</strong></h3><p>泛型，即“参数化类型”，将类型定义成参数形式(形参)，使用的使用传入具体的类型(实参)，也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。</p>
<h3 id="2-泛型解决什么样的问题"><a href="#2-泛型解决什么样的问题" class="headerlink" title="2.泛型解决什么样的问题"></a><strong>2.泛型解决什么样的问题</strong></h3><pre><code class="hljs">List arrayList = new ArrayList();
arrayList.add(&quot;aaaa&quot;);
arrayList.add(100);

for(int i = 0; i&lt; arrayList.size();i++)&#123;
    String item = (String)arrayList.get(i);
    Log.d(&quot;泛型测试&quot;,&quot;item = &quot; + item);
&#125;
</code></pre>
<p>这段代码是可以编译成功的，因为 arrayList 本身就可以存放任意类型的数据，但是运行时会报错，因为你使用的时候强制将 Integer 当做 String 类型使用，所以这样的特性并不利于我们代码的纠错与维护，我们希望在编译的时候就能给我们提示，于是泛型就应运而生</p>
<h3 id="3-泛型的生命周期"><a href="#3-泛型的生命周期" class="headerlink" title="3.泛型的生命周期"></a><strong>3.泛型的生命周期</strong></h3><p>为了更好地使用泛型，我们首先要知道泛型的生命周期只在编译阶段有效，也就是说泛型是提供给Javac编译器看的，可以限定集合中的输入类型，让编译器挡住源程序中的非法输入，在正确检验泛型结果后，会将泛型的相关信息抹去。</p>
<p><strong>代码实例：</strong></p>
<pre><code class="hljs">ArrayList&lt;String&gt; collection2 = new ArrayList&lt;String&gt;();
ArrayList&lt;Integer&gt; collection3 = new ArrayList&lt;Integer&gt;();

//对于参数化的泛型类型，getClass()方法的返回值和原始类型完全一样
System.out.println(collection3.getClass());//结果为：java.util.ArrayList
System.out.println(collection3.getClass() == collection2.getClass());//结果为true
</code></pre>
<p>也就是说我们能绕过编译器的眼睛，来往 arrayList 里面添加其他类型数据</p>
<p><strong>代码实例：</strong></p>
<pre><code class="hljs">//使用反射得到集合，然后调用add方法往原本只能存储Integer对象的集合中存储一个String类型的对象
collection3.getClass().getMethod(&quot;add&quot;, Object.class).invoke(collection3, &quot;abc&quot;);
System.out.println(collection3.get(0));//输出的结果为：abc，这证明字符串对象确实是存储到了原本只能存储Integer对象的集合中
</code></pre>
<h3 id="4-泛型的使用"><a href="#4-泛型的使用" class="headerlink" title="4.泛型的使用"></a><strong>4.泛型的使用</strong></h3><h4 id="1-泛型类"><a href="#1-泛型类" class="headerlink" title="(1)泛型类"></a><strong>(1)泛型类</strong></h4><p>泛型类型用于类的定义中，被称为泛型类。通过泛型可以完成对一组类的操作对外开放相同的接口。最典型的就是各种容器类，如：List、Set、Map。</p>
<p><strong>基本格式：</strong></p>
<pre><code class="hljs">class 类名称 &lt;泛型标识：可以随便写任意标识号，标识指定的泛型的类型&gt;&#123;
  private 泛型标识 /*（成员变量类型）*/ var; 
  .....

  &#125;
&#125;
</code></pre>
<p><strong>代码实例：</strong></p>
<p><strong>Generic.java</strong></p>
<pre><code class="hljs">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型
//在实例化泛型类时，必须指定T的具体类型
public class Generic&lt;T&gt;&#123;
    //key这个成员变量的类型为T,T的类型由外部指定
    private T key;

    public Generic(T key) &#123; //泛型构造方法形参key的类型也为T，T的类型由外部指定
        this.key = key;
    &#125;

    public T getKey()&#123; //泛型方法getKey的返回值类型为T，T的类型由外部指定
        return key;
    &#125;
&#125;
</code></pre>
<p><strong>Main.java</strong></p>
<pre><code class="hljs">import java.lang.*;

public class Main &#123;

    public static void main(String[] args) &#123;

        //泛型的类型参数只能是类类型（包括自定义类），不能是简单类型
        //传入的实参类型需与泛型的类型参数类型相同，即为Integer.
        Generic&lt;Integer&gt; genericInteger = new Generic&lt;Integer&gt;(123456);
        //传入的实参类型需与泛型的类型参数类型相同，即为String.
        Generic&lt;String&gt; genericString = new Generic&lt;String&gt;(&quot;key_vlaue&quot;);
        //不传入任何的泛型类型参数
        Generic generic = new Generic(&quot;111111&quot;);
        Generic generic1 = new Generic(4444);
        Generic generic2 = new Generic(55.55);
        Generic generic3 = new Generic(false);

        System.out.println(&quot;泛型测试 key is &quot; + genericInteger.getKey());
        System.out.println(&quot;泛型测试 key is &quot; + genericString.getKey());
        System.out.println(&quot;泛型测试 key is &quot; + generic.getKey());
        System.out.println(&quot;泛型测试 key is &quot; + generic1.getKey());
        System.out.println(&quot;泛型测试 key is &quot; + generic2.getKey());
        System.out.println(&quot;泛型测试 key is &quot; + generic3.getKey());


    &#125;
&#125;
</code></pre>
<p><strong>输出结果：</strong></p>
<pre><code class="hljs">泛型测试 key is 123456
泛型测试 key is key_vlaue
泛型测试 key is 111111
泛型测试 key is 4444
泛型测试 key is 55.55
泛型测试 key is false
</code></pre>
<p>从上面的例子我们可以看到，定义的泛型类，并不一定要传入泛型类型实参，在使用泛型的时候如果传入泛型实参，则会根据传入的泛型实参做相应的限制，此时泛型才会起到本应起到的限制作用。如果不传入泛型类型实参的话，在泛型类中使用泛型的方法或成员变量定义的类型可以为任何的类型。但是实际上这样是不推荐的，因为编辑器会有一个警告，如下图所示</p>
<p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/JAVA%20%E6%B3%9B%E5%9E%8B%E3%80%81%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%8A%80%E6%9C%AF%E8%A6%81%E7%82%B9%E6%A2%B3%E7%90%861.png" srcset="/img/loading.gif" lazyload alt="此处输入图片的描述"></p>
<p><strong>一些补充：</strong></p>
<p><strong>(1)参数化类型与原始类型的兼容性：</strong></p>
<ul>
<li><p>参数化类型可以引用一个原始类型的对象，编译时编译器会报警告，例如：<code>Collection&lt;String&gt;</code> c &#x3D; new Vector();</p>
</li>
<li><p>原始类型可以引用一个参数化类型的对象，编译时编译器会报警告，例如：Collection c &#x3D; new <code>Vector&lt;String&gt;()</code>;</p>
</li>
<li><p>参数化类型不考虑类型参数的继承关系：<br><code>Vector&lt;String&gt;</code> v &#x3D; new <code>Vector&lt;Object&gt;()</code>;&#x2F;&#x2F;错误，语法上不通过<br><code>Vector&lt;Object&gt;</code> v &#x3D; new <code>Vector&lt;String&gt;()</code>;&#x2F;&#x2F;错误，语法上不通过</p>
</li>
<li><p>假设 <code>Vector&lt;String&gt;</code> v &#x3D; new <code>Vector&lt;Object&gt;</code>;可以的话，那么以后从v中取出的对象当作String用，而v实际指向的集合中可以加入任意类型的对象，</p>
</li>
<li><p>假设 <code>Vector&lt;Object&gt;</code> v &#x3D; new <code>Vector&lt;String&gt;</code>;可以的话，那么以后可以向v中加入任意类型的对象，而v实际指向的集合中只能装String类型的对象</p>
</li>
</ul>
<p><strong>(2)思考：下面的代码会报错吗？（不会报错）</strong></p>
<p>Vector v1 &#x3D; new <code>Vector&lt;String&gt;()</code>;&#x2F;&#x2F;参数化类型的对象可以给原始类型的引用<br><code>Vector&lt;Object&gt;</code> v&#x3D;v1;&#x2F;&#x2F;参数化类型的引用可以指向原始类型的对象</p>
<h4 id="2-泛型接口"><a href="#2-泛型接口" class="headerlink" title="(2)泛型接口"></a><strong>(2)泛型接口</strong></h4><p>泛型接口与泛型类的定义及使用基本相同。泛型接口常被用在各种类的生产器中，可以看一个例子：</p>
<pre><code class="hljs">//定义一个泛型接口
public interface Generator&lt;T&gt; &#123;
    public T next();
&#125;
</code></pre>
<p>当实现泛型接口的类，未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中</p>
<p>即：class <code>FruitGenerator&lt;T&gt;</code> implements Generator<T>{…}如果不声明泛型，如：class FruitGenerator implements <code>Generator&lt;T&gt;</code>，编译器会报错：”Unknown class”</p>
<pre><code class="hljs">class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;&#123;
    @Override
    public T next() &#123;
        return null;
    &#125;
&#125;
</code></pre>
<p>当实现泛型接口的类，传入泛型实参时：定义一个生产器实现这个接口,虽然我们只创建了一个泛型接口<code>Generator&lt;T&gt;</code>但是我们可以为T传入无数个实参，形成无数种类型的Generator接口。在实现类实现泛型接口时，如已将泛型类型传入实参类型，则所有使用泛型的地方都要替换成传入的实参类型,即：<code>Generator&lt;T&gt;</code>，public T next();中的的T都要替换成传入的String类型。</p>
<pre><code class="hljs">public class FruitGenerator implements Generator&lt;String&gt; &#123;

    private String[] fruits = new String[]&#123;&quot;Apple&quot;, &quot;Banana&quot;, &quot;Pear&quot;&#125;;

    @Override
    public String next() &#123;
        Random rand = new Random();
        return fruits[rand.nextInt(3)];
    &#125;
&#125;
</code></pre>
<h4 id="3-泛型通配符”-”"><a href="#3-泛型通配符”-”" class="headerlink" title="(3)泛型通配符”?”"></a><strong>(3)泛型通配符”?”</strong></h4><p>首先我们要明确一点，那就是泛型之间是不存在类型兼容性的，比如说，Ingeter是Number的一个子类，但是在使用 <code>Generic&lt;Number&gt;</code>作为形参的方法中，是不能使用<code>Generic&lt;Ingeter&gt;</code>的实例传入的，换句话说 <code>Generic&lt;Integer&gt;</code> 不能被看作为<code>Generic&lt;Number&gt;</code>的子类</p>
<p><strong>代码实例：</strong></p>
<pre><code class="hljs">public void showKeyValue1(Generic&lt;Number&gt; obj)&#123;
    System.out.println(&quot;泛型测试 key value is &quot; + obj.getKey());
&#125;

Generic&lt;Integer&gt; gInteger = new Generic&lt;Integer&gt;(123);
Generic&lt;Number&gt; gNumber = new Generic&lt;Number&gt;(456);

showKeyValue(gInteger);
</code></pre>
<p>showKeyValue这个方法编译器会为我们报错：<code>Generic&lt;java.lang.Integer&gt;</code> cannot be applied to <code>Generic&lt;java.lang.Number&gt;</code> showKeyValue(gInteger);</p>
<p>因此我们需要一个在逻辑上可以表示同时是 <code>Generic&lt;Integer&gt;</code> 和 <code>Generic&lt;Number&gt;</code> 父类的引用类型,我们对上面的方法进行如下修改</p>
<pre><code class="hljs">public void showKeyValue1(Generic&lt;?&gt; obj)&#123;
    System.out.println(&quot;泛型测试 key value is &quot; + obj.getKey());
&#125;
</code></pre>
<blockquote>
<p><strong>注意：</strong></p>
<p>1.这里的 “?” 代替具体的类型<strong>实参</strong>，和Number、String、Integer一样都是一种实际的类型，可以把”?看成所有类型的父类。</p>
<p>2.可以解决当具体类型不确定的时候，这个通配符就是 “?” 当操作类型时，不需要使用类型的具体功能时，只使用Object类中的功能。那么可以用 “?” 通配符来表未知类型。</p>
</blockquote>
<h4 id="4-泛型方法"><a href="#4-泛型方法" class="headerlink" title="(4)泛型方法"></a><strong>(4)泛型方法</strong></h4><h5 id="1-类比泛型类解释泛型方法"><a href="#1-类比泛型类解释泛型方法" class="headerlink" title="1.类比泛型类解释泛型方法"></a><strong>1.类比泛型类解释泛型方法</strong></h5><p>泛型类，是在实例化类的时候指明泛型的具体类型，而泛型方法，是在调用方法的时候指明泛型的具体类型。</p>
<p><strong>实例代码：</strong></p>
<pre><code class="hljs">public &lt;T&gt; T genericMethod(Class&lt;T&gt; tClass)throws InstantiationException ,
  IllegalAccessException&#123;
        T instance = tClass.newInstance();
        return instance;
&#125;

Object obj = genericMethod(Class.forName(&quot;com.test.test&quot;));
</code></pre>
<p><strong>解释：</strong></p>
<p> 1）public 与 返回值中间<code>&lt;T&gt;</code>非常重要，可以理解为声明此方法为泛型方法。<br> 2）只有声明了<code>&lt;T&gt;</code>的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。<br> 3）<T>表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。<br> 4）与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。</p>
<h5 id="2-泛型方法的基本使用"><a href="#2-泛型方法的基本使用" class="headerlink" title="2.泛型方法的基本使用"></a><strong>2.泛型方法的基本使用</strong></h5><pre><code class="hljs">public class GenericTest &#123;
   //这个类是个泛型类，在上面已经介绍过
   public class Generic&lt;T&gt;&#123;     
        private T key;

        public Generic(T key) &#123;
            this.key = key;
        &#125;

        //我想说的其实是这个，虽然在方法中使用了泛型，但是这并不是一个泛型方法。
        //这只是类中一个普通的成员方法，只不过他的返回值是在声明泛型类已经声明过的泛型。
        //所以在这个方法中才可以继续使用 T 这个泛型。
        public T getKey()&#123;
            return key;
        &#125;

        /**
         * 这个方法显然是有问题的，在编译器会给我们提示这样的错误信息&quot;cannot reslove symbol E&quot;
         * 因为在类的声明中并未声明泛型E，所以在使用E做形参和返回值类型时，编译器会无法识别。
        public E setKey(E key)&#123;
             this.key = keu
        &#125;
        */
    &#125;

        /** 
         * 这才是一个真正的泛型方法。
         * 首先在public与返回值之间的&lt;T&gt;必不可少，这表明这是一个泛型方法，并且声明了一个泛型T
         * 这个T可以出现在这个泛型方法的任意位置.
         * 泛型的数量也可以为任意多个 
         *    如：public &lt;T,K&gt; K showKeyName(Generic&lt;T&gt; container)&#123;
         *        ...
         *        &#125;
         */
        public &lt;T&gt; T showKeyName(Generic&lt;T&gt; container)&#123;
            System.out.println(&quot;container key :&quot; + container.getKey());
            //当然这个例子举的不太合适，只是为了说明泛型方法的特性。
            T test = container.getKey();
            return test;
        &#125;

    &#125;
&#125;
</code></pre>
<h5 id="3-泛型类中泛型方法的使用"><a href="#3-泛型类中泛型方法的使用" class="headerlink" title="3.泛型类中泛型方法的使用"></a><strong>3.泛型类中泛型方法的使用</strong></h5><pre><code class="hljs">public class GenericFruit &#123;
    class Fruit&#123;
        @Override
        public String toString() &#123;
            return &quot;fruit&quot;;
        &#125;
    &#125;

    class Apple extends Fruit&#123;
        @Override
        public String toString() &#123;
            return &quot;apple&quot;;
        &#125;
    &#125;

    class Person&#123;
        @Override
        public String toString() &#123;
            return &quot;Person&quot;;
        &#125;
    &#125;

    class GenerateTest&lt;T&gt;&#123;
        public void show_1(T t)&#123;
            System.out.println(t.toString());
        &#125;

        //在泛型类中声明了一个泛型方法，使用泛型E，这种泛型E可以为任意类型。可以类型与T相同，也可以不同。
        //由于泛型方法在声明的时候会声明泛型&lt;E&gt;，因此即使在泛型类中并未声明泛型，编译器也能够正确识别泛型方法中识别的泛型。
        public &lt;E&gt; void show_3(E t)&#123;
            System.out.println(t.toString());
        &#125;

        //在泛型类中声明了一个泛型方法，使用泛型T，注意这个T是一种全新的类型，可以与泛型类中声明的T不是同一种类型。
        public &lt;T&gt; void show_2(T t)&#123;
            System.out.println(t.toString());
        &#125;
    &#125;

    public static void main(String[] args) &#123;
        Apple apple = new Apple();
        Person person = new Person();

        GenerateTest&lt;Fruit&gt; generateTest = new GenerateTest&lt;Fruit&gt;();
        //apple是Fruit的子类，所以这里可以
        generateTest.show_1(apple);
        //编译器会报错，因为泛型类型实参指定的是Fruit，而传入的实参类是Person
        //generateTest.show_1(person);

        //使用这两个方法都可以成功
        generateTest.show_2(apple);
        generateTest.show_2(person);

        //使用这两个方法也都可以成功
        generateTest.show_3(apple);
        generateTest.show_3(person);
    &#125;
&#125;
</code></pre>
<h5 id="4-静态方法与泛型"><a href="#4-静态方法与泛型" class="headerlink" title="4.静态方法与泛型"></a><strong>4.静态方法与泛型</strong></h5><p>静态方法无法访问类上定义的泛型；如果静态方法要使用泛型的话，必须将静态方法也定义成泛型方法 </p>
<pre><code class="hljs">public class StaticGenerator&lt;T&gt; &#123;
    ....
    ....
    /**
     * 如果在类中定义使用泛型的静态方法，需要添加额外的泛型声明（将这个方法定义成泛型方法）
     * 即使静态方法要使用泛型类中已经声明过的泛型也不可以。
     * 如：public static void show(T t)&#123;..&#125;,此时编译器会提示错误信息：
          &quot;StaticGenerator cannot be refrenced from static context&quot;
     */
    public static &lt;T&gt; void show(T t)&#123;

    &#125;
&#125;
</code></pre>
<h5 id="5-泛型的上下边界"><a href="#5-泛型的上下边界" class="headerlink" title="5.泛型的上下边界"></a><strong>5.泛型的上下边界</strong></h5><p>为泛型添加上边界，即传入的类型实参必须是指定类型的子类型</p>
<pre><code class="hljs">public void showKeyValue1(Generic&lt;? extends Number&gt; obj)&#123;
    System.out.println(&quot;泛型测试 key value is &quot; + obj.getKey());
&#125;



Generic&lt;String&gt; generic1 = new Generic&lt;String&gt;(&quot;11111&quot;);
Generic&lt;Integer&gt; generic2 = new Generic&lt;Integer&gt;(2222);
Generic&lt;Float&gt; generic3 = new Generic&lt;Float&gt;(2.4f);
Generic&lt;Double&gt; generic4 = new Generic&lt;Double&gt;(2.56);
    
//showKeyValue1(generic1);//这一行代码编译器会提示错误，因为String类型并不是Number类型的子类

showKeyValue1(generic2);
showKeyValue1(generic3);
showKeyValue1(generic4);
</code></pre>
<blockquote>
<p><strong>注意：</strong></p>
<p>为泛型方法添加上下边界的时候，必须在权限声明与返回值之间的<code>&lt;T&gt;</code>上添加上下边界，即在泛型声明的时候添加</p>
<pre><code class="hljs">//public &lt;T&gt; T showKeyName(Generic&lt;T extends Number&gt; container)，编译器会报错：&quot;Unexpected bound&quot;
public &lt;T extends Number&gt; T showKeyName(Generic&lt;T&gt; container)&#123;
    System.out.println(&quot;container key :&quot; + container.getKey());
    T test = container.getKey();
    return test;
</code></pre>
</blockquote>
<h5 id="6-泛型数组"><a href="#6-泛型数组" class="headerlink" title="6.泛型数组"></a><strong>6.泛型数组</strong></h5><p>也就是说下面的这个例子是不可以的：</p>
<p>List<String>[] ls &#x3D; new ArrayList<String>[10];  </p>
<p>而使用通配符创建泛型数组是可以的，如下面这个例子：</p>
<p>List<?>[] ls = new ArrayList<?>[10];  </p>
<p>这样也是可以的：</p>
<p>List<String>[] ls &#x3D; new ArrayList[10];</p>
<h2 id="0X02-动态代理"><a href="#0X02-动态代理" class="headerlink" title="0X02 动态代理"></a><strong>0X02 动态代理</strong></h2><h3 id="1-什么是代理"><a href="#1-什么是代理" class="headerlink" title="1.什么是代理"></a><strong>1.什么是代理</strong></h3><p>我想代理这个词对我们从事计算机行业的人来说并不陌生，我们会通过代理去访问国外的一些网站，我们在渗透时通过代理去访问内部网络…代理就是我们与目标的一个中间人，我们想访问目标就要先访问代理，然后代理再代替我们访问目标。</p>
<h3 id="2-我们为什么需要代理呢"><a href="#2-我们为什么需要代理呢" class="headerlink" title="2.我们为什么需要代理呢"></a><strong>2.我们为什么需要代理呢</strong></h3><p>我们在网络中需要代理是因为我们可能无法直接访问对应的目标，但是这在开发中并不存在，我们不会说访问不到我们自己定义的某一个类，那我们要代理做什么？实际上，我上面说了代理其实是我们与目标的一个中间人，中间人难道只能原封不动的传递信息吗？当然不是，要不就没有中间人攻击了对不对？</p>
<p>我们这里设置代理实际上是想动态地给我们要访问的对象添加功能，如果我们直接调用 A 对象的 a 方法的话，那就只能运行 a 方法，但是如果我们给 A 对象添加一个代理 ，然后我们在代理类中就可以在 a 方法前面添加 b 方法，在 a 方法后面添加 c 方法，然后我们通过代理类的对象 D 去调用 a 方法的时候就能同时运行 b 和 c 方法，这就是我们添加代理的目的。</p>
<p>在实际的场景中经常出现在要给某个返回值添加过滤器，那么我们的代理就可以作为一个过滤器，那又有人要问了，为什么不直接在原来的类里面添加过滤器？那是因为如果只有一个类还好说，但是如果有一个“类族” 都要添加过滤器呢？对吧，我们使用代理就能实现一次编写到处使用了。</p>
<h3 id="3-动态代理和静态代理的区别"><a href="#3-动态代理和静态代理的区别" class="headerlink" title="3.动态代理和静态代理的区别"></a><strong>3.动态代理和静态代理的区别</strong></h3><p>本节的标题是动态代理，那么相对的肯定有静态代理，为了体现动态代理的优势，我们这里还是要介绍一下静态代理的使用方法，然后对比引出动态代理。</p>
<p>代理的本质是新创建了一个类，这个类要相对于原始类有了更强大的功能，那么静态代理就非常的死板，他必须要实现原始类的接口，因此相当于将原始类硬编译进去了</p>
<h4 id="1-静态代理的实现"><a href="#1-静态代理的实现" class="headerlink" title="(1)静态代理的实现"></a><strong>(1)静态代理的实现</strong></h4><p>假设，开发者写代码之前并没有写文档的习惯，现在老板要求开发人员必须要在写代码前先写文档，于是我们可以给开发人员的类添加一个代理实现这个功能</p>
<pre><code class="hljs">/**
 * 目标对象实现的接口
 */

public interface IDeveloper &#123;

    public void writeCode();
&#125;


/**
 * 目标对象实现类
 */
    
public class Developer implements IDeveloper&#123;
	private String name;
	public Developer(String name)&#123;
		this.name = name;
	&#125;
	@Override
	public void writeCode() &#123;
		System.out.println(&quot;Developer &quot; + name + &quot; writes code&quot;);
	&#125;
&#125;

/**
 * 代理类，需要实现与目标对象相同的接口来实现目标原始的功能
 */
 
public class DeveloperProxy implements IDeveloper&#123;
	private IDeveloper developer;
	public DeveloperProxy(IDeveloper developer)&#123;
		this.developer = developer;
	&#125;
	@Override
	public void writeCode() &#123;
		System.out.println(&quot;Write documentation...&quot;);
		this.developer.writeCode();
	&#125;
&#125;

/**
 * 最终调用，先去实现原始的类，然后把原始类对象传入代理类创建代理类对象
 */
     
public class DeveloperTest &#123;
	public static void main(String[] args) &#123;
		IDeveloper jerry = new Developer(&quot;Jerry&quot;);
		IDeveloper jerryProxy = new DeveloperProxy(jerry);
		jerryProxy.writeCode();

	&#125;
&#125;

/**
 * 运行结果
 */

Write documentation...
Developer jerry writes code
</code></pre>
<h5 id="解释："><a href="#解释：" class="headerlink" title="解释："></a><strong>解释：</strong></h5><p><strong>1.代理类的代码中涉及到了接口类型的对象，实现相同接口的对象可以有不同的动作，实际上这是实现多态的常用手法,下面是一个使用接口实现多态的例子</strong></p>
<p>(1)定义一个接口TestFace</p>
<pre><code class="hljs">public interface TestFace&#123;//定一个接口
   void make();//定义一个接口方法
&#125;
</code></pre>
<p>(2)定义一个类MyClass，里面包含一个接口型变量</p>
<pre><code class="hljs">public class MyClass&#123;//定义一个类
    TestFace tf;//定义一个接口型变量tf
    public MyClass(TestFace tf)&#123;//构造函数初始化接口型变量tf
       this.tf = tf;
    &#125;
    public work()&#123;  //函数调用
       this.tf.make();//实际的接口型类实例。
    &#125;
&#125;
</code></pre>
<p>(3)定义2个类，实现接口TestFace </p>
<pre><code class="hljs">public class C1 implements TestFace&#123;//定一个类C1实现接口TestFace
    public void make()&#123;//实现接口的方法make
       System.out.println(&quot;c1&quot;);//打印c1
    &#125;
&#125;
public class C2 implements TestFace&#123;//定一个类C2实现接口TestFace
    public void make()&#123;//实现接口的方法make
       System.out.println(&quot;c2&quot;);//打印c2
    &#125;
&#125;
</code></pre>
<p>(4)使用接口变量</p>
<pre><code class="hljs">TestFace tf1 = new C1();//实现一个类实例C1
TestFace tf2 = new C2();//实现一个类实例C2
MyClass mc = MyClass(tf1);//定义一个MyClass的类实例，使用tf1
MyClass mc2 = MyClass(tf2);//定义一个MyClass的类实例，使用tf1
//同一个类的work，能够实现不同的打印内容
mc.work();
mc2.work();
</code></pre>
<p><strong>2.最终调用部分传入的是原始的对象</strong></p>
<h4 id="2-静态代理方式的缺点"><a href="#2-静态代理方式的缺点" class="headerlink" title="(2)静态代理方式的缺点"></a><strong>(2)静态代理方式的缺点</strong></h4><p>比如我们还想要求测试工程师在进行测试之前也要写文档，那么我们还需要从新编辑我们的代理类，添加我们测试接口</p>
<pre><code class="hljs">public interface ITester &#123;
	public void doTesting();
&#125;

public class Tester implements ITester &#123;
	private String name;
	public Tester(String name)&#123;
		this.name = name;
	&#125;
	@Override
	public void doTesting() &#123;
		System.out.println(&quot;Tester &quot; + name + &quot; is testing code&quot;);
	&#125;
&#125;
public class TesterProxy implements ITester&#123;
	private ITester tester;
	public TesterProxy(ITester tester)&#123;
		this.tester = tester;
	&#125;
	@Override
	public void doTesting() &#123;
		System.out.println(&quot;Tester is preparing test documentation...&quot;);
		tester.doTesting();
	&#125;
&#125;
</code></pre>
<p>由于静态代理的每次为一个新的类做代理的时候都要实现新的接口，这样这个代理类就太不通用了，代码量就大大提升，所以我们就有了一个新的代理方法，叫做动态代理，这种代理方式不需要去实现所代理的累的接口，使用起来更加方便。</p>
<h4 id="2-动态代理的实现"><a href="#2-动态代理的实现" class="headerlink" title="(2)动态代理的实现"></a><strong>(2)动态代理的实现</strong></h4><pre><code class="hljs">  /**
     * 代理类，无需实现原始类的接口
     */

public class EnginnerProxy implements InvocationHandler &#123;
	Object obj;
	public Object bind(Object obj)
	&#123;
		this.obj = obj;
		return Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj
		.getClass().getInterfaces(), this);
	&#125;
	
	@Override
	public Object invoke(Object proxy, Method method, Object[] args)
	throws Throwable
	&#123;
		System.out.println(&quot;Enginner writes document&quot;);
		Object res = method.invoke(obj, args);
		return res;
	&#125;
&#125;

 /**
 * 新的接口
 */


public interface ITester &#123;
	public void doTesting();
&#125;

  /**
 * 新的类
 */

    
public class Tester implements ITester &#123;
	private String name;
	public Tester(String name)&#123;
		this.name = name;
	&#125;
	@Override
	public void doTesting() &#123;
		System.out.println(&quot;Tester &quot; + name + &quot; is testing code&quot;);
	&#125;
&#125;

  /**
 * 最终调用，先去实现原始的类，然后把原始类对象传入代理类创建代理类对象
 */

public class DeveloperTest &#123;
    public static void main(String[] args) &#123;
        IDeveloper jerry = new Developer(&quot;Jerry&quot;);
        ITester Tom = new Tester(&quot;Tom&quot;);

        IDeveloper jerryProxy = (IDeveloper) new EngineerProxy().bind(jerry);
        jerryProxy.writeCode();

        ITester TomProxy = (ITester) new EngineerProxy().bind(Tom);
        TomProxy.doTesting();

    &#125;
&#125;

 /**
 * 运行结果
 */

Enginner writes document
Developer Jerry writes code
Enginner writes document
Tester Tom is testing code
</code></pre>
<h5 id="1-InvocationHandler"><a href="#1-InvocationHandler" class="headerlink" title="1.InvocationHandler"></a><strong>1.InvocationHandler</strong></h5><p>首先我们看到的是 InvocationHandler ，这是 JDK 为我们提供的一个内置接口，从名字就能看出来这是一个调用处理程序的实现接口，因为我们代理类的函数调用实现都是通过内部的一个 invok 方法实现的</p>
<h5 id="2-newProxyInstance"><a href="#2-newProxyInstance" class="headerlink" title="2.newProxyInstance"></a><strong>2.newProxyInstance</strong></h5><p>newProxyInstance 方法用来返回一个代理对象，它的函数原型:</p>
<pre><code class="hljs">static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) 
</code></pre>
<p><strong>我们来解释一下这三个参数：</strong></p>
<p><strong>(1)ClassLoader loader:</strong> 定义了这个新的类的加载器，我们知道每一个类在 javac 编译器编译后都会从 .java 文件转化成对应的 .class 文件(这在我们的反射机制中是比较重要的部分)，加载器的作用就是将 .class 文件中的 虚拟机指令转化成对应的类的字节码</p>
<p><strong>(2)<code>Class&lt;?&gt;[] interfaces:</code></strong> 用来指明生成的代理对象要实现的接口，这里其实是通过反射的方法去获取的</p>
<p><strong>(3)InvocationHandler h:</strong> 来指明这个代理对象需要完成的动作，实际上就是 invoke 函数，所以这里用 This 作为实参</p>
<h5 id="3-invoke"><a href="#3-invoke" class="headerlink" title="3.invoke"></a><strong>3.invoke</strong></h5><p>代理对象调用任何方法都会被这个方法截获，所以这个方法是代理对类的核心方法，它有三个参数，并且这三个参数是在调用过程中自动传入的，无需认为干预</p>
<p>**(1)proxy:**代表我们要代理的原始对象</p>
<p>**(2)method:**我们通过代理对象调用的原对象的方法，这里要注意，如果原始类的方法有很多的话，这里可以使用反射的方式获取到调用的具体方法名，然后写一个判断，从而调用不同的方法</p>
<pre><code class="hljs">if(method.getName().equals(&quot;xxx&quot;))
</code></pre>
<p>**(3)args:**原对象方法的参数</p>
<h2 id="0X03-参考链接"><a href="#0X03-参考链接" class="headerlink" title="0X03 参考链接"></a><strong>0X03 参考链接</strong></h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jiyukai/p/6958744.html">https://www.cnblogs.com/jiyukai/p/6958744.html</a><br><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1185885">https://cloud.tencent.com/developer/article/1185885</a><br><a target="_blank" rel="noopener" href="https://zhidao.baidu.com/question/342312672.html">https://zhidao.baidu.com/question/342312672.html</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xdp-gacl/p/3971367.html">https://www.cnblogs.com/xdp-gacl/p/3971367.html</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xdp-gacl/p/3629723.html">https://www.cnblogs.com/xdp-gacl/p/3629723.html</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/s10461/article/details/53941091">https://blog.csdn.net/s10461/article/details/53941091</a></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E5%A4%87%E5%BF%98/" class="category-chain-item">备忘</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/java-%E5%A4%87%E5%BF%98/" class="print-no-link">#java 备忘</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>JAVA 泛型、动态代理技术要点梳理</div>
      <div>http://example.com/2019/04/20/JAVA 泛型、动态代理技术要点梳理/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>April 20, 2019</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="NC - Non-commercial">
                    <i class="iconfont icon-cc-nc"></i>
                  </span>
                </a>
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="SA - Share-alike">
                    <i class="iconfont icon-cc-sa"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2019/05/03/Python3%20%E7%88%AC%E8%99%AB%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86(%E5%9F%BA%E7%A1%80%E7%AF%87)/" title="Python3 爬虫知识梳理(基础篇)">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Python3 爬虫知识梳理(基础篇)</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2019/04/04/TCTF%202019%20%E7%BA%BF%E4%B8%8A%E8%B5%9B%20web%20%E9%A2%98%20writeup/" title="TCTF 2019 线上赛 web 题 writeup">
                        <span class="hidden-mobile">TCTF 2019 线上赛 web 题 writeup</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
